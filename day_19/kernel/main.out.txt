
main.out.o：     文件格式 elf32-i386


Disassembly of section .text:

00280000 <bootmain>:
#include "header.h"


int bootmain()
{
  280000:	55                   	push   %ebp
	//the buf for all strings.
	char s[50] = {0};
  280001:	31 c0                	xor    %eax,%eax
  280003:	b9 32 00 00 00       	mov    $0x32,%ecx
#include "header.h"


int bootmain()
{
  280008:	89 e5                	mov    %esp,%ebp
  28000a:	57                   	push   %edi
  28000b:	56                   	push   %esi
	//the buf for all strings.
	char s[50] = {0};
  28000c:	8d bd 36 fc ff ff    	lea    -0x3ca(%ebp),%edi
#include "header.h"


int bootmain()
{
  280012:	53                   	push   %ebx
  280013:	81 ec 5c 04 00 00    	sub    $0x45c,%esp
	//the buf for all strings.
	char s[50] = {0};
  280019:	f3 aa                	rep stos %al,%es:(%edi)
	struct BOOTINFO *binfo = (struct BOOTINFO *)0xff0;

	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
  28001b:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
  280021:	6a 00                	push   $0x0
  280023:	50                   	push   %eax
  280024:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  28002a:	68 80 00 00 00       	push   $0x80
  28002f:	50                   	push   %eax
  280030:	e8 a2 18 00 00       	call   2818d7 <fifo32_init>
	fifo32_init(&keycmd,32,keycmd_buf,0);
  280035:	8d 85 68 fc ff ff    	lea    -0x398(%ebp),%eax
  28003b:	6a 00                	push   $0x0
  28003d:	50                   	push   %eax
  28003e:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  280044:	6a 20                	push   $0x20
  280046:	50                   	push   %eax
  280047:	e8 8b 18 00 00       	call   2818d7 <fifo32_init>
	
	int key_leds = (binfo->leds>>4)&7;
  28004c:	a0 f1 0f 00 00       	mov    0xff1,%al

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280051:	83 c4 18             	add    $0x18,%esp
  280054:	68 ed 00 00 00       	push   $0xed
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
	fifo32_init(&keycmd,32,keycmd_buf,0);
	
	int key_leds = (binfo->leds>>4)&7;
  280059:	c0 f8 04             	sar    $0x4,%al
  28005c:	83 e0 07             	and    $0x7,%eax
  28005f:	89 85 e0 fb ff ff    	mov    %eax,-0x420(%ebp)

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280065:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  28006b:	50                   	push   %eax
  28006c:	e8 97 18 00 00       	call   281908 <fifo32_put>
	fifo32_put(&keycmd,key_leds);
  280071:	58                   	pop    %eax
  280072:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  280078:	5a                   	pop    %edx
  280079:	ff b5 e0 fb ff ff    	pushl  -0x420(%ebp)
  28007f:	50                   	push   %eax
  280080:	e8 83 18 00 00       	call   281908 <fifo32_put>

	//init gdt idt pic and enable cpu interrupt
	init_gdtidt();
  280085:	e8 20 13 00 00       	call   2813aa <init_gdtidt>
	init_pic();
  28008a:	e8 5e 14 00 00       	call   2814ed <init_pic>
	io_sti();
  28008f:	e8 70 0a 00 00       	call   280b04 <io_sti>

	//init keyboard and mouse
	init_keyboard(&fifo,256);
  280094:	59                   	pop    %ecx
  280095:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  28009b:	5b                   	pop    %ebx
  28009c:	68 00 01 00 00       	push   $0x100
  2800a1:	50                   	push   %eax
  2800a2:	e8 6a 1a 00 00       	call   281b11 <init_keyboard>
	struct MOUSE_DEC mdec;
	enable_mouse(&fifo,512,&mdec);
  2800a7:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  2800ad:	83 c4 0c             	add    $0xc,%esp
  2800b0:	50                   	push   %eax
  2800b1:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  2800b7:	68 00 02 00 00       	push   $0x200
  2800bc:	50                   	push   %eax
  2800bd:	e8 01 19 00 00       	call   2819c3 <enable_mouse>
	
	//init timer
	init_pit();
  2800c2:	e8 13 26 00 00       	call   2826da <init_pit>
	
	io_out8(PIC0_IMR,0xf8);
  2800c7:	5e                   	pop    %esi
  2800c8:	5f                   	pop    %edi
  2800c9:	68 f8 00 00 00       	push   $0xf8
  2800ce:	6a 21                	push   $0x21
  2800d0:	e8 61 0a 00 00       	call   280b36 <io_out8>
	io_out8(PIC1_IMR,0xef);
  2800d5:	58                   	pop    %eax
  2800d6:	5a                   	pop    %edx
  2800d7:	68 ef 00 00 00       	push   $0xef
  2800dc:	68 a1 00 00 00       	push   $0xa1
  2800e1:	e8 50 0a 00 00       	call   280b36 <io_out8>

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800e6:	59                   	pop    %ecx
  2800e7:	5b                   	pop    %ebx
  2800e8:	68 ff ff ff bf       	push   $0xbfffffff
  2800ed:	68 00 00 40 00       	push   $0x400000
  2800f2:	e8 b4 1a 00 00       	call   281bab <memtest>
	memman_init(memman);
  2800f7:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
	io_out8(PIC1_IMR,0xef);

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800fe:	89 85 e4 fb ff ff    	mov    %eax,-0x41c(%ebp)
	memman_init(memman);
  280104:	e8 e1 1b 00 00       	call   281cea <memman_init>
	//init memman with two mem block:0x00001000-0x0009efff and 0x00400000-memtotal
	memman_free(memman,0x00001000,0x0009e000);
  280109:	83 c4 0c             	add    $0xc,%esp
  28010c:	68 00 e0 09 00       	push   $0x9e000
  280111:	68 00 10 00 00       	push   $0x1000
  280116:	68 00 00 3c 00       	push   $0x3c0000
  28011b:	e8 19 1d 00 00       	call   281e39 <memman_free>
	memman_free(memman,0x00400000,memtotal-0x00400000);
  280120:	8b 85 e4 fb ff ff    	mov    -0x41c(%ebp),%eax
  280126:	83 c4 0c             	add    $0xc,%esp
  280129:	2d 00 00 40 00       	sub    $0x400000,%eax
  28012e:	50                   	push   %eax
  28012f:	68 00 00 40 00       	push   $0x400000
  280134:	68 00 00 3c 00       	push   $0x3c0000
  280139:	e8 fb 1c 00 00       	call   281e39 <memman_free>
	struct SHTCTL *shtctl;
	struct SHEET *sht_bg, *sht_mouse, *sht_window, *sht_console;
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;
	
	init_palette();
  28013e:	e8 28 0b 00 00       	call   280c6b <init_palette>
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  280143:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  28014a:	50                   	push   %eax
  28014b:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280152:	50                   	push   %eax
  280153:	ff 35 f8 0f 00 00    	pushl  0xff8
  280159:	68 00 00 3c 00       	push   $0x3c0000
  28015e:	e8 84 1f 00 00       	call   2820e7 <shtctl_init>
	task_a = task_init(memman); //main task
  280163:	83 c4 14             	add    $0x14,%esp
	struct SHEET *sht_bg, *sht_mouse, *sht_window, *sht_console;
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;
	
	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  280166:	89 c6                	mov    %eax,%esi
	task_a = task_init(memman); //main task
  280168:	68 00 00 3c 00       	push   $0x3c0000
  28016d:	e8 ce 29 00 00       	call   282b40 <task_init>
	fifo.task = task_a;
	task_run(task_a,1,0);
  280172:	83 c4 0c             	add    $0xc,%esp
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;
	
	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	task_a = task_init(memman); //main task
  280175:	89 85 a8 fb ff ff    	mov    %eax,-0x458(%ebp)
	fifo.task = task_a;
  28017b:	89 85 14 fc ff ff    	mov    %eax,-0x3ec(%ebp)
	task_run(task_a,1,0);
  280181:	6a 00                	push   $0x0
  280183:	6a 01                	push   $0x1
  280185:	50                   	push   %eax
  280186:	e8 22 29 00 00       	call   282aad <task_run>

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
  28018b:	89 34 24             	mov    %esi,(%esp)
  28018e:	e8 e8 1f 00 00       	call   28217b <sheet_alloc>
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  280193:	5f                   	pop    %edi
  280194:	0f bf 15 f4 0f 00 00 	movswl 0xff4,%edx
	task_a = task_init(memman); //main task
	fifo.task = task_a;
	task_run(task_a,1,0);

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
  28019b:	89 85 c0 fb ff ff    	mov    %eax,-0x440(%ebp)
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  2801a1:	58                   	pop    %eax
  2801a2:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801a9:	0f af c2             	imul   %edx,%eax
  2801ac:	50                   	push   %eax
  2801ad:	68 00 00 3c 00       	push   $0x3c0000
  2801b2:	e8 d5 1e 00 00       	call   28208c <memman_alloc_4k>
  2801b7:	89 c3                	mov    %eax,%ebx
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
  2801b9:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801c0:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  2801c7:	50                   	push   %eax
  2801c8:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801cf:	50                   	push   %eax
  2801d0:	53                   	push   %ebx
  2801d1:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2801d7:	e8 06 20 00 00       	call   2821e2 <sheet_setbuf>
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
  2801dc:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801e3:	83 c4 1c             	add    $0x1c,%esp
  2801e6:	50                   	push   %eax
  2801e7:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801ee:	50                   	push   %eax
  2801ef:	53                   	push   %ebx
  2801f0:	e8 ff 0a 00 00       	call   280cf4 <init_screen8>
	
	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
  2801f5:	89 34 24             	mov    %esi,(%esp)
  2801f8:	e8 7e 1f 00 00       	call   28217b <sheet_alloc>
  2801fd:	89 c3                	mov    %eax,%ebx
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  2801ff:	58                   	pop    %eax
  280200:	5a                   	pop    %edx
  280201:	68 80 20 00 00       	push   $0x2080
  280206:	68 00 00 3c 00       	push   $0x3c0000
  28020b:	e8 7c 1e 00 00       	call   28208c <memman_alloc_4k>
	sheet_setbuf(sht_window,buf_window,144,52,-1);
  280210:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  280217:	6a 34                	push   $0x34
  280219:	68 90 00 00 00       	push   $0x90
  28021e:	50                   	push   %eax
  28021f:	53                   	push   %ebx
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
	
	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  280220:	89 85 b8 fb ff ff    	mov    %eax,-0x448(%ebp)
	sheet_setbuf(sht_window,buf_window,144,52,-1);
  280226:	e8 b7 1f 00 00       	call   2821e2 <sheet_setbuf>
	make_window8(buf_window,144,52,"task_a",1);
  28022b:	83 c4 14             	add    $0x14,%esp
  28022e:	6a 01                	push   $0x1
  280230:	68 00 3c 28 00       	push   $0x283c00
  280235:	6a 34                	push   $0x34
  280237:	68 90 00 00 00       	push   $0x90
  28023c:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  280242:	e8 3e 0d 00 00       	call   280f85 <make_window8>
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
  280247:	83 c4 18             	add    $0x18,%esp
  28024a:	6a 07                	push   $0x7
  28024c:	6a 10                	push   $0x10
  28024e:	68 80 00 00 00       	push   $0x80
  280253:	6a 1c                	push   $0x1c
  280255:	6a 08                	push   $0x8
  280257:	53                   	push   %ebx
  280258:	e8 eb 0e 00 00       	call   281148 <make_textbox8>
	cursor_x = 8;
	cursor_c = COL8_FFFFFF;
	//timer for cursor.
	struct TIMER *timer;
	timer = timer_alloc();
  28025d:	83 c4 20             	add    $0x20,%esp
  280260:	e8 21 24 00 00       	call   282686 <timer_alloc>
  280265:	89 85 bc fb ff ff    	mov    %eax,-0x444(%ebp)
	timer_init(timer,&fifo,1);
  28026b:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  280271:	51                   	push   %ecx
  280272:	6a 01                	push   $0x1
  280274:	50                   	push   %eax
  280275:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  28027b:	e8 d7 24 00 00       	call   282757 <timer_init>
	timer_settime(timer,50);
  280280:	5f                   	pop    %edi
  280281:	58                   	pop    %eax

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  280282:	8d bd e8 fc ff ff    	lea    -0x318(%ebp),%edi
	cursor_c = COL8_FFFFFF;
	//timer for cursor.
	struct TIMER *timer;
	timer = timer_alloc();
	timer_init(timer,&fifo,1);
	timer_settime(timer,50);
  280288:	6a 32                	push   $0x32
  28028a:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280290:	e8 d6 24 00 00       	call   28276b <timer_settime>

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  280295:	89 34 24             	mov    %esi,(%esp)
  280298:	e8 de 1e 00 00       	call   28217b <sheet_alloc>
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  28029d:	c7 04 24 63 00 00 00 	movl   $0x63,(%esp)
  2802a4:	6a 10                	push   $0x10
  2802a6:	6a 10                	push   $0x10
  2802a8:	57                   	push   %edi
  2802a9:	50                   	push   %eax
	timer = timer_alloc();
	timer_init(timer,&fifo,1);
	timer_settime(timer,50);

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  2802aa:	89 85 b4 fb ff ff    	mov    %eax,-0x44c(%ebp)
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  2802b0:	e8 2d 1f 00 00       	call   2821e2 <sheet_setbuf>
	init_mouse_cursor8(buf_mouse,99);
  2802b5:	83 c4 18             	add    $0x18,%esp
  2802b8:	6a 63                	push   $0x63
  2802ba:	57                   	push   %edi
  2802bb:	e8 a3 0b 00 00       	call   280e63 <init_mouse_cursor8>
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  2802c0:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2802c7:	b9 02 00 00 00       	mov    $0x2,%ecx
  2802cc:	83 e8 10             	sub    $0x10,%eax
  2802cf:	99                   	cltd   
  2802d0:	f7 f9                	idiv   %ecx
  2802d2:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
	int my = (binfo->scrny-28-16)/2;
  2802d8:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax

	//console sheet
	sht_console = sheet_alloc(shtctl);
  2802df:	89 34 24             	mov    %esi,(%esp)
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
  2802e2:	83 e8 2c             	sub    $0x2c,%eax
  2802e5:	99                   	cltd   
  2802e6:	f7 f9                	idiv   %ecx
  2802e8:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)

	//console sheet
	sht_console = sheet_alloc(shtctl);
  2802ee:	e8 88 1e 00 00       	call   28217b <sheet_alloc>
  2802f3:	89 85 d8 fb ff ff    	mov    %eax,-0x428(%ebp)
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
  2802f9:	58                   	pop    %eax
  2802fa:	5a                   	pop    %edx
  2802fb:	68 00 a5 00 00       	push   $0xa500
  280300:	68 00 00 3c 00       	push   $0x3c0000
  280305:	e8 82 1d 00 00       	call   28208c <memman_alloc_4k>
	sheet_setbuf(sht_console,buf_console,256,165,-1);
  28030a:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  280311:	68 a5 00 00 00       	push   $0xa5
  280316:	68 00 01 00 00       	push   $0x100
  28031b:	50                   	push   %eax
  28031c:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;

	//console sheet
	sht_console = sheet_alloc(shtctl);
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
  280322:	89 85 b0 fb ff ff    	mov    %eax,-0x450(%ebp)
	sheet_setbuf(sht_console,buf_console,256,165,-1);
  280328:	e8 b5 1e 00 00       	call   2821e2 <sheet_setbuf>
	make_window8(buf_console,256,165,"console",0);
  28032d:	83 c4 14             	add    $0x14,%esp
  280330:	6a 00                	push   $0x0
  280332:	68 0c 3c 28 00       	push   $0x283c0c
  280337:	68 a5 00 00 00       	push   $0xa5
  28033c:	68 00 01 00 00       	push   $0x100
  280341:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  280347:	e8 39 0c 00 00       	call   280f85 <make_window8>
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
  28034c:	83 c4 18             	add    $0x18,%esp
  28034f:	6a 00                	push   $0x0
  280351:	68 80 00 00 00       	push   $0x80
  280356:	68 f0 00 00 00       	push   $0xf0
  28035b:	6a 1c                	push   $0x1c
  28035d:	6a 08                	push   $0x8
  28035f:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280365:	e8 de 0d 00 00       	call   281148 <make_textbox8>
	task_console = task_alloc();
  28036a:	83 c4 20             	add    $0x20,%esp
  28036d:	e8 56 25 00 00       	call   2828c8 <task_alloc>
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  280372:	51                   	push   %ecx
  280373:	51                   	push   %ecx
	sht_console = sheet_alloc(shtctl);
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
	sheet_setbuf(sht_console,buf_console,256,165,-1);
	make_window8(buf_console,256,165,"console",0);
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
	task_console = task_alloc();
  280374:	89 c7                	mov    %eax,%edi
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  280376:	68 00 00 01 00       	push   $0x10000
  28037b:	68 00 00 3c 00       	push   $0x3c0000
  280380:	e8 07 1d 00 00       	call   28208c <memman_alloc_4k>
	task_console->tss.cs = 3*8;
	task_console->tss.ss = 1*8;
	task_console->tss.ds = 1*8;
	task_console->tss.fs = 1*8;
	task_console->tss.gs = 1*8;
	*((int *)(task_console->tss.esp + 4)) = sht_console;
  280385:	8b 8d d8 fb ff ff    	mov    -0x428(%ebp),%ecx
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
	sheet_setbuf(sht_console,buf_console,256,165,-1);
	make_window8(buf_console,256,165,"console",0);
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
	task_console = task_alloc();
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  28038b:	8d 90 f4 ff 00 00    	lea    0xfff4(%eax),%edx
	task_console->tss.eip = (int)&console_task - 0x280000;
  280391:	c7 47 4c 61 2d 00 00 	movl   $0x2d61,0x4c(%edi)
	task_console->tss.es = 1*8;
  280398:	c7 47 74 08 00 00 00 	movl   $0x8,0x74(%edi)
	task_console->tss.cs = 3*8;
  28039f:	c7 47 78 18 00 00 00 	movl   $0x18,0x78(%edi)
	task_console->tss.ds = 1*8;
	task_console->tss.fs = 1*8;
	task_console->tss.gs = 1*8;
	*((int *)(task_console->tss.esp + 4)) = sht_console;
	*((int *)(task_console->tss.esp + 8)) = memtotal;
	task_run(task_console,2,2);
  2803a6:	83 c4 0c             	add    $0xc,%esp
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
	sheet_setbuf(sht_console,buf_console,256,165,-1);
	make_window8(buf_console,256,165,"console",0);
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
	task_console = task_alloc();
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  2803a9:	89 57 64             	mov    %edx,0x64(%edi)
	task_console->tss.eip = (int)&console_task - 0x280000;
	task_console->tss.es = 1*8;
	task_console->tss.cs = 3*8;
	task_console->tss.ss = 1*8;
  2803ac:	c7 47 7c 08 00 00 00 	movl   $0x8,0x7c(%edi)
	task_console->tss.ds = 1*8;
  2803b3:	c7 87 80 00 00 00 08 	movl   $0x8,0x80(%edi)
  2803ba:	00 00 00 
	task_console->tss.fs = 1*8;
  2803bd:	c7 87 84 00 00 00 08 	movl   $0x8,0x84(%edi)
  2803c4:	00 00 00 
	task_console->tss.gs = 1*8;
  2803c7:	c7 87 88 00 00 00 08 	movl   $0x8,0x88(%edi)
  2803ce:	00 00 00 
	*((int *)(task_console->tss.esp + 4)) = sht_console;
  2803d1:	89 88 f8 ff 00 00    	mov    %ecx,0xfff8(%eax)
	*((int *)(task_console->tss.esp + 8)) = memtotal;
  2803d7:	8b 8d e4 fb ff ff    	mov    -0x41c(%ebp),%ecx
  2803dd:	8b 47 64             	mov    0x64(%edi),%eax
  2803e0:	89 48 08             	mov    %ecx,0x8(%eax)
	task_run(task_console,2,2);
  2803e3:	6a 02                	push   $0x2
  2803e5:	6a 02                	push   $0x2
  2803e7:	57                   	push   %edi
  2803e8:	e8 c0 26 00 00       	call   282aad <task_run>


	sheet_slide(sht_bg,0,0);
  2803ed:	83 c4 0c             	add    $0xc,%esp
  2803f0:	6a 00                	push   $0x0
  2803f2:	6a 00                	push   $0x0
  2803f4:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2803fa:	e8 04 22 00 00       	call   282603 <sheet_slide>
	sheet_slide(sht_console,32,4);
  2803ff:	83 c4 0c             	add    $0xc,%esp
  280402:	6a 04                	push   $0x4
  280404:	6a 20                	push   $0x20
  280406:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  28040c:	e8 f2 21 00 00       	call   282603 <sheet_slide>
	sheet_slide(sht_window,	64, 56);
  280411:	83 c4 0c             	add    $0xc,%esp
  280414:	6a 38                	push   $0x38
  280416:	6a 40                	push   $0x40
  280418:	53                   	push   %ebx
  280419:	e8 e5 21 00 00       	call   282603 <sheet_slide>
	sheet_slide(sht_mouse,mx,my);
  28041e:	83 c4 0c             	add    $0xc,%esp
  280421:	ff b5 d0 fb ff ff    	pushl  -0x430(%ebp)
  280427:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  28042d:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  280433:	e8 cb 21 00 00       	call   282603 <sheet_slide>
	sheet_updown(sht_bg,0);
  280438:	5e                   	pop    %esi
  280439:	58                   	pop    %eax
  28043a:	6a 00                	push   $0x0
  28043c:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  280442:	e8 d3 20 00 00       	call   28251a <sheet_updown>
	sheet_updown(sht_console,1);
  280447:	58                   	pop    %eax
  280448:	5a                   	pop    %edx
  280449:	6a 01                	push   $0x1
  28044b:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280451:	e8 c4 20 00 00       	call   28251a <sheet_updown>
	sheet_updown(sht_window,2);
  280456:	59                   	pop    %ecx
  280457:	5e                   	pop    %esi
  280458:	6a 02                	push   $0x2
  28045a:	53                   	push   %ebx
	sheet_setbuf(sht_window,buf_window,144,52,-1);
	make_window8(buf_window,144,52,"task_a",1);
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
	cursor_x = 8;
  28045b:	be 08 00 00 00       	mov    $0x8,%esi
	sheet_slide(sht_console,32,4);
	sheet_slide(sht_window,	64, 56);
	sheet_slide(sht_mouse,mx,my);
	sheet_updown(sht_bg,0);
	sheet_updown(sht_console,1);
	sheet_updown(sht_window,2);
  280460:	e8 b5 20 00 00       	call   28251a <sheet_updown>
	sheet_updown(sht_mouse,3);
  280465:	58                   	pop    %eax
  280466:	5a                   	pop    %edx
  280467:	6a 03                	push   $0x3
  280469:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  28046f:	e8 a6 20 00 00       	call   28251a <sheet_updown>

	int key_to = 0,key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  280474:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
	sheet_slide(sht_window,	64, 56);
	sheet_slide(sht_mouse,mx,my);
	sheet_updown(sht_bg,0);
	sheet_updown(sht_console,1);
	sheet_updown(sht_window,2);
	sheet_updown(sht_mouse,3);
  28047a:	83 c4 10             	add    $0x10,%esp
	
	extern struct TIMERCTL timerctl;

	int key_to = 0,key_shift = 0,keycmd_wait = -1;
  28047d:	c7 85 c4 fb ff ff ff 	movl   $0xffffffff,-0x43c(%ebp)
  280484:	ff ff ff 
  280487:	c7 85 cc fb ff ff 00 	movl   $0x0,-0x434(%ebp)
  28048e:	00 00 00 
  280491:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  280498:	00 00 00 

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  28049b:	89 85 c8 fb ff ff    	mov    %eax,-0x438(%ebp)
			keycmd_wait = fifo32_get(&keycmd);
			wait_KBC_sendready();
			io_out8(PORT_KEYDAT,keycmd_wait);
		}
		io_cli();
		if(fifo32_status(&fifo) == 0)
  2804a1:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
	make_window8(buf_window,144,52,"task_a",1);
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
	cursor_x = 8;
	cursor_c = COL8_FFFFFF;
  2804a7:	c7 85 dc fb ff ff 07 	movl   $0x7,-0x424(%ebp)
  2804ae:	00 00 00 
			keycmd_wait = fifo32_get(&keycmd);
			wait_KBC_sendready();
			io_out8(PORT_KEYDAT,keycmd_wait);
		}
		io_cli();
		if(fifo32_status(&fifo) == 0)
  2804b1:	89 85 ac fb ff ff    	mov    %eax,-0x454(%ebp)

	int key_to = 0,key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  2804b7:	83 ec 0c             	sub    $0xc,%esp
  2804ba:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2804c0:	e8 f0 14 00 00       	call   2819b5 <fifo32_status>
  2804c5:	8b 8d c4 fb ff ff    	mov    -0x43c(%ebp),%ecx
  2804cb:	83 c4 10             	add    $0x10,%esp
  2804ce:	c1 e9 1f             	shr    $0x1f,%ecx
  2804d1:	74 2f                	je     280502 <bootmain+0x502>
  2804d3:	85 c0                	test   %eax,%eax
  2804d5:	7e 2b                	jle    280502 <bootmain+0x502>
		{
			keycmd_wait = fifo32_get(&keycmd);
  2804d7:	83 ec 0c             	sub    $0xc,%esp
  2804da:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2804e0:	e8 95 14 00 00       	call   28197a <fifo32_get>
  2804e5:	89 85 c4 fb ff ff    	mov    %eax,-0x43c(%ebp)
			wait_KBC_sendready();
  2804eb:	e8 08 16 00 00       	call   281af8 <wait_KBC_sendready>
			io_out8(PORT_KEYDAT,keycmd_wait);
  2804f0:	59                   	pop    %ecx
  2804f1:	58                   	pop    %eax
  2804f2:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  2804f8:	6a 60                	push   $0x60
  2804fa:	e8 37 06 00 00       	call   280b36 <io_out8>
  2804ff:	83 c4 10             	add    $0x10,%esp
		}
		io_cli();
  280502:	e8 fb 05 00 00       	call   280b02 <io_cli>
		if(fifo32_status(&fifo) == 0)
  280507:	83 ec 0c             	sub    $0xc,%esp
  28050a:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280510:	e8 a0 14 00 00       	call   2819b5 <fifo32_status>
  280515:	83 c4 10             	add    $0x10,%esp
  280518:	85 c0                	test   %eax,%eax
  28051a:	75 18                	jne    280534 <bootmain+0x534>
		{	
			task_sleep(task_a);
  28051c:	83 ec 0c             	sub    $0xc,%esp
  28051f:	ff b5 a8 fb ff ff    	pushl  -0x458(%ebp)
  280525:	e8 f5 27 00 00       	call   282d1f <task_sleep>
			io_sti();
  28052a:	e8 d5 05 00 00       	call   280b04 <io_sti>
  28052f:	e9 75 05 00 00       	jmp    280aa9 <bootmain+0xaa9>
		}
		else
		{
			int i = fifo32_get(&fifo);
  280534:	83 ec 0c             	sub    $0xc,%esp
  280537:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  28053d:	e8 38 14 00 00       	call   28197a <fifo32_get>
  280542:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
			io_sti();
  280548:	e8 b7 05 00 00       	call   280b04 <io_sti>
			if(256<=i && i<=511)
  28054d:	8b 95 a4 fb ff ff    	mov    -0x45c(%ebp),%edx
  280553:	83 c4 10             	add    $0x10,%esp
  280556:	8d 82 00 ff ff ff    	lea    -0x100(%edx),%eax
  28055c:	3d ff 00 00 00       	cmp    $0xff,%eax
  280561:	0f 87 1e 04 00 00    	ja     280985 <bootmain+0x985>
			{
				xtoa(i-256,s);
  280567:	8d 8d 36 fc ff ff    	lea    -0x3ca(%ebp),%ecx
  28056d:	89 95 9c fb ff ff    	mov    %edx,-0x464(%ebp)
  280573:	52                   	push   %edx
  280574:	52                   	push   %edx
  280575:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
  28057b:	51                   	push   %ecx
  28057c:	50                   	push   %eax
  28057d:	89 8d a0 fb ff ff    	mov    %ecx,-0x460(%ebp)
  280583:	e8 fd 10 00 00       	call   281685 <xtoa>
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);
  280588:	8b 8d a0 fb ff ff    	mov    -0x460(%ebp),%ecx
  28058e:	83 c4 0c             	add    $0xc,%esp
  280591:	6a 04                	push   $0x4
  280593:	51                   	push   %ecx
  280594:	6a 00                	push   $0x0
  280596:	6a 07                	push   $0x7
  280598:	6a 10                	push   $0x10
  28059a:	6a 00                	push   $0x0
  28059c:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2805a2:	e8 3c 0b 00 00       	call   2810e3 <putfonts8_asc_sht>
				
				s[0] = key_char(i-256,key_shift);
  2805a7:	8b 85 a4 fb ff ff    	mov    -0x45c(%ebp),%eax
  2805ad:	83 c4 18             	add    $0x18,%esp
  2805b0:	ff b5 cc fb ff ff    	pushl  -0x434(%ebp)
  2805b6:	50                   	push   %eax
  2805b7:	e8 c7 15 00 00       	call   281b83 <key_char>
				s[1] = 0;

				if('A' <= s[0] && s[0] <= 'Z')
  2805bc:	8d 48 bf             	lea    -0x41(%eax),%ecx
  2805bf:	83 c4 10             	add    $0x10,%esp
			if(256<=i && i<=511)
			{
				xtoa(i-256,s);
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);
				
				s[0] = key_char(i-256,key_shift);
  2805c2:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				s[1] = 0;
  2805c8:	c6 85 37 fc ff ff 00 	movb   $0x0,-0x3c9(%ebp)

				if('A' <= s[0] && s[0] <= 'Z')
  2805cf:	8b 95 9c fb ff ff    	mov    -0x464(%ebp),%edx
  2805d5:	80 f9 19             	cmp    $0x19,%cl
  2805d8:	77 26                	ja     280600 <bootmain+0x600>
				{
					if((key_leds&4) == 0 && key_shift != 0 ||	//keyboard led off and shift on
  2805da:	f6 85 e0 fb ff ff 04 	testb  $0x4,-0x420(%ebp)
  2805e1:	75 0b                	jne    2805ee <bootmain+0x5ee>
  2805e3:	83 bd cc fb ff ff 00 	cmpl   $0x0,-0x434(%ebp)
  2805ea:	75 0b                	jne    2805f7 <bootmain+0x5f7>
  2805ec:	eb 12                	jmp    280600 <bootmain+0x600>
						(key_leds&4) != 0 && key_shift == 0)			//keyboard led on and shift off
  2805ee:	83 bd cc fb ff ff 00 	cmpl   $0x0,-0x434(%ebp)
  2805f5:	75 09                	jne    280600 <bootmain+0x600>
						s[0] += 0x20;		//uppercase 2 lowercases					
  2805f7:	83 c0 20             	add    $0x20,%eax
  2805fa:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				}
				if(s[0]!=0)//visible char
  280600:	0f be 85 36 fc ff ff 	movsbl -0x3ca(%ebp),%eax
  280607:	84 c0                	test   %al,%al
  280609:	74 73                	je     28067e <bootmain+0x67e>
				{
					if(key_to == 0 && cursor_x <128)
  28060b:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  280612:	75 30                	jne    280644 <bootmain+0x644>
  280614:	83 fe 7f             	cmp    $0x7f,%esi
  280617:	7f 2b                	jg     280644 <bootmain+0x644>
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF,s,1);
  280619:	8d 85 36 fc ff ff    	lea    -0x3ca(%ebp),%eax
  28061f:	51                   	push   %ecx
  280620:	6a 01                	push   $0x1
  280622:	89 95 a4 fb ff ff    	mov    %edx,-0x45c(%ebp)
  280628:	50                   	push   %eax
  280629:	6a 07                	push   $0x7
  28062b:	6a 00                	push   $0x0
  28062d:	6a 1c                	push   $0x1c
  28062f:	56                   	push   %esi
  280630:	53                   	push   %ebx
						cursor_x += 8;
  280631:	83 c6 08             	add    $0x8,%esi
				}
				if(s[0]!=0)//visible char
				{
					if(key_to == 0 && cursor_x <128)
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF,s,1);
  280634:	e8 aa 0a 00 00       	call   2810e3 <putfonts8_asc_sht>
  280639:	83 c4 20             	add    $0x20,%esp
  28063c:	8b 95 a4 fb ff ff    	mov    -0x45c(%ebp),%edx
  280642:	eb 3a                	jmp    28067e <bootmain+0x67e>
						cursor_x += 8;
					}
					else if(key_to == 1)
  280644:	83 bd e4 fb ff ff 01 	cmpl   $0x1,-0x41c(%ebp)
  28064b:	75 31                	jne    28067e <bootmain+0x67e>
					{
						fifo32_put(&task_console->fifo,s[0]+256); //send key to console fifo
  28064d:	05 00 01 00 00       	add    $0x100,%eax
  280652:	89 95 a4 fb ff ff    	mov    %edx,-0x45c(%ebp)
  280658:	52                   	push   %edx
  280659:	52                   	push   %edx
  28065a:	50                   	push   %eax
  28065b:	8d 47 10             	lea    0x10(%edi),%eax
  28065e:	50                   	push   %eax
  28065f:	e8 a4 12 00 00       	call   281908 <fifo32_put>
					}
					
				}
				if(i == 256 + 0x0f) //tab key
  280664:	8b 95 a4 fb ff ff    	mov    -0x45c(%ebp),%edx
  28066a:	83 c4 10             	add    $0x10,%esp
  28066d:	81 fa 0f 01 00 00    	cmp    $0x10f,%edx
  280673:	0f 85 7f 01 00 00    	jne    2807f8 <bootmain+0x7f8>
  280679:	e9 84 00 00 00       	jmp    280702 <bootmain+0x702>
  28067e:	81 fa 0f 01 00 00    	cmp    $0x10f,%edx
  280684:	0f 85 ff 00 00 00    	jne    280789 <bootmain+0x789>
				{
					if(key_to == 0)
  28068a:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  280691:	75 6f                	jne    280702 <bootmain+0x702>
					{
						//switch to task_console window
						key_to = 1;
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",0);
  280693:	6a 00                	push   $0x0
  280695:	68 00 3c 28 00       	push   $0x283c00
  28069a:	ff 73 04             	pushl  0x4(%ebx)
  28069d:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  2806a3:	e8 25 08 00 00       	call   280ecd <make_wtitle8>
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",1);
  2806a8:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  2806ae:	6a 01                	push   $0x1
  2806b0:	68 07 3c 28 00       	push   $0x283c07
  2806b5:	ff 70 04             	pushl  0x4(%eax)
  2806b8:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  2806be:	e8 0a 08 00 00       	call   280ecd <make_wtitle8>
						cursor_c = -1;	//set cursor color to null(-1) to hide
						boxfill8(sht_window->buf,sht_window->bxsize,COL8_FFFFFF,cursor_x,28,cursor_x+7,43);
  2806c3:	8d 46 07             	lea    0x7(%esi),%eax
  2806c6:	83 c4 1c             	add    $0x1c,%esp
  2806c9:	6a 2b                	push   $0x2b
  2806cb:	50                   	push   %eax
  2806cc:	6a 1c                	push   $0x1c
  2806ce:	56                   	push   %esi
  2806cf:	6a 07                	push   $0x7
  2806d1:	ff 73 04             	pushl  0x4(%ebx)
  2806d4:	ff 33                	pushl  (%ebx)
  2806d6:	e8 a9 05 00 00       	call   280c84 <boxfill8>
						fifo32_put(&task_console->fifo,2); //wake console cursor
  2806db:	8d 47 10             	lea    0x10(%edi),%eax
  2806de:	83 c4 18             	add    $0x18,%esp
  2806e1:	6a 02                	push   $0x2
  2806e3:	50                   	push   %eax
  2806e4:	e8 1f 12 00 00       	call   281908 <fifo32_put>
  2806e9:	83 c4 10             	add    $0x10,%esp
				if(i == 256 + 0x0f) //tab key
				{
					if(key_to == 0)
					{
						//switch to task_console window
						key_to = 1;
  2806ec:	c7 85 e4 fb ff ff 01 	movl   $0x1,-0x41c(%ebp)
  2806f3:	00 00 00 
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",0);
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",1);
						cursor_c = -1;	//set cursor color to null(-1) to hide
  2806f6:	c7 85 dc fb ff ff ff 	movl   $0xffffffff,-0x424(%ebp)
  2806fd:	ff ff ff 
  280700:	eb 55                	jmp    280757 <bootmain+0x757>
					}
					else
					{
						//back to task_a window
						key_to = 0;
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",1);
  280702:	6a 01                	push   $0x1
  280704:	68 00 3c 28 00       	push   $0x283c00
  280709:	ff 73 04             	pushl  0x4(%ebx)
  28070c:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  280712:	e8 b6 07 00 00       	call   280ecd <make_wtitle8>
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",0);
  280717:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  28071d:	6a 00                	push   $0x0
  28071f:	68 07 3c 28 00       	push   $0x283c07
  280724:	ff 70 04             	pushl  0x4(%eax)
  280727:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  28072d:	e8 9b 07 00 00       	call   280ecd <make_wtitle8>
						cursor_c = COL8_000000;//show the cursor
						fifo32_put(&task_console->fifo,3); //stop console cursor
  280732:	8d 47 10             	lea    0x10(%edi),%eax
  280735:	83 c4 18             	add    $0x18,%esp
  280738:	6a 03                	push   $0x3
  28073a:	50                   	push   %eax
  28073b:	e8 c8 11 00 00       	call   281908 <fifo32_put>
  280740:	83 c4 10             	add    $0x10,%esp
						fifo32_put(&task_console->fifo,2); //wake console cursor
					}
					else
					{
						//back to task_a window
						key_to = 0;
  280743:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  28074a:	00 00 00 
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",1);
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",0);
						cursor_c = COL8_000000;//show the cursor
  28074d:	c7 85 dc fb ff ff 00 	movl   $0x0,-0x424(%ebp)
  280754:	00 00 00 
						fifo32_put(&task_console->fifo,3); //stop console cursor
					}
					sheet_refresh(sht_window,0,0,sht_window->bxsize,21);
  280757:	83 ec 0c             	sub    $0xc,%esp
  28075a:	6a 15                	push   $0x15
  28075c:	ff 73 04             	pushl  0x4(%ebx)
  28075f:	6a 00                	push   $0x0
  280761:	6a 00                	push   $0x0
  280763:	53                   	push   %ebx
  280764:	e8 78 1d 00 00       	call   2824e1 <sheet_refresh>
					sheet_refresh(sht_console,0,0,sht_console->bxsize,21);
  280769:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  28076f:	83 c4 14             	add    $0x14,%esp
  280772:	6a 15                	push   $0x15
  280774:	ff 70 04             	pushl  0x4(%eax)
  280777:	6a 00                	push   $0x0
  280779:	6a 00                	push   $0x0
  28077b:	50                   	push   %eax
  28077c:	e8 60 1d 00 00       	call   2824e1 <sheet_refresh>
  280781:	83 c4 20             	add    $0x20,%esp
  280784:	e9 77 01 00 00       	jmp    280900 <bootmain+0x900>
				}
			 	else if(i == 256 + 0x0e) //back key
  280789:	81 fa 0e 01 00 00    	cmp    $0x10e,%edx
  28078f:	75 6f                	jne    280800 <bootmain+0x800>
				{
					if(key_to == 0 && cursor_x >8)
  280791:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  280798:	75 2f                	jne    2807c9 <bootmain+0x7c9>
  28079a:	83 fe 08             	cmp    $0x8,%esi
  28079d:	7e 2a                	jle    2807c9 <bootmain+0x7c9>
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF," ",1);
  28079f:	50                   	push   %eax
  2807a0:	6a 01                	push   $0x1
  2807a2:	68 14 3c 28 00       	push   $0x283c14
  2807a7:	6a 07                	push   $0x7
  2807a9:	6a 00                	push   $0x0
  2807ab:	6a 1c                	push   $0x1c
  2807ad:	56                   	push   %esi
  2807ae:	53                   	push   %ebx
						cursor_x -= 8;
  2807af:	83 ee 08             	sub    $0x8,%esi
				}
			 	else if(i == 256 + 0x0e) //back key
				{
					if(key_to == 0 && cursor_x >8)
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF," ",1);
  2807b2:	e8 2c 09 00 00       	call   2810e3 <putfonts8_asc_sht>
  2807b7:	83 c4 20             	add    $0x20,%esp
  2807ba:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  2807c1:	00 00 00 
  2807c4:	e9 37 01 00 00       	jmp    280900 <bootmain+0x900>
						cursor_x -= 8;
					}
					else if(key_to == 1)
  2807c9:	83 bd e4 fb ff ff 01 	cmpl   $0x1,-0x41c(%ebp)
  2807d0:	0f 85 2a 01 00 00    	jne    280900 <bootmain+0x900>
					{
						fifo32_put(&task_console->fifo,8+256);
  2807d6:	50                   	push   %eax
  2807d7:	50                   	push   %eax
  2807d8:	8d 47 10             	lea    0x10(%edi),%eax
  2807db:	68 08 01 00 00       	push   $0x108
  2807e0:	50                   	push   %eax
  2807e1:	e8 22 11 00 00       	call   281908 <fifo32_put>
  2807e6:	83 c4 10             	add    $0x10,%esp
  2807e9:	c7 85 e4 fb ff ff 01 	movl   $0x1,-0x41c(%ebp)
  2807f0:	00 00 00 
  2807f3:	e9 08 01 00 00       	jmp    280900 <bootmain+0x900>
						fifo32_put(&task_console->fifo,3); //stop console cursor
					}
					sheet_refresh(sht_window,0,0,sht_window->bxsize,21);
					sheet_refresh(sht_console,0,0,sht_console->bxsize,21);
				}
			 	else if(i == 256 + 0x0e) //back key
  2807f8:	81 fa 0e 01 00 00    	cmp    $0x10e,%edx
  2807fe:	74 d6                	je     2807d6 <bootmain+0x7d6>
					else if(key_to == 1)
					{
						fifo32_put(&task_console->fifo,8+256);
					}
				}
				else if(i == 256 + 0x1c)  //return key
  280800:	81 fa 1c 01 00 00    	cmp    $0x11c,%edx
  280806:	75 1d                	jne    280825 <bootmain+0x825>
				{
					if(key_to!=0) //forcus on task_console window
  280808:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  28080f:	0f 84 eb 00 00 00    	je     280900 <bootmain+0x900>
					{
						fifo32_put(&task_console->fifo,10+256);
  280815:	50                   	push   %eax
  280816:	50                   	push   %eax
  280817:	8d 47 10             	lea    0x10(%edi),%eax
  28081a:	68 0a 01 00 00       	push   $0x10a
  28081f:	50                   	push   %eax
  280820:	e9 a1 00 00 00       	jmp    2808c6 <bootmain+0x8c6>
					}
				}
				else if(i == 256 + 0x2a)  //left shift on
  280825:	81 fa 2a 01 00 00    	cmp    $0x12a,%edx
  28082b:	75 0c                	jne    280839 <bootmain+0x839>
				{
					key_shift |= 1;
  28082d:	83 8d cc fb ff ff 01 	orl    $0x1,-0x434(%ebp)
  280834:	e9 c7 00 00 00       	jmp    280900 <bootmain+0x900>
				} 
				else if(i == 256 + 0x36) //right shift on
  280839:	81 fa 36 01 00 00    	cmp    $0x136,%edx
  28083f:	75 0c                	jne    28084d <bootmain+0x84d>
				{
					key_shift |= 2;
  280841:	83 8d cc fb ff ff 02 	orl    $0x2,-0x434(%ebp)
  280848:	e9 b3 00 00 00       	jmp    280900 <bootmain+0x900>
				}
				else if(i == 256 + 0xaa)  //left shift off
  28084d:	81 fa aa 01 00 00    	cmp    $0x1aa,%edx
  280853:	75 0c                	jne    280861 <bootmain+0x861>
				{
					key_shift &= ~1;
  280855:	83 a5 cc fb ff ff fe 	andl   $0xfffffffe,-0x434(%ebp)
  28085c:	e9 9f 00 00 00       	jmp    280900 <bootmain+0x900>
				} 
				else if(i == 256 + 0xb6) //right shift off
  280861:	81 fa b6 01 00 00    	cmp    $0x1b6,%edx
  280867:	75 0c                	jne    280875 <bootmain+0x875>
				{
					key_shift &= ~2;
  280869:	83 a5 cc fb ff ff fd 	andl   $0xfffffffd,-0x434(%ebp)
  280870:	e9 8b 00 00 00       	jmp    280900 <bootmain+0x900>
				}
				else if(i == 256 + 0x3a) //CapsLock
  280875:	81 fa 3a 01 00 00    	cmp    $0x13a,%edx
  28087b:	75 09                	jne    280886 <bootmain+0x886>
				{
					key_leds ^= 4;
  28087d:	83 b5 e0 fb ff ff 04 	xorl   $0x4,-0x420(%ebp)
  280884:	eb 20                	jmp    2808a6 <bootmain+0x8a6>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x45) //NumLock
  280886:	81 fa 45 01 00 00    	cmp    $0x145,%edx
  28088c:	75 09                	jne    280897 <bootmain+0x897>
				{
					key_leds ^= 2;
  28088e:	83 b5 e0 fb ff ff 02 	xorl   $0x2,-0x420(%ebp)
  280895:	eb 0f                	jmp    2808a6 <bootmain+0x8a6>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x46) //ScrollLock
  280897:	81 fa 46 01 00 00    	cmp    $0x146,%edx
  28089d:	75 2e                	jne    2808cd <bootmain+0x8cd>
				{
					key_leds ^= 1;
  28089f:	83 b5 e0 fb ff ff 01 	xorl   $0x1,-0x420(%ebp)
					fifo32_put(&keycmd,KEYCMD_LED);
  2808a6:	52                   	push   %edx
  2808a7:	52                   	push   %edx
  2808a8:	68 ed 00 00 00       	push   $0xed
  2808ad:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2808b3:	e8 50 10 00 00       	call   281908 <fifo32_put>
					fifo32_put(&keycmd,key_leds);
  2808b8:	59                   	pop    %ecx
  2808b9:	58                   	pop    %eax
  2808ba:	ff b5 e0 fb ff ff    	pushl  -0x420(%ebp)
  2808c0:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2808c6:	e8 3d 10 00 00       	call   281908 <fifo32_put>
  2808cb:	eb 24                	jmp    2808f1 <bootmain+0x8f1>
				}
				else if(i == 256 + 0xfa)
  2808cd:	81 fa fa 01 00 00    	cmp    $0x1fa,%edx
  2808d3:	74 21                	je     2808f6 <bootmain+0x8f6>
				{
					keycmd_wait = -1;
				}
				else if(i == 256 + 0xfe)
  2808d5:	81 fa fe 01 00 00    	cmp    $0x1fe,%edx
  2808db:	75 23                	jne    280900 <bootmain+0x900>
				{
					wait_KBC_sendready();
  2808dd:	e8 16 12 00 00       	call   281af8 <wait_KBC_sendready>
					io_out8(PORT_KEYDAT,keycmd_wait);
  2808e2:	50                   	push   %eax
  2808e3:	50                   	push   %eax
  2808e4:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  2808ea:	6a 60                	push   $0x60
  2808ec:	e8 45 02 00 00       	call   280b36 <io_out8>
  2808f1:	83 c4 10             	add    $0x10,%esp
  2808f4:	eb 0a                	jmp    280900 <bootmain+0x900>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0xfa)
				{
					keycmd_wait = -1;
  2808f6:	c7 85 c4 fb ff ff ff 	movl   $0xffffffff,-0x43c(%ebp)
  2808fd:	ff ff ff 
				else if(i == 256 + 0xfe)
				{
					wait_KBC_sendready();
					io_out8(PORT_KEYDAT,keycmd_wait);
				}
				if(cursor_c >= 0)
  280900:	83 bd dc fb ff ff 00 	cmpl   $0x0,-0x424(%ebp)
  280907:	78 1d                	js     280926 <bootmain+0x926>
				{
					//show cursor after show character
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
  280909:	50                   	push   %eax
  28090a:	8d 46 07             	lea    0x7(%esi),%eax
  28090d:	6a 2b                	push   $0x2b
  28090f:	50                   	push   %eax
  280910:	6a 1c                	push   $0x1c
  280912:	56                   	push   %esi
  280913:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280919:	ff 73 04             	pushl  0x4(%ebx)
  28091c:	ff 33                	pushl  (%ebx)
  28091e:	e8 61 03 00 00       	call   280c84 <boxfill8>
  280923:	83 c4 20             	add    $0x20,%esp
				}
				sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
  280926:	8d 46 08             	lea    0x8(%esi),%eax
  280929:	83 ec 0c             	sub    $0xc,%esp
  28092c:	6a 2c                	push   $0x2c
  28092e:	50                   	push   %eax
  28092f:	6a 1c                	push   $0x1c
  280931:	56                   	push   %esi
  280932:	53                   	push   %ebx
  280933:	e8 a9 1b 00 00       	call   2824e1 <sheet_refresh>
				sprintf(s,"%d,%d",key_leds,key_shift);
  280938:	8d 85 36 fc ff ff    	lea    -0x3ca(%ebp),%eax
  28093e:	83 c4 20             	add    $0x20,%esp
  280941:	ff b5 cc fb ff ff    	pushl  -0x434(%ebp)
  280947:	ff b5 e0 fb ff ff    	pushl  -0x420(%ebp)
  28094d:	68 16 3c 28 00       	push   $0x283c16
  280952:	50                   	push   %eax
  280953:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
  280959:	e8 be 0d 00 00       	call   28171c <sprintf>
				putfonts8_asc_sht(sht_bg,0,32,COL8_FFFFFF,COL8_000000,s,4);
  28095e:	8b 85 a4 fb ff ff    	mov    -0x45c(%ebp),%eax
  280964:	83 c4 0c             	add    $0xc,%esp
  280967:	6a 04                	push   $0x4
  280969:	50                   	push   %eax
  28096a:	6a 00                	push   $0x0
  28096c:	6a 07                	push   $0x7
  28096e:	6a 20                	push   $0x20
  280970:	6a 00                	push   $0x0
  280972:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  280978:	e8 66 07 00 00       	call   2810e3 <putfonts8_asc_sht>
  28097d:	83 c4 20             	add    $0x20,%esp
  280980:	e9 32 fb ff ff       	jmp    2804b7 <bootmain+0x4b7>

			}
			else if(512<=i && i<=767)
  280985:	8d 82 00 fe ff ff    	lea    -0x200(%edx),%eax
  28098b:	3d ff 00 00 00       	cmp    $0xff,%eax
  280990:	0f 87 b5 00 00 00    	ja     280a4b <bootmain+0xa4b>
			{
				if(mouse_decode(&mdec,i-512)!=0)
  280996:	50                   	push   %eax
  280997:	50                   	push   %eax
  280998:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  28099e:	0f b6 d2             	movzbl %dl,%edx
  2809a1:	52                   	push   %edx
  2809a2:	50                   	push   %eax
  2809a3:	e8 65 10 00 00       	call   281a0d <mouse_decode>
  2809a8:	83 c4 10             	add    $0x10,%esp
  2809ab:	85 c0                	test   %eax,%eax
  2809ad:	0f 84 04 fb ff ff    	je     2804b7 <bootmain+0x4b7>
  2809b3:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  2809b9:	31 c9                	xor    %ecx,%ecx
  2809bb:	03 85 f0 fb ff ff    	add    -0x410(%ebp),%eax
  2809c1:	0f 48 c1             	cmovs  %ecx,%eax
  2809c4:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
  2809ca:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  2809d0:	03 85 f4 fb ff ff    	add    -0x40c(%ebp),%eax
  2809d6:	0f 49 c8             	cmovns %eax,%ecx
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  2809d9:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2809e0:	39 85 d4 fb ff ff    	cmp    %eax,-0x42c(%ebp)
  2809e6:	8d 50 ff             	lea    -0x1(%eax),%edx
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2809e9:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  2809f0:	0f 4c 95 d4 fb ff ff 	cmovl  -0x42c(%ebp),%edx
  2809f7:	89 95 d4 fb ff ff    	mov    %edx,-0x42c(%ebp)
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2809fd:	8d 50 ff             	lea    -0x1(%eax),%edx
  280a00:	39 c1                	cmp    %eax,%ecx
					sheet_slide(sht_mouse,mx,my);
  280a02:	50                   	push   %eax
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  280a03:	0f 4c d1             	cmovl  %ecx,%edx
					sheet_slide(sht_mouse,mx,my);
  280a06:	52                   	push   %edx
  280a07:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280a0d:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  280a13:	89 95 d0 fb ff ff    	mov    %edx,-0x430(%ebp)
					sheet_slide(sht_mouse,mx,my);
  280a19:	e8 e5 1b 00 00       	call   282603 <sheet_slide>
					if(mdec.btn & 0x01)
  280a1e:	83 c4 10             	add    $0x10,%esp
  280a21:	f6 85 f8 fb ff ff 01 	testb  $0x1,-0x408(%ebp)
  280a28:	0f 84 89 fa ff ff    	je     2804b7 <bootmain+0x4b7>
					{
						sheet_slide(sht_window,mx-80,my-8);
  280a2e:	50                   	push   %eax
  280a2f:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  280a35:	83 e8 08             	sub    $0x8,%eax
  280a38:	50                   	push   %eax
  280a39:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  280a3f:	83 e8 50             	sub    $0x50,%eax
  280a42:	50                   	push   %eax
  280a43:	53                   	push   %ebx
  280a44:	e8 ba 1b 00 00       	call   282603 <sheet_slide>
  280a49:	eb 5e                	jmp    280aa9 <bootmain+0xaa9>
					}
				}
			}
			else if(i<=1)
  280a4b:	83 fa 01             	cmp    $0x1,%edx
  280a4e:	0f 8f 63 fa ff ff    	jg     2804b7 <bootmain+0x4b7>
			{
				if(i != 0)
  280a54:	85 d2                	test   %edx,%edx
  280a56:	74 22                	je     280a7a <bootmain+0xa7a>
				{
					timer_init(timer,&fifo,0);
  280a58:	50                   	push   %eax
  280a59:	6a 00                	push   $0x0
  280a5b:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280a61:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280a67:	e8 eb 1c 00 00       	call   282757 <timer_init>
					if(cursor_c>=0) cursor_c = COL8_000000;
  280a6c:	83 c4 10             	add    $0x10,%esp
  280a6f:	83 bd dc fb ff ff 00 	cmpl   $0x0,-0x424(%ebp)
  280a76:	79 39                	jns    280ab1 <bootmain+0xab1>
  280a78:	eb 20                	jmp    280a9a <bootmain+0xa9a>
				}
				else
				{
					timer_init(timer,&fifo,1);
  280a7a:	51                   	push   %ecx
  280a7b:	6a 01                	push   $0x1
  280a7d:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280a83:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280a89:	e8 c9 1c 00 00       	call   282757 <timer_init>
					if(cursor_c>=0) cursor_c = COL8_FFFFFF;
  280a8e:	83 c4 10             	add    $0x10,%esp
  280a91:	83 bd dc fb ff ff 00 	cmpl   $0x0,-0x424(%ebp)
  280a98:	79 23                	jns    280abd <bootmain+0xabd>
				if(cursor_c >= 0) // check if the color invalid
				{
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
					sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
				}
				timer_settime(timer,50);
  280a9a:	52                   	push   %edx
  280a9b:	52                   	push   %edx
  280a9c:	6a 32                	push   $0x32
  280a9e:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280aa4:	e8 c2 1c 00 00       	call   28276b <timer_settime>
  280aa9:	83 c4 10             	add    $0x10,%esp
  280aac:	e9 06 fa ff ff       	jmp    2804b7 <bootmain+0x4b7>
			else if(i<=1)
			{
				if(i != 0)
				{
					timer_init(timer,&fifo,0);
					if(cursor_c>=0) cursor_c = COL8_000000;
  280ab1:	c7 85 dc fb ff ff 00 	movl   $0x0,-0x424(%ebp)
  280ab8:	00 00 00 
  280abb:	eb 0a                	jmp    280ac7 <bootmain+0xac7>
				}
				else
				{
					timer_init(timer,&fifo,1);
					if(cursor_c>=0) cursor_c = COL8_FFFFFF;
  280abd:	c7 85 dc fb ff ff 07 	movl   $0x7,-0x424(%ebp)
  280ac4:	00 00 00 
				}
				if(cursor_c >= 0) // check if the color invalid
				{
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
  280ac7:	50                   	push   %eax
  280ac8:	8d 46 07             	lea    0x7(%esi),%eax
  280acb:	6a 2b                	push   $0x2b
  280acd:	50                   	push   %eax
  280ace:	6a 1c                	push   $0x1c
  280ad0:	56                   	push   %esi
  280ad1:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280ad7:	ff 73 04             	pushl  0x4(%ebx)
  280ada:	ff 33                	pushl  (%ebx)
  280adc:	e8 a3 01 00 00       	call   280c84 <boxfill8>
					sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
  280ae1:	8d 46 08             	lea    0x8(%esi),%eax
  280ae4:	83 c4 14             	add    $0x14,%esp
  280ae7:	6a 2c                	push   $0x2c
  280ae9:	50                   	push   %eax
  280aea:	6a 1c                	push   $0x1c
  280aec:	56                   	push   %esi
  280aed:	53                   	push   %ebx
  280aee:	e8 ee 19 00 00       	call   2824e1 <sheet_refresh>
  280af3:	83 c4 20             	add    $0x20,%esp
  280af6:	eb a2                	jmp    280a9a <bootmain+0xa9a>
  280af8:	66 90                	xchg   %ax,%ax
  280afa:	66 90                	xchg   %ax,%ax
  280afc:	66 90                	xchg   %ax,%ax
  280afe:	66 90                	xchg   %ax,%ax

00280b00 <io_hlt>:
  280b00:	f4                   	hlt    
  280b01:	c3                   	ret    

00280b02 <io_cli>:
  280b02:	fa                   	cli    
  280b03:	c3                   	ret    

00280b04 <io_sti>:
  280b04:	fb                   	sti    
  280b05:	c3                   	ret    

00280b06 <io_stihlt>:
  280b06:	fb                   	sti    
  280b07:	f4                   	hlt    
  280b08:	c3                   	ret    

00280b09 <write_mem8>:
  280b09:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  280b0d:	8a 44 24 08          	mov    0x8(%esp),%al
  280b11:	88 01                	mov    %al,(%ecx)
  280b13:	c3                   	ret    

00280b14 <io_in8>:
  280b14:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b18:	b8 00 00 00 00       	mov    $0x0,%eax
  280b1d:	ec                   	in     (%dx),%al
  280b1e:	c3                   	ret    

00280b1f <io_in16>:
  280b1f:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b23:	b8 00 00 00 00       	mov    $0x0,%eax
  280b28:	66 ed                	in     (%dx),%ax
  280b2a:	c3                   	ret    

00280b2b <io_in32>:
  280b2b:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b2f:	b8 00 00 00 00       	mov    $0x0,%eax
  280b34:	ed                   	in     (%dx),%eax
  280b35:	c3                   	ret    

00280b36 <io_out8>:
  280b36:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b3a:	8b 44 24 08          	mov    0x8(%esp),%eax
  280b3e:	ee                   	out    %al,(%dx)
  280b3f:	c3                   	ret    

00280b40 <io_out16>:
  280b40:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b44:	8b 44 24 08          	mov    0x8(%esp),%eax
  280b48:	66 ef                	out    %ax,(%dx)
  280b4a:	c3                   	ret    

00280b4b <io_out32>:
  280b4b:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b4f:	8b 44 24 08          	mov    0x8(%esp),%eax
  280b53:	ef                   	out    %eax,(%dx)
  280b54:	c3                   	ret    

00280b55 <io_load_eflags>:
  280b55:	9c                   	pushf  
  280b56:	58                   	pop    %eax
  280b57:	c3                   	ret    

00280b58 <io_store_eflags>:
  280b58:	8b 44 24 04          	mov    0x4(%esp),%eax
  280b5c:	50                   	push   %eax
  280b5d:	9d                   	popf   
  280b5e:	c3                   	ret    

00280b5f <load_gdtr>:
  280b5f:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280b64:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280b69:	0f 01 54 24 06       	lgdtl  0x6(%esp)
  280b6e:	c3                   	ret    

00280b6f <load_idtr>:
  280b6f:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280b74:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280b79:	0f 01 5c 24 06       	lidtl  0x6(%esp)
  280b7e:	c3                   	ret    

00280b7f <load_cr0>:
  280b7f:	0f 20 c0             	mov    %cr0,%eax
  280b82:	c3                   	ret    

00280b83 <store_cr0>:
  280b83:	8b 44 24 04          	mov    0x4(%esp),%eax
  280b87:	0f 22 c0             	mov    %eax,%cr0
  280b8a:	c3                   	ret    

00280b8b <_memtest_sub>:
  280b8b:	57                   	push   %edi
  280b8c:	56                   	push   %esi
  280b8d:	53                   	push   %ebx
  280b8e:	be 55 aa 55 aa       	mov    $0xaa55aa55,%esi
  280b93:	bf aa 55 aa 55       	mov    $0x55aa55aa,%edi
  280b98:	8b 44 24 10          	mov    0x10(%esp),%eax

00280b9c <mts_loop>:
  280b9c:	89 c3                	mov    %eax,%ebx
  280b9e:	81 c3 fc 0f 00 00    	add    $0xffc,%ebx
  280ba4:	8b 13                	mov    (%ebx),%edx
  280ba6:	89 33                	mov    %esi,(%ebx)
  280ba8:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280bab:	3b 3b                	cmp    (%ebx),%edi
  280bad:	75 18                	jne    280bc7 <mts_qit>
  280baf:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280bb2:	3b 33                	cmp    (%ebx),%esi
  280bb4:	75 11                	jne    280bc7 <mts_qit>
  280bb6:	89 13                	mov    %edx,(%ebx)
  280bb8:	05 00 10 00 00       	add    $0x1000,%eax
  280bbd:	3b 44 24 14          	cmp    0x14(%esp),%eax
  280bc1:	76 d9                	jbe    280b9c <mts_loop>

00280bc3 <mts_ret>:
  280bc3:	5b                   	pop    %ebx
  280bc4:	5e                   	pop    %esi
  280bc5:	5f                   	pop    %edi
  280bc6:	c3                   	ret    

00280bc7 <mts_qit>:
  280bc7:	89 13                	mov    %edx,(%ebx)
  280bc9:	5b                   	pop    %ebx
  280bca:	5e                   	pop    %esi
  280bcb:	5f                   	pop    %edi
  280bcc:	c3                   	ret    

00280bcd <set_palette>:
	set_palette(0,15,table_rgb);
	return;	
}

void set_palette(int start, int end, unsigned char *rgb)
{
  280bcd:	55                   	push   %ebp
  280bce:	89 e5                	mov    %esp,%ebp
  280bd0:	57                   	push   %edi
  280bd1:	56                   	push   %esi
  280bd2:	53                   	push   %ebx
  280bd3:	83 ec 1c             	sub    $0x1c,%esp
  280bd6:	8b 75 08             	mov    0x8(%ebp),%esi
  280bd9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  280bdc:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int i,eflags;
	eflags = io_load_eflags();
  280bdf:	e8 71 ff ff ff       	call   280b55 <io_load_eflags>
  280be4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	io_cli();
  280be7:	e8 16 ff ff ff       	call   280b02 <io_cli>
	io_out8(0x03c8,start);
  280bec:	83 ec 08             	sub    $0x8,%esp
  280bef:	56                   	push   %esi
  280bf0:	68 c8 03 00 00       	push   $0x3c8
  280bf5:	e8 3c ff ff ff       	call   280b36 <io_out8>
	for(i=start;i<=end;i++)
  280bfa:	83 c4 10             	add    $0x10,%esp
  280bfd:	39 fe                	cmp    %edi,%esi
  280bff:	7f 54                	jg     280c55 <set_palette+0x88>
	{
		io_out8(0x03c9,rgb[0]/4);
  280c01:	83 ec 08             	sub    $0x8,%esp
  280c04:	0f b6 03             	movzbl (%ebx),%eax
  280c07:	c0 e8 02             	shr    $0x2,%al
  280c0a:	0f b6 c0             	movzbl %al,%eax
  280c0d:	50                   	push   %eax
  280c0e:	68 c9 03 00 00       	push   $0x3c9
  280c13:	e8 1e ff ff ff       	call   280b36 <io_out8>
		io_out8(0x03c9,rgb[1]/4);
  280c18:	83 c4 08             	add    $0x8,%esp
  280c1b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  280c1f:	c0 e8 02             	shr    $0x2,%al
  280c22:	0f b6 c0             	movzbl %al,%eax
  280c25:	50                   	push   %eax
  280c26:	68 c9 03 00 00       	push   $0x3c9
  280c2b:	e8 06 ff ff ff       	call   280b36 <io_out8>
		io_out8(0x03c9,rgb[2]/4);
  280c30:	83 c4 08             	add    $0x8,%esp
  280c33:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
  280c37:	c0 e8 02             	shr    $0x2,%al
  280c3a:	0f b6 c0             	movzbl %al,%eax
  280c3d:	50                   	push   %eax
  280c3e:	68 c9 03 00 00       	push   $0x3c9
  280c43:	e8 ee fe ff ff       	call   280b36 <io_out8>
		rgb+=3;
  280c48:	83 c3 03             	add    $0x3,%ebx
{
	int i,eflags;
	eflags = io_load_eflags();
	io_cli();
	io_out8(0x03c8,start);
	for(i=start;i<=end;i++)
  280c4b:	83 c6 01             	add    $0x1,%esi
  280c4e:	83 c4 10             	add    $0x10,%esp
  280c51:	39 f7                	cmp    %esi,%edi
  280c53:	7d ac                	jge    280c01 <set_palette+0x34>
		io_out8(0x03c9,rgb[0]/4);
		io_out8(0x03c9,rgb[1]/4);
		io_out8(0x03c9,rgb[2]/4);
		rgb+=3;
	}
	io_store_eflags(eflags);
  280c55:	83 ec 0c             	sub    $0xc,%esp
  280c58:	ff 75 e4             	pushl  -0x1c(%ebp)
  280c5b:	e8 f8 fe ff ff       	call   280b58 <io_store_eflags>
	return;
  280c60:	83 c4 10             	add    $0x10,%esp
}
  280c63:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280c66:	5b                   	pop    %ebx
  280c67:	5e                   	pop    %esi
  280c68:	5f                   	pop    %edi
  280c69:	5d                   	pop    %ebp
  280c6a:	c3                   	ret    

00280c6b <init_palette>:
#include "graphics.h"

void init_palette(void)
{
  280c6b:	55                   	push   %ebp
  280c6c:	89 e5                	mov    %esp,%ebp
  280c6e:	83 ec 0c             	sub    $0xc,%esp
		0x00, 0x00, 0x84,	//dark blue
		0x84, 0x00, 0x84,	//dark purple
		0x00, 0x84, 0x84,	//dark light blue
		0x84, 0x84, 0x84,	//dark gray
	};
	set_palette(0,15,table_rgb);
  280c71:	68 80 4a 28 00       	push   $0x284a80
  280c76:	6a 0f                	push   $0xf
  280c78:	6a 00                	push   $0x0
  280c7a:	e8 4e ff ff ff       	call   280bcd <set_palette>
	return;	
  280c7f:	83 c4 10             	add    $0x10,%esp
}
  280c82:	c9                   	leave  
  280c83:	c3                   	ret    

00280c84 <boxfill8>:
	io_store_eflags(eflags);
	return;
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
  280c84:	55                   	push   %ebp
  280c85:	89 e5                	mov    %esp,%ebp
  280c87:	57                   	push   %edi
  280c88:	56                   	push   %esi
  280c89:	53                   	push   %ebx
  280c8a:	83 ec 04             	sub    $0x4,%esp
  280c8d:	8b 55 0c             	mov    0xc(%ebp),%edx
  280c90:	8b 7d 14             	mov    0x14(%ebp),%edi
  280c93:	8b 75 18             	mov    0x18(%ebp),%esi
  280c96:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  280c99:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
	int x,y;
	for(y=y0;y<=y1;y++)
  280c9d:	3b 75 20             	cmp    0x20(%ebp),%esi
  280ca0:	7f 28                	jg     280cca <boxfill8+0x46>
  280ca2:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280ca5:	0f af d6             	imul   %esi,%edx
  280ca8:	03 55 08             	add    0x8(%ebp),%edx
  280cab:	eb 15                	jmp    280cc2 <boxfill8+0x3e>
	{
		for(x=x0;x<=x1;x++)
			vram[y*xsize+x]=c;
  280cad:	88 1c 02             	mov    %bl,(%edx,%eax,1)
void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
	{
		for(x=x0;x<=x1;x++)
  280cb0:	83 c0 01             	add    $0x1,%eax
  280cb3:	39 c1                	cmp    %eax,%ecx
  280cb5:	7d f6                	jge    280cad <boxfill8+0x29>
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
  280cb7:	83 c6 01             	add    $0x1,%esi
  280cba:	03 55 f0             	add    -0x10(%ebp),%edx
  280cbd:	39 75 20             	cmp    %esi,0x20(%ebp)
  280cc0:	7c 08                	jl     280cca <boxfill8+0x46>
	{
		for(x=x0;x<=x1;x++)
  280cc2:	89 f8                	mov    %edi,%eax
  280cc4:	39 cf                	cmp    %ecx,%edi
  280cc6:	7e e5                	jle    280cad <boxfill8+0x29>
  280cc8:	eb ed                	jmp    280cb7 <boxfill8+0x33>
			vram[y*xsize+x]=c;
	}
		
	return;
}
  280cca:	83 c4 04             	add    $0x4,%esp
  280ccd:	5b                   	pop    %ebx
  280cce:	5e                   	pop    %esi
  280ccf:	5f                   	pop    %edi
  280cd0:	5d                   	pop    %ebp
  280cd1:	c3                   	ret    

00280cd2 <boxfill8_test>:

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
  280cd2:	55                   	push   %ebp
  280cd3:	89 e5                	mov    %esp,%ebp
  280cd5:	53                   	push   %ebx
  280cd6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  280cd9:	8b 55 10             	mov    0x10(%ebp),%edx
  280cdc:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	int i;
	for(i=0;i<size;i++)
  280ce0:	85 d2                	test   %edx,%edx
  280ce2:	7e 0d                	jle    280cf1 <boxfill8_test+0x1f>
  280ce4:	89 d8                	mov    %ebx,%eax
  280ce6:	01 da                	add    %ebx,%edx
	{
		vram[i] = c;
  280ce8:	88 08                	mov    %cl,(%eax)
  280cea:	83 c0 01             	add    $0x1,%eax
}

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
	int i;
	for(i=0;i<size;i++)
  280ced:	39 d0                	cmp    %edx,%eax
  280cef:	75 f7                	jne    280ce8 <boxfill8_test+0x16>
	{
		vram[i] = c;
	}
	//vram[TRY_BG_SIZE-1] = c;
}
  280cf1:	5b                   	pop    %ebx
  280cf2:	5d                   	pop    %ebp
  280cf3:	c3                   	ret    

00280cf4 <init_screen8>:

void init_screen8(unsigned char *vram, int xsize, int ysize)
{
  280cf4:	55                   	push   %ebp
  280cf5:	89 e5                	mov    %esp,%ebp
  280cf7:	57                   	push   %edi
  280cf8:	56                   	push   %esi
  280cf9:	53                   	push   %ebx
  280cfa:	83 ec 14             	sub    $0x14,%esp
  280cfd:	8b 7d 08             	mov    0x8(%ebp),%edi
  280d00:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280d03:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(vram,310,COL8_008484,0,0,310,190);
  280d06:	68 be 00 00 00       	push   $0xbe
  280d0b:	68 36 01 00 00       	push   $0x136
  280d10:	6a 00                	push   $0x0
  280d12:	6a 00                	push   $0x0
  280d14:	6a 0e                	push   $0xe
  280d16:	68 36 01 00 00       	push   $0x136
  280d1b:	57                   	push   %edi
  280d1c:	e8 63 ff ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_008484,0,      0,          xsize-1,    ysize-29);
  280d21:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280d24:	89 c2                	mov    %eax,%edx
  280d26:	8d 46 e3             	lea    -0x1d(%esi),%eax
  280d29:	50                   	push   %eax
  280d2a:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280d2d:	52                   	push   %edx
  280d2e:	6a 00                	push   $0x0
  280d30:	6a 00                	push   $0x0
  280d32:	6a 0e                	push   $0xe
  280d34:	53                   	push   %ebx
  280d35:	57                   	push   %edi
  280d36:	e8 49 ff ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-28,   xsize-1,    ysize-28);
  280d3b:	8d 46 e4             	lea    -0x1c(%esi),%eax
  280d3e:	83 c4 38             	add    $0x38,%esp
  280d41:	50                   	push   %eax
  280d42:	ff 75 f0             	pushl  -0x10(%ebp)
  280d45:	50                   	push   %eax
  280d46:	6a 00                	push   $0x0
  280d48:	6a 08                	push   $0x8
  280d4a:	53                   	push   %ebx
  280d4b:	57                   	push   %edi
  280d4c:	e8 33 ff ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,0,      ysize-27,   xsize-1,    ysize-27);
  280d51:	8d 46 e5             	lea    -0x1b(%esi),%eax
  280d54:	50                   	push   %eax
  280d55:	ff 75 f0             	pushl  -0x10(%ebp)
  280d58:	50                   	push   %eax
  280d59:	6a 00                	push   $0x0
  280d5b:	6a 07                	push   $0x7
  280d5d:	53                   	push   %ebx
  280d5e:	57                   	push   %edi
  280d5f:	e8 20 ff ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-26,   xsize-1,    ysize- 1);
  280d64:	83 c4 38             	add    $0x38,%esp
  280d67:	8d 46 ff             	lea    -0x1(%esi),%eax
  280d6a:	50                   	push   %eax
  280d6b:	ff 75 f0             	pushl  -0x10(%ebp)
  280d6e:	8d 46 e6             	lea    -0x1a(%esi),%eax
  280d71:	50                   	push   %eax
  280d72:	6a 00                	push   $0x0
  280d74:	6a 08                	push   $0x8
  280d76:	53                   	push   %ebx
  280d77:	57                   	push   %edi
  280d78:	e8 07 ff ff ff       	call   280c84 <boxfill8>
	
	
	boxfill8(vram,xsize,COL8_FFFFFF,3,      ysize-24,   59,         ysize-24);
  280d7d:	8d 46 e8             	lea    -0x18(%esi),%eax
  280d80:	50                   	push   %eax
  280d81:	6a 3b                	push   $0x3b
  280d83:	89 45 f0             	mov    %eax,-0x10(%ebp)
  280d86:	50                   	push   %eax
  280d87:	6a 03                	push   $0x3
  280d89:	6a 07                	push   $0x7
  280d8b:	53                   	push   %ebx
  280d8c:	57                   	push   %edi
  280d8d:	e8 f2 fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,2,      ysize-24,    2,         ysize- 4);
  280d92:	8d 4e fc             	lea    -0x4(%esi),%ecx
  280d95:	83 c4 38             	add    $0x38,%esp
  280d98:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  280d9b:	51                   	push   %ecx
  280d9c:	6a 02                	push   $0x2
  280d9e:	ff 75 f0             	pushl  -0x10(%ebp)
  280da1:	6a 02                	push   $0x2
  280da3:	6a 07                	push   $0x7
  280da5:	53                   	push   %ebx
  280da6:	57                   	push   %edi
  280da7:	e8 d8 fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,3,      ysize- 4,   59,         ysize- 4);
  280dac:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  280daf:	51                   	push   %ecx
  280db0:	6a 3b                	push   $0x3b
  280db2:	51                   	push   %ecx
  280db3:	6a 03                	push   $0x3
  280db5:	6a 0f                	push   $0xf
  280db7:	53                   	push   %ebx
  280db8:	57                   	push   %edi
  280db9:	e8 c6 fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,59,     ysize-23,   59,         ysize- 5);
  280dbe:	8d 56 e9             	lea    -0x17(%esi),%edx
  280dc1:	83 c4 38             	add    $0x38,%esp
  280dc4:	8d 46 fb             	lea    -0x5(%esi),%eax
  280dc7:	50                   	push   %eax
  280dc8:	6a 3b                	push   $0x3b
  280dca:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  280dcd:	52                   	push   %edx
  280dce:	6a 3b                	push   $0x3b
  280dd0:	6a 0f                	push   $0xf
  280dd2:	53                   	push   %ebx
  280dd3:	57                   	push   %edi
  280dd4:	e8 ab fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,2,      ysize- 3,   59,         ysize- 3);
  280dd9:	83 ee 03             	sub    $0x3,%esi
  280ddc:	56                   	push   %esi
  280ddd:	6a 3b                	push   $0x3b
  280ddf:	56                   	push   %esi
  280de0:	6a 02                	push   $0x2
  280de2:	6a 00                	push   $0x0
  280de4:	53                   	push   %ebx
  280de5:	57                   	push   %edi
  280de6:	e8 99 fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,60,     ysize-24,   60,         ysize- 3);
  280deb:	83 c4 38             	add    $0x38,%esp
  280dee:	56                   	push   %esi
  280def:	6a 3c                	push   $0x3c
  280df1:	ff 75 f0             	pushl  -0x10(%ebp)
  280df4:	6a 3c                	push   $0x3c
  280df6:	6a 00                	push   $0x0
  280df8:	53                   	push   %ebx
  280df9:	57                   	push   %edi
  280dfa:	e8 85 fe ff ff       	call   280c84 <boxfill8>
	
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-24,   xsize- 4,   ysize-24);
  280dff:	8d 4b fc             	lea    -0x4(%ebx),%ecx
  280e02:	8d 53 d1             	lea    -0x2f(%ebx),%edx
  280e05:	8b 45 f0             	mov    -0x10(%ebp),%eax
  280e08:	50                   	push   %eax
  280e09:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  280e0c:	51                   	push   %ecx
  280e0d:	50                   	push   %eax
  280e0e:	89 55 e8             	mov    %edx,-0x18(%ebp)
  280e11:	52                   	push   %edx
  280e12:	6a 0f                	push   $0xf
  280e14:	53                   	push   %ebx
  280e15:	57                   	push   %edi
  280e16:	e8 69 fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-23,   xsize-47,   ysize- 4);
  280e1b:	83 c4 38             	add    $0x38,%esp
  280e1e:	ff 75 ec             	pushl  -0x14(%ebp)
  280e21:	8b 55 e8             	mov    -0x18(%ebp),%edx
  280e24:	52                   	push   %edx
  280e25:	ff 75 e4             	pushl  -0x1c(%ebp)
  280e28:	52                   	push   %edx
  280e29:	6a 0f                	push   $0xf
  280e2b:	53                   	push   %ebx
  280e2c:	57                   	push   %edi
  280e2d:	e8 52 fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize-47,       ysize- 3,   xsize- 4,   ysize- 3);
  280e32:	56                   	push   %esi
  280e33:	ff 75 e0             	pushl  -0x20(%ebp)
  280e36:	56                   	push   %esi
  280e37:	ff 75 e8             	pushl  -0x18(%ebp)
  280e3a:	6a 07                	push   $0x7
  280e3c:	53                   	push   %ebx
  280e3d:	57                   	push   %edi
  280e3e:	e8 41 fe ff ff       	call   280c84 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
  280e43:	8d 43 fd             	lea    -0x3(%ebx),%eax
  280e46:	83 c4 38             	add    $0x38,%esp
  280e49:	56                   	push   %esi
  280e4a:	50                   	push   %eax
  280e4b:	ff 75 f0             	pushl  -0x10(%ebp)
  280e4e:	50                   	push   %eax
  280e4f:	6a 07                	push   $0x7
  280e51:	53                   	push   %ebx
  280e52:	57                   	push   %edi
  280e53:	e8 2c fe ff ff       	call   280c84 <boxfill8>
}
  280e58:	83 c4 1c             	add    $0x1c,%esp
  280e5b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280e5e:	5b                   	pop    %ebx
  280e5f:	5e                   	pop    %esi
  280e60:	5f                   	pop    %edi
  280e61:	5d                   	pop    %ebp
  280e62:	c3                   	ret    

00280e63 <init_mouse_cursor8>:


void init_mouse_cursor8(char *mouse, char bc)
{
  280e63:	55                   	push   %ebp
  280e64:	89 e5                	mov    %esp,%ebp
  280e66:	57                   	push   %edi
  280e67:	56                   	push   %esi
  280e68:	53                   	push   %ebx
  280e69:	83 ec 08             	sub    $0x8,%esp
  280e6c:	8b 75 08             	mov    0x8(%ebp),%esi
  280e6f:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
  280e73:	89 75 f0             	mov    %esi,-0x10(%ebp)
  280e76:	8d 86 00 01 00 00    	lea    0x100(%esi),%eax
  280e7c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  280e7f:	eb 38                	jmp    280eb9 <init_mouse_cursor8+0x56>
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280e81:	0f b6 94 03 00 3d 28 	movzbl 0x283d00(%ebx,%eax,1),%edx
  280e88:	00 
  280e89:	80 fa 2a             	cmp    $0x2a,%dl
  280e8c:	75 06                	jne    280e94 <init_mouse_cursor8+0x31>
				mouse[y*16+x] = COL8_000000;
  280e8e:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
  280e92:	eb 15                	jmp    280ea9 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == 'O')
  280e94:	80 fa 4f             	cmp    $0x4f,%dl
  280e97:	75 06                	jne    280e9f <init_mouse_cursor8+0x3c>
				mouse[y*16+x] = COL8_FFFFFF;
  280e99:	c6 04 06 07          	movb   $0x7,(%esi,%eax,1)
  280e9d:	eb 0a                	jmp    280ea9 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == '.')
  280e9f:	80 fa 2e             	cmp    $0x2e,%dl
  280ea2:	75 05                	jne    280ea9 <init_mouse_cursor8+0x46>
				mouse[y*16+x] = bc;
  280ea4:	89 fa                	mov    %edi,%edx
  280ea6:	88 14 06             	mov    %dl,(%esi,%eax,1)
	};
	int x,y;
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
  280ea9:	83 c0 01             	add    $0x1,%eax
  280eac:	83 f8 10             	cmp    $0x10,%eax
  280eaf:	75 d0                	jne    280e81 <init_mouse_cursor8+0x1e>
  280eb1:	83 c6 10             	add    $0x10,%esi
        "............*OO*",
        ".............***"
	};
	int x,y;
	
	for(y=0;y<16;y++)
  280eb4:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  280eb7:	74 0c                	je     280ec5 <init_mouse_cursor8+0x62>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
}


void init_mouse_cursor8(char *mouse, char bc)
{
  280eb9:	b8 00 00 00 00       	mov    $0x0,%eax
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280ebe:	89 f3                	mov    %esi,%ebx
  280ec0:	2b 5d f0             	sub    -0x10(%ebp),%ebx
  280ec3:	eb bc                	jmp    280e81 <init_mouse_cursor8+0x1e>
			else if(cursor[y][x] == '.')
				mouse[y*16+x] = bc;
		}
	}
	return;
}
  280ec5:	83 c4 08             	add    $0x8,%esp
  280ec8:	5b                   	pop    %ebx
  280ec9:	5e                   	pop    %esi
  280eca:	5f                   	pop    %edi
  280ecb:	5d                   	pop    %ebp
  280ecc:	c3                   	ret    

00280ecd <make_wtitle8>:
	make_wtitle8(buf,xsize,title,act);
	return;
}

void make_wtitle8(unsigned char *buf,int xsize,char *title,char act)
{
  280ecd:	55                   	push   %ebp
  280ece:	89 e5                	mov    %esp,%ebp
  280ed0:	57                   	push   %edi
  280ed1:	56                   	push   %esi
  280ed2:	53                   	push   %ebx
  280ed3:	83 ec 1c             	sub    $0x1c,%esp
  280ed6:	8b 75 08             	mov    0x8(%ebp),%esi
  280ed9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280edc:	8b 55 14             	mov    0x14(%ebp),%edx
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
		tbc= COL8_848484;
  280edf:	80 fa 01             	cmp    $0x1,%dl
  280ee2:	19 c0                	sbb    %eax,%eax
  280ee4:	83 e0 03             	and    $0x3,%eax
  280ee7:	83 c0 0c             	add    $0xc,%eax
  280eea:	80 fa 01             	cmp    $0x1,%dl
  280eed:	19 ff                	sbb    %edi,%edi
  280eef:	f7 d7                	not    %edi
  280ef1:	83 c7 08             	add    $0x8,%edi
	}
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
  280ef4:	6a 14                	push   $0x14
  280ef6:	8d 53 fc             	lea    -0x4(%ebx),%edx
  280ef9:	52                   	push   %edx
  280efa:	6a 03                	push   $0x3
  280efc:	6a 03                	push   $0x3
  280efe:	0f b6 c0             	movzbl %al,%eax
  280f01:	50                   	push   %eax
  280f02:	53                   	push   %ebx
  280f03:	56                   	push   %esi
  280f04:	e8 7b fd ff ff       	call   280c84 <boxfill8>
	putfonts8_asc(buf,xsize,24,4,tc,title);
  280f09:	83 c4 04             	add    $0x4,%esp
  280f0c:	ff 75 10             	pushl  0x10(%ebp)
  280f0f:	89 f8                	mov    %edi,%eax
  280f11:	0f be f8             	movsbl %al,%edi
  280f14:	57                   	push   %edi
  280f15:	6a 04                	push   $0x4
  280f17:	6a 18                	push   $0x18
  280f19:	53                   	push   %ebx
  280f1a:	56                   	push   %esi
  280f1b:	e8 b9 03 00 00       	call   2812d9 <putfonts8_asc>
  280f20:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  280f23:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
  280f26:	01 fb                	add    %edi,%ebx
  280f28:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
  280f2b:	83 c4 30             	add    $0x30,%esp
  280f2e:	be 00 00 00 00       	mov    $0x0,%esi
  280f33:	eb 41                	jmp    280f76 <make_wtitle8+0xa9>
  280f35:	89 c1                	mov    %eax,%ecx
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
		{
			c=closebtn[y][x];
  280f37:	0f b6 9c 06 20 3c 28 	movzbl 0x283c20(%esi,%eax,1),%ebx
  280f3e:	00 
			if(c == '@') c=COL8_000000;
  280f3f:	ba 00 00 00 00       	mov    $0x0,%edx
  280f44:	80 fb 40             	cmp    $0x40,%bl
  280f47:	74 13                	je     280f5c <make_wtitle8+0x8f>
			else if(c == '$') c=COL8_848484;
  280f49:	ba 0f 00 00 00       	mov    $0xf,%edx
  280f4e:	80 fb 24             	cmp    $0x24,%bl
  280f51:	74 09                	je     280f5c <make_wtitle8+0x8f>
			else if(c == 'Q') c=COL8_C6C6C6;
			else c=COL8_FFFFFF;
  280f53:	80 fb 51             	cmp    $0x51,%bl
  280f56:	0f 94 c2             	sete   %dl
  280f59:	83 c2 07             	add    $0x7,%edx
			buf[(5+y)*xsize+(xsize-21+x)] = c;
  280f5c:	88 54 0f eb          	mov    %dl,-0x15(%edi,%ecx,1)
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
  280f60:	83 c0 01             	add    $0x1,%eax
  280f63:	83 f8 10             	cmp    $0x10,%eax
  280f66:	75 cd                	jne    280f35 <make_wtitle8+0x68>
  280f68:	03 7d e4             	add    -0x1c(%ebp),%edi
  280f6b:	83 c6 10             	add    $0x10,%esi
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
  280f6e:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
  280f74:	74 07                	je     280f7d <make_wtitle8+0xb0>
		tc = COL8_FFFFFF;
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
  280f76:	b8 00 00 00 00       	mov    $0x0,%eax
  280f7b:	eb b8                	jmp    280f35 <make_wtitle8+0x68>
			else c=COL8_FFFFFF;
			buf[(5+y)*xsize+(xsize-21+x)] = c;
		}
	}
	return;
}
  280f7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280f80:	5b                   	pop    %ebx
  280f81:	5e                   	pop    %esi
  280f82:	5f                   	pop    %edi
  280f83:	5d                   	pop    %ebp
  280f84:	c3                   	ret    

00280f85 <make_window8>:
	}
	return;
}

void make_window8(unsigned char *buf,int xsize,int ysize,char *title,char act)
{
  280f85:	55                   	push   %ebp
  280f86:	89 e5                	mov    %esp,%ebp
  280f88:	57                   	push   %edi
  280f89:	56                   	push   %esi
  280f8a:	53                   	push   %ebx
  280f8b:	83 ec 1c             	sub    $0x1c,%esp
  280f8e:	8b 75 08             	mov    0x8(%ebp),%esi
  280f91:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280f94:	8b 45 18             	mov    0x18(%ebp),%eax
  280f97:	89 45 d8             	mov    %eax,-0x28(%ebp)
	boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , xsize - 1, 0  );
  280f9a:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280f9d:	6a 00                	push   $0x0
  280f9f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  280fa2:	50                   	push   %eax
  280fa3:	6a 00                	push   $0x0
  280fa5:	6a 00                	push   $0x0
  280fa7:	6a 08                	push   $0x8
  280fa9:	53                   	push   %ebx
  280faa:	56                   	push   %esi
  280fab:	e8 d4 fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , xsize - 2, 1  );
  280fb0:	8d 53 fe             	lea    -0x2(%ebx),%edx
  280fb3:	6a 01                	push   $0x1
  280fb5:	89 55 e0             	mov    %edx,-0x20(%ebp)
  280fb8:	52                   	push   %edx
  280fb9:	6a 01                	push   $0x1
  280fbb:	6a 01                	push   $0x1
  280fbd:	6a 07                	push   $0x7
  280fbf:	53                   	push   %ebx
  280fc0:	56                   	push   %esi
  280fc1:	e8 be fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , 0     , ysize-1);
  280fc6:	8b 7d 10             	mov    0x10(%ebp),%edi
  280fc9:	8d 4f ff             	lea    -0x1(%edi),%ecx
  280fcc:	83 c4 38             	add    $0x38,%esp
  280fcf:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  280fd2:	51                   	push   %ecx
  280fd3:	6a 00                	push   $0x0
  280fd5:	6a 00                	push   $0x0
  280fd7:	6a 00                	push   $0x0
  280fd9:	6a 08                	push   $0x8
  280fdb:	53                   	push   %ebx
  280fdc:	56                   	push   %esi
  280fdd:	e8 a2 fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , 1     , ysize-2);
  280fe2:	8b 7d 10             	mov    0x10(%ebp),%edi
  280fe5:	83 ef 02             	sub    $0x2,%edi
  280fe8:	57                   	push   %edi
  280fe9:	6a 01                	push   $0x1
  280feb:	6a 01                	push   $0x1
  280fed:	6a 01                	push   $0x1
  280fef:	6a 07                	push   $0x7
  280ff1:	53                   	push   %ebx
  280ff2:	56                   	push   %esi
  280ff3:	e8 8c fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, xsize-2,1     , xsize-2,ysize-2);
  280ff8:	83 c4 38             	add    $0x38,%esp
  280ffb:	57                   	push   %edi
  280ffc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  280fff:	52                   	push   %edx
  281000:	6a 01                	push   $0x1
  281002:	52                   	push   %edx
  281003:	6a 0f                	push   $0xf
  281005:	53                   	push   %ebx
  281006:	56                   	push   %esi
  281007:	e8 78 fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, xsize-1,0     , xsize-1,ysize-1);
  28100c:	ff 75 dc             	pushl  -0x24(%ebp)
  28100f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  281012:	50                   	push   %eax
  281013:	6a 00                	push   $0x0
  281015:	50                   	push   %eax
  281016:	6a 00                	push   $0x0
  281018:	53                   	push   %ebx
  281019:	56                   	push   %esi
  28101a:	e8 65 fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 2     , 2     , xsize-3,ysize-3);
  28101f:	83 c4 38             	add    $0x38,%esp
  281022:	8b 55 10             	mov    0x10(%ebp),%edx
  281025:	8d 42 fd             	lea    -0x3(%edx),%eax
  281028:	50                   	push   %eax
  281029:	8d 43 fd             	lea    -0x3(%ebx),%eax
  28102c:	50                   	push   %eax
  28102d:	6a 02                	push   $0x2
  28102f:	6a 02                	push   $0x2
  281031:	6a 08                	push   $0x8
  281033:	53                   	push   %ebx
  281034:	56                   	push   %esi
  281035:	e8 4a fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, 1     , ysize-2,xsize-2,ysize-2);
  28103a:	57                   	push   %edi
  28103b:	ff 75 e0             	pushl  -0x20(%ebp)
  28103e:	57                   	push   %edi
  28103f:	6a 01                	push   $0x1
  281041:	6a 0f                	push   $0xf
  281043:	53                   	push   %ebx
  281044:	56                   	push   %esi
  281045:	e8 3a fc ff ff       	call   280c84 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, 0     , ysize-1,xsize-1,ysize-1);
  28104a:	83 c4 38             	add    $0x38,%esp
  28104d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  281050:	51                   	push   %ecx
  281051:	ff 75 e4             	pushl  -0x1c(%ebp)
  281054:	51                   	push   %ecx
  281055:	6a 00                	push   $0x0
  281057:	6a 00                	push   $0x0
  281059:	53                   	push   %ebx
  28105a:	56                   	push   %esi
  28105b:	e8 24 fc ff ff       	call   280c84 <boxfill8>
	make_wtitle8(buf,xsize,title,act);
  281060:	83 c4 1c             	add    $0x1c,%esp
  281063:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  281067:	50                   	push   %eax
  281068:	ff 75 14             	pushl  0x14(%ebp)
  28106b:	53                   	push   %ebx
  28106c:	56                   	push   %esi
  28106d:	e8 5b fe ff ff       	call   280ecd <make_wtitle8>
	return;
  281072:	83 c4 10             	add    $0x10,%esp
}
  281075:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281078:	5b                   	pop    %ebx
  281079:	5e                   	pop    %esi
  28107a:	5f                   	pop    %edi
  28107b:	5d                   	pop    %ebp
  28107c:	c3                   	ret    

0028107d <putblock8_8>:
	}
	return;
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
  28107d:	55                   	push   %ebp
  28107e:	89 e5                	mov    %esp,%ebp
  281080:	57                   	push   %edi
  281081:	56                   	push   %esi
  281082:	53                   	push   %ebx
  281083:	83 ec 04             	sub    $0x4,%esp
  281086:	8b 45 0c             	mov    0xc(%ebp),%eax
  281089:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int x,y;
	for(y=0;y<pysize;y++)
  28108c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  281090:	7e 49                	jle    2810db <putblock8_8+0x5e>
  281092:	8b 7d 24             	mov    0x24(%ebp),%edi
  281095:	8b 4d 20             	mov    0x20(%ebp),%ecx
  281098:	89 45 f0             	mov    %eax,-0x10(%ebp)
  28109b:	0f af 45 1c          	imul   0x1c(%ebp),%eax
  28109f:	03 45 18             	add    0x18(%ebp),%eax
  2810a2:	89 c2                	mov    %eax,%edx
  2810a4:	03 55 08             	add    0x8(%ebp),%edx
  2810a7:	be 00 00 00 00       	mov    $0x0,%esi
  2810ac:	eb 22                	jmp    2810d0 <putblock8_8+0x53>
  2810ae:	89 5d 10             	mov    %ebx,0x10(%ebp)
		for(x=0;x<pxsize;x++)
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];
  2810b1:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
  2810b5:	88 1c 02             	mov    %bl,(%edx,%eax,1)

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
		for(x=0;x<pxsize;x++)
  2810b8:	83 c0 01             	add    $0x1,%eax
  2810bb:	39 45 10             	cmp    %eax,0x10(%ebp)
  2810be:	75 f1                	jne    2810b1 <putblock8_8+0x34>
  2810c0:	8b 5d 10             	mov    0x10(%ebp),%ebx
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
  2810c3:	83 c6 01             	add    $0x1,%esi
  2810c6:	01 f9                	add    %edi,%ecx
  2810c8:	03 55 f0             	add    -0x10(%ebp),%edx
  2810cb:	39 75 14             	cmp    %esi,0x14(%ebp)
  2810ce:	74 0b                	je     2810db <putblock8_8+0x5e>
		for(x=0;x<pxsize;x++)
  2810d0:	b8 00 00 00 00       	mov    $0x0,%eax
  2810d5:	85 db                	test   %ebx,%ebx
  2810d7:	7f d5                	jg     2810ae <putblock8_8+0x31>
  2810d9:	eb e8                	jmp    2810c3 <putblock8_8+0x46>
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];

	return;
}
  2810db:	83 c4 04             	add    $0x4,%esp
  2810de:	5b                   	pop    %ebx
  2810df:	5e                   	pop    %esi
  2810e0:	5f                   	pop    %edi
  2810e1:	5d                   	pop    %ebp
  2810e2:	c3                   	ret    

002810e3 <putfonts8_asc_sht>:
//b background color
//c font color
void putfonts8_asc_sht(struct SHEET *sht,int x,int y,int c,int b,char *s,int l)
{
  2810e3:	55                   	push   %ebp
  2810e4:	89 e5                	mov    %esp,%ebp
  2810e6:	57                   	push   %edi
  2810e7:	56                   	push   %esi
  2810e8:	53                   	push   %ebx
  2810e9:	83 ec 0c             	sub    $0xc,%esp
  2810ec:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2810ef:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(sht->buf,sht->bxsize,b,x,y,x+l*8-1,y+15);
  2810f2:	8b 45 20             	mov    0x20(%ebp),%eax
  2810f5:	8b 55 0c             	mov    0xc(%ebp),%edx
  2810f8:	8d 3c c2             	lea    (%edx,%eax,8),%edi
  2810fb:	8d 46 0f             	lea    0xf(%esi),%eax
  2810fe:	50                   	push   %eax
  2810ff:	8d 47 ff             	lea    -0x1(%edi),%eax
  281102:	50                   	push   %eax
  281103:	56                   	push   %esi
  281104:	52                   	push   %edx
  281105:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  281109:	50                   	push   %eax
  28110a:	ff 73 04             	pushl  0x4(%ebx)
  28110d:	ff 33                	pushl  (%ebx)
  28110f:	e8 70 fb ff ff       	call   280c84 <boxfill8>
	putfonts8_asc(sht->buf,sht->bxsize,x,y,c,s);
  281114:	83 c4 04             	add    $0x4,%esp
  281117:	ff 75 1c             	pushl  0x1c(%ebp)
  28111a:	ff 75 14             	pushl  0x14(%ebp)
  28111d:	56                   	push   %esi
  28111e:	ff 75 0c             	pushl  0xc(%ebp)
  281121:	ff 73 04             	pushl  0x4(%ebx)
  281124:	ff 33                	pushl  (%ebx)
  281126:	e8 ae 01 00 00       	call   2812d9 <putfonts8_asc>
	sheet_refresh(sht,x,y,x+l*8,y+16);
  28112b:	83 c4 24             	add    $0x24,%esp
  28112e:	8d 46 10             	lea    0x10(%esi),%eax
  281131:	50                   	push   %eax
  281132:	57                   	push   %edi
  281133:	56                   	push   %esi
  281134:	ff 75 0c             	pushl  0xc(%ebp)
  281137:	53                   	push   %ebx
  281138:	e8 a4 13 00 00       	call   2824e1 <sheet_refresh>
}
  28113d:	83 c4 20             	add    $0x20,%esp
  281140:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281143:	5b                   	pop    %ebx
  281144:	5e                   	pop    %esi
  281145:	5f                   	pop    %edi
  281146:	5d                   	pop    %ebp
  281147:	c3                   	ret    

00281148 <make_textbox8>:

void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c)
{
  281148:	55                   	push   %ebp
  281149:	89 e5                	mov    %esp,%ebp
  28114b:	57                   	push   %edi
  28114c:	56                   	push   %esi
  28114d:	53                   	push   %ebx
  28114e:	83 ec 18             	sub    $0x18,%esp
  281151:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int x1 = x0 + sx, y1 = y0 + sy;
  281154:	8b 45 0c             	mov    0xc(%ebp),%eax
  281157:	03 45 14             	add    0x14(%ebp),%eax
  28115a:	8b 55 10             	mov    0x10(%ebp),%edx
  28115d:	03 55 18             	add    0x18(%ebp),%edx
  281160:	89 d7                	mov    %edx,%edi
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 2, y0 - 3, x1 + 1, y0 - 3);
  281162:	89 45 e8             	mov    %eax,-0x18(%ebp)
  281165:	8d 48 01             	lea    0x1(%eax),%ecx
  281168:	8b 75 10             	mov    0x10(%ebp),%esi
  28116b:	83 ee 03             	sub    $0x3,%esi
  28116e:	8b 55 0c             	mov    0xc(%ebp),%edx
  281171:	83 ea 02             	sub    $0x2,%edx
  281174:	56                   	push   %esi
  281175:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  281178:	51                   	push   %ecx
  281179:	56                   	push   %esi
  28117a:	89 55 f0             	mov    %edx,-0x10(%ebp)
  28117d:	52                   	push   %edx
  28117e:	6a 0f                	push   $0xf
  281180:	ff 73 04             	pushl  0x4(%ebx)
  281183:	ff 33                	pushl  (%ebx)
  281185:	e8 fa fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 3, y0 - 3, x0 - 3, y1 + 1);
  28118a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  28118d:	8d 7f 01             	lea    0x1(%edi),%edi
  281190:	89 f9                	mov    %edi,%ecx
  281192:	8b 7d 0c             	mov    0xc(%ebp),%edi
  281195:	83 ef 03             	sub    $0x3,%edi
  281198:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  28119b:	51                   	push   %ecx
  28119c:	57                   	push   %edi
  28119d:	56                   	push   %esi
  28119e:	57                   	push   %edi
  28119f:	6a 0f                	push   $0xf
  2811a1:	ff 73 04             	pushl  0x4(%ebx)
  2811a4:	ff 33                	pushl  (%ebx)
  2811a6:	e8 d9 fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x0 - 3, y1 + 2, x1 + 1, y1 + 2);
  2811ab:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  2811ae:	8d 4a 02             	lea    0x2(%edx),%ecx
  2811b1:	83 c4 38             	add    $0x38,%esp
  2811b4:	51                   	push   %ecx
  2811b5:	ff 75 e0             	pushl  -0x20(%ebp)
  2811b8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  2811bb:	51                   	push   %ecx
  2811bc:	57                   	push   %edi
  2811bd:	6a 07                	push   $0x7
  2811bf:	ff 73 04             	pushl  0x4(%ebx)
  2811c2:	ff 33                	pushl  (%ebx)
  2811c4:	e8 bb fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x1 + 2, y0 - 3, x1 + 2, y1 + 2);
  2811c9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  2811cc:	83 c0 02             	add    $0x2,%eax
  2811cf:	ff 75 dc             	pushl  -0x24(%ebp)
  2811d2:	50                   	push   %eax
  2811d3:	56                   	push   %esi
  2811d4:	50                   	push   %eax
  2811d5:	6a 07                	push   $0x7
  2811d7:	ff 73 04             	pushl  0x4(%ebx)
  2811da:	ff 33                	pushl  (%ebx)
  2811dc:	e8 a3 fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 1, y0 - 2, x1 + 0, y0 - 2);
  2811e1:	8b 75 10             	mov    0x10(%ebp),%esi
  2811e4:	8d 7e fe             	lea    -0x2(%esi),%edi
  2811e7:	8b 75 0c             	mov    0xc(%ebp),%esi
  2811ea:	83 ee 01             	sub    $0x1,%esi
  2811ed:	83 c4 38             	add    $0x38,%esp
  2811f0:	57                   	push   %edi
  2811f1:	ff 75 e8             	pushl  -0x18(%ebp)
  2811f4:	57                   	push   %edi
  2811f5:	56                   	push   %esi
  2811f6:	6a 00                	push   $0x0
  2811f8:	ff 73 04             	pushl  0x4(%ebx)
  2811fb:	ff 33                	pushl  (%ebx)
  2811fd:	e8 82 fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 2, y0 - 2, x0 - 2, y1 + 0);
  281202:	ff 75 e4             	pushl  -0x1c(%ebp)
  281205:	8b 55 f0             	mov    -0x10(%ebp),%edx
  281208:	52                   	push   %edx
  281209:	57                   	push   %edi
  28120a:	52                   	push   %edx
  28120b:	6a 00                	push   $0x0
  28120d:	ff 73 04             	pushl  0x4(%ebx)
  281210:	ff 33                	pushl  (%ebx)
  281212:	e8 6d fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x0 - 2, y1 + 1, x1 + 0, y1 + 1);
  281217:	83 c4 38             	add    $0x38,%esp
  28121a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  28121d:	50                   	push   %eax
  28121e:	ff 75 e8             	pushl  -0x18(%ebp)
  281221:	50                   	push   %eax
  281222:	ff 75 f0             	pushl  -0x10(%ebp)
  281225:	6a 08                	push   $0x8
  281227:	ff 73 04             	pushl  0x4(%ebx)
  28122a:	ff 33                	pushl  (%ebx)
  28122c:	e8 53 fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x1 + 1, y0 - 2, x1 + 1, y1 + 1);
  281231:	ff 75 ec             	pushl  -0x14(%ebp)
  281234:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  281237:	51                   	push   %ecx
  281238:	57                   	push   %edi
  281239:	51                   	push   %ecx
  28123a:	6a 08                	push   $0x8
  28123c:	ff 73 04             	pushl  0x4(%ebx)
  28123f:	ff 33                	pushl  (%ebx)
  281241:	e8 3e fa ff ff       	call   280c84 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, c,           x0 - 1, y0 - 1, x1 + 0, y1 + 0);
  281246:	83 c4 38             	add    $0x38,%esp
  281249:	ff 75 e4             	pushl  -0x1c(%ebp)
  28124c:	ff 75 e8             	pushl  -0x18(%ebp)
  28124f:	8b 45 10             	mov    0x10(%ebp),%eax
  281252:	83 e8 01             	sub    $0x1,%eax
  281255:	50                   	push   %eax
  281256:	56                   	push   %esi
  281257:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  28125b:	50                   	push   %eax
  28125c:	ff 73 04             	pushl  0x4(%ebx)
  28125f:	ff 33                	pushl  (%ebx)
  281261:	e8 1e fa ff ff       	call   280c84 <boxfill8>
    return;
  281266:	83 c4 1c             	add    $0x1c,%esp
}
  281269:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28126c:	5b                   	pop    %ebx
  28126d:	5e                   	pop    %esi
  28126e:	5f                   	pop    %edi
  28126f:	5d                   	pop    %ebp
  281270:	c3                   	ret    

00281271 <putfont8>:
#include "fontascii.h"
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
  281271:	55                   	push   %ebp
  281272:	89 e5                	mov    %esp,%ebp
  281274:	57                   	push   %edi
  281275:	56                   	push   %esi
  281276:	53                   	push   %ebx
  281277:	83 ec 08             	sub    $0x8,%esp
  28127a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28127d:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  281280:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  281284:	89 fb                	mov    %edi,%ebx
  281286:	89 45 ec             	mov    %eax,-0x14(%ebp)
  281289:	0f af 45 14          	imul   0x14(%ebp),%eax
  28128d:	03 45 10             	add    0x10(%ebp),%eax
  281290:	89 c1                	mov    %eax,%ecx
  281292:	03 4d 08             	add    0x8(%ebp),%ecx
  281295:	83 c7 10             	add    $0x10,%edi
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
  281298:	0f b6 13             	movzbl (%ebx),%edx
		int col = HKK_TABLE_COL-1;
  28129b:	b8 07 00 00 00       	mov    $0x7,%eax
  2812a0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  2812a3:	89 f1                	mov    %esi,%ecx
  2812a5:	89 de                	mov    %ebx,%esi
  2812a7:	89 cb                	mov    %ecx,%ebx
		for(;col>=0;col--)
		{
			if(d&0x1) p[col] = c;
  2812a9:	f6 c2 01             	test   $0x1,%dl
  2812ac:	74 06                	je     2812b4 <putfont8+0x43>
  2812ae:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  2812b1:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
			d=d>>1;
  2812b4:	d0 ea                	shr    %dl
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
		int col = HKK_TABLE_COL-1;
		for(;col>=0;col--)
  2812b6:	83 e8 01             	sub    $0x1,%eax
  2812b9:	83 f8 ff             	cmp    $0xffffffff,%eax
  2812bc:	75 eb                	jne    2812a9 <putfont8+0x38>
  2812be:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  2812c1:	89 d8                	mov    %ebx,%eax
  2812c3:	89 f3                	mov    %esi,%ebx
  2812c5:	89 c6                	mov    %eax,%esi
  2812c7:	83 c3 01             	add    $0x1,%ebx
  2812ca:	03 4d ec             	add    -0x14(%ebp),%ecx
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
	int i;
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
  2812cd:	39 fb                	cmp    %edi,%ebx
  2812cf:	75 c7                	jne    281298 <putfont8+0x27>
			if(d&0x1) p[col] = c;
			d=d>>1;
		}
	}

}
  2812d1:	83 c4 08             	add    $0x8,%esp
  2812d4:	5b                   	pop    %ebx
  2812d5:	5e                   	pop    %esi
  2812d6:	5f                   	pop    %edi
  2812d7:	5d                   	pop    %ebp
  2812d8:	c3                   	ret    

002812d9 <putfonts8_asc>:

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
  2812d9:	55                   	push   %ebp
  2812da:	89 e5                	mov    %esp,%ebp
  2812dc:	57                   	push   %edi
  2812dd:	56                   	push   %esi
  2812de:	53                   	push   %ebx
  2812df:	8b 75 10             	mov    0x10(%ebp),%esi
  2812e2:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  2812e5:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
	extern char hankaku[];
	for(;*s !=0x00;s++)
  2812e9:	0f b6 03             	movzbl (%ebx),%eax
  2812ec:	84 c0                	test   %al,%al
  2812ee:	74 2f                	je     28131f <putfonts8_asc+0x46>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
  2812f0:	0f be fa             	movsbl %dl,%edi
  2812f3:	0f b6 c0             	movzbl %al,%eax
  2812f6:	c1 e0 04             	shl    $0x4,%eax
  2812f9:	05 c0 4a 28 00       	add    $0x284ac0,%eax
  2812fe:	50                   	push   %eax
  2812ff:	57                   	push   %edi
  281300:	ff 75 14             	pushl  0x14(%ebp)
  281303:	56                   	push   %esi
  281304:	ff 75 0c             	pushl  0xc(%ebp)
  281307:	ff 75 08             	pushl  0x8(%ebp)
  28130a:	e8 62 ff ff ff       	call   281271 <putfont8>
		x+=HKK_TABLE_COL;
  28130f:	83 c6 08             	add    $0x8,%esi
}

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
	extern char hankaku[];
	for(;*s !=0x00;s++)
  281312:	83 c3 01             	add    $0x1,%ebx
  281315:	0f b6 03             	movzbl (%ebx),%eax
  281318:	83 c4 18             	add    $0x18,%esp
  28131b:	84 c0                	test   %al,%al
  28131d:	75 d4                	jne    2812f3 <putfonts8_asc+0x1a>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
		x+=HKK_TABLE_COL;
	}
	return; 
}
  28131f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281322:	5b                   	pop    %ebx
  281323:	5e                   	pop    %esi
  281324:	5f                   	pop    %edi
  281325:	5d                   	pop    %ebp
  281326:	c3                   	ret    

00281327 <set_segmdesc>:
#include "dsctbl.h"
#include "io.h"

void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit,int base,int ar)
{
  281327:	55                   	push   %ebp
  281328:	89 e5                	mov    %esp,%ebp
  28132a:	57                   	push   %edi
  28132b:	56                   	push   %esi
  28132c:	53                   	push   %ebx
  28132d:	8b 55 08             	mov    0x8(%ebp),%edx
  281330:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281333:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281336:	8b 7d 14             	mov    0x14(%ebp),%edi
	if(limit>0xfffff)
  281339:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
  28133f:	76 09                	jbe    28134a <set_segmdesc+0x23>
	{
		ar |= 0x8000;
  281341:	81 cf 00 80 00 00    	or     $0x8000,%edi
		limit /= 0x1000;
  281347:	c1 eb 0c             	shr    $0xc,%ebx
	}
	sd->limit_low = limit&0xffff;
  28134a:	66 89 1a             	mov    %bx,(%edx)
	sd->base_low = base&0xffff;
  28134d:	66 89 4a 02          	mov    %cx,0x2(%edx)
	sd->base_mid = (base>>16) & 0xff;
  281351:	89 ce                	mov    %ecx,%esi
  281353:	c1 fe 10             	sar    $0x10,%esi
  281356:	89 f0                	mov    %esi,%eax
  281358:	88 42 04             	mov    %al,0x4(%edx)
	sd->access_right = ar & 0xff;
  28135b:	89 f8                	mov    %edi,%eax
  28135d:	88 42 05             	mov    %al,0x5(%edx)
	sd->limit_high = ((limit>>16)&0x0f) | ((ar>>8)&0xf0);
  281360:	c1 eb 10             	shr    $0x10,%ebx
  281363:	83 e3 0f             	and    $0xf,%ebx
  281366:	89 f8                	mov    %edi,%eax
  281368:	c1 f8 08             	sar    $0x8,%eax
  28136b:	83 e0 f0             	and    $0xfffffff0,%eax
  28136e:	09 d8                	or     %ebx,%eax
  281370:	88 42 06             	mov    %al,0x6(%edx)
	sd->base_high = (base>>24)&0xff;
  281373:	c1 e9 18             	shr    $0x18,%ecx
  281376:	88 4a 07             	mov    %cl,0x7(%edx)
	return;
}
  281379:	5b                   	pop    %ebx
  28137a:	5e                   	pop    %esi
  28137b:	5f                   	pop    %edi
  28137c:	5d                   	pop    %ebp
  28137d:	c3                   	ret    

0028137e <set_gatedesc>:

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
  28137e:	55                   	push   %ebp
  28137f:	89 e5                	mov    %esp,%ebp
  281381:	53                   	push   %ebx
  281382:	8b 45 08             	mov    0x8(%ebp),%eax
  281385:	8b 55 0c             	mov    0xc(%ebp),%edx
  281388:	8b 4d 14             	mov    0x14(%ebp),%ecx
	gd->offset_low = offset & 0xffff;
  28138b:	66 89 10             	mov    %dx,(%eax)
	gd->selector = selector;
  28138e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  281391:	66 89 58 02          	mov    %bx,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  281395:	89 cb                	mov    %ecx,%ebx
  281397:	c1 fb 08             	sar    $0x8,%ebx
  28139a:	88 58 04             	mov    %bl,0x4(%eax)
	gd->access_right = ar&0xff;
  28139d:	88 48 05             	mov    %cl,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  2813a0:	c1 ea 10             	shr    $0x10,%edx
  2813a3:	66 89 50 06          	mov    %dx,0x6(%eax)
	return;
}
  2813a7:	5b                   	pop    %ebx
  2813a8:	5d                   	pop    %ebp
  2813a9:	c3                   	ret    

002813aa <init_gdtidt>:

void init_gdtidt(void)
{
  2813aa:	55                   	push   %ebp
  2813ab:	89 e5                	mov    %esp,%ebp
  2813ad:	53                   	push   %ebx
  2813ae:	83 ec 04             	sub    $0x4,%esp
  2813b1:	bb 00 00 27 00       	mov    $0x270000,%ebx
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
	{
		set_segmdesc(gdt+i,0,0,0);
  2813b6:	6a 00                	push   $0x0
  2813b8:	6a 00                	push   $0x0
  2813ba:	6a 00                	push   $0x0
  2813bc:	53                   	push   %ebx
  2813bd:	e8 65 ff ff ff       	call   281327 <set_segmdesc>
  2813c2:	83 c3 08             	add    $0x8,%ebx
{
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
  2813c5:	83 c4 10             	add    $0x10,%esp
  2813c8:	81 fb 00 00 28 00    	cmp    $0x280000,%ebx
  2813ce:	75 e6                	jne    2813b6 <init_gdtidt+0xc>
	{
		set_segmdesc(gdt+i,0,0,0);
	}
	//must be similiar with bootstrap gdt.
	//otherwise the code will run with different segment descriptor.
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
  2813d0:	68 92 40 00 00       	push   $0x4092
  2813d5:	6a 00                	push   $0x0
  2813d7:	6a ff                	push   $0xffffffff
  2813d9:	68 08 00 27 00       	push   $0x270008
  2813de:	e8 44 ff ff ff       	call   281327 <set_segmdesc>
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
  2813e3:	68 9a 40 00 00       	push   $0x409a
  2813e8:	6a 00                	push   $0x0
  2813ea:	68 ff ff 0f 00       	push   $0xfffff
  2813ef:	68 10 00 27 00       	push   $0x270010
  2813f4:	e8 2e ff ff ff       	call   281327 <set_segmdesc>
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
  2813f9:	83 c4 20             	add    $0x20,%esp
  2813fc:	68 9a 40 00 00       	push   $0x409a
  281401:	68 00 00 28 00       	push   $0x280000
  281406:	68 ff ff 07 00       	push   $0x7ffff
  28140b:	68 18 00 27 00       	push   $0x270018
  281410:	e8 12 ff ff ff       	call   281327 <set_segmdesc>
	load_gdtr(LIMIT_GDT,ADR_GDT);
  281415:	83 c4 08             	add    $0x8,%esp
  281418:	68 00 00 27 00       	push   $0x270000
  28141d:	68 ff ff 00 00       	push   $0xffff
  281422:	e8 38 f7 ff ff       	call   280b5f <load_gdtr>
  281427:	83 c4 10             	add    $0x10,%esp
  28142a:	b8 00 f8 26 00       	mov    $0x26f800,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28142f:	66 c7 00 00 00       	movw   $0x0,(%eax)
	gd->selector = selector;
  281434:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  28143a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	gd->access_right = ar&0xff;
  28143e:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  281442:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
  281448:	83 c0 08             	add    $0x8,%eax
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
	load_gdtr(LIMIT_GDT,ADR_GDT);

	for(i=0;i<256;i++)
  28144b:	3d 00 00 27 00       	cmp    $0x270000,%eax
  281450:	75 dd                	jne    28142f <init_gdtidt+0x85>
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
  281452:	b8 de 15 00 00       	mov    $0x15de,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281457:	66 a3 00 f9 26 00    	mov    %ax,0x26f900
	gd->selector = selector;
  28145d:	66 c7 05 02 f9 26 00 	movw   $0x18,0x26f902
  281464:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281466:	c6 05 04 f9 26 00 00 	movb   $0x0,0x26f904
	gd->access_right = ar&0xff;
  28146d:	c6 05 05 f9 26 00 8e 	movb   $0x8e,0x26f905
	gd->offset_high = (offset>>16)&0xffff;
  281474:	c1 e8 10             	shr    $0x10,%eax
  281477:	66 a3 06 f9 26 00    	mov    %ax,0x26f906
	for(i=0;i<256;i++)
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
  28147d:	b8 b0 15 00 00       	mov    $0x15b0,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281482:	66 a3 08 f9 26 00    	mov    %ax,0x26f908
	gd->selector = selector;
  281488:	66 c7 05 0a f9 26 00 	movw   $0x18,0x26f90a
  28148f:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281491:	c6 05 0c f9 26 00 00 	movb   $0x0,0x26f90c
	gd->access_right = ar&0xff;
  281498:	c6 05 0d f9 26 00 8e 	movb   $0x8e,0x26f90d
	gd->offset_high = (offset>>16)&0xffff;
  28149f:	c1 e8 10             	shr    $0x10,%eax
  2814a2:	66 a3 0e f9 26 00    	mov    %ax,0x26f90e
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
  2814a8:	b8 c7 15 00 00       	mov    $0x15c7,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2814ad:	66 a3 60 f9 26 00    	mov    %ax,0x26f960
	gd->selector = selector;
  2814b3:	66 c7 05 62 f9 26 00 	movw   $0x18,0x26f962
  2814ba:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2814bc:	c6 05 64 f9 26 00 00 	movb   $0x0,0x26f964
	gd->access_right = ar&0xff;
  2814c3:	c6 05 65 f9 26 00 8e 	movb   $0x8e,0x26f965
	gd->offset_high = (offset>>16)&0xffff;
  2814ca:	c1 e8 10             	shr    $0x10,%eax
  2814cd:	66 a3 66 f9 26 00    	mov    %ax,0x26f966
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	load_idtr(LIMIT_IDT,ADR_IDT);
  2814d3:	83 ec 08             	sub    $0x8,%esp
  2814d6:	68 00 f8 26 00       	push   $0x26f800
  2814db:	68 ff 07 00 00       	push   $0x7ff
  2814e0:	e8 8a f6 ff ff       	call   280b6f <load_idtr>

	return;
  2814e5:	83 c4 10             	add    $0x10,%esp
}
  2814e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2814eb:	c9                   	leave  
  2814ec:	c3                   	ret    

002814ed <init_pic>:
#include "graphics.h"
#include "const.h"
#include "fifo.h"
#include "timer.h"
void init_pic(void)
{
  2814ed:	55                   	push   %ebp
  2814ee:	89 e5                	mov    %esp,%ebp
  2814f0:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIC0_IMR, 0xff);	//disable all pic0 int
  2814f3:	68 ff 00 00 00       	push   $0xff
  2814f8:	6a 21                	push   $0x21
  2814fa:	e8 37 f6 ff ff       	call   280b36 <io_out8>
	io_out8(PIC1_IMR, 0xff);	//disable all pic1 int
  2814ff:	83 c4 08             	add    $0x8,%esp
  281502:	68 ff 00 00 00       	push   $0xff
  281507:	68 a1 00 00 00       	push   $0xa1
  28150c:	e8 25 f6 ff ff       	call   280b36 <io_out8>

	io_out8(PIC0_ICW1, 0x11);	
  281511:	83 c4 08             	add    $0x8,%esp
  281514:	6a 11                	push   $0x11
  281516:	6a 20                	push   $0x20
  281518:	e8 19 f6 ff ff       	call   280b36 <io_out8>
	io_out8(PIC0_ICW2, 0x20);
  28151d:	83 c4 08             	add    $0x8,%esp
  281520:	6a 20                	push   $0x20
  281522:	6a 21                	push   $0x21
  281524:	e8 0d f6 ff ff       	call   280b36 <io_out8>
	io_out8(PIC0_ICW3, 1 << 2);
  281529:	83 c4 08             	add    $0x8,%esp
  28152c:	6a 04                	push   $0x4
  28152e:	6a 21                	push   $0x21
  281530:	e8 01 f6 ff ff       	call   280b36 <io_out8>
	io_out8(PIC0_ICW4, 0x01);
  281535:	83 c4 08             	add    $0x8,%esp
  281538:	6a 01                	push   $0x1
  28153a:	6a 21                	push   $0x21
  28153c:	e8 f5 f5 ff ff       	call   280b36 <io_out8>

	io_out8(PIC1_ICW1, 0x11);
  281541:	83 c4 08             	add    $0x8,%esp
  281544:	6a 11                	push   $0x11
  281546:	68 a0 00 00 00       	push   $0xa0
  28154b:	e8 e6 f5 ff ff       	call   280b36 <io_out8>
	io_out8(PIC1_ICW2, 0x28);
  281550:	83 c4 08             	add    $0x8,%esp
  281553:	6a 28                	push   $0x28
  281555:	68 a1 00 00 00       	push   $0xa1
  28155a:	e8 d7 f5 ff ff       	call   280b36 <io_out8>
	io_out8(PIC1_ICW3, 2);
  28155f:	83 c4 08             	add    $0x8,%esp
  281562:	6a 02                	push   $0x2
  281564:	68 a1 00 00 00       	push   $0xa1
  281569:	e8 c8 f5 ff ff       	call   280b36 <io_out8>
	io_out8(PIC1_ICW4, 0x01);
  28156e:	83 c4 08             	add    $0x8,%esp
  281571:	6a 01                	push   $0x1
  281573:	68 a1 00 00 00       	push   $0xa1
  281578:	e8 b9 f5 ff ff       	call   280b36 <io_out8>

	io_out8(PIC0_IMR, 0xfb);
  28157d:	83 c4 08             	add    $0x8,%esp
  281580:	68 fb 00 00 00       	push   $0xfb
  281585:	6a 21                	push   $0x21
  281587:	e8 aa f5 ff ff       	call   280b36 <io_out8>
	io_out8(PIC1_IMR, 0xff);
  28158c:	83 c4 08             	add    $0x8,%esp
  28158f:	68 ff 00 00 00       	push   $0xff
  281594:	68 a1 00 00 00       	push   $0xa1
  281599:	e8 98 f5 ff ff       	call   280b36 <io_out8>
}
  28159e:	83 c4 10             	add    $0x10,%esp
  2815a1:	c9                   	leave  
  2815a2:	c3                   	ret    
  2815a3:	66 90                	xchg   %ax,%ax
  2815a5:	66 90                	xchg   %ax,%ax
  2815a7:	66 90                	xchg   %ax,%ax
  2815a9:	66 90                	xchg   %ax,%ax
  2815ab:	66 90                	xchg   %ax,%ax
  2815ad:	66 90                	xchg   %ax,%ax
  2815af:	90                   	nop

002815b0 <asm_inthandler21>:
  2815b0:	06                   	push   %es
  2815b1:	1e                   	push   %ds
  2815b2:	60                   	pusha  
  2815b3:	89 e0                	mov    %esp,%eax
  2815b5:	50                   	push   %eax
  2815b6:	66 8c d0             	mov    %ss,%ax
  2815b9:	8e d8                	mov    %eax,%ds
  2815bb:	8e c0                	mov    %eax,%es
  2815bd:	e8 8c 05 00 00       	call   281b4e <inthandler21>
  2815c2:	58                   	pop    %eax
  2815c3:	61                   	popa   
  2815c4:	1f                   	pop    %ds
  2815c5:	07                   	pop    %es
  2815c6:	cf                   	iret   

002815c7 <asm_inthandler2c>:
  2815c7:	06                   	push   %es
  2815c8:	1e                   	push   %ds
  2815c9:	60                   	pusha  
  2815ca:	89 e0                	mov    %esp,%eax
  2815cc:	50                   	push   %eax
  2815cd:	66 8c d0             	mov    %ss,%ax
  2815d0:	8e d8                	mov    %eax,%ds
  2815d2:	8e c0                	mov    %eax,%es
  2815d4:	e8 db 04 00 00       	call   281ab4 <inthandler2c>
  2815d9:	58                   	pop    %eax
  2815da:	61                   	popa   
  2815db:	1f                   	pop    %ds
  2815dc:	07                   	pop    %es
  2815dd:	cf                   	iret   

002815de <asm_inthandler20>:
  2815de:	06                   	push   %es
  2815df:	1e                   	push   %ds
  2815e0:	60                   	pusha  
  2815e1:	89 e0                	mov    %esp,%eax
  2815e3:	50                   	push   %eax
  2815e4:	66 8c d0             	mov    %ss,%ax
  2815e7:	8e d8                	mov    %eax,%ds
  2815e9:	8e c0                	mov    %eax,%es
  2815eb:	e8 17 12 00 00       	call   282807 <inthandler20>
  2815f0:	58                   	pop    %eax
  2815f1:	61                   	popa   
  2815f2:	1f                   	pop    %ds
  2815f3:	07                   	pop    %es
  2815f4:	cf                   	iret   

002815f5 <itoa>:
#include"string.h"
void itoa(int value,char *buf){
  2815f5:	55                   	push   %ebp
  2815f6:	89 e5                	mov    %esp,%ebp
  2815f8:	57                   	push   %edi
  2815f9:	56                   	push   %esi
  2815fa:	53                   	push   %ebx
  2815fb:	83 ec 10             	sub    $0x10,%esp
  2815fe:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281601:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char tmp_buf[10] = {0};
  281604:	c7 45 ea 00 00 00 00 	movl   $0x0,-0x16(%ebp)
  28160b:	c7 45 ee 00 00 00 00 	movl   $0x0,-0x12(%ebp)
  281612:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
  281618:	85 c9                	test   %ecx,%ecx
  28161a:	79 08                	jns    281624 <itoa+0x2f>
		*buf++ = '-';
  28161c:	c6 07 2d             	movb   $0x2d,(%edi)
		value = ~value + 1; 
  28161f:	f7 d9                	neg    %ecx
#include"string.h"
void itoa(int value,char *buf){
	char tmp_buf[10] = {0};
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
		*buf++ = '-';
  281621:	8d 7f 01             	lea    0x1(%edi),%edi
  281624:	8d 5d ea             	lea    -0x16(%ebp),%ebx
		value = ~value + 1; 
	}

	do{
		*tbp++ = ('0' + (char)(value % 10));
  281627:	be 67 66 66 66       	mov    $0x66666667,%esi
  28162c:	83 c3 01             	add    $0x1,%ebx
  28162f:	89 c8                	mov    %ecx,%eax
  281631:	f7 ee                	imul   %esi
  281633:	c1 fa 02             	sar    $0x2,%edx
  281636:	89 c8                	mov    %ecx,%eax
  281638:	c1 f8 1f             	sar    $0x1f,%eax
  28163b:	29 c2                	sub    %eax,%edx
  28163d:	8d 04 92             	lea    (%edx,%edx,4),%eax
  281640:	01 c0                	add    %eax,%eax
  281642:	29 c1                	sub    %eax,%ecx
  281644:	83 c1 30             	add    $0x30,%ecx
  281647:	88 4b ff             	mov    %cl,-0x1(%ebx)
		value /= 10;
  28164a:	89 d1                	mov    %edx,%ecx
	}while(value);
  28164c:	85 d2                	test   %edx,%edx
  28164e:	75 dc                	jne    28162c <itoa+0x37>
	while(tmp_buf != tbp--)
  281650:	8d 73 ff             	lea    -0x1(%ebx),%esi
  281653:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281656:	39 c3                	cmp    %eax,%ebx
  281658:	74 20                	je     28167a <itoa+0x85>
  28165a:	89 f0                	mov    %esi,%eax
  28165c:	89 fa                	mov    %edi,%edx
  28165e:	8d 5d e9             	lea    -0x17(%ebp),%ebx
		*buf++ = *tbp;
  281661:	83 c2 01             	add    $0x1,%edx
  281664:	0f b6 08             	movzbl (%eax),%ecx
  281667:	88 4a ff             	mov    %cl,-0x1(%edx)

	do{
		*tbp++ = ('0' + (char)(value % 10));
		value /= 10;
	}while(value);
	while(tmp_buf != tbp--)
  28166a:	83 e8 01             	sub    $0x1,%eax
  28166d:	39 d8                	cmp    %ebx,%eax
  28166f:	75 f0                	jne    281661 <itoa+0x6c>
  281671:	8d 45 f4             	lea    -0xc(%ebp),%eax
  281674:	29 c6                	sub    %eax,%esi
  281676:	8d 7c 37 0b          	lea    0xb(%edi,%esi,1),%edi
		*buf++ = *tbp;
	*buf='\0';
  28167a:	c6 07 00             	movb   $0x0,(%edi)
}
  28167d:	83 c4 10             	add    $0x10,%esp
  281680:	5b                   	pop    %ebx
  281681:	5e                   	pop    %esi
  281682:	5f                   	pop    %edi
  281683:	5d                   	pop    %ebp
  281684:	c3                   	ret    

00281685 <xtoa>:
    else
        value = value + 48;
    return value;
}

void xtoa(unsigned int value,char *buf){
  281685:	55                   	push   %ebp
  281686:	89 e5                	mov    %esp,%ebp
  281688:	57                   	push   %edi
  281689:	56                   	push   %esi
  28168a:	53                   	push   %ebx
  28168b:	83 ec 20             	sub    $0x20,%esp
  28168e:	8b 45 08             	mov    0x8(%ebp),%eax
    char tmp_buf[30] = {0};
  281691:	bb 00 00 00 00       	mov    $0x0,%ebx
  281696:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
  28169d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  2816a4:	b9 1c 00 00 00       	mov    $0x1c,%ecx
  2816a9:	ba 00 00 00 00       	mov    $0x0,%edx
  2816ae:	89 5c 15 d8          	mov    %ebx,-0x28(%ebp,%edx,1)
  2816b2:	83 c2 04             	add    $0x4,%edx
  2816b5:	39 ca                	cmp    %ecx,%edx
  2816b7:	72 f5                	jb     2816ae <xtoa+0x29>
    char *tbp = tmp_buf;

    *buf++='0';
  2816b9:	8b 75 0c             	mov    0xc(%ebp),%esi
  2816bc:	c6 06 30             	movb   $0x30,(%esi)
    *buf++='x';
  2816bf:	83 c6 02             	add    $0x2,%esi
  2816c2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  2816c5:	c6 43 01 78          	movb   $0x78,0x1(%ebx)
    return value;
}

void xtoa(unsigned int value,char *buf){
    char tmp_buf[30] = {0};
    char *tbp = tmp_buf;
  2816c9:	8d 5d d6             	lea    -0x2a(%ebp),%ebx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  2816cc:	83 c3 01             	add    $0x1,%ebx
  2816cf:	89 c1                	mov    %eax,%ecx
  2816d1:	83 e1 0f             	and    $0xf,%ecx
	*str='\0';
}

static  inline char fourbtoc(int value){
    if(value >= 10)
        value = value - 10 + 65;
  2816d4:	8d 79 37             	lea    0x37(%ecx),%edi
  2816d7:	8d 51 30             	lea    0x30(%ecx),%edx
  2816da:	83 f9 0a             	cmp    $0xa,%ecx
  2816dd:	0f 4d d7             	cmovge %edi,%edx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  2816e0:	88 53 ff             	mov    %dl,-0x1(%ebx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
  2816e3:	c1 e8 04             	shr    $0x4,%eax
    }while(value);
  2816e6:	85 c0                	test   %eax,%eax
  2816e8:	75 e2                	jne    2816cc <xtoa+0x47>
    
    while(tmp_buf != tbp){
  2816ea:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  2816ed:	39 c3                	cmp    %eax,%ebx
  2816ef:	74 20                	je     281711 <xtoa+0x8c>
  2816f1:	89 d8                	mov    %ebx,%eax
  2816f3:	89 f1                	mov    %esi,%ecx
  2816f5:	8d 7d d6             	lea    -0x2a(%ebp),%edi
      tbp--;
  2816f8:	83 e8 01             	sub    $0x1,%eax
      *buf++ = *tbp;
  2816fb:	83 c1 01             	add    $0x1,%ecx
  2816fe:	0f b6 10             	movzbl (%eax),%edx
  281701:	88 51 ff             	mov    %dl,-0x1(%ecx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
    }while(value);
    
    while(tmp_buf != tbp){
  281704:	39 f8                	cmp    %edi,%eax
  281706:	75 f0                	jne    2816f8 <xtoa+0x73>
  281708:	8d 45 f4             	lea    -0xc(%ebp),%eax
  28170b:	29 c3                	sub    %eax,%ebx
  28170d:	8d 74 1e 1e          	lea    0x1e(%esi,%ebx,1),%esi
      tbp--;
      *buf++ = *tbp;
    }
    *buf='\0';
  281711:	c6 06 00             	movb   $0x0,(%esi)
}
  281714:	83 c4 20             	add    $0x20,%esp
  281717:	5b                   	pop    %ebx
  281718:	5e                   	pop    %esi
  281719:	5f                   	pop    %edi
  28171a:	5d                   	pop    %ebp
  28171b:	c3                   	ret    

0028171c <sprintf>:
	while(tmp_buf != tbp--)
		*buf++ = *tbp;
	*buf='\0';
}

void sprintf(char *str,char *format ,...){
  28171c:	55                   	push   %ebp
  28171d:	89 e5                	mov    %esp,%ebp
  28171f:	57                   	push   %edi
  281720:	56                   	push   %esi
  281721:	53                   	push   %ebx
  281722:	83 ec 10             	sub    $0x10,%esp
  281725:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
  281728:	8d 7d 10             	lea    0x10(%ebp),%edi
	char buffer[10];
	char *buf=buffer;
	while(*format){
  28172b:	e9 a8 00 00 00       	jmp    2817d8 <sprintf+0xbc>
		if(*format!='%'){
  281730:	3c 25                	cmp    $0x25,%al
  281732:	74 10                	je     281744 <sprintf+0x28>
			*str++=*format++;
  281734:	83 c6 01             	add    $0x1,%esi
  281737:	89 75 0c             	mov    %esi,0xc(%ebp)
  28173a:	88 03                	mov    %al,(%ebx)
  28173c:	8d 5b 01             	lea    0x1(%ebx),%ebx
			continue;
  28173f:	e9 94 00 00 00       	jmp    2817d8 <sprintf+0xbc>
		}
		else{
			format++;
  281744:	8d 46 01             	lea    0x1(%esi),%eax
  281747:	89 45 0c             	mov    %eax,0xc(%ebp)
			switch (*format){
  28174a:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  28174e:	3c 73                	cmp    $0x73,%al
  281750:	74 5e                	je     2817b0 <sprintf+0x94>
  281752:	3c 78                	cmp    $0x78,%al
  281754:	74 2f                	je     281785 <sprintf+0x69>
  281756:	3c 64                	cmp    $0x64,%al
  281758:	75 75                	jne    2817cf <sprintf+0xb3>
				case 'd':itoa(*var,buf);while(*buf){*str++=*buf++;};break;
  28175a:	8d 45 ea             	lea    -0x16(%ebp),%eax
  28175d:	50                   	push   %eax
  28175e:	ff 37                	pushl  (%edi)
  281760:	e8 90 fe ff ff       	call   2815f5 <itoa>
  281765:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281769:	83 c4 08             	add    $0x8,%esp
  28176c:	84 c0                	test   %al,%al
  28176e:	74 5f                	je     2817cf <sprintf+0xb3>
  281770:	8d 55 ea             	lea    -0x16(%ebp),%edx
  281773:	83 c3 01             	add    $0x1,%ebx
  281776:	83 c2 01             	add    $0x1,%edx
  281779:	88 43 ff             	mov    %al,-0x1(%ebx)
  28177c:	0f b6 02             	movzbl (%edx),%eax
  28177f:	84 c0                	test   %al,%al
  281781:	75 f0                	jne    281773 <sprintf+0x57>
  281783:	eb 4a                	jmp    2817cf <sprintf+0xb3>
				case 'x':xtoa(*var,buf);while(*buf){*str++=*buf++;};break;
  281785:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281788:	50                   	push   %eax
  281789:	ff 37                	pushl  (%edi)
  28178b:	e8 f5 fe ff ff       	call   281685 <xtoa>
  281790:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281794:	83 c4 08             	add    $0x8,%esp
  281797:	84 c0                	test   %al,%al
  281799:	74 34                	je     2817cf <sprintf+0xb3>
  28179b:	8d 55 ea             	lea    -0x16(%ebp),%edx
  28179e:	83 c3 01             	add    $0x1,%ebx
  2817a1:	83 c2 01             	add    $0x1,%edx
  2817a4:	88 43 ff             	mov    %al,-0x1(%ebx)
  2817a7:	0f b6 02             	movzbl (%edx),%eax
  2817aa:	84 c0                	test   %al,%al
  2817ac:	75 f0                	jne    28179e <sprintf+0x82>
  2817ae:	eb 1f                	jmp    2817cf <sprintf+0xb3>
				case 's':buf=(char*)(*var);while(*buf){*str++=*buf++;};break;
  2817b0:	8b 0f                	mov    (%edi),%ecx
  2817b2:	0f b6 11             	movzbl (%ecx),%edx
  2817b5:	84 d2                	test   %dl,%dl
  2817b7:	74 16                	je     2817cf <sprintf+0xb3>
  2817b9:	89 d8                	mov    %ebx,%eax
  2817bb:	83 c0 01             	add    $0x1,%eax
  2817be:	88 50 ff             	mov    %dl,-0x1(%eax)
  2817c1:	89 c2                	mov    %eax,%edx
  2817c3:	29 da                	sub    %ebx,%edx
  2817c5:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
  2817c9:	84 d2                	test   %dl,%dl
  2817cb:	75 ee                	jne    2817bb <sprintf+0x9f>
  2817cd:	89 c3                	mov    %eax,%ebx
			}
			buf=buffer;
			var++;
  2817cf:	83 c7 04             	add    $0x4,%edi
			format++;
  2817d2:	83 c6 02             	add    $0x2,%esi
  2817d5:	89 75 0c             	mov    %esi,0xc(%ebp)

void sprintf(char *str,char *format ,...){
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
	char buffer[10];
	char *buf=buffer;
	while(*format){
  2817d8:	8b 75 0c             	mov    0xc(%ebp),%esi
  2817db:	0f b6 06             	movzbl (%esi),%eax
  2817de:	84 c0                	test   %al,%al
  2817e0:	0f 85 4a ff ff ff    	jne    281730 <sprintf+0x14>
			buf=buffer;
			var++;
			format++;
		}
	}
	*str='\0';
  2817e6:	c6 03 00             	movb   $0x0,(%ebx)
}
  2817e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2817ec:	5b                   	pop    %ebx
  2817ed:	5e                   	pop    %esi
  2817ee:	5f                   	pop    %edi
  2817ef:	5d                   	pop    %ebp
  2817f0:	c3                   	ret    

002817f1 <strcmp>:
    }
    *buf='\0';
}

int strcmp(const char *str1,const char *str2)
{
  2817f1:	55                   	push   %ebp
  2817f2:	89 e5                	mov    %esp,%ebp
  2817f4:	57                   	push   %edi
  2817f5:	56                   	push   %esi
  2817f6:	53                   	push   %ebx
  2817f7:	8b 7d 08             	mov    0x8(%ebp),%edi
  2817fa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  2817fd:	0f b6 17             	movzbl (%edi),%edx
  281800:	be 00 00 00 00       	mov    $0x0,%esi
  281805:	84 d2                	test   %dl,%dl
  281807:	74 40                	je     281849 <strcmp+0x58>
  281809:	eb 1d                	jmp    281828 <strcmp+0x37>
	{
		if(c1==c2) i++;
  28180b:	38 ca                	cmp    %cl,%dl
  28180d:	75 0f                	jne    28181e <strcmp+0x2d>
  28180f:	83 c0 01             	add    $0x1,%eax

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281812:	89 c6                	mov    %eax,%esi
  281814:	0f b6 14 07          	movzbl (%edi,%eax,1),%edx
  281818:	84 d2                	test   %dl,%dl
  28181a:	75 1e                	jne    28183a <strcmp+0x49>
  28181c:	eb 2b                	jmp    281849 <strcmp+0x58>
	{
		if(c1==c2) i++;
		else return c1-c2;
  28181e:	0f be c2             	movsbl %dl,%eax
  281821:	0f be c9             	movsbl %cl,%ecx
  281824:	29 c8                	sub    %ecx,%eax
  281826:	eb 2a                	jmp    281852 <strcmp+0x61>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281828:	0f b6 0b             	movzbl (%ebx),%ecx
  28182b:	84 c9                	test   %cl,%cl
  28182d:	74 15                	je     281844 <strcmp+0x53>
	{
		if(c1==c2) i++;
  28182f:	b8 00 00 00 00       	mov    $0x0,%eax
  281834:	38 ca                	cmp    %cl,%dl
  281836:	74 d7                	je     28180f <strcmp+0x1e>
  281838:	eb e4                	jmp    28181e <strcmp+0x2d>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  28183a:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  28183e:	84 c9                	test   %cl,%cl
  281840:	75 c9                	jne    28180b <strcmp+0x1a>
  281842:	eb 05                	jmp    281849 <strcmp+0x58>
  281844:	be 00 00 00 00       	mov    $0x0,%esi
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281849:	0f be c2             	movsbl %dl,%eax
  28184c:	0f be 14 33          	movsbl (%ebx,%esi,1),%edx
  281850:	29 d0                	sub    %edx,%eax
}
  281852:	5b                   	pop    %ebx
  281853:	5e                   	pop    %esi
  281854:	5f                   	pop    %edi
  281855:	5d                   	pop    %ebp
  281856:	c3                   	ret    

00281857 <strncmp>:

int strncmp(const char *str1,const char *str2,unsigned int n)
{
  281857:	55                   	push   %ebp
  281858:	89 e5                	mov    %esp,%ebp
  28185a:	57                   	push   %edi
  28185b:	56                   	push   %esi
  28185c:	53                   	push   %ebx
  28185d:	8b 75 08             	mov    0x8(%ebp),%esi
  281860:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281863:	8b 7d 10             	mov    0x10(%ebp),%edi
	if(n == 0) return 0;
  281866:	b8 00 00 00 00       	mov    $0x0,%eax
  28186b:	85 ff                	test   %edi,%edi
  28186d:	74 63                	je     2818d2 <strncmp+0x7b>
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  28186f:	83 ef 01             	sub    $0x1,%edi
  281872:	89 fa                	mov    %edi,%edx
  281874:	74 52                	je     2818c8 <strncmp+0x71>
  281876:	eb 19                	jmp    281891 <strncmp+0x3a>
	{
		if(c1==c2) i++;
  281878:	38 c8                	cmp    %cl,%al
  28187a:	75 0b                	jne    281887 <strncmp+0x30>
  28187c:	83 c2 01             	add    $0x1,%edx
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  28187f:	39 fa                	cmp    %edi,%edx
  281881:	75 27                	jne    2818aa <strncmp+0x53>
	{
		if(c1==c2) i++;
  281883:	89 fa                	mov    %edi,%edx
  281885:	eb 41                	jmp    2818c8 <strncmp+0x71>
		else return c1-c2;
  281887:	0f be c0             	movsbl %al,%eax
  28188a:	0f be c9             	movsbl %cl,%ecx
  28188d:	29 c8                	sub    %ecx,%eax
  28188f:	eb 41                	jmp    2818d2 <strncmp+0x7b>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281891:	0f b6 06             	movzbl (%esi),%eax
  281894:	84 c0                	test   %al,%al
  281896:	74 24                	je     2818bc <strncmp+0x65>
  281898:	0f b6 0b             	movzbl (%ebx),%ecx
  28189b:	84 c9                	test   %cl,%cl
  28189d:	74 24                	je     2818c3 <strncmp+0x6c>
	{
		if(c1==c2) i++;
  28189f:	ba 00 00 00 00       	mov    $0x0,%edx
  2818a4:	38 c8                	cmp    %cl,%al
  2818a6:	74 d4                	je     28187c <strncmp+0x25>
  2818a8:	eb dd                	jmp    281887 <strncmp+0x30>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  2818aa:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
  2818ae:	84 c0                	test   %al,%al
  2818b0:	74 16                	je     2818c8 <strncmp+0x71>
  2818b2:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  2818b6:	84 c9                	test   %cl,%cl
  2818b8:	75 be                	jne    281878 <strncmp+0x21>
  2818ba:	eb 0c                	jmp    2818c8 <strncmp+0x71>
  2818bc:	ba 00 00 00 00       	mov    $0x0,%edx
  2818c1:	eb 05                	jmp    2818c8 <strncmp+0x71>
  2818c3:	ba 00 00 00 00       	mov    $0x0,%edx
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  2818c8:	0f be 04 16          	movsbl (%esi,%edx,1),%eax
  2818cc:	0f be 14 13          	movsbl (%ebx,%edx,1),%edx
  2818d0:	29 d0                	sub    %edx,%eax
}
  2818d2:	5b                   	pop    %ebx
  2818d3:	5e                   	pop    %esi
  2818d4:	5f                   	pop    %edi
  2818d5:	5d                   	pop    %ebp
  2818d6:	c3                   	ret    

002818d7 <fifo32_init>:
#include "fifo.h"
#include "task.h"
void fifo32_init(struct FIFO32 *fifo,int size,int *buf,struct TASK *task)
{
  2818d7:	55                   	push   %ebp
  2818d8:	89 e5                	mov    %esp,%ebp
  2818da:	8b 45 08             	mov    0x8(%ebp),%eax
  2818dd:	8b 55 0c             	mov    0xc(%ebp),%edx
	fifo->size=size;
  2818e0:	89 50 0c             	mov    %edx,0xc(%eax)
	fifo->buf=buf;
  2818e3:	8b 4d 10             	mov    0x10(%ebp),%ecx
  2818e6:	89 08                	mov    %ecx,(%eax)
	fifo->free = size;
  2818e8:	89 50 10             	mov    %edx,0x10(%eax)
	fifo->flags = 0;
  2818eb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	fifo->p = 0;
  2818f2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->q = 0;
  2818f9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	fifo->task = task;
  281900:	8b 55 14             	mov    0x14(%ebp),%edx
  281903:	89 50 18             	mov    %edx,0x18(%eax)
	return;
}
  281906:	5d                   	pop    %ebp
  281907:	c3                   	ret    

00281908 <fifo32_put>:
#define FLAGS_OVERRUN 0x0001
#include "timer.h"
extern struct TIMERCTL timerctl;

int fifo32_put(struct FIFO32 *fifo,int data)
{
  281908:	55                   	push   %ebp
  281909:	89 e5                	mov    %esp,%ebp
  28190b:	53                   	push   %ebx
  28190c:	83 ec 04             	sub    $0x4,%esp
  28190f:	8b 45 08             	mov    0x8(%ebp),%eax
	if(fifo->free == 0)
  281912:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  281916:	75 0b                	jne    281923 <fifo32_put+0x1b>
	{
		fifo->flags |= FLAGS_OVERRUN;
  281918:	83 48 14 01          	orl    $0x1,0x14(%eax)
		return -1;
  28191c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  281921:	eb 52                	jmp    281975 <fifo32_put+0x6d>
	}
	fifo->buf[fifo->p] = data;
  281923:	8b 48 04             	mov    0x4(%eax),%ecx
  281926:	8b 10                	mov    (%eax),%edx
  281928:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  28192b:	89 1c 8a             	mov    %ebx,(%edx,%ecx,4)
	fifo->p++;
  28192e:	8b 48 04             	mov    0x4(%eax),%ecx
  281931:	8d 51 01             	lea    0x1(%ecx),%edx
  281934:	89 50 04             	mov    %edx,0x4(%eax)
	if(fifo->p == fifo->size)
  281937:	3b 50 0c             	cmp    0xc(%eax),%edx
  28193a:	75 07                	jne    281943 <fifo32_put+0x3b>
		fifo->p = 0;
  28193c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->free--;
  281943:	83 68 10 01          	subl   $0x1,0x10(%eax)

	//wake up task
	if(fifo->task!=0)
  281947:	8b 50 18             	mov    0x18(%eax),%edx
  28194a:	85 d2                	test   %edx,%edx
  28194c:	74 22                	je     281970 <fifo32_put+0x68>
		if(fifo->task->flags!=2)
		{
			task_run(fifo->task,-1,0);
		}
	}
	return 0;
  28194e:	b8 00 00 00 00       	mov    $0x0,%eax
	fifo->free--;

	//wake up task
	if(fifo->task!=0)
	{
		if(fifo->task->flags!=2)
  281953:	83 7a 04 02          	cmpl   $0x2,0x4(%edx)
  281957:	74 1c                	je     281975 <fifo32_put+0x6d>
		{
			task_run(fifo->task,-1,0);
  281959:	83 ec 04             	sub    $0x4,%esp
  28195c:	6a 00                	push   $0x0
  28195e:	6a ff                	push   $0xffffffff
  281960:	52                   	push   %edx
  281961:	e8 47 11 00 00       	call   282aad <task_run>
  281966:	83 c4 10             	add    $0x10,%esp
		}
	}
	return 0;
  281969:	b8 00 00 00 00       	mov    $0x0,%eax
  28196e:	eb 05                	jmp    281975 <fifo32_put+0x6d>
  281970:	b8 00 00 00 00       	mov    $0x0,%eax
}
  281975:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  281978:	c9                   	leave  
  281979:	c3                   	ret    

0028197a <fifo32_get>:

int fifo32_get(struct FIFO32 *fifo)
{
  28197a:	55                   	push   %ebp
  28197b:	89 e5                	mov    %esp,%ebp
  28197d:	56                   	push   %esi
  28197e:	53                   	push   %ebx
  28197f:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if(fifo->free == fifo->size)
  281982:	8b 59 10             	mov    0x10(%ecx),%ebx
  281985:	8b 71 0c             	mov    0xc(%ecx),%esi
  281988:	39 f3                	cmp    %esi,%ebx
  28198a:	74 20                	je     2819ac <fifo32_get+0x32>
		return -1;
	int data = fifo->buf[fifo->q];
  28198c:	8b 51 08             	mov    0x8(%ecx),%edx
  28198f:	8b 01                	mov    (%ecx),%eax
  281991:	8b 04 90             	mov    (%eax,%edx,4),%eax
	fifo->q++;
  281994:	83 c2 01             	add    $0x1,%edx
	if(fifo->q == fifo->size)
  281997:	39 d6                	cmp    %edx,%esi
int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
	int data = fifo->buf[fifo->q];
	fifo->q++;
  281999:	be 00 00 00 00       	mov    $0x0,%esi
  28199e:	0f 44 d6             	cmove  %esi,%edx
  2819a1:	89 51 08             	mov    %edx,0x8(%ecx)
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
  2819a4:	83 c3 01             	add    $0x1,%ebx
  2819a7:	89 59 10             	mov    %ebx,0x10(%ecx)
	return data;
  2819aa:	eb 05                	jmp    2819b1 <fifo32_get+0x37>
}

int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
  2819ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	fifo->q++;
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
	return data;
}
  2819b1:	5b                   	pop    %ebx
  2819b2:	5e                   	pop    %esi
  2819b3:	5d                   	pop    %ebp
  2819b4:	c3                   	ret    

002819b5 <fifo32_status>:

int fifo32_status(struct FIFO32 *fifo)
{
  2819b5:	55                   	push   %ebp
  2819b6:	89 e5                	mov    %esp,%ebp
  2819b8:	8b 55 08             	mov    0x8(%ebp),%edx
	return fifo->size - fifo->free;
  2819bb:	8b 42 0c             	mov    0xc(%edx),%eax
  2819be:	2b 42 10             	sub    0x10(%edx),%eax
}
  2819c1:	5d                   	pop    %ebp
  2819c2:	c3                   	ret    

002819c3 <enable_mouse>:
#include "mouse.h"
struct FIFO32 *mousefifo;
int mousedata0;
void enable_mouse(struct FIFO32 *fifo,int data0,struct MOUSE_DEC *mdec)
{
  2819c3:	55                   	push   %ebp
  2819c4:	89 e5                	mov    %esp,%ebp
  2819c6:	83 ec 08             	sub    $0x8,%esp
	mousefifo = fifo;
  2819c9:	8b 45 08             	mov    0x8(%ebp),%eax
  2819cc:	a3 a4 64 28 00       	mov    %eax,0x2864a4
	mousedata0 = data0;
  2819d1:	8b 45 0c             	mov    0xc(%ebp),%eax
  2819d4:	a3 a0 64 28 00       	mov    %eax,0x2864a0

	wait_KBC_sendready();
  2819d9:	e8 1a 01 00 00       	call   281af8 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_SENDTO_MOUSE);
  2819de:	83 ec 08             	sub    $0x8,%esp
  2819e1:	68 d4 00 00 00       	push   $0xd4
  2819e6:	6a 64                	push   $0x64
  2819e8:	e8 49 f1 ff ff       	call   280b36 <io_out8>
	wait_KBC_sendready();
  2819ed:	e8 06 01 00 00       	call   281af8 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,MOUSECMD_ENABLE);
  2819f2:	83 c4 08             	add    $0x8,%esp
  2819f5:	68 f4 00 00 00       	push   $0xf4
  2819fa:	6a 60                	push   $0x60
  2819fc:	e8 35 f1 ff ff       	call   280b36 <io_out8>
	mdec->phase = 0;
  281a01:	8b 45 10             	mov    0x10(%ebp),%eax
  281a04:	c6 40 03 00          	movb   $0x0,0x3(%eax)
	return;
  281a08:	83 c4 10             	add    $0x10,%esp
}
  281a0b:	c9                   	leave  
  281a0c:	c3                   	ret    

00281a0d <mouse_decode>:

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
  281a0d:	55                   	push   %ebp
  281a0e:	89 e5                	mov    %esp,%ebp
  281a10:	56                   	push   %esi
  281a11:	53                   	push   %ebx
  281a12:	8b 55 08             	mov    0x8(%ebp),%edx
  281a15:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if(mdec->phase == 0)
  281a18:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  281a1c:	84 c0                	test   %al,%al
  281a1e:	75 14                	jne    281a34 <mouse_decode+0x27>
	{
		if(dat == 0xfa)
			mdec->phase = 1;
		return 0;
  281a20:	b8 00 00 00 00       	mov    $0x0,%eax

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
	if(mdec->phase == 0)
	{
		if(dat == 0xfa)
  281a25:	80 f9 fa             	cmp    $0xfa,%cl
  281a28:	0f 85 82 00 00 00    	jne    281ab0 <mouse_decode+0xa3>
			mdec->phase = 1;
  281a2e:	c6 42 03 01          	movb   $0x1,0x3(%edx)
  281a32:	eb 7c                	jmp    281ab0 <mouse_decode+0xa3>
		return 0;
	}
	if(mdec->phase == 1)
  281a34:	3c 01                	cmp    $0x1,%al
  281a36:	75 17                	jne    281a4f <mouse_decode+0x42>
	{
		if((dat&0xc8) == 0x08)
  281a38:	89 cb                	mov    %ecx,%ebx
  281a3a:	83 e3 c8             	and    $0xffffffc8,%ebx
		{
			mdec->buf[0] = dat;
			mdec->phase = 2;
		}
		return 0;
  281a3d:	b8 00 00 00 00       	mov    $0x0,%eax
			mdec->phase = 1;
		return 0;
	}
	if(mdec->phase == 1)
	{
		if((dat&0xc8) == 0x08)
  281a42:	80 fb 08             	cmp    $0x8,%bl
  281a45:	75 69                	jne    281ab0 <mouse_decode+0xa3>
		{
			mdec->buf[0] = dat;
  281a47:	88 0a                	mov    %cl,(%edx)
			mdec->phase = 2;
  281a49:	c6 42 03 02          	movb   $0x2,0x3(%edx)
  281a4d:	eb 61                	jmp    281ab0 <mouse_decode+0xa3>
		}
		return 0;
	}
	if(mdec->phase == 2)
  281a4f:	3c 02                	cmp    $0x2,%al
  281a51:	75 0e                	jne    281a61 <mouse_decode+0x54>
	{
		mdec->buf[1] = dat;
  281a53:	88 4a 01             	mov    %cl,0x1(%edx)
		mdec->phase = 3;
  281a56:	c6 42 03 03          	movb   $0x3,0x3(%edx)
		return 0;
  281a5a:	b8 00 00 00 00       	mov    $0x0,%eax
  281a5f:	eb 4f                	jmp    281ab0 <mouse_decode+0xa3>
	}
	if(mdec->phase == 3)
  281a61:	3c 03                	cmp    $0x3,%al
  281a63:	75 46                	jne    281aab <mouse_decode+0x9e>
	{
		mdec->buf[2] = dat;
  281a65:	88 4a 02             	mov    %cl,0x2(%edx)
		mdec->phase = 1;
  281a68:	c6 42 03 01          	movb   $0x1,0x3(%edx)
		mdec->btn = mdec->buf[0] & 0x07;
  281a6c:	0f b6 02             	movzbl (%edx),%eax
  281a6f:	89 c3                	mov    %eax,%ebx
  281a71:	83 e3 07             	and    $0x7,%ebx
  281a74:	89 5a 0c             	mov    %ebx,0xc(%edx)
		mdec->x = mdec->buf[1];
  281a77:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
  281a7b:	0f b6 f3             	movzbl %bl,%esi
  281a7e:	89 72 04             	mov    %esi,0x4(%edx)
		
		mdec->y = mdec->buf[2];
  281a81:	0f b6 f1             	movzbl %cl,%esi
  281a84:	89 72 08             	mov    %esi,0x8(%edx)
		if((mdec->buf[0] & 0x10)!=0)
  281a87:	a8 10                	test   $0x10,%al
  281a89:	74 09                	je     281a94 <mouse_decode+0x87>
		{
			mdec->x |= 0xffffff00;
  281a8b:	81 cb 00 ff ff ff    	or     $0xffffff00,%ebx
  281a91:	89 5a 04             	mov    %ebx,0x4(%edx)
		}
		if((mdec->buf[0] & 0x20)!=0)
  281a94:	a8 20                	test   $0x20,%al
  281a96:	74 09                	je     281aa1 <mouse_decode+0x94>
		{
			mdec->y |= 0xffffff00;
  281a98:	81 c9 00 ff ff ff    	or     $0xffffff00,%ecx
  281a9e:	89 4a 08             	mov    %ecx,0x8(%edx)
		}
		mdec->y = -mdec->y;
  281aa1:	f7 5a 08             	negl   0x8(%edx)
		return 1;
  281aa4:	b8 01 00 00 00       	mov    $0x1,%eax
  281aa9:	eb 05                	jmp    281ab0 <mouse_decode+0xa3>
	}
	return -1;
  281aab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  281ab0:	5b                   	pop    %ebx
  281ab1:	5e                   	pop    %esi
  281ab2:	5d                   	pop    %ebp
  281ab3:	c3                   	ret    

00281ab4 <inthandler2c>:
#include "fifo.h"


//hanlder for int 2c (mouse interrupts)
void inthandler2c(int *esp)
{
  281ab4:	55                   	push   %ebp
  281ab5:	89 e5                	mov    %esp,%ebp
  281ab7:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic continue watch 2c int
	io_out8(PIC1_OCW2,0X64);
  281aba:	6a 64                	push   $0x64
  281abc:	68 a0 00 00 00       	push   $0xa0
  281ac1:	e8 70 f0 ff ff       	call   280b36 <io_out8>
	io_out8(PIC0_OCW2,0x62);
  281ac6:	83 c4 08             	add    $0x8,%esp
  281ac9:	6a 62                	push   $0x62
  281acb:	6a 20                	push   $0x20
  281acd:	e8 64 f0 ff ff       	call   280b36 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281ad2:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281ad9:	e8 36 f0 ff ff       	call   280b14 <io_in8>
	fifo32_put(mousefifo,data+mousedata0);
  281ade:	83 c4 08             	add    $0x8,%esp
  281ae1:	03 05 a0 64 28 00    	add    0x2864a0,%eax
  281ae7:	50                   	push   %eax
  281ae8:	ff 35 a4 64 28 00    	pushl  0x2864a4
  281aee:	e8 15 fe ff ff       	call   281908 <fifo32_put>
	return;
  281af3:	83 c4 10             	add    $0x10,%esp
}
  281af6:	c9                   	leave  
  281af7:	c3                   	ret    

00281af8 <wait_KBC_sendready>:

struct FIFO32 *keyfifo;
int keydata0;

void wait_KBC_sendready(void)
{
  281af8:	55                   	push   %ebp
  281af9:	89 e5                	mov    %esp,%ebp
  281afb:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		if((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0)
  281afe:	83 ec 0c             	sub    $0xc,%esp
  281b01:	6a 64                	push   $0x64
  281b03:	e8 0c f0 ff ff       	call   280b14 <io_in8>
  281b08:	83 c4 10             	add    $0x10,%esp
  281b0b:	a8 02                	test   $0x2,%al
  281b0d:	75 ef                	jne    281afe <wait_KBC_sendready+0x6>
			break;
	}
	return;
}
  281b0f:	c9                   	leave  
  281b10:	c3                   	ret    

00281b11 <init_keyboard>:

void init_keyboard(struct FIFO32 *fifo,int data0)
{
  281b11:	55                   	push   %ebp
  281b12:	89 e5                	mov    %esp,%ebp
  281b14:	83 ec 08             	sub    $0x8,%esp
	keyfifo = fifo;
  281b17:	8b 45 08             	mov    0x8(%ebp),%eax
  281b1a:	a3 a8 64 28 00       	mov    %eax,0x2864a8
	keydata0 = data0;
  281b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
  281b22:	a3 ac 64 28 00       	mov    %eax,0x2864ac
	wait_KBC_sendready();
  281b27:	e8 cc ff ff ff       	call   281af8 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_WRITE_MODE);
  281b2c:	83 ec 08             	sub    $0x8,%esp
  281b2f:	6a 60                	push   $0x60
  281b31:	6a 64                	push   $0x64
  281b33:	e8 fe ef ff ff       	call   280b36 <io_out8>
	wait_KBC_sendready();
  281b38:	e8 bb ff ff ff       	call   281af8 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,KBC_MODE);
  281b3d:	83 c4 08             	add    $0x8,%esp
  281b40:	6a 47                	push   $0x47
  281b42:	6a 60                	push   $0x60
  281b44:	e8 ed ef ff ff       	call   280b36 <io_out8>
	return;
  281b49:	83 c4 10             	add    $0x10,%esp
}
  281b4c:	c9                   	leave  
  281b4d:	c3                   	ret    

00281b4e <inthandler21>:
#include "fifo.h"


//handler for int 21 (keyboard interrupts)
void inthandler21(int *esp)
{
  281b4e:	55                   	push   %ebp
  281b4f:	89 e5                	mov    %esp,%ebp
  281b51:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic contine watch 21 int
	io_out8(PIC0_OCW2,0x61);
  281b54:	6a 61                	push   $0x61
  281b56:	6a 20                	push   $0x20
  281b58:	e8 d9 ef ff ff       	call   280b36 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281b5d:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281b64:	e8 ab ef ff ff       	call   280b14 <io_in8>
	fifo32_put(keyfifo,data + keydata0);
  281b69:	83 c4 08             	add    $0x8,%esp
  281b6c:	03 05 ac 64 28 00    	add    0x2864ac,%eax
  281b72:	50                   	push   %eax
  281b73:	ff 35 a8 64 28 00    	pushl  0x2864a8
  281b79:	e8 8a fd ff ff       	call   281908 <fifo32_put>
	return;
  281b7e:	83 c4 10             	add    $0x10,%esp
}
  281b81:	c9                   	leave  
  281b82:	c3                   	ret    

00281b83 <key_char>:
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
  281b83:	55                   	push   %ebp
  281b84:	89 e5                	mov    %esp,%ebp
  281b86:	8b 55 08             	mov    0x8(%ebp),%edx
	if(key>=0 && key<0x80)
	{
		if(key_shift==0) return keytable0[key];
		else return keytable1[key];
	}
	else return 0;
  281b89:	b8 00 00 00 00       	mov    $0x0,%eax
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
	if(key>=0 && key<0x80)
  281b8e:	83 fa 7f             	cmp    $0x7f,%edx
  281b91:	77 16                	ja     281ba9 <key_char+0x26>
	{
		if(key_shift==0) return keytable0[key];
  281b93:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  281b97:	75 09                	jne    281ba2 <key_char+0x1f>
  281b99:	0f b6 82 80 3e 28 00 	movzbl 0x283e80(%edx),%eax
  281ba0:	eb 07                	jmp    281ba9 <key_char+0x26>
		else return keytable1[key];
  281ba2:	0f b6 82 00 3e 28 00 	movzbl 0x283e00(%edx),%eax
	}
	else return 0;
}
  281ba9:	5d                   	pop    %ebp
  281baa:	c3                   	ret    

00281bab <memtest>:
#include "memory.h"
#include "io.h"

extern unsigned int _memtest_sub(unsigned int start,unsigned int end);
unsigned int memtest(unsigned int start,unsigned int end)
{
  281bab:	55                   	push   %ebp
  281bac:	89 e5                	mov    %esp,%ebp
  281bae:	83 ec 18             	sub    $0x18,%esp
	char flg486 = 0;
  281bb1:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	unsigned int eflg,cr0,i;
	
	//check cpu type
	eflg = io_load_eflags();
  281bb5:	e8 9b ef ff ff       	call   280b55 <io_load_eflags>
  281bba:	89 45 f0             	mov    %eax,-0x10(%ebp)
	eflg != EFLAGS_AC_BIT;
	io_store_eflags(eflg);
  281bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281bc0:	83 ec 0c             	sub    $0xc,%esp
  281bc3:	50                   	push   %eax
  281bc4:	e8 8f ef ff ff       	call   280b58 <io_store_eflags>
  281bc9:	83 c4 10             	add    $0x10,%esp
	eflg = io_load_eflags();
  281bcc:	e8 84 ef ff ff       	call   280b55 <io_load_eflags>
  281bd1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if((eflg & EFLAGS_AC_BIT) !=0)
  281bd4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281bd7:	25 00 00 04 00       	and    $0x40000,%eax
  281bdc:	85 c0                	test   %eax,%eax
  281bde:	74 04                	je     281be4 <memtest+0x39>
		flg486 = 1;
  281be0:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
	eflg &= ~EFLAGS_AC_BIT;
  281be4:	81 65 f0 ff ff fb ff 	andl   $0xfffbffff,-0x10(%ebp)
	io_store_eflags(eflg);
  281beb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281bee:	83 ec 0c             	sub    $0xc,%esp
  281bf1:	50                   	push   %eax
  281bf2:	e8 61 ef ff ff       	call   280b58 <io_store_eflags>
  281bf7:	83 c4 10             	add    $0x10,%esp
	
	//disable cpu cache
	if(flg486)
  281bfa:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  281bfe:	74 1d                	je     281c1d <memtest+0x72>
	{
		cr0 = load_cr0;
  281c00:	c7 45 ec 7f 0b 28 00 	movl   $0x280b7f,-0x14(%ebp)
		cr0 |= CR0_CACHE_DISABLE;
  281c07:	81 4d ec 00 00 00 60 	orl    $0x60000000,-0x14(%ebp)
		store_cr0(cr0);
  281c0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  281c11:	83 ec 0c             	sub    $0xc,%esp
  281c14:	50                   	push   %eax
  281c15:	e8 69 ef ff ff       	call   280b83 <store_cr0>
  281c1a:	83 c4 10             	add    $0x10,%esp
	}
	
	//i = memtest_sub(start,end);
	i = _memtest_sub(start,end);
  281c1d:	83 ec 08             	sub    $0x8,%esp
  281c20:	ff 75 0c             	pushl  0xc(%ebp)
  281c23:	ff 75 08             	pushl  0x8(%ebp)
  281c26:	e8 60 ef ff ff       	call   280b8b <_memtest_sub>
  281c2b:	83 c4 10             	add    $0x10,%esp
  281c2e:	89 45 e8             	mov    %eax,-0x18(%ebp)
	
	//enable cpu cache
	if(flg486)
  281c31:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  281c35:	74 1e                	je     281c55 <memtest+0xaa>
	{
		cr0 = load_cr0();
  281c37:	e8 43 ef ff ff       	call   280b7f <load_cr0>
  281c3c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cr0 &= ~CR0_CACHE_DISABLE;
  281c3f:	81 65 ec ff ff ff 9f 	andl   $0x9fffffff,-0x14(%ebp)
		store_cr0(cr0);
  281c46:	8b 45 ec             	mov    -0x14(%ebp),%eax
  281c49:	83 ec 0c             	sub    $0xc,%esp
  281c4c:	50                   	push   %eax
  281c4d:	e8 31 ef ff ff       	call   280b83 <store_cr0>
  281c52:	83 c4 10             	add    $0x10,%esp
	}

	return i;
  281c55:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  281c58:	c9                   	leave  
  281c59:	c3                   	ret    

00281c5a <memtest_sub>:

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
  281c5a:	55                   	push   %ebp
  281c5b:	89 e5                	mov    %esp,%ebp
  281c5d:	83 ec 20             	sub    $0x20,%esp
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
  281c60:	c7 45 f8 55 aa 55 aa 	movl   $0xaa55aa55,-0x8(%ebp)
  281c67:	c7 45 f4 aa 55 aa 55 	movl   $0x55aa55aa,-0xc(%ebp)
	for(i=start;i<=end;i+=0x1000)
  281c6e:	8b 45 08             	mov    0x8(%ebp),%eax
  281c71:	89 45 fc             	mov    %eax,-0x4(%ebp)
  281c74:	eb 67                	jmp    281cdd <memtest_sub+0x83>
	{
		p = (unsigned int *) (i+0xffc);
  281c76:	8b 45 fc             	mov    -0x4(%ebp),%eax
  281c79:	05 fc 0f 00 00       	add    $0xffc,%eax
  281c7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		old = *p;
  281c81:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281c84:	8b 00                	mov    (%eax),%eax
  281c86:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*p = pat0;
  281c89:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281c8c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281c8f:	89 10                	mov    %edx,(%eax)
		*p ^= 0xffffffff;
  281c91:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281c94:	8b 00                	mov    (%eax),%eax
  281c96:	f7 d0                	not    %eax
  281c98:	89 c2                	mov    %eax,%edx
  281c9a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281c9d:	89 10                	mov    %edx,(%eax)
		if(*p != pat1)
  281c9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281ca2:	8b 00                	mov    (%eax),%eax
  281ca4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  281ca7:	74 0d                	je     281cb6 <memtest_sub+0x5c>
  281ca9:	eb 01                	jmp    281cac <memtest_sub+0x52>
			break;
		}
		*p ^= 0xffffffff;
		if(*p != pat0)
		{
			goto not_memory;
  281cab:	90                   	nop
		*p = pat0;
		*p ^= 0xffffffff;
		if(*p != pat1)
		{
not_memory:
			*p = old;
  281cac:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281caf:	8b 55 ec             	mov    -0x14(%ebp),%edx
  281cb2:	89 10                	mov    %edx,(%eax)
			break;
  281cb4:	eb 2f                	jmp    281ce5 <memtest_sub+0x8b>
		}
		*p ^= 0xffffffff;
  281cb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281cb9:	8b 00                	mov    (%eax),%eax
  281cbb:	f7 d0                	not    %eax
  281cbd:	89 c2                	mov    %eax,%edx
  281cbf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281cc2:	89 10                	mov    %edx,(%eax)
		if(*p != pat0)
  281cc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281cc7:	8b 00                	mov    (%eax),%eax
  281cc9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281ccc:	75 dd                	jne    281cab <memtest_sub+0x51>
		{
			goto not_memory;
		}
		*p = old;
  281cce:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281cd1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  281cd4:	89 10                	mov    %edx,(%eax)

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
	for(i=start;i<=end;i+=0x1000)
  281cd6:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%ebp)
  281cdd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  281ce0:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281ce3:	76 91                	jbe    281c76 <memtest_sub+0x1c>
		{
			goto not_memory;
		}
		*p = old;
	}
	return i;
  281ce5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  281ce8:	c9                   	leave  
  281ce9:	c3                   	ret    

00281cea <memman_init>:

void memman_init(struct MEMMAN *man)
{
  281cea:	55                   	push   %ebp
  281ceb:	89 e5                	mov    %esp,%ebp
	man->frees = 0;
  281ced:	8b 45 08             	mov    0x8(%ebp),%eax
  281cf0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	man->maxfrees = 0;
  281cf6:	8b 45 08             	mov    0x8(%ebp),%eax
  281cf9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	man->lostsize = 0;
  281d00:	8b 45 08             	mov    0x8(%ebp),%eax
  281d03:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	man->losts = 0;
  281d0a:	8b 45 08             	mov    0x8(%ebp),%eax
  281d0d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return;
  281d14:	90                   	nop
}
  281d15:	5d                   	pop    %ebp
  281d16:	c3                   	ret    

00281d17 <memman_total>:

unsigned int memman_total(struct MEMMAN *man)
{
  281d17:	55                   	push   %ebp
  281d18:	89 e5                	mov    %esp,%ebp
  281d1a:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,t = 0;
  281d1d:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;i<man->frees;i++)
  281d24:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  281d2b:	eb 14                	jmp    281d41 <memman_total+0x2a>
	{
		t+=man->free[i].size;
  281d2d:	8b 45 08             	mov    0x8(%ebp),%eax
  281d30:	8b 55 fc             	mov    -0x4(%ebp),%edx
  281d33:	83 c2 02             	add    $0x2,%edx
  281d36:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281d3a:	01 45 f8             	add    %eax,-0x8(%ebp)
}

unsigned int memman_total(struct MEMMAN *man)
{
	unsigned int i,t = 0;
	for(i=0;i<man->frees;i++)
  281d3d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  281d41:	8b 45 08             	mov    0x8(%ebp),%eax
  281d44:	8b 00                	mov    (%eax),%eax
  281d46:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  281d49:	77 e2                	ja     281d2d <memman_total+0x16>
	{
		t+=man->free[i].size;
	}
	return t;
  281d4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  281d4e:	c9                   	leave  
  281d4f:	c3                   	ret    

00281d50 <memman_alloc>:

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
  281d50:	55                   	push   %ebp
  281d51:	89 e5                	mov    %esp,%ebp
  281d53:	53                   	push   %ebx
  281d54:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  281d57:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  281d5e:	e9 bd 00 00 00       	jmp    281e20 <memman_alloc+0xd0>
	{
		if(man->free[i].size >= size)
  281d63:	8b 45 08             	mov    0x8(%ebp),%eax
  281d66:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281d69:	83 c2 02             	add    $0x2,%edx
  281d6c:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281d70:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281d73:	0f 82 a3 00 00 00    	jb     281e1c <memman_alloc+0xcc>
		{
			a = man->free[i].addr;
  281d79:	8b 45 08             	mov    0x8(%ebp),%eax
  281d7c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281d7f:	83 c2 02             	add    $0x2,%edx
  281d82:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  281d85:	89 45 f4             	mov    %eax,-0xc(%ebp)
			man->free[i].addr+=size;
  281d88:	8b 45 08             	mov    0x8(%ebp),%eax
  281d8b:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281d8e:	83 c2 02             	add    $0x2,%edx
  281d91:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  281d94:	8b 45 0c             	mov    0xc(%ebp),%eax
  281d97:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281d9a:	8b 45 08             	mov    0x8(%ebp),%eax
  281d9d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281da0:	83 c2 02             	add    $0x2,%edx
  281da3:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
			man->free[i].size-=size;
  281da6:	8b 45 08             	mov    0x8(%ebp),%eax
  281da9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281dac:	83 c2 02             	add    $0x2,%edx
  281daf:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281db3:	2b 45 0c             	sub    0xc(%ebp),%eax
  281db6:	89 c2                	mov    %eax,%edx
  281db8:	8b 45 08             	mov    0x8(%ebp),%eax
  281dbb:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  281dbe:	83 c1 02             	add    $0x2,%ecx
  281dc1:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
			if(man->free[i].size == 0)
  281dc5:	8b 45 08             	mov    0x8(%ebp),%eax
  281dc8:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281dcb:	83 c2 02             	add    $0x2,%edx
  281dce:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281dd2:	85 c0                	test   %eax,%eax
  281dd4:	75 41                	jne    281e17 <memman_alloc+0xc7>
			{
				man->frees--;
  281dd6:	8b 45 08             	mov    0x8(%ebp),%eax
  281dd9:	8b 00                	mov    (%eax),%eax
  281ddb:	8d 50 ff             	lea    -0x1(%eax),%edx
  281dde:	8b 45 08             	mov    0x8(%ebp),%eax
  281de1:	89 10                	mov    %edx,(%eax)
				for(;i<man->frees;i++)
  281de3:	eb 28                	jmp    281e0d <memman_alloc+0xbd>
				{
					man->free[i] = man->free[i+1];
  281de5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281de8:	8d 50 01             	lea    0x1(%eax),%edx
  281deb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281dee:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281df1:	8d 58 02             	lea    0x2(%eax),%ebx
  281df4:	8b 45 08             	mov    0x8(%ebp),%eax
  281df7:	83 c2 02             	add    $0x2,%edx
  281dfa:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  281dfd:	8b 02                	mov    (%edx),%eax
  281dff:	8b 52 04             	mov    0x4(%edx),%edx
  281e02:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  281e05:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
			man->free[i].addr+=size;
			man->free[i].size-=size;
			if(man->free[i].size == 0)
			{
				man->frees--;
				for(;i<man->frees;i++)
  281e09:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281e0d:	8b 45 08             	mov    0x8(%ebp),%eax
  281e10:	8b 00                	mov    (%eax),%eax
  281e12:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281e15:	77 ce                	ja     281de5 <memman_alloc+0x95>
				{
					man->free[i] = man->free[i+1];
				}
			}
			return a;
  281e17:	8b 45 f4             	mov    -0xc(%ebp),%eax
  281e1a:	eb 17                	jmp    281e33 <memman_alloc+0xe3>
}

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  281e1c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281e20:	8b 45 08             	mov    0x8(%ebp),%eax
  281e23:	8b 00                	mov    (%eax),%eax
  281e25:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281e28:	0f 87 35 ff ff ff    	ja     281d63 <memman_alloc+0x13>
				}
			}
			return a;
		}
	}
	return 0;
  281e2e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  281e33:	83 c4 10             	add    $0x10,%esp
  281e36:	5b                   	pop    %ebx
  281e37:	5d                   	pop    %ebp
  281e38:	c3                   	ret    

00281e39 <memman_free>:

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  281e39:	55                   	push   %ebp
  281e3a:	89 e5                	mov    %esp,%ebp
  281e3c:	53                   	push   %ebx
  281e3d:	83 ec 10             	sub    $0x10,%esp
	int i,j;
	
	for(i=0;i<man->frees;i++)
  281e40:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  281e47:	eb 15                	jmp    281e5e <memman_free+0x25>
	{
		if(man->free[i].addr>addr) break;
  281e49:	8b 45 08             	mov    0x8(%ebp),%eax
  281e4c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281e4f:	83 c2 02             	add    $0x2,%edx
  281e52:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  281e55:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281e58:	77 10                	ja     281e6a <memman_free+0x31>

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
	int i,j;
	
	for(i=0;i<man->frees;i++)
  281e5a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281e5e:	8b 45 08             	mov    0x8(%ebp),%eax
  281e61:	8b 00                	mov    (%eax),%eax
  281e63:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281e66:	7f e1                	jg     281e49 <memman_free+0x10>
  281e68:	eb 01                	jmp    281e6b <memman_free+0x32>
	{
		if(man->free[i].addr>addr) break;
  281e6a:	90                   	nop
	}

	//if prev combinable.
	if(i>0 && (man->free[i-1].addr+man->free[i-1].size == addr))
  281e6b:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  281e6f:	0f 8e f2 00 00 00    	jle    281f67 <memman_free+0x12e>
  281e75:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281e78:	8d 50 ff             	lea    -0x1(%eax),%edx
  281e7b:	8b 45 08             	mov    0x8(%ebp),%eax
  281e7e:	83 c2 02             	add    $0x2,%edx
  281e81:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  281e84:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281e87:	8d 48 ff             	lea    -0x1(%eax),%ecx
  281e8a:	8b 45 08             	mov    0x8(%ebp),%eax
  281e8d:	83 c1 02             	add    $0x2,%ecx
  281e90:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  281e94:	01 d0                	add    %edx,%eax
  281e96:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281e99:	0f 85 c8 00 00 00    	jne    281f67 <memman_free+0x12e>
	{
		//combine with prev
		man->free[i-1].size += size;
  281e9f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281ea2:	8d 58 ff             	lea    -0x1(%eax),%ebx
  281ea5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281ea8:	8d 50 ff             	lea    -0x1(%eax),%edx
  281eab:	8b 45 08             	mov    0x8(%ebp),%eax
  281eae:	83 c2 02             	add    $0x2,%edx
  281eb1:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  281eb5:	8b 45 10             	mov    0x10(%ebp),%eax
  281eb8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281ebb:	8b 45 08             	mov    0x8(%ebp),%eax
  281ebe:	8d 53 02             	lea    0x2(%ebx),%edx
  281ec1:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)

		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
  281ec5:	8b 45 08             	mov    0x8(%ebp),%eax
  281ec8:	8b 00                	mov    (%eax),%eax
  281eca:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281ecd:	0f 8e 8a 00 00 00    	jle    281f5d <memman_free+0x124>
  281ed3:	8b 55 0c             	mov    0xc(%ebp),%edx
  281ed6:	8b 45 10             	mov    0x10(%ebp),%eax
  281ed9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281edc:	8b 45 08             	mov    0x8(%ebp),%eax
  281edf:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281ee2:	83 c2 02             	add    $0x2,%edx
  281ee5:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  281ee8:	39 c1                	cmp    %eax,%ecx
  281eea:	75 71                	jne    281f5d <memman_free+0x124>
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
  281eec:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281eef:	8d 58 ff             	lea    -0x1(%eax),%ebx
  281ef2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281ef5:	8d 50 ff             	lea    -0x1(%eax),%edx
  281ef8:	8b 45 08             	mov    0x8(%ebp),%eax
  281efb:	83 c2 02             	add    $0x2,%edx
  281efe:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  281f02:	8b 45 08             	mov    0x8(%ebp),%eax
  281f05:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  281f08:	83 c1 02             	add    $0x2,%ecx
  281f0b:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  281f0f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281f12:	8b 45 08             	mov    0x8(%ebp),%eax
  281f15:	8d 53 02             	lea    0x2(%ebx),%edx
  281f18:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
			for(;i<man->frees;i++)
  281f1c:	eb 28                	jmp    281f46 <memman_free+0x10d>
				man->free[i] = man->free[i+1];
  281f1e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281f21:	8d 50 01             	lea    0x1(%eax),%edx
  281f24:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281f27:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281f2a:	8d 58 02             	lea    0x2(%eax),%ebx
  281f2d:	8b 45 08             	mov    0x8(%ebp),%eax
  281f30:	83 c2 02             	add    $0x2,%edx
  281f33:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  281f36:	8b 02                	mov    (%edx),%eax
  281f38:	8b 52 04             	mov    0x4(%edx),%edx
  281f3b:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  281f3e:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
			for(;i<man->frees;i++)
  281f42:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281f46:	8b 45 08             	mov    0x8(%ebp),%eax
  281f49:	8b 00                	mov    (%eax),%eax
  281f4b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281f4e:	7f ce                	jg     281f1e <memman_free+0xe5>
				man->free[i] = man->free[i+1];
			man->frees--;
  281f50:	8b 45 08             	mov    0x8(%ebp),%eax
  281f53:	8b 00                	mov    (%eax),%eax
  281f55:	8d 50 ff             	lea    -0x1(%eax),%edx
  281f58:	8b 45 08             	mov    0x8(%ebp),%eax
  281f5b:	89 10                	mov    %edx,(%eax)
		}
		
		return 0;
  281f5d:	b8 00 00 00 00       	mov    $0x0,%eax
  281f62:	e9 1f 01 00 00       	jmp    282086 <memman_free+0x24d>
	}

	//if next combinable
	if(i<man->frees && (addr + size == man->free[i].addr))
  281f67:	8b 45 08             	mov    0x8(%ebp),%eax
  281f6a:	8b 00                	mov    (%eax),%eax
  281f6c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281f6f:	7e 52                	jle    281fc3 <memman_free+0x18a>
  281f71:	8b 55 0c             	mov    0xc(%ebp),%edx
  281f74:	8b 45 10             	mov    0x10(%ebp),%eax
  281f77:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281f7a:	8b 45 08             	mov    0x8(%ebp),%eax
  281f7d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f80:	83 c2 02             	add    $0x2,%edx
  281f83:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  281f86:	39 c1                	cmp    %eax,%ecx
  281f88:	75 39                	jne    281fc3 <memman_free+0x18a>
	{
		man->free[i].addr = addr;
  281f8a:	8b 45 08             	mov    0x8(%ebp),%eax
  281f8d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f90:	8d 4a 02             	lea    0x2(%edx),%ecx
  281f93:	8b 55 0c             	mov    0xc(%ebp),%edx
  281f96:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size += size;
  281f99:	8b 45 08             	mov    0x8(%ebp),%eax
  281f9c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f9f:	83 c2 02             	add    $0x2,%edx
  281fa2:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  281fa6:	8b 45 10             	mov    0x10(%ebp),%eax
  281fa9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281fac:	8b 45 08             	mov    0x8(%ebp),%eax
  281faf:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281fb2:	83 c2 02             	add    $0x2,%edx
  281fb5:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
		return 0;
  281fb9:	b8 00 00 00 00       	mov    $0x0,%eax
  281fbe:	e9 c3 00 00 00       	jmp    282086 <memman_free+0x24d>
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
  281fc3:	8b 45 08             	mov    0x8(%ebp),%eax
  281fc6:	8b 00                	mov    (%eax),%eax
  281fc8:	3d f9 0f 00 00       	cmp    $0xff9,%eax
  281fcd:	0f 8f 8a 00 00 00    	jg     28205d <memman_free+0x224>
	{
		for(j=man->frees-1;j>=i;j--)
  281fd3:	8b 45 08             	mov    0x8(%ebp),%eax
  281fd6:	8b 00                	mov    (%eax),%eax
  281fd8:	83 e8 01             	sub    $0x1,%eax
  281fdb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  281fde:	eb 28                	jmp    282008 <memman_free+0x1cf>
			man->free[j+1] = man->free[j];
  281fe0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  281fe3:	83 c0 01             	add    $0x1,%eax
  281fe6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281fe9:	8d 58 02             	lea    0x2(%eax),%ebx
  281fec:	8b 45 08             	mov    0x8(%ebp),%eax
  281fef:	8b 55 f4             	mov    -0xc(%ebp),%edx
  281ff2:	83 c2 02             	add    $0x2,%edx
  281ff5:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  281ff8:	8b 02                	mov    (%edx),%eax
  281ffa:	8b 52 04             	mov    0x4(%edx),%edx
  281ffd:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  282000:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
	{
		for(j=man->frees-1;j>=i;j--)
  282004:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  282008:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28200b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28200e:	7d d0                	jge    281fe0 <memman_free+0x1a7>
			man->free[j+1] = man->free[j];
		if(man->maxfrees < man->frees) man->maxfrees = man->frees;
  282010:	8b 45 08             	mov    0x8(%ebp),%eax
  282013:	8b 50 04             	mov    0x4(%eax),%edx
  282016:	8b 45 08             	mov    0x8(%ebp),%eax
  282019:	8b 00                	mov    (%eax),%eax
  28201b:	39 c2                	cmp    %eax,%edx
  28201d:	7d 0b                	jge    28202a <memman_free+0x1f1>
  28201f:	8b 45 08             	mov    0x8(%ebp),%eax
  282022:	8b 10                	mov    (%eax),%edx
  282024:	8b 45 08             	mov    0x8(%ebp),%eax
  282027:	89 50 04             	mov    %edx,0x4(%eax)
		man->free[i].addr = addr;
  28202a:	8b 45 08             	mov    0x8(%ebp),%eax
  28202d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282030:	8d 4a 02             	lea    0x2(%edx),%ecx
  282033:	8b 55 0c             	mov    0xc(%ebp),%edx
  282036:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size = size;
  282039:	8b 45 08             	mov    0x8(%ebp),%eax
  28203c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  28203f:	8d 4a 02             	lea    0x2(%edx),%ecx
  282042:	8b 55 10             	mov    0x10(%ebp),%edx
  282045:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
		man->frees++;
  282049:	8b 45 08             	mov    0x8(%ebp),%eax
  28204c:	8b 00                	mov    (%eax),%eax
  28204e:	8d 50 01             	lea    0x1(%eax),%edx
  282051:	8b 45 08             	mov    0x8(%ebp),%eax
  282054:	89 10                	mov    %edx,(%eax)
		return 0;
  282056:	b8 00 00 00 00       	mov    $0x0,%eax
  28205b:	eb 29                	jmp    282086 <memman_free+0x24d>
	}

	//no room for new free
	man->losts++;
  28205d:	8b 45 08             	mov    0x8(%ebp),%eax
  282060:	8b 40 0c             	mov    0xc(%eax),%eax
  282063:	8d 50 01             	lea    0x1(%eax),%edx
  282066:	8b 45 08             	mov    0x8(%ebp),%eax
  282069:	89 50 0c             	mov    %edx,0xc(%eax)
	man->lostsize += size;
  28206c:	8b 45 08             	mov    0x8(%ebp),%eax
  28206f:	8b 40 08             	mov    0x8(%eax),%eax
  282072:	89 c2                	mov    %eax,%edx
  282074:	8b 45 10             	mov    0x10(%ebp),%eax
  282077:	01 d0                	add    %edx,%eax
  282079:	89 c2                	mov    %eax,%edx
  28207b:	8b 45 08             	mov    0x8(%ebp),%eax
  28207e:	89 50 08             	mov    %edx,0x8(%eax)
	return -1;
  282081:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  282086:	83 c4 10             	add    $0x10,%esp
  282089:	5b                   	pop    %ebx
  28208a:	5d                   	pop    %ebp
  28208b:	c3                   	ret    

0028208c <memman_alloc_4k>:

unsigned int memman_alloc_4k(struct MEMMAN *man,unsigned int size)
{
  28208c:	55                   	push   %ebp
  28208d:	89 e5                	mov    %esp,%ebp
  28208f:	83 ec 10             	sub    $0x10,%esp
	unsigned int a;
	size = (size+0xfff) & 0xfffff000;
  282092:	8b 45 0c             	mov    0xc(%ebp),%eax
  282095:	05 ff 0f 00 00       	add    $0xfff,%eax
  28209a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  28209f:	89 45 0c             	mov    %eax,0xc(%ebp)
	a = memman_alloc(man,size);
  2820a2:	ff 75 0c             	pushl  0xc(%ebp)
  2820a5:	ff 75 08             	pushl  0x8(%ebp)
  2820a8:	e8 a3 fc ff ff       	call   281d50 <memman_alloc>
  2820ad:	83 c4 08             	add    $0x8,%esp
  2820b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return a;
  2820b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  2820b6:	c9                   	leave  
  2820b7:	c3                   	ret    

002820b8 <memman_free_4k>:

int memman_free_4k(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  2820b8:	55                   	push   %ebp
  2820b9:	89 e5                	mov    %esp,%ebp
  2820bb:	83 ec 10             	sub    $0x10,%esp
	int i;
	size = (size+0xfff) & 0xfffff000;
  2820be:	8b 45 10             	mov    0x10(%ebp),%eax
  2820c1:	05 ff 0f 00 00       	add    $0xfff,%eax
  2820c6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  2820cb:	89 45 10             	mov    %eax,0x10(%ebp)
	i = memman_free(man,addr,size);
  2820ce:	ff 75 10             	pushl  0x10(%ebp)
  2820d1:	ff 75 0c             	pushl  0xc(%ebp)
  2820d4:	ff 75 08             	pushl  0x8(%ebp)
  2820d7:	e8 5d fd ff ff       	call   281e39 <memman_free>
  2820dc:	83 c4 0c             	add    $0xc,%esp
  2820df:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return i;
  2820e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  2820e5:	c9                   	leave  
  2820e6:	c3                   	ret    

002820e7 <shtctl_init>:
#include "map_sheet.h"

struct SHTCTL* shtctl_init(struct MEMMAN *man,unsigned char *vram,int xsize,int ysize)
{
  2820e7:	55                   	push   %ebp
  2820e8:	89 e5                	mov    %esp,%ebp
  2820ea:	57                   	push   %edi
  2820eb:	56                   	push   %esi
  2820ec:	53                   	push   %ebx
  2820ed:	83 ec 14             	sub    $0x14,%esp
  2820f0:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct SHTCTL *ctl;
	int i;
	ctl = (struct SHTCTL *)memman_alloc_4k(man,sizeof(struct SHTCTL));
  2820f3:	68 14 28 00 00       	push   $0x2814
  2820f8:	57                   	push   %edi
  2820f9:	e8 8e ff ff ff       	call   28208c <memman_alloc_4k>
  2820fe:	89 c6                	mov    %eax,%esi
	if(ctl == 0)
  282100:	83 c4 10             	add    $0x10,%esp
  282103:	85 c0                	test   %eax,%eax
  282105:	74 6a                	je     282171 <shtctl_init+0x8a>
  282107:	89 c3                	mov    %eax,%ebx
		goto err;
	ctl->vram = vram;
  282109:	8b 45 0c             	mov    0xc(%ebp),%eax
  28210c:	89 06                	mov    %eax,(%esi)
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
  28210e:	83 ec 08             	sub    $0x8,%esp
  282111:	8b 45 10             	mov    0x10(%ebp),%eax
  282114:	0f af 45 14          	imul   0x14(%ebp),%eax
  282118:	50                   	push   %eax
  282119:	57                   	push   %edi
  28211a:	e8 6d ff ff ff       	call   28208c <memman_alloc_4k>
  28211f:	89 46 04             	mov    %eax,0x4(%esi)
	if(ctl->map == 0)
  282122:	83 c4 10             	add    $0x10,%esp
  282125:	85 c0                	test   %eax,%eax
  282127:	75 19                	jne    282142 <shtctl_init+0x5b>
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
  282129:	83 ec 04             	sub    $0x4,%esp
  28212c:	68 14 28 00 00       	push   $0x2814
  282131:	56                   	push   %esi
  282132:	57                   	push   %edi
  282133:	e8 80 ff ff ff       	call   2820b8 <memman_free_4k>
		ctl = 0;
		goto err;
  282138:	83 c4 10             	add    $0x10,%esp
	ctl->vram = vram;
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
	if(ctl->map == 0)
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
		ctl = 0;
  28213b:	be 00 00 00 00       	mov    $0x0,%esi
		goto err;
  282140:	eb 2f                	jmp    282171 <shtctl_init+0x8a>
	}
	ctl->xsize= xsize;
  282142:	8b 45 10             	mov    0x10(%ebp),%eax
  282145:	89 46 08             	mov    %eax,0x8(%esi)
	ctl->ysize= ysize;
  282148:	8b 45 14             	mov    0x14(%ebp),%eax
  28214b:	89 46 0c             	mov    %eax,0xc(%esi)
	ctl->top = -1;
  28214e:	c7 46 10 ff ff ff ff 	movl   $0xffffffff,0x10(%esi)
  282155:	8d 86 30 04 00 00    	lea    0x430(%esi),%eax
  28215b:	81 c3 30 28 00 00    	add    $0x2830,%ebx
	for(i=0;i<MAX_SHEETS;i++)
	{
		ctl->sheets0[i].flags = 0;
  282161:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ctl->sheets0[i].ctl = ctl;
  282167:	89 70 04             	mov    %esi,0x4(%eax)
  28216a:	83 c0 24             	add    $0x24,%eax
		goto err;
	}
	ctl->xsize= xsize;
	ctl->ysize= ysize;
	ctl->top = -1;
	for(i=0;i<MAX_SHEETS;i++)
  28216d:	39 d8                	cmp    %ebx,%eax
  28216f:	75 f0                	jne    282161 <shtctl_init+0x7a>
		ctl->sheets0[i].flags = 0;
		ctl->sheets0[i].ctl = ctl;
	}
	err:
		return ctl;
}
  282171:	89 f0                	mov    %esi,%eax
  282173:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282176:	5b                   	pop    %ebx
  282177:	5e                   	pop    %esi
  282178:	5f                   	pop    %edi
  282179:	5d                   	pop    %ebp
  28217a:	c3                   	ret    

0028217b <sheet_alloc>:

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
  28217b:	55                   	push   %ebp
  28217c:	89 e5                	mov    %esp,%ebp
  28217e:	56                   	push   %esi
  28217f:	53                   	push   %ebx
  282180:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
	{
		if(ctl->sheets0[i].flags == 0)
  282183:	83 b9 30 04 00 00 00 	cmpl   $0x0,0x430(%ecx)
  28218a:	74 12                	je     28219e <sheet_alloc+0x23>
  28218c:	8d 91 54 04 00 00    	lea    0x454(%ecx),%edx

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  282192:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(ctl->sheets0[i].flags == 0)
  282197:	83 3a 00             	cmpl   $0x0,(%edx)
  28219a:	75 30                	jne    2821cc <sheet_alloc+0x51>
  28219c:	eb 05                	jmp    2821a3 <sheet_alloc+0x28>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  28219e:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(ctl->sheets0[i].flags == 0)
		{
			sht = &ctl->sheets0[i];
  2821a3:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  2821aa:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
			sht->flags = SHEET_USE;
  2821ad:	c7 84 99 30 04 00 00 	movl   $0x1,0x430(%ecx,%ebx,4)
  2821b4:	01 00 00 00 
			sht->height = -1;
  2821b8:	c7 84 99 2c 04 00 00 	movl   $0xffffffff,0x42c(%ecx,%ebx,4)
  2821bf:	ff ff ff ff 
			return sht;
  2821c3:	8d 84 99 14 04 00 00 	lea    0x414(%ecx,%ebx,4),%eax
  2821ca:	eb 12                	jmp    2821de <sheet_alloc+0x63>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  2821cc:	83 c0 01             	add    $0x1,%eax
  2821cf:	83 c2 24             	add    $0x24,%edx
  2821d2:	3d 00 01 00 00       	cmp    $0x100,%eax
  2821d7:	75 be                	jne    282197 <sheet_alloc+0x1c>
			sht->flags = SHEET_USE;
			sht->height = -1;
			return sht;
		}
	}
	return 0;
  2821d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2821de:	5b                   	pop    %ebx
  2821df:	5e                   	pop    %esi
  2821e0:	5d                   	pop    %ebp
  2821e1:	c3                   	ret    

002821e2 <sheet_setbuf>:

void sheet_setbuf(struct SHEET *sht,unsigned char *buf,int xsize,int ysize,int col_inv)
{
  2821e2:	55                   	push   %ebp
  2821e3:	89 e5                	mov    %esp,%ebp
  2821e5:	8b 45 08             	mov    0x8(%ebp),%eax
	sht->buf = buf;
  2821e8:	8b 55 0c             	mov    0xc(%ebp),%edx
  2821eb:	89 10                	mov    %edx,(%eax)
	sht->bxsize = xsize;
  2821ed:	8b 55 10             	mov    0x10(%ebp),%edx
  2821f0:	89 50 04             	mov    %edx,0x4(%eax)
	sht->bysize = ysize;
  2821f3:	8b 55 14             	mov    0x14(%ebp),%edx
  2821f6:	89 50 08             	mov    %edx,0x8(%eax)
	sht->col_inv = col_inv;
  2821f9:	8b 55 18             	mov    0x18(%ebp),%edx
  2821fc:	89 50 14             	mov    %edx,0x14(%eax)
	return;
}
  2821ff:	5d                   	pop    %ebp
  282200:	c3                   	ret    

00282201 <sheet_refresh_ob>:
}

//not good refresh
//obsolete
void sheet_refresh_ob(struct SHTCTL *ctl)
{
  282201:	55                   	push   %ebp
  282202:	89 e5                	mov    %esp,%ebp
  282204:	57                   	push   %edi
  282205:	56                   	push   %esi
  282206:	53                   	push   %ebx
  282207:	83 ec 10             	sub    $0x10,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
  28220a:	8b 45 08             	mov    0x8(%ebp),%eax
  28220d:	8b 00                	mov    (%eax),%eax
  28220f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282212:	8b 45 08             	mov    0x8(%ebp),%eax
  282215:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  282219:	0f 88 80 00 00 00    	js     28229f <sheet_refresh_ob+0x9e>
  28221f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	{
		sht = ctl->sheets[h];
  282226:	8b 45 08             	mov    0x8(%ebp),%eax
  282229:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  28222c:	8b 54 b8 14          	mov    0x14(%eax,%edi,4),%edx
		buf = sht->buf;
  282230:	8b 02                	mov    (%edx),%eax
  282232:	89 45 f0             	mov    %eax,-0x10(%ebp)
		for(by=0;by<sht->bysize;by++)
  282235:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  282239:	7e 55                	jle    282290 <sheet_refresh_ob+0x8f>
  28223b:	bf 00 00 00 00       	mov    $0x0,%edi
		{
			vy = sht->vy0+by;
  282240:	89 f8                	mov    %edi,%eax
  282242:	03 42 10             	add    0x10(%edx),%eax
  282245:	89 45 ec             	mov    %eax,-0x14(%ebp)
			for(bx=0;bx<sht->bxsize;bx++)
  282248:	8b 4a 04             	mov    0x4(%edx),%ecx
  28224b:	85 c9                	test   %ecx,%ecx
  28224d:	7e 39                	jle    282288 <sheet_refresh_ob+0x87>
  28224f:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				vx = sht->vx0+bx;
				c=buf[by*sht->bxsize+bx];
  282254:	0f af cf             	imul   %edi,%ecx
  282257:	8b 75 f0             	mov    -0x10(%ebp),%esi
  28225a:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  28225d:	0f b6 1c 0b          	movzbl (%ebx,%ecx,1),%ebx
				if(c!=sht->col_inv)
  282261:	0f b6 cb             	movzbl %bl,%ecx
  282264:	3b 4a 14             	cmp    0x14(%edx),%ecx
  282267:	74 15                	je     28227e <sheet_refresh_ob+0x7d>
					vram[vy*ctl->xsize+vx] = c;
  282269:	8b 4d 08             	mov    0x8(%ebp),%ecx
  28226c:	8b 75 ec             	mov    -0x14(%ebp),%esi
  28226f:	0f af 71 08          	imul   0x8(%ecx),%esi
  282273:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  282276:	01 c1                	add    %eax,%ecx
  282278:	03 4a 0c             	add    0xc(%edx),%ecx
  28227b:	88 1c 31             	mov    %bl,(%ecx,%esi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0+by;
			for(bx=0;bx<sht->bxsize;bx++)
  28227e:	83 c0 01             	add    $0x1,%eax
  282281:	8b 4a 04             	mov    0x4(%edx),%ecx
  282284:	39 c1                	cmp    %eax,%ecx
  282286:	7f cc                	jg     282254 <sheet_refresh_ob+0x53>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  282288:	83 c7 01             	add    $0x1,%edi
  28228b:	39 7a 08             	cmp    %edi,0x8(%edx)
  28228e:	7f b0                	jg     282240 <sheet_refresh_ob+0x3f>
void sheet_refresh_ob(struct SHTCTL *ctl)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282290:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  282294:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  282297:	8b 7d 08             	mov    0x8(%ebp),%edi
  28229a:	39 47 10             	cmp    %eax,0x10(%edi)
  28229d:	7d 87                	jge    282226 <sheet_refresh_ob+0x25>
					vram[vy*ctl->xsize+vx] = c;
			}
		}
	}
	return;
}
  28229f:	83 c4 10             	add    $0x10,%esp
  2822a2:	5b                   	pop    %ebx
  2822a3:	5e                   	pop    %esi
  2822a4:	5f                   	pop    %edi
  2822a5:	5d                   	pop    %ebp
  2822a6:	c3                   	ret    

002822a7 <sheet_refreshsub1>:



void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
  2822a7:	55                   	push   %ebp
  2822a8:	89 e5                	mov    %esp,%ebp
  2822aa:	57                   	push   %edi
  2822ab:	56                   	push   %esi
  2822ac:	53                   	push   %ebx
  2822ad:	83 ec 14             	sub    $0x14,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
  2822b0:	8b 45 08             	mov    0x8(%ebp),%eax
  2822b3:	8b 00                	mov    (%eax),%eax
  2822b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  2822b8:	8b 45 08             	mov    0x8(%ebp),%eax
  2822bb:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  2822bf:	0f 88 a7 00 00 00    	js     28236c <sheet_refreshsub1+0xc5>
  2822c5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	{
		sht = ctl->sheets[h];
  2822cc:	8b 45 08             	mov    0x8(%ebp),%eax
  2822cf:	8b 7d e0             	mov    -0x20(%ebp),%edi
  2822d2:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  2822d6:	8b 01                	mov    (%ecx),%eax
  2822d8:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(by=0;by<sht->bysize;by++)
  2822db:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  2822df:	7e 78                	jle    282359 <sheet_refreshsub1+0xb2>
  2822e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		{
			vy = sht->vy0 + by;
  2822e8:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  2822eb:	03 59 10             	add    0x10(%ecx),%ebx
			for(bx=0;bx<sht->bxsize;bx++)
  2822ee:	8b 71 04             	mov    0x4(%ecx),%esi
  2822f1:	85 f6                	test   %esi,%esi
  2822f3:	7e 58                	jle    28234d <sheet_refreshsub1+0xa6>
  2822f5:	b8 00 00 00 00       	mov    $0x0,%eax
  2822fa:	89 5d f0             	mov    %ebx,-0x10(%ebp)
			{
				vx = sht->vx0 + bx;
  2822fd:	89 c2                	mov    %eax,%edx
  2822ff:	03 51 0c             	add    0xc(%ecx),%edx
				if(vx0<=vx && vx<vx1 && vy0<=vy && vy<vy1)
  282302:	3b 55 0c             	cmp    0xc(%ebp),%edx
  282305:	7c 3c                	jl     282343 <sheet_refreshsub1+0x9c>
  282307:	3b 55 14             	cmp    0x14(%ebp),%edx
  28230a:	7d 37                	jge    282343 <sheet_refreshsub1+0x9c>
  28230c:	8b 7d f0             	mov    -0x10(%ebp),%edi
  28230f:	3b 7d 10             	cmp    0x10(%ebp),%edi
  282312:	7c 2f                	jl     282343 <sheet_refreshsub1+0x9c>
  282314:	3b 7d 18             	cmp    0x18(%ebp),%edi
  282317:	7d 2a                	jge    282343 <sheet_refreshsub1+0x9c>
				{
					c = buf[by*sht->bxsize+bx];
  282319:	0f af 75 ec          	imul   -0x14(%ebp),%esi
  28231d:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  282320:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
  282323:	0f b6 34 37          	movzbl (%edi,%esi,1),%esi
					if(c!=sht->col_inv)
  282327:	89 f3                	mov    %esi,%ebx
  282329:	0f b6 fb             	movzbl %bl,%edi
  28232c:	3b 79 14             	cmp    0x14(%ecx),%edi
  28232f:	74 12                	je     282343 <sheet_refreshsub1+0x9c>
						vram[vy*ctl->xsize+vx] = c;
  282331:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282334:	8b 7d f0             	mov    -0x10(%ebp),%edi
  282337:	0f af 7b 08          	imul   0x8(%ebx),%edi
  28233b:	03 55 e4             	add    -0x1c(%ebp),%edx
  28233e:	89 f3                	mov    %esi,%ebx
  282340:	88 1c 3a             	mov    %bl,(%edx,%edi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0 + by;
			for(bx=0;bx<sht->bxsize;bx++)
  282343:	83 c0 01             	add    $0x1,%eax
  282346:	8b 71 04             	mov    0x4(%ecx),%esi
  282349:	39 c6                	cmp    %eax,%esi
  28234b:	7f b0                	jg     2822fd <sheet_refreshsub1+0x56>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  28234d:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  282351:	8b 45 ec             	mov    -0x14(%ebp),%eax
  282354:	39 41 08             	cmp    %eax,0x8(%ecx)
  282357:	7f 8f                	jg     2822e8 <sheet_refreshsub1+0x41>
void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282359:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  28235d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  282360:	8b 7d 08             	mov    0x8(%ebp),%edi
  282363:	39 47 10             	cmp    %eax,0x10(%edi)
  282366:	0f 8d 60 ff ff ff    	jge    2822cc <sheet_refreshsub1+0x25>
						vram[vy*ctl->xsize+vx] = c;
				}
			}
		}
	}
}
  28236c:	83 c4 14             	add    $0x14,%esp
  28236f:	5b                   	pop    %ebx
  282370:	5e                   	pop    %esi
  282371:	5f                   	pop    %edi
  282372:	5d                   	pop    %ebp
  282373:	c3                   	ret    

00282374 <sheet_refreshsub2>:

void sheet_refreshsub2(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1,int h0)
{
  282374:	55                   	push   %ebp
  282375:	89 e5                	mov    %esp,%ebp
  282377:	57                   	push   %edi
  282378:	56                   	push   %esi
  282379:	53                   	push   %ebx
  28237a:	83 ec 30             	sub    $0x30,%esp
  28237d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  282380:	8b 55 10             	mov    0x10(%ebp),%edx
  282383:	8b 75 14             	mov    0x14(%ebp),%esi
  282386:	8b 7d 18             	mov    0x18(%ebp),%edi
  282389:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	int h,bx,by,vx,vy,bx0,by0,bx1,by1;
	unsigned char *buf,c,*vram = ctl->vram,*map = ctl->map;
  28238c:	8b 45 08             	mov    0x8(%ebp),%eax
  28238f:	8b 00                	mov    (%eax),%eax
  282391:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  282394:	8b 45 08             	mov    0x8(%ebp),%eax
  282397:	8b 40 04             	mov    0x4(%eax),%eax
  28239a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  28239d:	b8 00 00 00 00       	mov    $0x0,%eax
  2823a2:	85 c9                	test   %ecx,%ecx
  2823a4:	0f 48 c8             	cmovs  %eax,%ecx
  2823a7:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  2823aa:	85 d2                	test   %edx,%edx
  2823ac:	0f 48 d0             	cmovs  %eax,%edx
  2823af:	89 55 d0             	mov    %edx,-0x30(%ebp)
	struct SHEET *sht;
	
	//limit the refresh rect in the visible rect.
	if(vx0<0) vx0 = 0;
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
  2823b2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2823b5:	8b 51 08             	mov    0x8(%ecx),%edx
  2823b8:	39 f2                	cmp    %esi,%edx
  2823ba:	0f 4e f2             	cmovle %edx,%esi
  2823bd:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
  2823c0:	8b 51 0c             	mov    0xc(%ecx),%edx
  2823c3:	39 fa                	cmp    %edi,%edx
  2823c5:	0f 4e fa             	cmovle %edx,%edi
  2823c8:	89 7d cc             	mov    %edi,-0x34(%ebp)
  2823cb:	85 db                	test   %ebx,%ebx
  2823cd:	0f 49 c3             	cmovns %ebx,%eax
  2823d0:	89 45 d8             	mov    %eax,-0x28(%ebp)
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  2823d3:	39 41 10             	cmp    %eax,0x10(%ecx)
  2823d6:	0f 8c b3 00 00 00    	jl     28248f <sheet_refreshsub2+0x11b>
	{
		//calculate the need-refresh rect of each sheet.
		sht = ctl->sheets[h];
  2823dc:	8b 45 08             	mov    0x8(%ebp),%eax
  2823df:	8b 7d d8             	mov    -0x28(%ebp),%edi
  2823e2:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  2823e6:	8b 01                	mov    (%ecx),%eax
  2823e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		bx0 = vx0 - sht->vx0;
  2823eb:	8b 41 0c             	mov    0xc(%ecx),%eax
		by0 = vy0 - sht->vy0;
  2823ee:	8b 71 10             	mov    0x10(%ecx),%esi
		bx1 = vx1 - sht->vx0;
  2823f1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  2823f4:	29 c2                	sub    %eax,%edx
		by1 = vy1 - sht->vy0;
  2823f6:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  2823f9:	29 f3                	sub    %esi,%ebx
  2823fb:	8b 7d c8             	mov    -0x38(%ebp),%edi
  2823fe:	29 c7                	sub    %eax,%edi
  282400:	89 f8                	mov    %edi,%eax
  282402:	bf 00 00 00 00       	mov    $0x0,%edi
  282407:	0f 48 c7             	cmovs  %edi,%eax
  28240a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  28240d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  282410:	29 f0                	sub    %esi,%eax
  282412:	0f 49 f8             	cmovns %eax,%edi

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
  282415:	8b 41 04             	mov    0x4(%ecx),%eax
  282418:	39 c2                	cmp    %eax,%edx
  28241a:	0f 4e c2             	cmovle %edx,%eax
  28241d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(by1>sht->bysize) by1=sht->bysize;
  282420:	8b 41 08             	mov    0x8(%ecx),%eax
  282423:	39 c3                	cmp    %eax,%ebx
  282425:	0f 4e c3             	cmovle %ebx,%eax
  282428:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for(by=by0;by<by1;by++)
  28242b:	39 f8                	cmp    %edi,%eax
  28242d:	7e 4d                	jle    28247c <sheet_refreshsub2+0x108>
		{
			vy = sht->vy0+by;
  28242f:	89 f8                	mov    %edi,%eax
  282431:	03 41 10             	add    0x10(%ecx),%eax
  282434:	89 45 e8             	mov    %eax,-0x18(%ebp)
			for(bx=bx0;bx<bx1;bx++)
  282437:	8b 45 dc             	mov    -0x24(%ebp),%eax
  28243a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  28243d:	7e 35                	jle    282474 <sheet_refreshsub2+0x100>
			{
				vx = sht->vx0+bx;
				c  = buf[by*sht->bxsize+bx];
  28243f:	89 fa                	mov    %edi,%edx
  282441:	0f af 51 04          	imul   0x4(%ecx),%edx
  282445:	8b 75 ec             	mov    -0x14(%ebp),%esi
  282448:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  28244b:	0f b6 1c 13          	movzbl (%ebx,%edx,1),%ebx
				if(c!=sht->col_inv)
  28244f:	0f b6 d3             	movzbl %bl,%edx
  282452:	3b 51 14             	cmp    0x14(%ecx),%edx
  282455:	74 15                	je     28246c <sheet_refreshsub2+0xf8>
					map[vy*ctl->xsize+vx] = c;
  282457:	8b 55 08             	mov    0x8(%ebp),%edx
  28245a:	8b 75 e8             	mov    -0x18(%ebp),%esi
  28245d:	0f af 72 08          	imul   0x8(%edx),%esi
  282461:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  282464:	01 c2                	add    %eax,%edx
  282466:	03 51 0c             	add    0xc(%ecx),%edx
  282469:	88 1c 32             	mov    %bl,(%edx,%esi,1)
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
		{
			vy = sht->vy0+by;
			for(bx=bx0;bx<bx1;bx++)
  28246c:	83 c0 01             	add    $0x1,%eax
  28246f:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  282472:	75 cb                	jne    28243f <sheet_refreshsub2+0xcb>

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
  282474:	83 c7 01             	add    $0x1,%edi
  282477:	39 7d e0             	cmp    %edi,-0x20(%ebp)
  28247a:	75 b3                	jne    28242f <sheet_refreshsub2+0xbb>
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  28247c:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  282480:	8b 45 d8             	mov    -0x28(%ebp),%eax
  282483:	8b 7d 08             	mov    0x8(%ebp),%edi
  282486:	39 47 10             	cmp    %eax,0x10(%edi)
  282489:	0f 8d 4d ff ff ff    	jge    2823dc <sheet_refreshsub2+0x68>
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  28248f:	8b 7d d0             	mov    -0x30(%ebp),%edi
  282492:	39 7d cc             	cmp    %edi,-0x34(%ebp)
  282495:	7f 2a                	jg     2824c1 <sheet_refreshsub2+0x14d>
  282497:	eb 40                	jmp    2824d9 <sheet_refreshsub2+0x165>
  282499:	89 4d f0             	mov    %ecx,-0x10(%ebp)
		for(vx=vx0;vx<vx1;vx++)
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
  28249c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28249f:	0f af 47 08          	imul   0x8(%edi),%eax
  2824a3:	01 d0                	add    %edx,%eax
  2824a5:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  2824a9:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
		for(vx=vx0;vx<vx1;vx++)
  2824ac:	83 c2 01             	add    $0x1,%edx
  2824af:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
  2824b2:	75 e8                	jne    28249c <sheet_refreshsub2+0x128>
  2824b4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  2824b7:	83 c1 01             	add    $0x1,%ecx
  2824ba:	3b 4d cc             	cmp    -0x34(%ebp),%ecx
  2824bd:	74 1a                	je     2824d9 <sheet_refreshsub2+0x165>
  2824bf:	eb 0c                	jmp    2824cd <sheet_refreshsub2+0x159>
  2824c1:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  2824c4:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  2824c7:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  2824ca:	8b 7d 08             	mov    0x8(%ebp),%edi
		for(vx=vx0;vx<vx1;vx++)
  2824cd:	8b 45 c8             	mov    -0x38(%ebp),%eax
  2824d0:	89 c2                	mov    %eax,%edx
  2824d2:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  2824d5:	7f c2                	jg     282499 <sheet_refreshsub2+0x125>
  2824d7:	eb de                	jmp    2824b7 <sheet_refreshsub2+0x143>
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
}
  2824d9:	83 c4 30             	add    $0x30,%esp
  2824dc:	5b                   	pop    %ebx
  2824dd:	5e                   	pop    %esi
  2824de:	5f                   	pop    %edi
  2824df:	5d                   	pop    %ebp
  2824e0:	c3                   	ret    

002824e1 <sheet_refresh>:

void sheet_refresh(struct SHEET *sht,int bx0,int by0,int bx1,int by1)
{
  2824e1:	55                   	push   %ebp
  2824e2:	89 e5                	mov    %esp,%ebp
  2824e4:	53                   	push   %ebx
  2824e5:	8b 45 08             	mov    0x8(%ebp),%eax
	if(sht->height >= 0)
  2824e8:	8b 58 18             	mov    0x18(%eax),%ebx
  2824eb:	85 db                	test   %ebx,%ebx
  2824ed:	78 26                	js     282515 <sheet_refresh+0x34>
	{
		struct SHTCTL *ctl = sht->ctl;
		sheet_refreshsub2(ctl,sht->vx0+bx0,sht->vy0+by0,sht->vx0+bx1,sht->vy0+by1,sht->height);
  2824ef:	8b 48 10             	mov    0x10(%eax),%ecx
  2824f2:	8b 50 0c             	mov    0xc(%eax),%edx
  2824f5:	53                   	push   %ebx
  2824f6:	89 cb                	mov    %ecx,%ebx
  2824f8:	03 5d 18             	add    0x18(%ebp),%ebx
  2824fb:	53                   	push   %ebx
  2824fc:	89 d3                	mov    %edx,%ebx
  2824fe:	03 5d 14             	add    0x14(%ebp),%ebx
  282501:	53                   	push   %ebx
  282502:	03 4d 10             	add    0x10(%ebp),%ecx
  282505:	51                   	push   %ecx
  282506:	03 55 0c             	add    0xc(%ebp),%edx
  282509:	52                   	push   %edx
  28250a:	ff 70 20             	pushl  0x20(%eax)
  28250d:	e8 62 fe ff ff       	call   282374 <sheet_refreshsub2>
  282512:	83 c4 18             	add    $0x18,%esp
	}
	return;
}
  282515:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  282518:	c9                   	leave  
  282519:	c3                   	ret    

0028251a <sheet_updown>:
	return;
}

//update the sheet with new height
void sheet_updown(struct SHEET *sht,int height)
{
  28251a:	55                   	push   %ebp
  28251b:	89 e5                	mov    %esp,%ebp
  28251d:	57                   	push   %edi
  28251e:	56                   	push   %esi
  28251f:	53                   	push   %ebx
  282520:	8b 75 08             	mov    0x8(%ebp),%esi
  282523:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct SHTCTL *ctl = sht->ctl;
  282526:	8b 4e 20             	mov    0x20(%esi),%ecx
	int h,old = sht->height;
  282529:	8b 46 18             	mov    0x18(%esi),%eax
	if(height>ctl->top+1) height = ctl->top + 1;
  28252c:	8b 79 10             	mov    0x10(%ecx),%edi
  28252f:	8d 57 01             	lea    0x1(%edi),%edx
  282532:	39 da                	cmp    %ebx,%edx
  282534:	0f 4f d3             	cmovg  %ebx,%edx
  282537:	85 d2                	test   %edx,%edx
  282539:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  28253e:	0f 49 da             	cmovns %edx,%ebx
	if(height<-1) height = -1;
	sht->height = height;
  282541:	89 5e 18             	mov    %ebx,0x18(%esi)

	//push down the sheet
	if(old>height)
  282544:	39 d8                	cmp    %ebx,%eax
  282546:	7e 59                	jle    2825a1 <sheet_updown+0x87>
	{
		//if the sheet still shows
		if(height >=0 )
  282548:	85 db                	test   %ebx,%ebx
  28254a:	79 09                	jns    282555 <sheet_updown+0x3b>
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  28254c:	8b 59 10             	mov    0x10(%ecx),%ebx
  28254f:	39 d8                	cmp    %ebx,%eax
  282551:	7c 1c                	jl     28256f <sheet_updown+0x55>
  282553:	eb 31                	jmp    282586 <sheet_updown+0x6c>
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  282555:	8d 50 ff             	lea    -0x1(%eax),%edx
  282558:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  28255c:	89 7c 91 18          	mov    %edi,0x18(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282560:	89 47 18             	mov    %eax,0x18(%edi)
	if(old>height)
	{
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
  282563:	89 d0                	mov    %edx,%eax
  282565:	39 d3                	cmp    %edx,%ebx
  282567:	75 ec                	jne    282555 <sheet_updown+0x3b>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;	
  282569:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  28256d:	eb 1d                	jmp    28258c <sheet_updown+0x72>
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  28256f:	8d 50 01             	lea    0x1(%eax),%edx
  282572:	8b 5c 91 14          	mov    0x14(%ecx,%edx,4),%ebx
  282576:	89 5c 91 10          	mov    %ebx,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  28257a:	89 43 18             	mov    %eax,0x18(%ebx)
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  28257d:	8b 59 10             	mov    0x10(%ecx),%ebx
  282580:	89 d0                	mov    %edx,%eax
  282582:	39 d3                	cmp    %edx,%ebx
  282584:	7f e9                	jg     28256f <sheet_updown+0x55>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->top--;
  282586:	83 eb 01             	sub    $0x1,%ebx
  282589:	89 59 10             	mov    %ebx,0x10(%ecx)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  28258c:	ff 76 08             	pushl  0x8(%esi)
  28258f:	ff 76 04             	pushl  0x4(%esi)
  282592:	6a 00                	push   $0x0
  282594:	6a 00                	push   $0x0
  282596:	56                   	push   %esi
  282597:	e8 45 ff ff ff       	call   2824e1 <sheet_refresh>
  28259c:	83 c4 14             	add    $0x14,%esp
  28259f:	eb 5a                	jmp    2825fb <sheet_updown+0xe1>
	}
	else if(old<height) //pop up the sheet
  2825a1:	39 d8                	cmp    %ebx,%eax
  2825a3:	7d 56                	jge    2825fb <sheet_updown+0xe1>
	{
		if(old >= 0) //the sheet still shows.
  2825a5:	85 c0                	test   %eax,%eax
  2825a7:	78 1a                	js     2825c3 <sheet_updown+0xa9>
		{
			for(h=old;h<height;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  2825a9:	8d 50 01             	lea    0x1(%eax),%edx
  2825ac:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  2825b0:	89 7c 91 10          	mov    %edi,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  2825b4:	89 47 18             	mov    %eax,0x18(%edi)
	}
	else if(old<height) //pop up the sheet
	{
		if(old >= 0) //the sheet still shows.
		{
			for(h=old;h<height;h++)
  2825b7:	89 d0                	mov    %edx,%eax
  2825b9:	39 d3                	cmp    %edx,%ebx
  2825bb:	75 ec                	jne    2825a9 <sheet_updown+0x8f>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  2825bd:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  2825c1:	eb 25                	jmp    2825e8 <sheet_updown+0xce>
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
  2825c3:	8b 41 10             	mov    0x10(%ecx),%eax
  2825c6:	8d 50 01             	lea    0x1(%eax),%edx
  2825c9:	89 51 10             	mov    %edx,0x10(%ecx)
			for(h=ctl->top;h>height;h--)
  2825cc:	39 d3                	cmp    %edx,%ebx
  2825ce:	7d 14                	jge    2825e4 <sheet_updown+0xca>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  2825d0:	8d 42 ff             	lea    -0x1(%edx),%eax
  2825d3:	8b 7c 81 14          	mov    0x14(%ecx,%eax,4),%edi
  2825d7:	89 7c 81 18          	mov    %edi,0x18(%ecx,%eax,4)
				ctl->sheets[h]->height = h;
  2825db:	89 57 18             	mov    %edx,0x18(%edi)
			ctl->sheets[height] = sht;
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
			for(h=ctl->top;h>height;h--)
  2825de:	89 c2                	mov    %eax,%edx
  2825e0:	39 c3                	cmp    %eax,%ebx
  2825e2:	75 ec                	jne    2825d0 <sheet_updown+0xb6>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  2825e4:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  2825e8:	ff 76 08             	pushl  0x8(%esi)
  2825eb:	ff 76 04             	pushl  0x4(%esi)
  2825ee:	6a 00                	push   $0x0
  2825f0:	6a 00                	push   $0x0
  2825f2:	56                   	push   %esi
  2825f3:	e8 e9 fe ff ff       	call   2824e1 <sheet_refresh>
  2825f8:	83 c4 14             	add    $0x14,%esp
	}
	//else height not change.
	return;
}
  2825fb:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2825fe:	5b                   	pop    %ebx
  2825ff:	5e                   	pop    %esi
  282600:	5f                   	pop    %edi
  282601:	5d                   	pop    %ebp
  282602:	c3                   	ret    

00282603 <sheet_slide>:
	}
	return;
}

void sheet_slide(struct SHEET *sht,int vx0,int vy0)
{
  282603:	55                   	push   %ebp
  282604:	89 e5                	mov    %esp,%ebp
  282606:	57                   	push   %edi
  282607:	56                   	push   %esi
  282608:	53                   	push   %ebx
  282609:	8b 5d 08             	mov    0x8(%ebp),%ebx
  28260c:	8b 75 10             	mov    0x10(%ebp),%esi
	//(vx0,vy0): the sheet buf in the vram pos.
	int old_vx0 = sht->vx0,old_vy0 = sht->vy0;
  28260f:	8b 43 0c             	mov    0xc(%ebx),%eax
  282612:	8b 53 10             	mov    0x10(%ebx),%edx
	sht->vx0 = vx0;
  282615:	8b 7d 0c             	mov    0xc(%ebp),%edi
  282618:	89 7b 0c             	mov    %edi,0xc(%ebx)
	sht->vy0 = vy0;
  28261b:	89 73 10             	mov    %esi,0x10(%ebx)
	if(sht->height >= 0)
  28261e:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  282622:	78 36                	js     28265a <sheet_slide+0x57>
	{
		struct SHTCTL *ctl = sht->ctl;
  282624:	8b 7b 20             	mov    0x20(%ebx),%edi
		sheet_refreshsub2(ctl,old_vx0,old_vy0,old_vx0+sht->bxsize,old_vy0+sht->bysize, 0);
  282627:	6a 00                	push   $0x0
  282629:	89 d1                	mov    %edx,%ecx
  28262b:	03 4b 08             	add    0x8(%ebx),%ecx
  28262e:	51                   	push   %ecx
  28262f:	89 c1                	mov    %eax,%ecx
  282631:	03 4b 04             	add    0x4(%ebx),%ecx
  282634:	51                   	push   %ecx
  282635:	52                   	push   %edx
  282636:	50                   	push   %eax
  282637:	57                   	push   %edi
  282638:	e8 37 fd ff ff       	call   282374 <sheet_refreshsub2>
		sheet_refreshsub2(ctl,vx0,vy0,vx0+sht->bxsize,vy0+sht->bysize,sht->height);
  28263d:	ff 73 18             	pushl  0x18(%ebx)
  282640:	89 f0                	mov    %esi,%eax
  282642:	03 43 08             	add    0x8(%ebx),%eax
  282645:	50                   	push   %eax
  282646:	8b 45 0c             	mov    0xc(%ebp),%eax
  282649:	03 43 04             	add    0x4(%ebx),%eax
  28264c:	50                   	push   %eax
  28264d:	56                   	push   %esi
  28264e:	ff 75 0c             	pushl  0xc(%ebp)
  282651:	57                   	push   %edi
  282652:	e8 1d fd ff ff       	call   282374 <sheet_refreshsub2>
  282657:	83 c4 30             	add    $0x30,%esp
	}
	return;
}
  28265a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28265d:	5b                   	pop    %ebx
  28265e:	5e                   	pop    %esi
  28265f:	5f                   	pop    %edi
  282660:	5d                   	pop    %ebp
  282661:	c3                   	ret    

00282662 <sheet_free>:

void sheet_free(struct SHEET *sht)
{
  282662:	55                   	push   %ebp
  282663:	89 e5                	mov    %esp,%ebp
  282665:	53                   	push   %ebx
  282666:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(sht->height >= 0)
  282669:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  28266d:	78 0b                	js     28267a <sheet_free+0x18>
	{
		sheet_updown(sht,-1); //hide the sheet
  28266f:	6a ff                	push   $0xffffffff
  282671:	53                   	push   %ebx
  282672:	e8 a3 fe ff ff       	call   28251a <sheet_updown>
  282677:	83 c4 08             	add    $0x8,%esp
	}
	sht->flags = 0; //set sheet unused.
  28267a:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	return;
}
  282681:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  282684:	c9                   	leave  
  282685:	c3                   	ret    

00282686 <timer_alloc>:
	timerctl.next = 0xffffffff;
	return;
}

struct TIMER *timer_alloc(void)
{
  282686:	55                   	push   %ebp
  282687:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TIMER;i++)
	{
		if(timerctl.timers0[i].flags == 0)
  282689:	83 3d d0 64 28 00 00 	cmpl   $0x0,0x2864d0
  282690:	74 11                	je     2826a3 <timer_alloc+0x1d>
  282692:	ba e4 64 28 00       	mov    $0x2864e4,%edx
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282697:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(timerctl.timers0[i].flags == 0)
  28269c:	83 3a 00             	cmpl   $0x0,(%edx)
  28269f:	75 25                	jne    2826c6 <timer_alloc+0x40>
  2826a1:	eb 05                	jmp    2826a8 <timer_alloc+0x22>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  2826a3:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(timerctl.timers0[i].flags == 0)
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
  2826a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  2826af:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2826b2:	c7 04 8d d0 64 28 00 	movl   $0x1,0x2864d0(,%ecx,4)
  2826b9:	01 00 00 00 
			return &timerctl.timers0[i];
  2826bd:	8d 04 8d c8 64 28 00 	lea    0x2864c8(,%ecx,4),%eax
  2826c4:	eb 12                	jmp    2826d8 <timer_alloc+0x52>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  2826c6:	83 c0 01             	add    $0x1,%eax
  2826c9:	83 c2 14             	add    $0x14,%edx
  2826cc:	3d f4 01 00 00       	cmp    $0x1f4,%eax
  2826d1:	75 c9                	jne    28269c <timer_alloc+0x16>
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
			return &timerctl.timers0[i];
		}
	}
	return 0;
  2826d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2826d8:	5d                   	pop    %ebp
  2826d9:	c3                   	ret    

002826da <init_pit>:
#include "task.h"

struct TIMERCTL timerctl;

void init_pit(void)
{
  2826da:	55                   	push   %ebp
  2826db:	89 e5                	mov    %esp,%ebp
  2826dd:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIT_CTRL,0X34);
  2826e0:	6a 34                	push   $0x34
  2826e2:	6a 43                	push   $0x43
  2826e4:	e8 4d e4 ff ff       	call   280b36 <io_out8>
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
  2826e9:	83 c4 08             	add    $0x8,%esp
  2826ec:	68 9c 00 00 00       	push   $0x9c
  2826f1:	6a 40                	push   $0x40
  2826f3:	e8 3e e4 ff ff       	call   280b36 <io_out8>
	io_out8(PIT_CNT0,0x2e);
  2826f8:	83 c4 08             	add    $0x8,%esp
  2826fb:	6a 2e                	push   $0x2e
  2826fd:	6a 40                	push   $0x40
  2826ff:	e8 32 e4 ff ff       	call   280b36 <io_out8>
  282704:	b8 d0 64 28 00       	mov    $0x2864d0,%eax
  282709:	ba e0 8b 28 00       	mov    $0x288be0,%edx
  28270e:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<MAX_TIMER;i++)
		timerctl.timers0[i].flags = 0;
  282711:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  282717:	83 c0 14             	add    $0x14,%eax
{
	io_out8(PIT_CTRL,0X34);
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
	io_out8(PIT_CNT0,0x2e);
	for(int i=0;i<MAX_TIMER;i++)
  28271a:	39 d0                	cmp    %edx,%eax
  28271c:	75 f3                	jne    282711 <init_pit+0x37>
		timerctl.timers0[i].flags = 0;
	struct TIMER *t = timer_alloc();
  28271e:	e8 63 ff ff ff       	call   282686 <timer_alloc>
	t->next = 0;
  282723:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	t->timeout = 0xffffffff;
  282729:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
	t->flags = TIMER_FLAGS_USING;
  282730:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	timerctl.t0 = t;
  282737:	a3 d8 8b 28 00       	mov    %eax,0x288bd8
	timerctl.next = 0xffffffff;
  28273c:	c7 05 c4 64 28 00 ff 	movl   $0xffffffff,0x2864c4
  282743:	ff ff ff 
	return;
}
  282746:	c9                   	leave  
  282747:	c3                   	ret    

00282748 <timer_free>:
	}
	return 0;
}

void timer_free(struct TIMER *timer)
{
  282748:	55                   	push   %ebp
  282749:	89 e5                	mov    %esp,%ebp
	timer->flags = 0;
  28274b:	8b 45 08             	mov    0x8(%ebp),%eax
  28274e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return;
}
  282755:	5d                   	pop    %ebp
  282756:	c3                   	ret    

00282757 <timer_init>:

void timer_init(struct TIMER *timer,struct FIFO32 *fifo,unsigned char data)
{
  282757:	55                   	push   %ebp
  282758:	89 e5                	mov    %esp,%ebp
  28275a:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->fifo = fifo;
  28275d:	8b 55 0c             	mov    0xc(%ebp),%edx
  282760:	89 50 0c             	mov    %edx,0xc(%eax)
	timer->data = data;
  282763:	8b 55 10             	mov    0x10(%ebp),%edx
  282766:	88 50 10             	mov    %dl,0x10(%eax)
	return ;
}
  282769:	5d                   	pop    %ebp
  28276a:	c3                   	ret    

0028276b <timer_settime>:

void timer_settime(struct TIMER *timer,unsigned int timeout)
{
  28276b:	55                   	push   %ebp
  28276c:	89 e5                	mov    %esp,%ebp
  28276e:	57                   	push   %edi
  28276f:	56                   	push   %esi
  282770:	53                   	push   %ebx
  282771:	83 ec 0c             	sub    $0xc,%esp
  282774:	8b 5d 08             	mov    0x8(%ebp),%ebx
	timer->timeout = timeout + timerctl.count;
  282777:	a1 c0 64 28 00       	mov    0x2864c0,%eax
  28277c:	03 45 0c             	add    0xc(%ebp),%eax
  28277f:	89 43 04             	mov    %eax,0x4(%ebx)
	timer->flags = TIMER_FLAGS_USING;
  282782:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%ebx)
	int e = io_load_eflags();
  282789:	e8 c7 e3 ff ff       	call   280b55 <io_load_eflags>
  28278e:	89 c6                	mov    %eax,%esi
	io_cli();
  282790:	e8 6d e3 ff ff       	call   280b02 <io_cli>
	struct TIMER *t, *s;
	if(timer->timeout<=timerctl.t0->timeout)
  282795:	8b 4b 04             	mov    0x4(%ebx),%ecx
  282798:	8b 3d d8 8b 28 00    	mov    0x288bd8,%edi
  28279e:	3b 4f 04             	cmp    0x4(%edi),%ecx
  2827a1:	77 1e                	ja     2827c1 <timer_settime+0x56>
	{
		timer->next = timerctl.t0;
  2827a3:	89 3b                	mov    %edi,(%ebx)
		timerctl.t0 = timer;
  2827a5:	89 1d d8 8b 28 00    	mov    %ebx,0x288bd8
		timerctl.next = timer->timeout;
  2827ab:	8b 43 04             	mov    0x4(%ebx),%eax
  2827ae:	a3 c4 64 28 00       	mov    %eax,0x2864c4
		io_store_eflags(e);
  2827b3:	83 ec 0c             	sub    $0xc,%esp
  2827b6:	56                   	push   %esi
  2827b7:	e8 9c e3 ff ff       	call   280b58 <io_store_eflags>
		return;
  2827bc:	83 c4 10             	add    $0x10,%esp
  2827bf:	eb 3e                	jmp    2827ff <timer_settime+0x94>
	}
	t = timerctl.t0->next;
  2827c1:	8b 17                	mov    (%edi),%edx
	s = timerctl.t0;
	while(t)
  2827c3:	85 d2                	test   %edx,%edx
  2827c5:	74 2c                	je     2827f3 <timer_settime+0x88>
	{
		if(timer->timeout<=t->timeout)
  2827c7:	3b 4a 04             	cmp    0x4(%edx),%ecx
  2827ca:	77 21                	ja     2827ed <timer_settime+0x82>
  2827cc:	eb 07                	jmp    2827d5 <timer_settime+0x6a>
  2827ce:	3b 48 04             	cmp    0x4(%eax),%ecx
  2827d1:	77 18                	ja     2827eb <timer_settime+0x80>
  2827d3:	eb 04                	jmp    2827d9 <timer_settime+0x6e>
		timerctl.t0 = timer;
		timerctl.next = timer->timeout;
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
  2827d5:	89 d0                	mov    %edx,%eax
	s = timerctl.t0;
  2827d7:	89 fa                	mov    %edi,%edx
	while(t)
	{
		if(timer->timeout<=t->timeout)
		{
			timer->next = t;
  2827d9:	89 03                	mov    %eax,(%ebx)
			s->next = timer;
  2827db:	89 1a                	mov    %ebx,(%edx)
			io_store_eflags(e);
  2827dd:	83 ec 0c             	sub    $0xc,%esp
  2827e0:	56                   	push   %esi
  2827e1:	e8 72 e3 ff ff       	call   280b58 <io_store_eflags>
			return;
  2827e6:	83 c4 10             	add    $0x10,%esp
  2827e9:	eb 14                	jmp    2827ff <timer_settime+0x94>
		}
		s = t;
		t = t->next;
  2827eb:	89 c2                	mov    %eax,%edx
  2827ed:	8b 02                	mov    (%edx),%eax
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
	s = timerctl.t0;
	while(t)
  2827ef:	85 c0                	test   %eax,%eax
  2827f1:	75 db                	jne    2827ce <timer_settime+0x63>
			return;
		}
		s = t;
		t = t->next;
	}
	io_store_eflags(e);
  2827f3:	83 ec 0c             	sub    $0xc,%esp
  2827f6:	56                   	push   %esi
  2827f7:	e8 5c e3 ff ff       	call   280b58 <io_store_eflags>
	return;
  2827fc:	83 c4 10             	add    $0x10,%esp
}
  2827ff:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282802:	5b                   	pop    %ebx
  282803:	5e                   	pop    %esi
  282804:	5f                   	pop    %edi
  282805:	5d                   	pop    %ebp
  282806:	c3                   	ret    

00282807 <inthandler20>:

extern struct TIMER *task_timer;

//handler for int 20 (timer interrupts)
void inthandler20(int *esp)
{
  282807:	55                   	push   %ebp
  282808:	89 e5                	mov    %esp,%ebp
  28280a:	56                   	push   %esi
  28280b:	53                   	push   %ebx
	char ts = 0;

	io_out8(PIC0_OCW2,0x60); //tell pic continue watch 20 int
  28280c:	83 ec 08             	sub    $0x8,%esp
  28280f:	6a 60                	push   $0x60
  282811:	6a 20                	push   $0x20
  282813:	e8 1e e3 ff ff       	call   280b36 <io_out8>
	timerctl.count ++;
  282818:	a1 c0 64 28 00       	mov    0x2864c0,%eax
  28281d:	8d 50 01             	lea    0x1(%eax),%edx
  282820:	89 15 c0 64 28 00    	mov    %edx,0x2864c0
	
	if(timerctl.count >= timerctl.next)
  282826:	83 c4 10             	add    $0x10,%esp
  282829:	3b 15 c4 64 28 00    	cmp    0x2864c4,%edx
  28282f:	72 6e                	jb     28289f <inthandler20+0x98>
	{
		struct TIMER *t = timerctl.t0;
  282831:	8b 1d d8 8b 28 00    	mov    0x288bd8,%ebx
		while(t)
  282837:	85 db                	test   %ebx,%ebx
  282839:	75 4b                	jne    282886 <inthandler20+0x7f>
  28283b:	eb 62                	jmp    28289f <inthandler20+0x98>
		{
			if(t->timeout <= timerctl.count)
  28283d:	8b 43 04             	mov    0x4(%ebx),%eax
  282840:	3b 05 c0 64 28 00    	cmp    0x2864c0,%eax
  282846:	77 31                	ja     282879 <inthandler20+0x72>
			{
				t->flags = TIMER_FLAGS_ALLOC;
  282848:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
				if(t!=task_timer) fifo32_put(t->fifo,t->data);
  28284f:	39 1d e0 8b 28 00    	cmp    %ebx,0x288be0
  282855:	74 15                	je     28286c <inthandler20+0x65>
  282857:	83 ec 08             	sub    $0x8,%esp
  28285a:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  28285e:	50                   	push   %eax
  28285f:	ff 73 0c             	pushl  0xc(%ebx)
  282862:	e8 a1 f0 ff ff       	call   281908 <fifo32_put>
  282867:	83 c4 10             	add    $0x10,%esp
  28286a:	eb 05                	jmp    282871 <inthandler20+0x6a>
				else ts=1;
  28286c:	be 01 00 00 00       	mov    $0x1,%esi
				t = t->next;
  282871:	8b 1b                	mov    (%ebx),%ebx
	timerctl.count ++;
	
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
  282873:	85 db                	test   %ebx,%ebx
  282875:	75 c6                	jne    28283d <inthandler20+0x36>
  282877:	eb 1b                	jmp    282894 <inthandler20+0x8d>
				else ts=1;
				t = t->next;
			}
			else
			{
				timerctl.next = t->timeout;
  282879:	a3 c4 64 28 00       	mov    %eax,0x2864c4
				timerctl.t0 = t;
  28287e:	89 1d d8 8b 28 00    	mov    %ebx,0x288bd8
				break;
  282884:	eb 0e                	jmp    282894 <inthandler20+0x8d>
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
		{
			if(t->timeout <= timerctl.count)
  282886:	8b 43 04             	mov    0x4(%ebx),%eax
  282889:	be 00 00 00 00       	mov    $0x0,%esi
  28288e:	39 c2                	cmp    %eax,%edx
  282890:	73 b6                	jae    282848 <inthandler20+0x41>
  282892:	eb e5                	jmp    282879 <inthandler20+0x72>
				break;
			}
		}
	}

	if(ts!=0)task_switch();
  282894:	89 f0                	mov    %esi,%eax
  282896:	84 c0                	test   %al,%al
  282898:	74 05                	je     28289f <inthandler20+0x98>
  28289a:	e8 f2 03 00 00       	call   282c91 <task_switch>
	return;
}
  28289f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2828a2:	5b                   	pop    %ebx
  2828a3:	5e                   	pop    %esi
  2828a4:	5d                   	pop    %ebp
  2828a5:	c3                   	ret    
  2828a6:	66 90                	xchg   %ax,%ax
  2828a8:	66 90                	xchg   %ax,%ax
  2828aa:	66 90                	xchg   %ax,%ax
  2828ac:	66 90                	xchg   %ax,%ax
  2828ae:	66 90                	xchg   %ax,%ax

002828b0 <load_tr>:
  2828b0:	0f 00 5c 24 04       	ltr    0x4(%esp)
  2828b5:	c3                   	ret    

002828b6 <farjmp>:
  2828b6:	ff 6c 24 04          	ljmp   *0x4(%esp)
  2828ba:	c3                   	ret    

002828bb <task_idle>:

struct TASKCTL *taskctl;
struct TIMER *task_timer;

void task_idle(void)
{
  2828bb:	55                   	push   %ebp
  2828bc:	89 e5                	mov    %esp,%ebp
  2828be:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		io_hlt();
  2828c1:	e8 3a e2 ff ff       	call   280b00 <io_hlt>
  2828c6:	eb f9                	jmp    2828c1 <task_idle+0x6>

002828c8 <task_alloc>:
	task_run(idle,MAX_TASKLEVELS-1,1);
	return task;
}

struct TASK *task_alloc(void)
{
  2828c8:	55                   	push   %ebp
  2828c9:	89 e5                	mov    %esp,%ebp
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
	{
		if(taskctl->tasks0[i].flags == 0)
  2828cb:	8b 0d dc 8b 28 00    	mov    0x288bdc,%ecx
  2828d1:	83 b9 fc 0f 00 00 00 	cmpl   $0x0,0xffc(%ecx)
  2828d8:	74 16                	je     2828f0 <task_alloc+0x28>
  2828da:	8d 91 90 10 00 00    	lea    0x1090(%ecx),%edx

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  2828e0:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
  2828e5:	83 3a 00             	cmpl   $0x0,(%edx)
  2828e8:	0f 85 af 00 00 00    	jne    28299d <task_alloc+0xd5>
  2828ee:	eb 05                	jmp    2828f5 <task_alloc+0x2d>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  2828f0:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
		{
			task = &taskctl->tasks0[i];
  2828f5:	69 c0 94 00 00 00    	imul   $0x94,%eax,%eax
			task->flags = 1;
  2828fb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  2828fe:	c7 82 fc 0f 00 00 01 	movl   $0x1,0xffc(%edx)
  282905:	00 00 00 
			task->tss.eflags = 0x202;
  282908:	c7 82 48 10 00 00 02 	movl   $0x202,0x1048(%edx)
  28290f:	02 00 00 
			task->tss.eax = 0;
  282912:	c7 82 4c 10 00 00 00 	movl   $0x0,0x104c(%edx)
  282919:	00 00 00 
			task->tss.ecx = 0;
  28291c:	c7 82 50 10 00 00 00 	movl   $0x0,0x1050(%edx)
  282923:	00 00 00 
			task->tss.edx = 0;
  282926:	c7 82 54 10 00 00 00 	movl   $0x0,0x1054(%edx)
  28292d:	00 00 00 
			task->tss.ebx = 0;
  282930:	c7 82 58 10 00 00 00 	movl   $0x0,0x1058(%edx)
  282937:	00 00 00 
			task->tss.ebp = 0;
  28293a:	c7 82 60 10 00 00 00 	movl   $0x0,0x1060(%edx)
  282941:	00 00 00 
			task->tss.esi = 0;
  282944:	c7 82 64 10 00 00 00 	movl   $0x0,0x1064(%edx)
  28294b:	00 00 00 
			task->tss.edi = 0;
  28294e:	c7 82 68 10 00 00 00 	movl   $0x0,0x1068(%edx)
  282955:	00 00 00 
			task->tss.es  = 0;
  282958:	c7 82 6c 10 00 00 00 	movl   $0x0,0x106c(%edx)
  28295f:	00 00 00 
			task->tss.ds  = 0;
  282962:	c7 82 78 10 00 00 00 	movl   $0x0,0x1078(%edx)
  282969:	00 00 00 
			task->tss.fs  = 0;
  28296c:	c7 82 7c 10 00 00 00 	movl   $0x0,0x107c(%edx)
  282973:	00 00 00 
			task->tss.gs  = 0;
  282976:	c7 82 80 10 00 00 00 	movl   $0x0,0x1080(%edx)
  28297d:	00 00 00 
			task->tss.ldtr= 0;
  282980:	c7 82 84 10 00 00 00 	movl   $0x0,0x1084(%edx)
  282987:	00 00 00 
			task->tss.iomap = 0x40000000;
  28298a:	c7 82 88 10 00 00 00 	movl   $0x40000000,0x1088(%edx)
  282991:	00 00 40 
			return task;
  282994:	8d 84 01 f8 0f 00 00 	lea    0xff8(%ecx,%eax,1),%eax
  28299b:	eb 19                	jmp    2829b6 <task_alloc+0xee>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  28299d:	83 c0 01             	add    $0x1,%eax
  2829a0:	81 c2 94 00 00 00    	add    $0x94,%edx
  2829a6:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  2829ab:	0f 85 34 ff ff ff    	jne    2828e5 <task_alloc+0x1d>
			task->tss.ldtr= 0;
			task->tss.iomap = 0x40000000;
			return task;
		}
	}
	return 0;
  2829b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2829b6:	5d                   	pop    %ebp
  2829b7:	c3                   	ret    

002829b8 <task_now>:
	}
	return;
}

struct TASK *task_now(void)
{
  2829b8:	55                   	push   %ebp
  2829b9:	89 e5                	mov    %esp,%ebp
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  2829bb:	8b 15 dc 8b 28 00    	mov    0x288bdc,%edx
  2829c1:	8b 02                	mov    (%edx),%eax
	return tl->tasks[tl->now];
  2829c3:	69 c8 98 01 00 00    	imul   $0x198,%eax,%ecx
  2829c9:	6b c0 66             	imul   $0x66,%eax,%eax
  2829cc:	03 44 0a 0c          	add    0xc(%edx,%ecx,1),%eax
  2829d0:	8b 44 82 10          	mov    0x10(%edx,%eax,4),%eax
}
  2829d4:	5d                   	pop    %ebp
  2829d5:	c3                   	ret    

002829d6 <task_add>:

void task_add(struct TASK *task)
{
  2829d6:	55                   	push   %ebp
  2829d7:	89 e5                	mov    %esp,%ebp
  2829d9:	56                   	push   %esi
  2829da:	53                   	push   %ebx
  2829db:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  2829de:	8b 35 dc 8b 28 00    	mov    0x288bdc,%esi
  2829e4:	8b 4b 08             	mov    0x8(%ebx),%ecx
  2829e7:	69 c1 98 01 00 00    	imul   $0x198,%ecx,%eax
  2829ed:	01 f0                	add    %esi,%eax
	if(tl->running == MAX_TASKS_LV) return;
  2829ef:	8b 50 08             	mov    0x8(%eax),%edx
  2829f2:	83 fa 64             	cmp    $0x64,%edx
  2829f5:	74 14                	je     282a0b <task_add+0x35>
	tl->tasks[tl->running] = task;
  2829f7:	6b c9 66             	imul   $0x66,%ecx,%ecx
  2829fa:	01 ca                	add    %ecx,%edx
  2829fc:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
	tl->running++;
  282a00:	83 40 08 01          	addl   $0x1,0x8(%eax)
	task->flags = 2;	//alive
  282a04:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	return;
}
  282a0b:	5b                   	pop    %ebx
  282a0c:	5e                   	pop    %esi
  282a0d:	5d                   	pop    %ebp
  282a0e:	c3                   	ret    

00282a0f <task_remove>:

void task_remove(struct TASK *task)
{
  282a0f:	55                   	push   %ebp
  282a10:	89 e5                	mov    %esp,%ebp
  282a12:	57                   	push   %edi
  282a13:	56                   	push   %esi
  282a14:	53                   	push   %ebx
  282a15:	83 ec 04             	sub    $0x4,%esp
  282a18:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  282a1b:	8b 3d dc 8b 28 00    	mov    0x288bdc,%edi
  282a21:	8b 43 08             	mov    0x8(%ebx),%eax
  282a24:	89 45 f0             	mov    %eax,-0x10(%ebp)
  282a27:	69 d0 98 01 00 00    	imul   $0x198,%eax,%edx
  282a2d:	01 fa                	add    %edi,%edx
	int i;
	for(i=0;i<tl->running;i++)
  282a2f:	8b 4a 08             	mov    0x8(%edx),%ecx
  282a32:	85 c9                	test   %ecx,%ecx
  282a34:	7e 1d                	jle    282a53 <task_remove+0x44>
	{
		if(tl->tasks[i] == task)
  282a36:	3b 5a 10             	cmp    0x10(%edx),%ebx
  282a39:	74 1f                	je     282a5a <task_remove+0x4b>
  282a3b:	b8 00 00 00 00       	mov    $0x0,%eax
  282a40:	eb 06                	jmp    282a48 <task_remove+0x39>
  282a42:	3b 5c 82 10          	cmp    0x10(%edx,%eax,4),%ebx
  282a46:	74 17                	je     282a5f <task_remove+0x50>

void task_remove(struct TASK *task)
{
	struct TASKLEVEL *tl = &taskctl->level[task->level];
	int i;
	for(i=0;i<tl->running;i++)
  282a48:	83 c0 01             	add    $0x1,%eax
  282a4b:	39 c8                	cmp    %ecx,%eax
  282a4d:	75 f3                	jne    282a42 <task_remove+0x33>
  282a4f:	89 c8                	mov    %ecx,%eax
  282a51:	eb 0c                	jmp    282a5f <task_remove+0x50>
  282a53:	b8 00 00 00 00       	mov    $0x0,%eax
  282a58:	eb 05                	jmp    282a5f <task_remove+0x50>
  282a5a:	b8 00 00 00 00       	mov    $0x0,%eax
		if(tl->tasks[i] == task)
		{
			break;
		}
	}
	tl->running--;
  282a5f:	83 e9 01             	sub    $0x1,%ecx
  282a62:	89 4a 08             	mov    %ecx,0x8(%edx)
	if(i<tl->now)
  282a65:	8b 72 0c             	mov    0xc(%edx),%esi
  282a68:	39 c6                	cmp    %eax,%esi
  282a6a:	7e 06                	jle    282a72 <task_remove+0x63>
	{
		tl->now--;
  282a6c:	83 ee 01             	sub    $0x1,%esi
  282a6f:	89 72 0c             	mov    %esi,0xc(%edx)
	}
	if(tl->now >= tl->running)
  282a72:	3b 4a 0c             	cmp    0xc(%edx),%ecx
  282a75:	7f 07                	jg     282a7e <task_remove+0x6f>
	{
		tl->now = 0;
  282a77:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	}
	task->flags = 1; //sleep;
  282a7e:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	
	for(;i<tl->running;i++)
  282a85:	39 42 08             	cmp    %eax,0x8(%edx)
  282a88:	7e 1b                	jle    282aa5 <task_remove+0x96>
  282a8a:	6b 4d f0 66          	imul   $0x66,-0x10(%ebp),%ecx
  282a8e:	8d 4c 08 05          	lea    0x5(%eax,%ecx,1),%ecx
  282a92:	8d 0c 8f             	lea    (%edi,%ecx,4),%ecx
	{
		tl->tasks[i] = tl->tasks[i+1];
  282a95:	83 c0 01             	add    $0x1,%eax
  282a98:	8b 19                	mov    (%ecx),%ebx
  282a9a:	89 59 fc             	mov    %ebx,-0x4(%ecx)
  282a9d:	83 c1 04             	add    $0x4,%ecx
	{
		tl->now = 0;
	}
	task->flags = 1; //sleep;
	
	for(;i<tl->running;i++)
  282aa0:	39 42 08             	cmp    %eax,0x8(%edx)
  282aa3:	7f f0                	jg     282a95 <task_remove+0x86>
	{
		tl->tasks[i] = tl->tasks[i+1];
	}
	return;
}
  282aa5:	83 c4 04             	add    $0x4,%esp
  282aa8:	5b                   	pop    %ebx
  282aa9:	5e                   	pop    %esi
  282aaa:	5f                   	pop    %edi
  282aab:	5d                   	pop    %ebp
  282aac:	c3                   	ret    

00282aad <task_run>:
	}
	return 0;
}

void task_run(struct TASK *task,int level,int priority)
{
  282aad:	55                   	push   %ebp
  282aae:	89 e5                	mov    %esp,%ebp
  282ab0:	56                   	push   %esi
  282ab1:	53                   	push   %ebx
  282ab2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282ab5:	8b 75 0c             	mov    0xc(%ebp),%esi
  282ab8:	8b 45 10             	mov    0x10(%ebp),%eax
	if(level < 0) level = task->level;
  282abb:	85 f6                	test   %esi,%esi
  282abd:	79 03                	jns    282ac2 <task_run+0x15>
  282abf:	8b 73 08             	mov    0x8(%ebx),%esi
	if(priority > 0) task->priority = priority;
  282ac2:	85 c0                	test   %eax,%eax
  282ac4:	7e 03                	jle    282ac9 <task_run+0x1c>
  282ac6:	89 43 0c             	mov    %eax,0xc(%ebx)
	if(task->flags == 2 && task->level != level)
  282ac9:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282acd:	75 14                	jne    282ae3 <task_run+0x36>
  282acf:	3b 73 08             	cmp    0x8(%ebx),%esi
  282ad2:	74 1b                	je     282aef <task_run+0x42>
	{
		task_remove(task); //then task->flags = 1;
  282ad4:	53                   	push   %ebx
  282ad5:	e8 35 ff ff ff       	call   282a0f <task_remove>
	}
	if(task->flags != 2)
  282ada:	83 c4 04             	add    $0x4,%esp
  282add:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282ae1:	74 0c                	je     282aef <task_run+0x42>
	{
		task->level = level;
  282ae3:	89 73 08             	mov    %esi,0x8(%ebx)
		task_add(task);
  282ae6:	53                   	push   %ebx
  282ae7:	e8 ea fe ff ff       	call   2829d6 <task_add>
  282aec:	83 c4 04             	add    $0x4,%esp
	}
	taskctl->lv_change = 1;
  282aef:	a1 dc 8b 28 00       	mov    0x288bdc,%eax
  282af4:	c6 40 04 01          	movb   $0x1,0x4(%eax)
	return;
}
  282af8:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282afb:	5b                   	pop    %ebx
  282afc:	5e                   	pop    %esi
  282afd:	5d                   	pop    %ebp
  282afe:	c3                   	ret    

00282aff <task_switchsub>:
	}
	return;
}

void task_switchsub(void)
{
  282aff:	55                   	push   %ebp
  282b00:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		if(taskctl->level[i].running>0) break;
  282b02:	8b 0d dc 8b 28 00    	mov    0x288bdc,%ecx
  282b08:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  282b0c:	7f 20                	jg     282b2e <task_switchsub+0x2f>
  282b0e:	8d 91 a0 01 00 00    	lea    0x1a0(%ecx),%edx
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282b14:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->level[i].running>0) break;
  282b19:	83 3a 00             	cmpl   $0x0,(%edx)
  282b1c:	7f 15                	jg     282b33 <task_switchsub+0x34>
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282b1e:	83 c0 01             	add    $0x1,%eax
  282b21:	81 c2 98 01 00 00    	add    $0x198,%edx
  282b27:	83 f8 0a             	cmp    $0xa,%eax
  282b2a:	75 ed                	jne    282b19 <task_switchsub+0x1a>
  282b2c:	eb 05                	jmp    282b33 <task_switchsub+0x34>
  282b2e:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->level[i].running>0) break;
	}
	taskctl->now_lv = i;
  282b33:	89 01                	mov    %eax,(%ecx)
	taskctl->lv_change = 0;
  282b35:	a1 dc 8b 28 00       	mov    0x288bdc,%eax
  282b3a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	return;
}
  282b3e:	5d                   	pop    %ebp
  282b3f:	c3                   	ret    

00282b40 <task_init>:
		io_hlt();
	}
}

struct TASK *task_init(struct MEMMAN *memman)
{
  282b40:	55                   	push   %ebp
  282b41:	89 e5                	mov    %esp,%ebp
  282b43:	57                   	push   %edi
  282b44:	56                   	push   %esi
  282b45:	53                   	push   %ebx
  282b46:	83 ec 14             	sub    $0x14,%esp
  282b49:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
  282b4c:	68 18 52 02 00       	push   $0x25218
  282b51:	57                   	push   %edi
  282b52:	e8 35 f5 ff ff       	call   28208c <memman_alloc_4k>
  282b57:	a3 dc 8b 28 00       	mov    %eax,0x288bdc
  282b5c:	83 c4 10             	add    $0x10,%esp
  282b5f:	be 20 00 00 00       	mov    $0x20,%esi
	for(i=0;i<MAX_TASKS;i++)
  282b64:	bb 00 00 00 00       	mov    $0x0,%ebx
	{
		taskctl->tasks0[i].flags = 0;
  282b69:	8b 15 dc 8b 28 00    	mov    0x288bdc,%edx
  282b6f:	69 c3 94 00 00 00    	imul   $0x94,%ebx,%eax
  282b75:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282b78:	c7 81 fc 0f 00 00 00 	movl   $0x0,0xffc(%ecx)
  282b7f:	00 00 00 
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
  282b82:	89 b1 f8 0f 00 00    	mov    %esi,0xff8(%ecx)
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
  282b88:	68 89 00 00 00       	push   $0x89
  282b8d:	8d 84 02 24 10 00 00 	lea    0x1024(%edx,%eax,1),%eax
  282b94:	50                   	push   %eax
  282b95:	6a 67                	push   $0x67
  282b97:	8d 86 00 00 27 00    	lea    0x270000(%esi),%eax
  282b9d:	50                   	push   %eax
  282b9e:	e8 84 e7 ff ff       	call   281327 <set_segmdesc>
{
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
	for(i=0;i<MAX_TASKS;i++)
  282ba3:	83 c3 01             	add    $0x1,%ebx
  282ba6:	83 c6 08             	add    $0x8,%esi
  282ba9:	83 c4 10             	add    $0x10,%esp
  282bac:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
  282bb2:	75 b5                	jne    282b69 <task_init+0x29>
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		taskctl->level[i].running = 0;
  282bb4:	8b 15 dc 8b 28 00    	mov    0x288bdc,%edx
  282bba:	8d 42 08             	lea    0x8(%edx),%eax
  282bbd:	81 c2 f8 0f 00 00    	add    $0xff8,%edx
  282bc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		taskctl->level[i].now = 0;
  282bc9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  282bd0:	05 98 01 00 00       	add    $0x198,%eax
		taskctl->tasks0[i].flags = 0;
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
  282bd5:	39 d0                	cmp    %edx,%eax
  282bd7:	75 ea                	jne    282bc3 <task_init+0x83>
	{
		taskctl->level[i].running = 0;
		taskctl->level[i].now = 0;
	}
	task = task_alloc();
  282bd9:	e8 ea fc ff ff       	call   2828c8 <task_alloc>
  282bde:	89 c6                	mov    %eax,%esi
	task->flags = 2;
  282be0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
	task->priority = 2;
  282be7:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	task->level = 0;
  282bee:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	task_add(task);
  282bf5:	83 ec 0c             	sub    $0xc,%esp
  282bf8:	50                   	push   %eax
  282bf9:	e8 d8 fd ff ff       	call   2829d6 <task_add>
	
	task_switchsub();
  282bfe:	e8 fc fe ff ff       	call   282aff <task_switchsub>
	load_tr(task->sel);
  282c03:	83 c4 04             	add    $0x4,%esp
  282c06:	ff 36                	pushl  (%esi)
  282c08:	e8 a3 fc ff ff       	call   2828b0 <load_tr>
	task_timer = timer_alloc();
  282c0d:	e8 74 fa ff ff       	call   282686 <timer_alloc>
  282c12:	a3 e0 8b 28 00       	mov    %eax,0x288be0
	timer_settime(task_timer,task->priority);
  282c17:	83 c4 08             	add    $0x8,%esp
  282c1a:	ff 76 0c             	pushl  0xc(%esi)
  282c1d:	50                   	push   %eax
  282c1e:	e8 48 fb ff ff       	call   28276b <timer_settime>

	struct TASK *idle = task_alloc();
  282c23:	e8 a0 fc ff ff       	call   2828c8 <task_alloc>
  282c28:	89 c3                	mov    %eax,%ebx
	idle->tss.esp = memman_alloc(memman,64*1024)+64*1024;
  282c2a:	83 c4 08             	add    $0x8,%esp
  282c2d:	68 00 00 01 00       	push   $0x10000
  282c32:	57                   	push   %edi
  282c33:	e8 18 f1 ff ff       	call   281d50 <memman_alloc>
  282c38:	05 00 00 01 00       	add    $0x10000,%eax
  282c3d:	89 43 64             	mov    %eax,0x64(%ebx)
	idle->tss.eip = (int)&task_idle-0x280000;
  282c40:	c7 43 4c bb 28 00 00 	movl   $0x28bb,0x4c(%ebx)
	idle->tss.es = 1*8;
  282c47:	c7 43 74 08 00 00 00 	movl   $0x8,0x74(%ebx)
	idle->tss.cs = 3*8;
  282c4e:	c7 43 78 18 00 00 00 	movl   $0x18,0x78(%ebx)
	idle->tss.ss = 1*8;
  282c55:	c7 43 7c 08 00 00 00 	movl   $0x8,0x7c(%ebx)
	idle->tss.ds = 1*8;
  282c5c:	c7 83 80 00 00 00 08 	movl   $0x8,0x80(%ebx)
  282c63:	00 00 00 
	idle->tss.fs = 1*8;
  282c66:	c7 83 84 00 00 00 08 	movl   $0x8,0x84(%ebx)
  282c6d:	00 00 00 
	idle->tss.gs = 1*8;
  282c70:	c7 83 88 00 00 00 08 	movl   $0x8,0x88(%ebx)
  282c77:	00 00 00 
	task_run(idle,MAX_TASKLEVELS-1,1);
  282c7a:	83 c4 0c             	add    $0xc,%esp
  282c7d:	6a 01                	push   $0x1
  282c7f:	6a 09                	push   $0x9
  282c81:	53                   	push   %ebx
  282c82:	e8 26 fe ff ff       	call   282aad <task_run>
	return task;
}
  282c87:	89 f0                	mov    %esi,%eax
  282c89:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282c8c:	5b                   	pop    %ebx
  282c8d:	5e                   	pop    %esi
  282c8e:	5f                   	pop    %edi
  282c8f:	5d                   	pop    %ebp
  282c90:	c3                   	ret    

00282c91 <task_switch>:
	taskctl->lv_change = 1;
	return;
}

void task_switch(void)
{
  282c91:	55                   	push   %ebp
  282c92:	89 e5                	mov    %esp,%ebp
  282c94:	56                   	push   %esi
  282c95:	53                   	push   %ebx
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282c96:	8b 0d dc 8b 28 00    	mov    0x288bdc,%ecx
  282c9c:	8b 31                	mov    (%ecx),%esi
  282c9e:	69 c6 98 01 00 00    	imul   $0x198,%esi,%eax
  282ca4:	01 c8                	add    %ecx,%eax
	struct TASK *new_task,*now_task = tl->tasks[tl->now];
  282ca6:	8b 50 0c             	mov    0xc(%eax),%edx
  282ca9:	6b de 66             	imul   $0x66,%esi,%ebx
  282cac:	01 d3                	add    %edx,%ebx
  282cae:	8b 5c 99 10          	mov    0x10(%ecx,%ebx,4),%ebx
	tl->now++;
  282cb2:	83 c2 01             	add    $0x1,%edx
  282cb5:	89 50 0c             	mov    %edx,0xc(%eax)
	if(tl->now == tl->running)
  282cb8:	3b 50 08             	cmp    0x8(%eax),%edx
  282cbb:	75 07                	jne    282cc4 <task_switch+0x33>
	{
		tl->now = 0;
  282cbd:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
	if(taskctl->lv_change!=0)
  282cc4:	80 79 04 00          	cmpb   $0x0,0x4(%ecx)
  282cc8:	75 0c                	jne    282cd6 <task_switch+0x45>
	return;
}

void task_switch(void)
{
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282cca:	69 f6 98 01 00 00    	imul   $0x198,%esi,%esi
  282cd0:	8d 44 31 08          	lea    0x8(%ecx,%esi,1),%eax
  282cd4:	eb 14                	jmp    282cea <task_switch+0x59>
	{
		tl->now = 0;
	}
	if(taskctl->lv_change!=0)
	{
		task_switchsub();
  282cd6:	e8 24 fe ff ff       	call   282aff <task_switchsub>
		tl = &taskctl->level[taskctl->now_lv];
  282cdb:	a1 dc 8b 28 00       	mov    0x288bdc,%eax
  282ce0:	69 10 98 01 00 00    	imul   $0x198,(%eax),%edx
  282ce6:	8d 44 10 08          	lea    0x8(%eax,%edx,1),%eax
	}
	new_task = tl->tasks[tl->now];
  282cea:	8b 50 04             	mov    0x4(%eax),%edx
  282ced:	8b 74 90 08          	mov    0x8(%eax,%edx,4),%esi
	timer_settime(task_timer,new_task->priority);
  282cf1:	83 ec 08             	sub    $0x8,%esp
  282cf4:	ff 76 0c             	pushl  0xc(%esi)
  282cf7:	ff 35 e0 8b 28 00    	pushl  0x288be0
  282cfd:	e8 69 fa ff ff       	call   28276b <timer_settime>
	if(new_task != now_task)
  282d02:	83 c4 10             	add    $0x10,%esp
  282d05:	39 f3                	cmp    %esi,%ebx
  282d07:	74 0f                	je     282d18 <task_switch+0x87>
	{
		farjmp(0,new_task->sel);
  282d09:	83 ec 08             	sub    $0x8,%esp
  282d0c:	ff 36                	pushl  (%esi)
  282d0e:	6a 00                	push   $0x0
  282d10:	e8 a1 fb ff ff       	call   2828b6 <farjmp>
  282d15:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  282d18:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282d1b:	5b                   	pop    %ebx
  282d1c:	5e                   	pop    %esi
  282d1d:	5d                   	pop    %ebp
  282d1e:	c3                   	ret    

00282d1f <task_sleep>:

void task_sleep(struct TASK *task)
{
  282d1f:	55                   	push   %ebp
  282d20:	89 e5                	mov    %esp,%ebp
  282d22:	56                   	push   %esi
  282d23:	53                   	push   %ebx
  282d24:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASK *now_task;
	if(task->flags == 2)
  282d27:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282d2b:	75 2d                	jne    282d5a <task_sleep+0x3b>
	{
		now_task = task_now();
  282d2d:	e8 86 fc ff ff       	call   2829b8 <task_now>
  282d32:	89 c6                	mov    %eax,%esi
		task_remove(task);
  282d34:	53                   	push   %ebx
  282d35:	e8 d5 fc ff ff       	call   282a0f <task_remove>
		if(task == now_task)
  282d3a:	83 c4 04             	add    $0x4,%esp
  282d3d:	39 f3                	cmp    %esi,%ebx
  282d3f:	75 19                	jne    282d5a <task_sleep+0x3b>
		{
			task_switchsub();
  282d41:	e8 b9 fd ff ff       	call   282aff <task_switchsub>
			now_task = task_now();
  282d46:	e8 6d fc ff ff       	call   2829b8 <task_now>
			farjmp(0,now_task->sel);
  282d4b:	83 ec 08             	sub    $0x8,%esp
  282d4e:	ff 30                	pushl  (%eax)
  282d50:	6a 00                	push   $0x0
  282d52:	e8 5f fb ff ff       	call   2828b6 <farjmp>
  282d57:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  282d5a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282d5d:	5b                   	pop    %ebx
  282d5e:	5e                   	pop    %esi
  282d5f:	5d                   	pop    %ebp
  282d60:	c3                   	ret    

00282d61 <console_task>:
#include "header.h"
void console_task(struct SHEET *sheet,unsigned int memtotal)
{
  282d61:	55                   	push   %ebp
  282d62:	89 e5                	mov    %esp,%ebp
  282d64:	56                   	push   %esi
  282d65:	53                   	push   %ebx
  282d66:	81 ec a0 02 00 00    	sub    $0x2a0,%esp
	char s[50],cmdline[30];
	struct TIMER *timer;
	struct TASK *task = task_now();
  282d6c:	e8 47 fc ff ff       	call   2829b8 <task_now>
  282d71:	89 45 c8             	mov    %eax,-0x38(%ebp)
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
  282d74:	c7 45 c4 00 00 3c 00 	movl   $0x3c0000,-0x3c(%ebp)
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG+0x002600); //0x002600 the offset of directory entry in the os.img
  282d7b:	c7 45 c0 00 26 10 00 	movl   $0x102600,-0x40(%ebp)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
  282d82:	c7 45 bc 00 00 27 00 	movl   $0x270000,-0x44(%ebp)

	int i,fifobuf[128],cursor_x = 16,cursor_y = 28,cursor_c = -1;
  282d89:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
  282d90:	c7 45 f0 1c 00 00 00 	movl   $0x1c,-0x10(%ebp)
  282d97:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
	fifo32_init(&task->fifo,128,fifobuf,task);
  282d9e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  282da1:	8d 50 10             	lea    0x10(%eax),%edx
  282da4:	ff 75 c8             	pushl  -0x38(%ebp)
  282da7:	8d 85 58 fd ff ff    	lea    -0x2a8(%ebp),%eax
  282dad:	50                   	push   %eax
  282dae:	68 80 00 00 00       	push   $0x80
  282db3:	52                   	push   %edx
  282db4:	e8 1e eb ff ff       	call   2818d7 <fifo32_init>
  282db9:	83 c4 10             	add    $0x10,%esp
	timer = timer_alloc();
  282dbc:	e8 c5 f8 ff ff       	call   282686 <timer_alloc>
  282dc1:	89 45 b8             	mov    %eax,-0x48(%ebp)
	timer_init(timer,&task->fifo,1);
  282dc4:	8b 45 c8             	mov    -0x38(%ebp),%eax
  282dc7:	83 c0 10             	add    $0x10,%eax
  282dca:	83 ec 04             	sub    $0x4,%esp
  282dcd:	6a 01                	push   $0x1
  282dcf:	50                   	push   %eax
  282dd0:	ff 75 b8             	pushl  -0x48(%ebp)
  282dd3:	e8 7f f9 ff ff       	call   282757 <timer_init>
  282dd8:	83 c4 10             	add    $0x10,%esp
	timer_settime(timer,50);
  282ddb:	83 ec 08             	sub    $0x8,%esp
  282dde:	6a 32                	push   $0x32
  282de0:	ff 75 b8             	pushl  -0x48(%ebp)
  282de3:	e8 83 f9 ff ff       	call   28276b <timer_settime>
  282de8:	83 c4 10             	add    $0x10,%esp
	
	//draw prompt char
	putfonts8_asc_sht(sheet,8,28,COL8_FFFFFF,COL8_000000,">",1);
  282deb:	83 ec 04             	sub    $0x4,%esp
  282dee:	6a 01                	push   $0x1
  282df0:	68 00 3f 28 00       	push   $0x283f00
  282df5:	6a 00                	push   $0x0
  282df7:	6a 07                	push   $0x7
  282df9:	6a 1c                	push   $0x1c
  282dfb:	6a 08                	push   $0x8
  282dfd:	ff 75 08             	pushl  0x8(%ebp)
  282e00:	e8 de e2 ff ff       	call   2810e3 <putfonts8_asc_sht>
  282e05:	83 c4 20             	add    $0x20,%esp

	int *fat = (int *)memman_alloc_4k(memman, 4*2880);
  282e08:	83 ec 08             	sub    $0x8,%esp
  282e0b:	68 00 2d 00 00       	push   $0x2d00
  282e10:	ff 75 c4             	pushl  -0x3c(%ebp)
  282e13:	e8 74 f2 ff ff       	call   28208c <memman_alloc_4k>
  282e18:	83 c4 10             	add    $0x10,%esp
  282e1b:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG+0x000200));
  282e1e:	83 ec 08             	sub    $0x8,%esp
  282e21:	68 00 02 10 00       	push   $0x100200
  282e26:	ff 75 b4             	pushl  -0x4c(%ebp)
  282e29:	e8 be 0c 00 00       	call   283aec <file_readfat>
  282e2e:	83 c4 10             	add    $0x10,%esp
	for(;;)
	{
		io_cli();
  282e31:	e8 cc dc ff ff       	call   280b02 <io_cli>
		if(fifo32_status(&task->fifo)==0)
  282e36:	8b 45 c8             	mov    -0x38(%ebp),%eax
  282e39:	83 c0 10             	add    $0x10,%eax
  282e3c:	83 ec 0c             	sub    $0xc,%esp
  282e3f:	50                   	push   %eax
  282e40:	e8 70 eb ff ff       	call   2819b5 <fifo32_status>
  282e45:	83 c4 10             	add    $0x10,%esp
  282e48:	85 c0                	test   %eax,%eax
  282e4a:	75 15                	jne    282e61 <console_task+0x100>
		{
			task_sleep(task);
  282e4c:	83 ec 0c             	sub    $0xc,%esp
  282e4f:	ff 75 c8             	pushl  -0x38(%ebp)
  282e52:	e8 c8 fe ff ff       	call   282d1f <task_sleep>
  282e57:	83 c4 10             	add    $0x10,%esp
			io_sti();
  282e5a:	e8 a5 dc ff ff       	call   280b04 <io_sti>
  282e5f:	eb d0                	jmp    282e31 <console_task+0xd0>
		}
		else
		{
			i=fifo32_get(&task->fifo);
  282e61:	8b 45 c8             	mov    -0x38(%ebp),%eax
  282e64:	83 c0 10             	add    $0x10,%eax
  282e67:	83 ec 0c             	sub    $0xc,%esp
  282e6a:	50                   	push   %eax
  282e6b:	e8 0a eb ff ff       	call   28197a <fifo32_get>
  282e70:	83 c4 10             	add    $0x10,%esp
  282e73:	89 45 b0             	mov    %eax,-0x50(%ebp)
			io_sti();
  282e76:	e8 89 dc ff ff       	call   280b04 <io_sti>
			if(i<=1) //for cursor
  282e7b:	83 7d b0 01          	cmpl   $0x1,-0x50(%ebp)
  282e7f:	7f 65                	jg     282ee6 <console_task+0x185>
			{
				if(i!=0)
  282e81:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  282e85:	74 26                	je     282ead <console_task+0x14c>
				{
					timer_init(timer,&task->fifo,0);
  282e87:	8b 45 c8             	mov    -0x38(%ebp),%eax
  282e8a:	83 c0 10             	add    $0x10,%eax
  282e8d:	83 ec 04             	sub    $0x4,%esp
  282e90:	6a 00                	push   $0x0
  282e92:	50                   	push   %eax
  282e93:	ff 75 b8             	pushl  -0x48(%ebp)
  282e96:	e8 bc f8 ff ff       	call   282757 <timer_init>
  282e9b:	83 c4 10             	add    $0x10,%esp
					if(cursor_c >= 0) cursor_c = COL8_FFFFFF;
  282e9e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  282ea2:	78 2d                	js     282ed1 <console_task+0x170>
  282ea4:	c7 45 ec 07 00 00 00 	movl   $0x7,-0x14(%ebp)
  282eab:	eb 24                	jmp    282ed1 <console_task+0x170>
				}
				else
				{
					timer_init(timer,&task->fifo,1);
  282ead:	8b 45 c8             	mov    -0x38(%ebp),%eax
  282eb0:	83 c0 10             	add    $0x10,%eax
  282eb3:	83 ec 04             	sub    $0x4,%esp
  282eb6:	6a 01                	push   $0x1
  282eb8:	50                   	push   %eax
  282eb9:	ff 75 b8             	pushl  -0x48(%ebp)
  282ebc:	e8 96 f8 ff ff       	call   282757 <timer_init>
  282ec1:	83 c4 10             	add    $0x10,%esp
					if(cursor_c >= 0) cursor_c = COL8_000000;
  282ec4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  282ec8:	78 07                	js     282ed1 <console_task+0x170>
  282eca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
				}
				timer_settime(timer,50);
  282ed1:	83 ec 08             	sub    $0x8,%esp
  282ed4:	6a 32                	push   $0x32
  282ed6:	ff 75 b8             	pushl  -0x48(%ebp)
  282ed9:	e8 8d f8 ff ff       	call   28276b <timer_settime>
  282ede:	83 c4 10             	add    $0x10,%esp
  282ee1:	e9 be 0a 00 00       	jmp    2839a4 <console_task+0xc43>
							
			}
			else if(i == 2) //get show cursor msg
  282ee6:	83 7d b0 02          	cmpl   $0x2,-0x50(%ebp)
  282eea:	75 0c                	jne    282ef8 <console_task+0x197>
			{
				cursor_c = COL8_FFFFFF;
  282eec:	c7 45 ec 07 00 00 00 	movl   $0x7,-0x14(%ebp)
  282ef3:	e9 ac 0a 00 00       	jmp    2839a4 <console_task+0xc43>
			}
			else if(i == 3) //get hide cursor msg
  282ef8:	83 7d b0 03          	cmpl   $0x3,-0x50(%ebp)
  282efc:	75 34                	jne    282f32 <console_task+0x1d1>
			{
				cursor_c = -1;
  282efe:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)
				boxfill8(sheet->buf,sheet->bxsize,COL8_000000,cursor_x,28,cursor_x+7,43);
  282f05:	8b 45 f4             	mov    -0xc(%ebp),%eax
  282f08:	8d 48 07             	lea    0x7(%eax),%ecx
  282f0b:	8b 45 08             	mov    0x8(%ebp),%eax
  282f0e:	8b 50 04             	mov    0x4(%eax),%edx
  282f11:	8b 45 08             	mov    0x8(%ebp),%eax
  282f14:	8b 00                	mov    (%eax),%eax
  282f16:	83 ec 04             	sub    $0x4,%esp
  282f19:	6a 2b                	push   $0x2b
  282f1b:	51                   	push   %ecx
  282f1c:	6a 1c                	push   $0x1c
  282f1e:	ff 75 f4             	pushl  -0xc(%ebp)
  282f21:	6a 00                	push   $0x0
  282f23:	52                   	push   %edx
  282f24:	50                   	push   %eax
  282f25:	e8 5a dd ff ff       	call   280c84 <boxfill8>
  282f2a:	83 c4 20             	add    $0x20,%esp
  282f2d:	e9 72 0a 00 00       	jmp    2839a4 <console_task+0xc43>
			}
			else if(256<=i && i<=511)
  282f32:	81 7d b0 ff 00 00 00 	cmpl   $0xff,-0x50(%ebp)
  282f39:	0f 8e 65 0a 00 00    	jle    2839a4 <console_task+0xc43>
  282f3f:	81 7d b0 ff 01 00 00 	cmpl   $0x1ff,-0x50(%ebp)
  282f46:	0f 8f 58 0a 00 00    	jg     2839a4 <console_task+0xc43>
			{
				if(i == 8+256) //back key
  282f4c:	81 7d b0 08 01 00 00 	cmpl   $0x108,-0x50(%ebp)
  282f53:	75 32                	jne    282f87 <console_task+0x226>
				{
					if(cursor_x > 16)
  282f55:	83 7d f4 10          	cmpl   $0x10,-0xc(%ebp)
  282f59:	0f 8e 45 0a 00 00    	jle    2839a4 <console_task+0xc43>
					{
						putfonts8_asc_sht(sheet,cursor_x,cursor_y,COL8_FFFFFF,COL8_000000," ",1);
  282f5f:	83 ec 04             	sub    $0x4,%esp
  282f62:	6a 01                	push   $0x1
  282f64:	68 02 3f 28 00       	push   $0x283f02
  282f69:	6a 00                	push   $0x0
  282f6b:	6a 07                	push   $0x7
  282f6d:	ff 75 f0             	pushl  -0x10(%ebp)
  282f70:	ff 75 f4             	pushl  -0xc(%ebp)
  282f73:	ff 75 08             	pushl  0x8(%ebp)
  282f76:	e8 68 e1 ff ff       	call   2810e3 <putfonts8_asc_sht>
  282f7b:	83 c4 20             	add    $0x20,%esp
						cursor_x -= 8;
  282f7e:	83 6d f4 08          	subl   $0x8,-0xc(%ebp)
  282f82:	e9 1d 0a 00 00       	jmp    2839a4 <console_task+0xc43>
					}
				}
				else if(i == 10+256) //return key
  282f87:	81 7d b0 0a 01 00 00 	cmpl   $0x10a,-0x50(%ebp)
  282f8e:	0f 85 b7 09 00 00    	jne    28394b <console_task+0xbea>
				{
					
					putfonts8_asc_sht(sheet,cursor_x,cursor_y,COL8_FFFFFF,COL8_000000," ",1); //erase the cursor
  282f94:	83 ec 04             	sub    $0x4,%esp
  282f97:	6a 01                	push   $0x1
  282f99:	68 02 3f 28 00       	push   $0x283f02
  282f9e:	6a 00                	push   $0x0
  282fa0:	6a 07                	push   $0x7
  282fa2:	ff 75 f0             	pushl  -0x10(%ebp)
  282fa5:	ff 75 f4             	pushl  -0xc(%ebp)
  282fa8:	ff 75 08             	pushl  0x8(%ebp)
  282fab:	e8 33 e1 ff ff       	call   2810e3 <putfonts8_asc_sht>
  282fb0:	83 c4 20             	add    $0x20,%esp
					cmdline[cursor_x/8-2] = 0;
  282fb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  282fb6:	8d 50 07             	lea    0x7(%eax),%edx
  282fb9:	85 c0                	test   %eax,%eax
  282fbb:	0f 48 c2             	cmovs  %edx,%eax
  282fbe:	c1 f8 03             	sar    $0x3,%eax
  282fc1:	83 e8 02             	sub    $0x2,%eax
  282fc4:	c6 84 05 58 ff ff ff 	movb   $0x0,-0xa8(%ebp,%eax,1)
  282fcb:	00 
					cursor_y = cons_newline(cursor_y,sheet);
  282fcc:	83 ec 08             	sub    $0x8,%esp
  282fcf:	ff 75 08             	pushl  0x8(%ebp)
  282fd2:	ff 75 f0             	pushl  -0x10(%ebp)
  282fd5:	e8 2a 0a 00 00       	call   283a04 <cons_newline>
  282fda:	83 c4 10             	add    $0x10,%esp
  282fdd:	89 45 f0             	mov    %eax,-0x10(%ebp)
					if(strcmp(cmdline,"mem")==0)
  282fe0:	83 ec 08             	sub    $0x8,%esp
  282fe3:	68 04 3f 28 00       	push   $0x283f04
  282fe8:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
  282fee:	50                   	push   %eax
  282fef:	e8 fd e7 ff ff       	call   2817f1 <strcmp>
  282ff4:	83 c4 10             	add    $0x10,%esp
  282ff7:	85 c0                	test   %eax,%eax
  282ff9:	0f 85 c8 00 00 00    	jne    2830c7 <console_task+0x366>
					{
						//mem cmd
						sprintf(s,"total %dMB",memtotal/(1024*1024));
  282fff:	8b 45 0c             	mov    0xc(%ebp),%eax
  283002:	c1 e8 14             	shr    $0x14,%eax
  283005:	83 ec 04             	sub    $0x4,%esp
  283008:	50                   	push   %eax
  283009:	68 08 3f 28 00       	push   $0x283f08
  28300e:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  283014:	50                   	push   %eax
  283015:	e8 02 e7 ff ff       	call   28171c <sprintf>
  28301a:	83 c4 10             	add    $0x10,%esp
						putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,s,30);
  28301d:	83 ec 04             	sub    $0x4,%esp
  283020:	6a 1e                	push   $0x1e
  283022:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  283028:	50                   	push   %eax
  283029:	6a 00                	push   $0x0
  28302b:	6a 07                	push   $0x7
  28302d:	ff 75 f0             	pushl  -0x10(%ebp)
  283030:	6a 08                	push   $0x8
  283032:	ff 75 08             	pushl  0x8(%ebp)
  283035:	e8 a9 e0 ff ff       	call   2810e3 <putfonts8_asc_sht>
  28303a:	83 c4 20             	add    $0x20,%esp
						cursor_y = cons_newline(cursor_y,sheet);
  28303d:	83 ec 08             	sub    $0x8,%esp
  283040:	ff 75 08             	pushl  0x8(%ebp)
  283043:	ff 75 f0             	pushl  -0x10(%ebp)
  283046:	e8 b9 09 00 00       	call   283a04 <cons_newline>
  28304b:	83 c4 10             	add    $0x10,%esp
  28304e:	89 45 f0             	mov    %eax,-0x10(%ebp)
						sprintf(s,"free %dKB",memman_total(memman)/1024);
  283051:	83 ec 0c             	sub    $0xc,%esp
  283054:	ff 75 c4             	pushl  -0x3c(%ebp)
  283057:	e8 bb ec ff ff       	call   281d17 <memman_total>
  28305c:	83 c4 10             	add    $0x10,%esp
  28305f:	c1 e8 0a             	shr    $0xa,%eax
  283062:	83 ec 04             	sub    $0x4,%esp
  283065:	50                   	push   %eax
  283066:	68 13 3f 28 00       	push   $0x283f13
  28306b:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  283071:	50                   	push   %eax
  283072:	e8 a5 e6 ff ff       	call   28171c <sprintf>
  283077:	83 c4 10             	add    $0x10,%esp
						putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,s,30);
  28307a:	83 ec 04             	sub    $0x4,%esp
  28307d:	6a 1e                	push   $0x1e
  28307f:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  283085:	50                   	push   %eax
  283086:	6a 00                	push   $0x0
  283088:	6a 07                	push   $0x7
  28308a:	ff 75 f0             	pushl  -0x10(%ebp)
  28308d:	6a 08                	push   $0x8
  28308f:	ff 75 08             	pushl  0x8(%ebp)
  283092:	e8 4c e0 ff ff       	call   2810e3 <putfonts8_asc_sht>
  283097:	83 c4 20             	add    $0x20,%esp
						cursor_y = cons_newline(cursor_y,sheet);
  28309a:	83 ec 08             	sub    $0x8,%esp
  28309d:	ff 75 08             	pushl  0x8(%ebp)
  2830a0:	ff 75 f0             	pushl  -0x10(%ebp)
  2830a3:	e8 5c 09 00 00       	call   283a04 <cons_newline>
  2830a8:	83 c4 10             	add    $0x10,%esp
  2830ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
						cursor_y = cons_newline(cursor_y,sheet);
  2830ae:	83 ec 08             	sub    $0x8,%esp
  2830b1:	ff 75 08             	pushl  0x8(%ebp)
  2830b4:	ff 75 f0             	pushl  -0x10(%ebp)
  2830b7:	e8 48 09 00 00       	call   283a04 <cons_newline>
  2830bc:	83 c4 10             	add    $0x10,%esp
  2830bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  2830c2:	e9 5d 08 00 00       	jmp    283924 <console_task+0xbc3>
					}
					else if(strcmp(cmdline,"cls")==0)
  2830c7:	83 ec 08             	sub    $0x8,%esp
  2830ca:	68 1d 3f 28 00       	push   $0x283f1d
  2830cf:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
  2830d5:	50                   	push   %eax
  2830d6:	e8 16 e7 ff ff       	call   2817f1 <strcmp>
  2830db:	83 c4 10             	add    $0x10,%esp
  2830de:	85 c0                	test   %eax,%eax
  2830e0:	75 6f                	jne    283151 <console_task+0x3f0>
					{
						for(int y=28;y<8+128;y++)
  2830e2:	c7 45 e8 1c 00 00 00 	movl   $0x1c,-0x18(%ebp)
  2830e9:	eb 35                	jmp    283120 <console_task+0x3bf>
							for(int x=8;x<8+240;x++)
  2830eb:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%ebp)
  2830f2:	eb 1f                	jmp    283113 <console_task+0x3b2>
								sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  2830f4:	8b 45 08             	mov    0x8(%ebp),%eax
  2830f7:	8b 10                	mov    (%eax),%edx
  2830f9:	8b 45 08             	mov    0x8(%ebp),%eax
  2830fc:	8b 40 04             	mov    0x4(%eax),%eax
  2830ff:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  283103:	89 c1                	mov    %eax,%ecx
  283105:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  283108:	01 c8                	add    %ecx,%eax
  28310a:	01 d0                	add    %edx,%eax
  28310c:	c6 00 00             	movb   $0x0,(%eax)
						cursor_y = cons_newline(cursor_y,sheet);
					}
					else if(strcmp(cmdline,"cls")==0)
					{
						for(int y=28;y<8+128;y++)
							for(int x=8;x<8+240;x++)
  28310f:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  283113:	81 7d e4 f7 00 00 00 	cmpl   $0xf7,-0x1c(%ebp)
  28311a:	7e d8                	jle    2830f4 <console_task+0x393>
						cursor_y = cons_newline(cursor_y,sheet);
						cursor_y = cons_newline(cursor_y,sheet);
					}
					else if(strcmp(cmdline,"cls")==0)
					{
						for(int y=28;y<8+128;y++)
  28311c:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
  283120:	81 7d e8 87 00 00 00 	cmpl   $0x87,-0x18(%ebp)
  283127:	7e c2                	jle    2830eb <console_task+0x38a>
							for(int x=8;x<8+240;x++)
								sheet->buf[x+y*sheet->bxsize] = COL8_000000;
						sheet_refresh(sheet,8,28,8+240,28+128);
  283129:	83 ec 0c             	sub    $0xc,%esp
  28312c:	68 9c 00 00 00       	push   $0x9c
  283131:	68 f8 00 00 00       	push   $0xf8
  283136:	6a 1c                	push   $0x1c
  283138:	6a 08                	push   $0x8
  28313a:	ff 75 08             	pushl  0x8(%ebp)
  28313d:	e8 9f f3 ff ff       	call   2824e1 <sheet_refresh>
  283142:	83 c4 20             	add    $0x20,%esp
						cursor_y = 28;
  283145:	c7 45 f0 1c 00 00 00 	movl   $0x1c,-0x10(%ebp)
  28314c:	e9 d3 07 00 00       	jmp    283924 <console_task+0xbc3>
					}
					else if(strcmp(cmdline,"dir")==0)
  283151:	83 ec 08             	sub    $0x8,%esp
  283154:	68 21 3f 28 00       	push   $0x283f21
  283159:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
  28315f:	50                   	push   %eax
  283160:	e8 8c e6 ff ff       	call   2817f1 <strcmp>
  283165:	83 c4 10             	add    $0x10,%esp
  283168:	85 c0                	test   %eax,%eax
  28316a:	0f 85 48 01 00 00    	jne    2832b8 <console_task+0x557>
					{
						for(int x=0;x<224;x++)
  283170:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  283177:	e9 2a 01 00 00       	jmp    2832a6 <console_task+0x545>
						{
							if(finfo[x].name[0] == 0) break;
  28317c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  28317f:	c1 e0 06             	shl    $0x6,%eax
  283182:	89 c2                	mov    %eax,%edx
  283184:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283187:	01 d0                	add    %edx,%eax
  283189:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  28318d:	84 c0                	test   %al,%al
  28318f:	0f 84 8e 07 00 00    	je     283923 <console_task+0xbc2>
							if(finfo[x].name[0] != 0xe5 &&(finfo[x].type & 0x18) == 0)
  283195:	8b 45 e0             	mov    -0x20(%ebp),%eax
  283198:	c1 e0 06             	shl    $0x6,%eax
  28319b:	89 c2                	mov    %eax,%edx
  28319d:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2831a0:	01 d0                	add    %edx,%eax
  2831a2:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  2831a6:	3c e5                	cmp    $0xe5,%al
  2831a8:	0f 84 f4 00 00 00    	je     2832a2 <console_task+0x541>
  2831ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
  2831b1:	c1 e0 06             	shl    $0x6,%eax
  2831b4:	89 c2                	mov    %eax,%edx
  2831b6:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2831b9:	01 d0                	add    %edx,%eax
  2831bb:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  2831bf:	0f b6 c0             	movzbl %al,%eax
  2831c2:	83 e0 18             	and    $0x18,%eax
  2831c5:	85 c0                	test   %eax,%eax
  2831c7:	0f 85 d5 00 00 00    	jne    2832a2 <console_task+0x541>
							{
								sprintf(s,"filename.ext %d",finfo[x].size);
  2831cd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  2831d0:	c1 e0 06             	shl    $0x6,%eax
  2831d3:	89 c2                	mov    %eax,%edx
  2831d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2831d8:	01 d0                	add    %edx,%eax
  2831da:	8b 40 3c             	mov    0x3c(%eax),%eax
  2831dd:	83 ec 04             	sub    $0x4,%esp
  2831e0:	50                   	push   %eax
  2831e1:	68 25 3f 28 00       	push   $0x283f25
  2831e6:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  2831ec:	50                   	push   %eax
  2831ed:	e8 2a e5 ff ff       	call   28171c <sprintf>
  2831f2:	83 c4 10             	add    $0x10,%esp
								for(int y=0;y<8;y++)
  2831f5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  2831fc:	eb 2b                	jmp    283229 <console_task+0x4c8>
								{
									s[y] = finfo[x].name[y];
  2831fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
  283201:	c1 e0 06             	shl    $0x6,%eax
  283204:	89 c2                	mov    %eax,%edx
  283206:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283209:	01 c2                	add    %eax,%edx
  28320b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  28320e:	01 d0                	add    %edx,%eax
  283210:	83 c0 20             	add    $0x20,%eax
  283213:	0f b6 00             	movzbl (%eax),%eax
  283216:	89 c1                	mov    %eax,%ecx
  283218:	8d 95 76 ff ff ff    	lea    -0x8a(%ebp),%edx
  28321e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  283221:	01 d0                	add    %edx,%eax
  283223:	88 08                	mov    %cl,(%eax)
						{
							if(finfo[x].name[0] == 0) break;
							if(finfo[x].name[0] != 0xe5 &&(finfo[x].type & 0x18) == 0)
							{
								sprintf(s,"filename.ext %d",finfo[x].size);
								for(int y=0;y<8;y++)
  283225:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
  283229:	83 7d dc 07          	cmpl   $0x7,-0x24(%ebp)
  28322d:	7e cf                	jle    2831fe <console_task+0x49d>
								{
									s[y] = finfo[x].name[y];
								}
								s[9]=finfo[x].ext[0];
  28322f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  283232:	c1 e0 06             	shl    $0x6,%eax
  283235:	89 c2                	mov    %eax,%edx
  283237:	8b 45 c0             	mov    -0x40(%ebp),%eax
  28323a:	01 d0                	add    %edx,%eax
  28323c:	0f b6 40 28          	movzbl 0x28(%eax),%eax
  283240:	88 85 7f ff ff ff    	mov    %al,-0x81(%ebp)
								s[10]=finfo[x].ext[1];
  283246:	8b 45 e0             	mov    -0x20(%ebp),%eax
  283249:	c1 e0 06             	shl    $0x6,%eax
  28324c:	89 c2                	mov    %eax,%edx
  28324e:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283251:	01 d0                	add    %edx,%eax
  283253:	0f b6 40 29          	movzbl 0x29(%eax),%eax
  283257:	88 45 80             	mov    %al,-0x80(%ebp)
								s[11]=finfo[x].ext[2];
  28325a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  28325d:	c1 e0 06             	shl    $0x6,%eax
  283260:	89 c2                	mov    %eax,%edx
  283262:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283265:	01 d0                	add    %edx,%eax
  283267:	0f b6 40 2a          	movzbl 0x2a(%eax),%eax
  28326b:	88 45 81             	mov    %al,-0x7f(%ebp)
								putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,s,30);
  28326e:	83 ec 04             	sub    $0x4,%esp
  283271:	6a 1e                	push   $0x1e
  283273:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  283279:	50                   	push   %eax
  28327a:	6a 00                	push   $0x0
  28327c:	6a 07                	push   $0x7
  28327e:	ff 75 f0             	pushl  -0x10(%ebp)
  283281:	6a 08                	push   $0x8
  283283:	ff 75 08             	pushl  0x8(%ebp)
  283286:	e8 58 de ff ff       	call   2810e3 <putfonts8_asc_sht>
  28328b:	83 c4 20             	add    $0x20,%esp
								cursor_y = cons_newline(cursor_y,sheet);
  28328e:	83 ec 08             	sub    $0x8,%esp
  283291:	ff 75 08             	pushl  0x8(%ebp)
  283294:	ff 75 f0             	pushl  -0x10(%ebp)
  283297:	e8 68 07 00 00       	call   283a04 <cons_newline>
  28329c:	83 c4 10             	add    $0x10,%esp
  28329f:	89 45 f0             	mov    %eax,-0x10(%ebp)
						sheet_refresh(sheet,8,28,8+240,28+128);
						cursor_y = 28;
					}
					else if(strcmp(cmdline,"dir")==0)
					{
						for(int x=0;x<224;x++)
  2832a2:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  2832a6:	81 7d e0 df 00 00 00 	cmpl   $0xdf,-0x20(%ebp)
  2832ad:	0f 8e c9 fe ff ff    	jle    28317c <console_task+0x41b>
  2832b3:	e9 6c 06 00 00       	jmp    283924 <console_task+0xbc3>
								putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,s,30);
								cursor_y = cons_newline(cursor_y,sheet);
							}
						}
					}
					else if(strncmp(cmdline,"type ",5) == 0)
  2832b8:	83 ec 04             	sub    $0x4,%esp
  2832bb:	6a 05                	push   $0x5
  2832bd:	68 35 3f 28 00       	push   $0x283f35
  2832c2:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
  2832c8:	50                   	push   %eax
  2832c9:	e8 89 e5 ff ff       	call   281857 <strncmp>
  2832ce:	83 c4 10             	add    $0x10,%esp
  2832d1:	85 c0                	test   %eax,%eax
  2832d3:	0f 85 b6 03 00 00    	jne    28368f <console_task+0x92e>
					{
						int x,y;
						for(y = 0;y < 11;y++)
  2832d9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  2832e0:	eb 12                	jmp    2832f4 <console_task+0x593>
						{
							s[y] = ' ';
  2832e2:	8d 95 76 ff ff ff    	lea    -0x8a(%ebp),%edx
  2832e8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  2832eb:	01 d0                	add    %edx,%eax
  2832ed:	c6 00 20             	movb   $0x20,(%eax)
						}
					}
					else if(strncmp(cmdline,"type ",5) == 0)
					{
						int x,y;
						for(y = 0;y < 11;y++)
  2832f0:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
  2832f4:	83 7d d4 0a          	cmpl   $0xa,-0x2c(%ebp)
  2832f8:	7e e8                	jle    2832e2 <console_task+0x581>
						{
							s[y] = ' ';
						}
						y=0;
  2832fa:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
						for(x=5;y<11&&cmdline[x]!=0;x++)
  283301:	c7 45 d8 05 00 00 00 	movl   $0x5,-0x28(%ebp)
  283308:	e9 88 00 00 00       	jmp    283395 <console_task+0x634>
						{
							if(cmdline[x] == '.' && y <= 8) y = 8;
  28330d:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
  283313:	8b 45 d8             	mov    -0x28(%ebp),%eax
  283316:	01 d0                	add    %edx,%eax
  283318:	0f b6 00             	movzbl (%eax),%eax
  28331b:	3c 2e                	cmp    $0x2e,%al
  28331d:	75 0f                	jne    28332e <console_task+0x5cd>
  28331f:	83 7d d4 08          	cmpl   $0x8,-0x2c(%ebp)
  283323:	7f 09                	jg     28332e <console_task+0x5cd>
  283325:	c7 45 d4 08 00 00 00 	movl   $0x8,-0x2c(%ebp)
  28332c:	eb 63                	jmp    283391 <console_task+0x630>
							else 
							{
								s[y] = cmdline[x];
  28332e:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
  283334:	8b 45 d8             	mov    -0x28(%ebp),%eax
  283337:	01 d0                	add    %edx,%eax
  283339:	0f b6 00             	movzbl (%eax),%eax
  28333c:	8d 8d 76 ff ff ff    	lea    -0x8a(%ebp),%ecx
  283342:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  283345:	01 ca                	add    %ecx,%edx
  283347:	88 02                	mov    %al,(%edx)
								if('a'<=s[y] && s[y]<='z')
  283349:	8d 95 76 ff ff ff    	lea    -0x8a(%ebp),%edx
  28334f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283352:	01 d0                	add    %edx,%eax
  283354:	0f b6 00             	movzbl (%eax),%eax
  283357:	3c 60                	cmp    $0x60,%al
  283359:	7e 32                	jle    28338d <console_task+0x62c>
  28335b:	8d 95 76 ff ff ff    	lea    -0x8a(%ebp),%edx
  283361:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283364:	01 d0                	add    %edx,%eax
  283366:	0f b6 00             	movzbl (%eax),%eax
  283369:	3c 7a                	cmp    $0x7a,%al
  28336b:	7f 20                	jg     28338d <console_task+0x62c>
								{
									s[y] -= 0x20;
  28336d:	8d 95 76 ff ff ff    	lea    -0x8a(%ebp),%edx
  283373:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283376:	01 d0                	add    %edx,%eax
  283378:	0f b6 00             	movzbl (%eax),%eax
  28337b:	83 e8 20             	sub    $0x20,%eax
  28337e:	89 c1                	mov    %eax,%ecx
  283380:	8d 95 76 ff ff ff    	lea    -0x8a(%ebp),%edx
  283386:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283389:	01 d0                	add    %edx,%eax
  28338b:	88 08                	mov    %cl,(%eax)
								}
								y++;
  28338d:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
						for(y = 0;y < 11;y++)
						{
							s[y] = ' ';
						}
						y=0;
						for(x=5;y<11&&cmdline[x]!=0;x++)
  283391:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  283395:	83 7d d4 0a          	cmpl   $0xa,-0x2c(%ebp)
  283399:	7f 16                	jg     2833b1 <console_task+0x650>
  28339b:	8d 95 58 ff ff ff    	lea    -0xa8(%ebp),%edx
  2833a1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2833a4:	01 d0                	add    %edx,%eax
  2833a6:	0f b6 00             	movzbl (%eax),%eax
  2833a9:	84 c0                	test   %al,%al
  2833ab:	0f 85 5c ff ff ff    	jne    28330d <console_task+0x5ac>
									s[y] -= 0x20;
								}
								y++;
							}
						}
						for(x=0;x<224;)
  2833b1:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  2833b8:	e9 87 00 00 00       	jmp    283444 <console_task+0x6e3>
						{
							y = 0;
  2833bd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
							if(finfo[x].name[0]==0) break;
  2833c4:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2833c7:	c1 e0 06             	shl    $0x6,%eax
  2833ca:	89 c2                	mov    %eax,%edx
  2833cc:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2833cf:	01 d0                	add    %edx,%eax
  2833d1:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  2833d5:	84 c0                	test   %al,%al
  2833d7:	74 7a                	je     283453 <console_task+0x6f2>
							if((finfo[x].type & 0x18)==0)
  2833d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2833dc:	c1 e0 06             	shl    $0x6,%eax
  2833df:	89 c2                	mov    %eax,%edx
  2833e1:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2833e4:	01 d0                	add    %edx,%eax
  2833e6:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  2833ea:	0f b6 c0             	movzbl %al,%eax
  2833ed:	83 e0 18             	and    $0x18,%eax
  2833f0:	85 c0                	test   %eax,%eax
  2833f2:	75 46                	jne    28343a <console_task+0x6d9>
							{
								for(y=0;y<11;y++)
  2833f4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  2833fb:	eb 34                	jmp    283431 <console_task+0x6d0>
								{
									if(finfo[x].name[y]!=s[y])
  2833fd:	8b 45 d8             	mov    -0x28(%ebp),%eax
  283400:	c1 e0 06             	shl    $0x6,%eax
  283403:	89 c2                	mov    %eax,%edx
  283405:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283408:	01 c2                	add    %eax,%edx
  28340a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  28340d:	01 d0                	add    %edx,%eax
  28340f:	83 c0 20             	add    $0x20,%eax
  283412:	0f b6 00             	movzbl (%eax),%eax
  283415:	0f b6 d0             	movzbl %al,%edx
  283418:	8d 8d 76 ff ff ff    	lea    -0x8a(%ebp),%ecx
  28341e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283421:	01 c8                	add    %ecx,%eax
  283423:	0f b6 00             	movzbl (%eax),%eax
  283426:	0f be c0             	movsbl %al,%eax
  283429:	39 c2                	cmp    %eax,%edx
  28342b:	75 0c                	jne    283439 <console_task+0x6d8>
						{
							y = 0;
							if(finfo[x].name[0]==0) break;
							if((finfo[x].type & 0x18)==0)
							{
								for(y=0;y<11;y++)
  28342d:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
  283431:	83 7d d4 0a          	cmpl   $0xa,-0x2c(%ebp)
  283435:	7e c6                	jle    2833fd <console_task+0x69c>
  283437:	eb 01                	jmp    28343a <console_task+0x6d9>
								{
									if(finfo[x].name[y]!=s[y])
									{
										break;
  283439:	90                   	nop
									}
								}
							}
							if(y>10)
  28343a:	83 7d d4 0a          	cmpl   $0xa,-0x2c(%ebp)
  28343e:	7f 16                	jg     283456 <console_task+0x6f5>
							{ 
								break;
							}
							x++;
  283440:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
									s[y] -= 0x20;
								}
								y++;
							}
						}
						for(x=0;x<224;)
  283444:	81 7d d8 df 00 00 00 	cmpl   $0xdf,-0x28(%ebp)
  28344b:	0f 8e 6c ff ff ff    	jle    2833bd <console_task+0x65c>
  283451:	eb 04                	jmp    283457 <console_task+0x6f6>
						{
							y = 0;
							if(finfo[x].name[0]==0) break;
  283453:	90                   	nop
  283454:	eb 01                	jmp    283457 <console_task+0x6f6>
									}
								}
							}
							if(y>10)
							{ 
								break;
  283456:	90                   	nop
							}
							x++;
						}
						if(x<224 && finfo[x].name[0]!=0)
  283457:	81 7d d8 df 00 00 00 	cmpl   $0xdf,-0x28(%ebp)
  28345e:	0f 8f cc 01 00 00    	jg     283630 <console_task+0x8cf>
  283464:	8b 45 d8             	mov    -0x28(%ebp),%eax
  283467:	c1 e0 06             	shl    $0x6,%eax
  28346a:	89 c2                	mov    %eax,%edx
  28346c:	8b 45 c0             	mov    -0x40(%ebp),%eax
  28346f:	01 d0                	add    %edx,%eax
  283471:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  283475:	84 c0                	test   %al,%al
  283477:	0f 84 b3 01 00 00    	je     283630 <console_task+0x8cf>
						{
							//file found!
							char *p = (char *)memman_alloc_4k(memman,finfo[x].size);
  28347d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  283480:	c1 e0 06             	shl    $0x6,%eax
  283483:	89 c2                	mov    %eax,%edx
  283485:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283488:	01 d0                	add    %edx,%eax
  28348a:	8b 40 3c             	mov    0x3c(%eax),%eax
  28348d:	83 ec 08             	sub    $0x8,%esp
  283490:	50                   	push   %eax
  283491:	ff 75 c4             	pushl  -0x3c(%ebp)
  283494:	e8 f3 eb ff ff       	call   28208c <memman_alloc_4k>
  283499:	83 c4 10             	add    $0x10,%esp
  28349c:	89 45 ac             	mov    %eax,-0x54(%ebp)
							file_loadfile(finfo[x].clustno,finfo[x].size,p,fat,(char *)(ADR_DISKIMG+0x003e00));
  28349f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2834a2:	c1 e0 06             	shl    $0x6,%eax
  2834a5:	89 c2                	mov    %eax,%edx
  2834a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2834aa:	01 d0                	add    %edx,%eax
  2834ac:	8b 40 3c             	mov    0x3c(%eax),%eax
  2834af:	89 c1                	mov    %eax,%ecx
  2834b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2834b4:	c1 e0 06             	shl    $0x6,%eax
  2834b7:	89 c2                	mov    %eax,%edx
  2834b9:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2834bc:	01 d0                	add    %edx,%eax
  2834be:	0f b7 40 3a          	movzwl 0x3a(%eax),%eax
  2834c2:	0f b7 c0             	movzwl %ax,%eax
  2834c5:	83 ec 0c             	sub    $0xc,%esp
  2834c8:	68 00 3e 10 00       	push   $0x103e00
  2834cd:	ff 75 b4             	pushl  -0x4c(%ebp)
  2834d0:	ff 75 ac             	pushl  -0x54(%ebp)
  2834d3:	51                   	push   %ecx
  2834d4:	50                   	push   %eax
  2834d5:	e8 5d 06 00 00       	call   283b37 <file_loadfile>
  2834da:	83 c4 20             	add    $0x20,%esp
							cursor_x = 8;
  2834dd:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
							for(y=0;y<finfo[x].size;y++)
  2834e4:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  2834eb:	e9 00 01 00 00       	jmp    2835f0 <console_task+0x88f>
							{
								s[0] = p[y];
  2834f0:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  2834f3:	8b 45 ac             	mov    -0x54(%ebp),%eax
  2834f6:	01 d0                	add    %edx,%eax
  2834f8:	0f b6 00             	movzbl (%eax),%eax
  2834fb:	88 85 76 ff ff ff    	mov    %al,-0x8a(%ebp)
								s[1] = 0;
  283501:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
								if(s[0] == 0x09) //tab
  283508:	0f b6 85 76 ff ff ff 	movzbl -0x8a(%ebp),%eax
  28350f:	3c 09                	cmp    $0x9,%al
  283511:	75 5a                	jne    28356d <console_task+0x80c>
								{
									for(;;)
									{
										putfonts8_asc_sht(sheet,cursor_x,cursor_y,COL8_FFFFFF,COL8_000000," ",1);
  283513:	83 ec 04             	sub    $0x4,%esp
  283516:	6a 01                	push   $0x1
  283518:	68 02 3f 28 00       	push   $0x283f02
  28351d:	6a 00                	push   $0x0
  28351f:	6a 07                	push   $0x7
  283521:	ff 75 f0             	pushl  -0x10(%ebp)
  283524:	ff 75 f4             	pushl  -0xc(%ebp)
  283527:	ff 75 08             	pushl  0x8(%ebp)
  28352a:	e8 b4 db ff ff       	call   2810e3 <putfonts8_asc_sht>
  28352f:	83 c4 20             	add    $0x20,%esp
										cursor_x += 8;
  283532:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
										if(cursor_x == 8+240)
  283536:	81 7d f4 f8 00 00 00 	cmpl   $0xf8,-0xc(%ebp)
  28353d:	75 1b                	jne    28355a <console_task+0x7f9>
										{
											cursor_x = 8;
  28353f:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
											cursor_y = cons_newline(cursor_y,sheet);
  283546:	83 ec 08             	sub    $0x8,%esp
  283549:	ff 75 08             	pushl  0x8(%ebp)
  28354c:	ff 75 f0             	pushl  -0x10(%ebp)
  28354f:	e8 b0 04 00 00       	call   283a04 <cons_newline>
  283554:	83 c4 10             	add    $0x10,%esp
  283557:	89 45 f0             	mov    %eax,-0x10(%ebp)
										}
										if(((cursor_x -8) & 0x1f) == 0)
  28355a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28355d:	83 e8 08             	sub    $0x8,%eax
  283560:	83 e0 1f             	and    $0x1f,%eax
  283563:	85 c0                	test   %eax,%eax
  283565:	0f 84 80 00 00 00    	je     2835eb <console_task+0x88a>
										{
											break;
										}
									}
  28356b:	eb a6                	jmp    283513 <console_task+0x7b2>
								}
								else if(s[0] == 0x0a) //change line
  28356d:	0f b6 85 76 ff ff ff 	movzbl -0x8a(%ebp),%eax
  283574:	3c 0a                	cmp    $0xa,%al
  283576:	75 1d                	jne    283595 <console_task+0x834>
								{
									cursor_x = 8;
  283578:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
									cursor_y = cons_newline(cursor_y,sheet);
  28357f:	83 ec 08             	sub    $0x8,%esp
  283582:	ff 75 08             	pushl  0x8(%ebp)
  283585:	ff 75 f0             	pushl  -0x10(%ebp)
  283588:	e8 77 04 00 00       	call   283a04 <cons_newline>
  28358d:	83 c4 10             	add    $0x10,%esp
  283590:	89 45 f0             	mov    %eax,-0x10(%ebp)
  283593:	eb 57                	jmp    2835ec <console_task+0x88b>
								}
								else if(s[0] == 0x0d) //return key
  283595:	0f b6 85 76 ff ff ff 	movzbl -0x8a(%ebp),%eax
  28359c:	3c 0d                	cmp    $0xd,%al
  28359e:	74 4c                	je     2835ec <console_task+0x88b>
								{
									//todo
								}
								else
								{
									putfonts8_asc_sht(sheet,cursor_x,cursor_y,COL8_FFFFFF,COL8_000000,s,1);
  2835a0:	83 ec 04             	sub    $0x4,%esp
  2835a3:	6a 01                	push   $0x1
  2835a5:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  2835ab:	50                   	push   %eax
  2835ac:	6a 00                	push   $0x0
  2835ae:	6a 07                	push   $0x7
  2835b0:	ff 75 f0             	pushl  -0x10(%ebp)
  2835b3:	ff 75 f4             	pushl  -0xc(%ebp)
  2835b6:	ff 75 08             	pushl  0x8(%ebp)
  2835b9:	e8 25 db ff ff       	call   2810e3 <putfonts8_asc_sht>
  2835be:	83 c4 20             	add    $0x20,%esp
									cursor_x += 8;
  2835c1:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
									if(cursor_x == 8+240)
  2835c5:	81 7d f4 f8 00 00 00 	cmpl   $0xf8,-0xc(%ebp)
  2835cc:	75 1e                	jne    2835ec <console_task+0x88b>
									{
										cursor_x = 8;
  2835ce:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
										cursor_y = cons_newline(cursor_y,sheet);
  2835d5:	83 ec 08             	sub    $0x8,%esp
  2835d8:	ff 75 08             	pushl  0x8(%ebp)
  2835db:	ff 75 f0             	pushl  -0x10(%ebp)
  2835de:	e8 21 04 00 00       	call   283a04 <cons_newline>
  2835e3:	83 c4 10             	add    $0x10,%esp
  2835e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  2835e9:	eb 01                	jmp    2835ec <console_task+0x88b>
											cursor_x = 8;
											cursor_y = cons_newline(cursor_y,sheet);
										}
										if(((cursor_x -8) & 0x1f) == 0)
										{
											break;
  2835eb:	90                   	nop
						{
							//file found!
							char *p = (char *)memman_alloc_4k(memman,finfo[x].size);
							file_loadfile(finfo[x].clustno,finfo[x].size,p,fat,(char *)(ADR_DISKIMG+0x003e00));
							cursor_x = 8;
							for(y=0;y<finfo[x].size;y++)
  2835ec:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
  2835f0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2835f3:	c1 e0 06             	shl    $0x6,%eax
  2835f6:	89 c2                	mov    %eax,%edx
  2835f8:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2835fb:	01 d0                	add    %edx,%eax
  2835fd:	8b 50 3c             	mov    0x3c(%eax),%edx
  283600:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283603:	39 c2                	cmp    %eax,%edx
  283605:	0f 87 e5 fe ff ff    	ja     2834f0 <console_task+0x78f>
										cursor_x = 8;
										cursor_y = cons_newline(cursor_y,sheet);
									}	
								}
							}
							memman_free_4k(memman,(int)p,finfo[x].size);
  28360b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  28360e:	c1 e0 06             	shl    $0x6,%eax
  283611:	89 c2                	mov    %eax,%edx
  283613:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283616:	01 d0                	add    %edx,%eax
  283618:	8b 50 3c             	mov    0x3c(%eax),%edx
  28361b:	8b 45 ac             	mov    -0x54(%ebp),%eax
  28361e:	83 ec 04             	sub    $0x4,%esp
  283621:	52                   	push   %edx
  283622:	50                   	push   %eax
  283623:	ff 75 c4             	pushl  -0x3c(%ebp)
  283626:	e8 8d ea ff ff       	call   2820b8 <memman_free_4k>
  28362b:	83 c4 10             	add    $0x10,%esp
								break;
							}
							x++;
						}
						if(x<224 && finfo[x].name[0]!=0)
						{
  28362e:	eb 46                	jmp    283676 <console_task+0x915>
							}
							memman_free_4k(memman,(int)p,finfo[x].size);
						}
						else
						{
							putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,"File not found.",15);
  283630:	83 ec 04             	sub    $0x4,%esp
  283633:	6a 0f                	push   $0xf
  283635:	68 3b 3f 28 00       	push   $0x283f3b
  28363a:	6a 00                	push   $0x0
  28363c:	6a 07                	push   $0x7
  28363e:	ff 75 f0             	pushl  -0x10(%ebp)
  283641:	6a 08                	push   $0x8
  283643:	ff 75 08             	pushl  0x8(%ebp)
  283646:	e8 98 da ff ff       	call   2810e3 <putfonts8_asc_sht>
  28364b:	83 c4 20             	add    $0x20,%esp
							cursor_y = cons_newline(cursor_y,sheet);
  28364e:	83 ec 08             	sub    $0x8,%esp
  283651:	ff 75 08             	pushl  0x8(%ebp)
  283654:	ff 75 f0             	pushl  -0x10(%ebp)
  283657:	e8 a8 03 00 00       	call   283a04 <cons_newline>
  28365c:	83 c4 10             	add    $0x10,%esp
  28365f:	89 45 f0             	mov    %eax,-0x10(%ebp)
							cursor_y = cons_newline(cursor_y,sheet);
  283662:	83 ec 08             	sub    $0x8,%esp
  283665:	ff 75 08             	pushl  0x8(%ebp)
  283668:	ff 75 f0             	pushl  -0x10(%ebp)
  28366b:	e8 94 03 00 00       	call   283a04 <cons_newline>
  283670:	83 c4 10             	add    $0x10,%esp
  283673:	89 45 f0             	mov    %eax,-0x10(%ebp)
						}
						cursor_y = cons_newline(cursor_y,sheet);
  283676:	83 ec 08             	sub    $0x8,%esp
  283679:	ff 75 08             	pushl  0x8(%ebp)
  28367c:	ff 75 f0             	pushl  -0x10(%ebp)
  28367f:	e8 80 03 00 00       	call   283a04 <cons_newline>
  283684:	83 c4 10             	add    $0x10,%esp
  283687:	89 45 f0             	mov    %eax,-0x10(%ebp)
  28368a:	e9 95 02 00 00       	jmp    283924 <console_task+0xbc3>
					}
					else if(strcmp(cmdline,"hlt") == 0)
  28368f:	83 ec 08             	sub    $0x8,%esp
  283692:	68 4b 3f 28 00       	push   $0x283f4b
  283697:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
  28369d:	50                   	push   %eax
  28369e:	e8 4e e1 ff ff       	call   2817f1 <strcmp>
  2836a3:	83 c4 10             	add    $0x10,%esp
  2836a6:	85 c0                	test   %eax,%eax
  2836a8:	0f 85 22 02 00 00    	jne    2838d0 <console_task+0xb6f>
					{
						int x,y;
						for(y=0;y<11;y++)
  2836ae:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  2836b5:	eb 12                	jmp    2836c9 <console_task+0x968>
							s[y] = ' ';
  2836b7:	8d 95 76 ff ff ff    	lea    -0x8a(%ebp),%edx
  2836bd:	8b 45 cc             	mov    -0x34(%ebp),%eax
  2836c0:	01 d0                	add    %edx,%eax
  2836c2:	c6 00 20             	movb   $0x20,(%eax)
						cursor_y = cons_newline(cursor_y,sheet);
					}
					else if(strcmp(cmdline,"hlt") == 0)
					{
						int x,y;
						for(y=0;y<11;y++)
  2836c5:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
  2836c9:	83 7d cc 0a          	cmpl   $0xa,-0x34(%ebp)
  2836cd:	7e e8                	jle    2836b7 <console_task+0x956>
							s[y] = ' ';
						s[0] = 'H';
  2836cf:	c6 85 76 ff ff ff 48 	movb   $0x48,-0x8a(%ebp)
						s[1] = 'L';
  2836d6:	c6 85 77 ff ff ff 4c 	movb   $0x4c,-0x89(%ebp)
						s[2] = 'T';
  2836dd:	c6 85 78 ff ff ff 54 	movb   $0x54,-0x88(%ebp)
						s[8] = 'B';
  2836e4:	c6 85 7e ff ff ff 42 	movb   $0x42,-0x82(%ebp)
						s[9] = 'I';
  2836eb:	c6 85 7f ff ff ff 49 	movb   $0x49,-0x81(%ebp)
						s[10] = 'N';
  2836f2:	c6 45 80 4e          	movb   $0x4e,-0x80(%ebp)
						for(x=0;x<224;)
  2836f6:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  2836fd:	e9 87 00 00 00       	jmp    283789 <console_task+0xa28>
						{
							y=0;
  283702:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
							if(finfo[x].name[0] == 0x00) break;
  283709:	8b 45 d0             	mov    -0x30(%ebp),%eax
  28370c:	c1 e0 06             	shl    $0x6,%eax
  28370f:	89 c2                	mov    %eax,%edx
  283711:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283714:	01 d0                	add    %edx,%eax
  283716:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  28371a:	84 c0                	test   %al,%al
  28371c:	74 7a                	je     283798 <console_task+0xa37>
							if((finfo[x].type & 0x18)==0)
  28371e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  283721:	c1 e0 06             	shl    $0x6,%eax
  283724:	89 c2                	mov    %eax,%edx
  283726:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283729:	01 d0                	add    %edx,%eax
  28372b:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  28372f:	0f b6 c0             	movzbl %al,%eax
  283732:	83 e0 18             	and    $0x18,%eax
  283735:	85 c0                	test   %eax,%eax
  283737:	75 46                	jne    28377f <console_task+0xa1e>
							{
								for(y=0;y<11;y++)
  283739:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  283740:	eb 34                	jmp    283776 <console_task+0xa15>
								{
									if(finfo[x].name[y]!=s[y])
  283742:	8b 45 d0             	mov    -0x30(%ebp),%eax
  283745:	c1 e0 06             	shl    $0x6,%eax
  283748:	89 c2                	mov    %eax,%edx
  28374a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  28374d:	01 c2                	add    %eax,%edx
  28374f:	8b 45 cc             	mov    -0x34(%ebp),%eax
  283752:	01 d0                	add    %edx,%eax
  283754:	83 c0 20             	add    $0x20,%eax
  283757:	0f b6 00             	movzbl (%eax),%eax
  28375a:	0f b6 d0             	movzbl %al,%edx
  28375d:	8d 8d 76 ff ff ff    	lea    -0x8a(%ebp),%ecx
  283763:	8b 45 cc             	mov    -0x34(%ebp),%eax
  283766:	01 c8                	add    %ecx,%eax
  283768:	0f b6 00             	movzbl (%eax),%eax
  28376b:	0f be c0             	movsbl %al,%eax
  28376e:	39 c2                	cmp    %eax,%edx
  283770:	75 0c                	jne    28377e <console_task+0xa1d>
						{
							y=0;
							if(finfo[x].name[0] == 0x00) break;
							if((finfo[x].type & 0x18)==0)
							{
								for(y=0;y<11;y++)
  283772:	83 45 cc 01          	addl   $0x1,-0x34(%ebp)
  283776:	83 7d cc 0a          	cmpl   $0xa,-0x34(%ebp)
  28377a:	7e c6                	jle    283742 <console_task+0x9e1>
  28377c:	eb 01                	jmp    28377f <console_task+0xa1e>
								{
									if(finfo[x].name[y]!=s[y])
									{
										break;
  28377e:	90                   	nop
									}
								}
							}
							if(y>10)
  28377f:	83 7d cc 0a          	cmpl   $0xa,-0x34(%ebp)
  283783:	7f 16                	jg     28379b <console_task+0xa3a>
							{ 
								break;
							}
							x++;
  283785:	83 45 d0 01          	addl   $0x1,-0x30(%ebp)
						s[1] = 'L';
						s[2] = 'T';
						s[8] = 'B';
						s[9] = 'I';
						s[10] = 'N';
						for(x=0;x<224;)
  283789:	81 7d d0 df 00 00 00 	cmpl   $0xdf,-0x30(%ebp)
  283790:	0f 8e 6c ff ff ff    	jle    283702 <console_task+0x9a1>
  283796:	eb 04                	jmp    28379c <console_task+0xa3b>
						{
							y=0;
							if(finfo[x].name[0] == 0x00) break;
  283798:	90                   	nop
  283799:	eb 01                	jmp    28379c <console_task+0xa3b>
									}
								}
							}
							if(y>10)
							{ 
								break;
  28379b:	90                   	nop
							}
							x++;
						}
						if(x<224 && finfo[x].name[0] != 0x00)
  28379c:	81 7d d0 df 00 00 00 	cmpl   $0xdf,-0x30(%ebp)
  2837a3:	0f 8f df 00 00 00    	jg     283888 <console_task+0xb27>
  2837a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
  2837ac:	c1 e0 06             	shl    $0x6,%eax
  2837af:	89 c2                	mov    %eax,%edx
  2837b1:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2837b4:	01 d0                	add    %edx,%eax
  2837b6:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  2837ba:	84 c0                	test   %al,%al
  2837bc:	0f 84 c6 00 00 00    	je     283888 <console_task+0xb27>
						{
							char *p = (char *)memman_alloc_4k(memman,finfo[x].size);
  2837c2:	8b 45 d0             	mov    -0x30(%ebp),%eax
  2837c5:	c1 e0 06             	shl    $0x6,%eax
  2837c8:	89 c2                	mov    %eax,%edx
  2837ca:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2837cd:	01 d0                	add    %edx,%eax
  2837cf:	8b 40 3c             	mov    0x3c(%eax),%eax
  2837d2:	83 ec 08             	sub    $0x8,%esp
  2837d5:	50                   	push   %eax
  2837d6:	ff 75 c4             	pushl  -0x3c(%ebp)
  2837d9:	e8 ae e8 ff ff       	call   28208c <memman_alloc_4k>
  2837de:	83 c4 10             	add    $0x10,%esp
  2837e1:	89 45 a8             	mov    %eax,-0x58(%ebp)
							file_loadfile(finfo[x].clustno,finfo[x].size,p,fat,(char *)(ADR_DISKIMG + 0x003e00));
  2837e4:	8b 45 d0             	mov    -0x30(%ebp),%eax
  2837e7:	c1 e0 06             	shl    $0x6,%eax
  2837ea:	89 c2                	mov    %eax,%edx
  2837ec:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2837ef:	01 d0                	add    %edx,%eax
  2837f1:	8b 40 3c             	mov    0x3c(%eax),%eax
  2837f4:	89 c1                	mov    %eax,%ecx
  2837f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
  2837f9:	c1 e0 06             	shl    $0x6,%eax
  2837fc:	89 c2                	mov    %eax,%edx
  2837fe:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283801:	01 d0                	add    %edx,%eax
  283803:	0f b7 40 3a          	movzwl 0x3a(%eax),%eax
  283807:	0f b7 c0             	movzwl %ax,%eax
  28380a:	83 ec 0c             	sub    $0xc,%esp
  28380d:	68 00 3e 10 00       	push   $0x103e00
  283812:	ff 75 b4             	pushl  -0x4c(%ebp)
  283815:	ff 75 a8             	pushl  -0x58(%ebp)
  283818:	51                   	push   %ecx
  283819:	50                   	push   %eax
  28381a:	e8 18 03 00 00       	call   283b37 <file_loadfile>
  28381f:	83 c4 20             	add    $0x20,%esp
							set_segmdesc(gdt + 1003,finfo[x].size-1,(int)p,AR_CODE32_ER);
  283822:	8b 45 a8             	mov    -0x58(%ebp),%eax
  283825:	8b 55 d0             	mov    -0x30(%ebp),%edx
  283828:	89 d1                	mov    %edx,%ecx
  28382a:	c1 e1 06             	shl    $0x6,%ecx
  28382d:	8b 55 c0             	mov    -0x40(%ebp),%edx
  283830:	01 ca                	add    %ecx,%edx
  283832:	8b 52 3c             	mov    0x3c(%edx),%edx
  283835:	8d 4a ff             	lea    -0x1(%edx),%ecx
  283838:	8b 55 bc             	mov    -0x44(%ebp),%edx
  28383b:	81 c2 58 1f 00 00    	add    $0x1f58,%edx
  283841:	68 9a 40 00 00       	push   $0x409a
  283846:	50                   	push   %eax
  283847:	51                   	push   %ecx
  283848:	52                   	push   %edx
  283849:	e8 d9 da ff ff       	call   281327 <set_segmdesc>
  28384e:	83 c4 10             	add    $0x10,%esp
							farjmp(0,1003*8);
  283851:	83 ec 08             	sub    $0x8,%esp
  283854:	68 58 1f 00 00       	push   $0x1f58
  283859:	6a 00                	push   $0x0
  28385b:	e8 56 f0 ff ff       	call   2828b6 <farjmp>
  283860:	83 c4 10             	add    $0x10,%esp
							memman_free_4k(memman,(int)p,finfo[x].size);
  283863:	8b 45 d0             	mov    -0x30(%ebp),%eax
  283866:	c1 e0 06             	shl    $0x6,%eax
  283869:	89 c2                	mov    %eax,%edx
  28386b:	8b 45 c0             	mov    -0x40(%ebp),%eax
  28386e:	01 d0                	add    %edx,%eax
  283870:	8b 50 3c             	mov    0x3c(%eax),%edx
  283873:	8b 45 a8             	mov    -0x58(%ebp),%eax
  283876:	83 ec 04             	sub    $0x4,%esp
  283879:	52                   	push   %edx
  28387a:	50                   	push   %eax
  28387b:	ff 75 c4             	pushl  -0x3c(%ebp)
  28387e:	e8 35 e8 ff ff       	call   2820b8 <memman_free_4k>
  283883:	83 c4 10             	add    $0x10,%esp
								break;
							}
							x++;
						}
						if(x<224 && finfo[x].name[0] != 0x00)
						{
  283886:	eb 32                	jmp    2838ba <console_task+0xb59>
							farjmp(0,1003*8);
							memman_free_4k(memman,(int)p,finfo[x].size);
						}
						else
						{
							putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,"hlt not found.",15);
  283888:	83 ec 04             	sub    $0x4,%esp
  28388b:	6a 0f                	push   $0xf
  28388d:	68 4f 3f 28 00       	push   $0x283f4f
  283892:	6a 00                	push   $0x0
  283894:	6a 07                	push   $0x7
  283896:	ff 75 f0             	pushl  -0x10(%ebp)
  283899:	6a 08                	push   $0x8
  28389b:	ff 75 08             	pushl  0x8(%ebp)
  28389e:	e8 40 d8 ff ff       	call   2810e3 <putfonts8_asc_sht>
  2838a3:	83 c4 20             	add    $0x20,%esp
							cursor_y = cons_newline(cursor_y,sheet);
  2838a6:	83 ec 08             	sub    $0x8,%esp
  2838a9:	ff 75 08             	pushl  0x8(%ebp)
  2838ac:	ff 75 f0             	pushl  -0x10(%ebp)
  2838af:	e8 50 01 00 00       	call   283a04 <cons_newline>
  2838b4:	83 c4 10             	add    $0x10,%esp
  2838b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
						}
						cursor_y = cons_newline(cursor_y,sheet);
  2838ba:	83 ec 08             	sub    $0x8,%esp
  2838bd:	ff 75 08             	pushl  0x8(%ebp)
  2838c0:	ff 75 f0             	pushl  -0x10(%ebp)
  2838c3:	e8 3c 01 00 00       	call   283a04 <cons_newline>
  2838c8:	83 c4 10             	add    $0x10,%esp
  2838cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  2838ce:	eb 54                	jmp    283924 <console_task+0xbc3>
					}
					else if(cmdline[0]!=0)
  2838d0:	0f b6 85 58 ff ff ff 	movzbl -0xa8(%ebp),%eax
  2838d7:	84 c0                	test   %al,%al
  2838d9:	74 49                	je     283924 <console_task+0xbc3>
					{
						putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,"Bad command.",12);
  2838db:	83 ec 04             	sub    $0x4,%esp
  2838de:	6a 0c                	push   $0xc
  2838e0:	68 5e 3f 28 00       	push   $0x283f5e
  2838e5:	6a 00                	push   $0x0
  2838e7:	6a 07                	push   $0x7
  2838e9:	ff 75 f0             	pushl  -0x10(%ebp)
  2838ec:	6a 08                	push   $0x8
  2838ee:	ff 75 08             	pushl  0x8(%ebp)
  2838f1:	e8 ed d7 ff ff       	call   2810e3 <putfonts8_asc_sht>
  2838f6:	83 c4 20             	add    $0x20,%esp
						cursor_y = cons_newline(cursor_y,sheet);
  2838f9:	83 ec 08             	sub    $0x8,%esp
  2838fc:	ff 75 08             	pushl  0x8(%ebp)
  2838ff:	ff 75 f0             	pushl  -0x10(%ebp)
  283902:	e8 fd 00 00 00       	call   283a04 <cons_newline>
  283907:	83 c4 10             	add    $0x10,%esp
  28390a:	89 45 f0             	mov    %eax,-0x10(%ebp)
						cursor_y = cons_newline(cursor_y,sheet);
  28390d:	83 ec 08             	sub    $0x8,%esp
  283910:	ff 75 08             	pushl  0x8(%ebp)
  283913:	ff 75 f0             	pushl  -0x10(%ebp)
  283916:	e8 e9 00 00 00       	call   283a04 <cons_newline>
  28391b:	83 c4 10             	add    $0x10,%esp
  28391e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  283921:	eb 01                	jmp    283924 <console_task+0xbc3>
					}
					else if(strcmp(cmdline,"dir")==0)
					{
						for(int x=0;x<224;x++)
						{
							if(finfo[x].name[0] == 0) break;
  283923:	90                   	nop
					{
						putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,"Bad command.",12);
						cursor_y = cons_newline(cursor_y,sheet);
						cursor_y = cons_newline(cursor_y,sheet);
					}
					putfonts8_asc_sht(sheet,8,cursor_y,COL8_FFFFFF,COL8_000000,">",1);
  283924:	83 ec 04             	sub    $0x4,%esp
  283927:	6a 01                	push   $0x1
  283929:	68 00 3f 28 00       	push   $0x283f00
  28392e:	6a 00                	push   $0x0
  283930:	6a 07                	push   $0x7
  283932:	ff 75 f0             	pushl  -0x10(%ebp)
  283935:	6a 08                	push   $0x8
  283937:	ff 75 08             	pushl  0x8(%ebp)
  28393a:	e8 a4 d7 ff ff       	call   2810e3 <putfonts8_asc_sht>
  28393f:	83 c4 20             	add    $0x20,%esp
					cursor_x = 16;
  283942:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
  283949:	eb 59                	jmp    2839a4 <console_task+0xc43>
				}
				else
				{
					if(cursor_x<240)
  28394b:	81 7d f4 ef 00 00 00 	cmpl   $0xef,-0xc(%ebp)
  283952:	7f 50                	jg     2839a4 <console_task+0xc43>
					{
						s[0] = i-256;
  283954:	8b 45 b0             	mov    -0x50(%ebp),%eax
  283957:	88 85 76 ff ff ff    	mov    %al,-0x8a(%ebp)
						s[1] = 0;
  28395d:	c6 85 77 ff ff ff 00 	movb   $0x0,-0x89(%ebp)
						cmdline[cursor_x/8-2] = i-256;
  283964:	8b 45 f4             	mov    -0xc(%ebp),%eax
  283967:	8d 50 07             	lea    0x7(%eax),%edx
  28396a:	85 c0                	test   %eax,%eax
  28396c:	0f 48 c2             	cmovs  %edx,%eax
  28396f:	c1 f8 03             	sar    $0x3,%eax
  283972:	83 e8 02             	sub    $0x2,%eax
  283975:	8b 55 b0             	mov    -0x50(%ebp),%edx
  283978:	88 94 05 58 ff ff ff 	mov    %dl,-0xa8(%ebp,%eax,1)
						putfonts8_asc_sht(sheet,cursor_x,cursor_y,COL8_FFFFFF,COL8_000000,s,1);
  28397f:	83 ec 04             	sub    $0x4,%esp
  283982:	6a 01                	push   $0x1
  283984:	8d 85 76 ff ff ff    	lea    -0x8a(%ebp),%eax
  28398a:	50                   	push   %eax
  28398b:	6a 00                	push   $0x0
  28398d:	6a 07                	push   $0x7
  28398f:	ff 75 f0             	pushl  -0x10(%ebp)
  283992:	ff 75 f4             	pushl  -0xc(%ebp)
  283995:	ff 75 08             	pushl  0x8(%ebp)
  283998:	e8 46 d7 ff ff       	call   2810e3 <putfonts8_asc_sht>
  28399d:	83 c4 20             	add    $0x20,%esp
						cursor_x += 8;
  2839a0:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
					}
				}
			}
			if(cursor_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cursor_c,cursor_x,cursor_y,cursor_x+7,cursor_y+15);
  2839a4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  2839a8:	78 33                	js     2839dd <console_task+0xc7c>
  2839aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2839ad:	8d 70 0f             	lea    0xf(%eax),%esi
  2839b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2839b3:	8d 58 07             	lea    0x7(%eax),%ebx
  2839b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  2839b9:	0f b6 c8             	movzbl %al,%ecx
  2839bc:	8b 45 08             	mov    0x8(%ebp),%eax
  2839bf:	8b 50 04             	mov    0x4(%eax),%edx
  2839c2:	8b 45 08             	mov    0x8(%ebp),%eax
  2839c5:	8b 00                	mov    (%eax),%eax
  2839c7:	83 ec 04             	sub    $0x4,%esp
  2839ca:	56                   	push   %esi
  2839cb:	53                   	push   %ebx
  2839cc:	ff 75 f0             	pushl  -0x10(%ebp)
  2839cf:	ff 75 f4             	pushl  -0xc(%ebp)
  2839d2:	51                   	push   %ecx
  2839d3:	52                   	push   %edx
  2839d4:	50                   	push   %eax
  2839d5:	e8 aa d2 ff ff       	call   280c84 <boxfill8>
  2839da:	83 c4 20             	add    $0x20,%esp
			sheet_refresh(sheet,cursor_x,cursor_y,cursor_x+8,cursor_y+16);
  2839dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2839e0:	8d 50 10             	lea    0x10(%eax),%edx
  2839e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2839e6:	83 c0 08             	add    $0x8,%eax
  2839e9:	83 ec 0c             	sub    $0xc,%esp
  2839ec:	52                   	push   %edx
  2839ed:	50                   	push   %eax
  2839ee:	ff 75 f0             	pushl  -0x10(%ebp)
  2839f1:	ff 75 f4             	pushl  -0xc(%ebp)
  2839f4:	ff 75 08             	pushl  0x8(%ebp)
  2839f7:	e8 e5 ea ff ff       	call   2824e1 <sheet_refresh>
  2839fc:	83 c4 20             	add    $0x20,%esp

		}
	}
  2839ff:	e9 2d f4 ff ff       	jmp    282e31 <console_task+0xd0>

00283a04 <cons_newline>:
}

int cons_newline(int cursor_y,struct SHEET *sheet)
{
  283a04:	55                   	push   %ebp
  283a05:	89 e5                	mov    %esp,%ebp
  283a07:	53                   	push   %ebx
  283a08:	83 ec 14             	sub    $0x14,%esp
	int x,y;
	if(cursor_y<28+112)
  283a0b:	81 7d 08 8b 00 00 00 	cmpl   $0x8b,0x8(%ebp)
  283a12:	7f 09                	jg     283a1d <cons_newline+0x19>
	{
		cursor_y += 16;
  283a14:	83 45 08 10          	addl   $0x10,0x8(%ebp)
  283a18:	e9 c7 00 00 00       	jmp    283ae4 <cons_newline+0xe0>
	}
	else
	{
		for(y=28;y<28+112;y++)
  283a1d:	c7 45 f0 1c 00 00 00 	movl   $0x1c,-0x10(%ebp)
  283a24:	eb 52                	jmp    283a78 <cons_newline+0x74>
			for(x=8;x<8+240;x++)
  283a26:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
  283a2d:	eb 3c                	jmp    283a6b <cons_newline+0x67>
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  283a2f:	8b 45 0c             	mov    0xc(%ebp),%eax
  283a32:	8b 10                	mov    (%eax),%edx
  283a34:	8b 45 0c             	mov    0xc(%ebp),%eax
  283a37:	8b 40 04             	mov    0x4(%eax),%eax
  283a3a:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  283a3e:	89 c1                	mov    %eax,%ecx
  283a40:	8b 45 f4             	mov    -0xc(%ebp),%eax
  283a43:	01 c8                	add    %ecx,%eax
  283a45:	01 c2                	add    %eax,%edx
  283a47:	8b 45 0c             	mov    0xc(%ebp),%eax
  283a4a:	8b 08                	mov    (%eax),%ecx
  283a4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  283a4f:	8d 58 10             	lea    0x10(%eax),%ebx
  283a52:	8b 45 0c             	mov    0xc(%ebp),%eax
  283a55:	8b 40 04             	mov    0x4(%eax),%eax
  283a58:	0f af d8             	imul   %eax,%ebx
  283a5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  283a5e:	01 d8                	add    %ebx,%eax
  283a60:	01 c8                	add    %ecx,%eax
  283a62:	0f b6 00             	movzbl (%eax),%eax
  283a65:	88 02                	mov    %al,(%edx)
		cursor_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
  283a67:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  283a6b:	81 7d f4 f7 00 00 00 	cmpl   $0xf7,-0xc(%ebp)
  283a72:	7e bb                	jle    283a2f <cons_newline+0x2b>
	{
		cursor_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
  283a74:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  283a78:	81 7d f0 8b 00 00 00 	cmpl   $0x8b,-0x10(%ebp)
  283a7f:	7e a5                	jle    283a26 <cons_newline+0x22>
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
  283a81:	c7 45 f0 8c 00 00 00 	movl   $0x8c,-0x10(%ebp)
  283a88:	eb 35                	jmp    283abf <cons_newline+0xbb>
			for(x=8;x<8+240;x++)
  283a8a:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
  283a91:	eb 1f                	jmp    283ab2 <cons_newline+0xae>
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  283a93:	8b 45 0c             	mov    0xc(%ebp),%eax
  283a96:	8b 10                	mov    (%eax),%edx
  283a98:	8b 45 0c             	mov    0xc(%ebp),%eax
  283a9b:	8b 40 04             	mov    0x4(%eax),%eax
  283a9e:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  283aa2:	89 c1                	mov    %eax,%ecx
  283aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  283aa7:	01 c8                	add    %ecx,%eax
  283aa9:	01 d0                	add    %edx,%eax
  283aab:	c6 00 00             	movb   $0x0,(%eax)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
  283aae:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  283ab2:	81 7d f4 f7 00 00 00 	cmpl   $0xf7,-0xc(%ebp)
  283ab9:	7e d8                	jle    283a93 <cons_newline+0x8f>
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
  283abb:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  283abf:	81 7d f0 9b 00 00 00 	cmpl   $0x9b,-0x10(%ebp)
  283ac6:	7e c2                	jle    283a8a <cons_newline+0x86>
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		sheet_refresh(sheet,8,28,8+240,28+128);
  283ac8:	83 ec 0c             	sub    $0xc,%esp
  283acb:	68 9c 00 00 00       	push   $0x9c
  283ad0:	68 f8 00 00 00       	push   $0xf8
  283ad5:	6a 1c                	push   $0x1c
  283ad7:	6a 08                	push   $0x8
  283ad9:	ff 75 0c             	pushl  0xc(%ebp)
  283adc:	e8 00 ea ff ff       	call   2824e1 <sheet_refresh>
  283ae1:	83 c4 20             	add    $0x20,%esp
	}
	return cursor_y;
  283ae4:	8b 45 08             	mov    0x8(%ebp),%eax
}
  283ae7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  283aea:	c9                   	leave  
  283aeb:	c3                   	ret    

00283aec <file_readfat>:
#include "fat.h"

void file_readfat(int *fat,unsigned char *img)
{
  283aec:	55                   	push   %ebp
  283aed:	89 e5                	mov    %esp,%ebp
  283aef:	56                   	push   %esi
  283af0:	53                   	push   %ebx
  283af1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  283af4:	8d 43 01             	lea    0x1(%ebx),%eax
  283af7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  283afa:	81 c3 e1 10 00 00    	add    $0x10e1,%ebx
	int i,j=0;
	for(i=0;i<2880;i+=2)
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
  283b00:	0f b6 10             	movzbl (%eax),%edx
  283b03:	c1 e2 08             	shl    $0x8,%edx
  283b06:	0f b6 70 ff          	movzbl -0x1(%eax),%esi
  283b0a:	09 f2                	or     %esi,%edx
  283b0c:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  283b12:	89 11                	mov    %edx,(%ecx)
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
  283b14:	0f b6 10             	movzbl (%eax),%edx
  283b17:	c0 ea 04             	shr    $0x4,%dl
  283b1a:	0f b6 f2             	movzbl %dl,%esi
  283b1d:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  283b21:	c1 e2 04             	shl    $0x4,%edx
  283b24:	09 f2                	or     %esi,%edx
  283b26:	89 51 04             	mov    %edx,0x4(%ecx)
  283b29:	83 c0 03             	add    $0x3,%eax
  283b2c:	83 c1 08             	add    $0x8,%ecx
#include "fat.h"

void file_readfat(int *fat,unsigned char *img)
{
	int i,j=0;
	for(i=0;i<2880;i+=2)
  283b2f:	39 d8                	cmp    %ebx,%eax
  283b31:	75 cd                	jne    283b00 <file_readfat+0x14>
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
		j+=3;
	}
	return;
}
  283b33:	5b                   	pop    %ebx
  283b34:	5e                   	pop    %esi
  283b35:	5d                   	pop    %ebp
  283b36:	c3                   	ret    

00283b37 <file_loadfile>:

void file_loadfile(int clustno,int size,char *buf,int *fat,char *img)
{
  283b37:	55                   	push   %ebp
  283b38:	89 e5                	mov    %esp,%ebp
  283b3a:	57                   	push   %edi
  283b3b:	56                   	push   %esi
  283b3c:	53                   	push   %ebx
  283b3d:	83 ec 04             	sub    $0x4,%esp
  283b40:	8b 5d 08             	mov    0x8(%ebp),%ebx
  283b43:	8b 7d 0c             	mov    0xc(%ebp),%edi
  283b46:	8b 55 10             	mov    0x10(%ebp),%edx
	int i;
	for(;;)
	{
		if(size <= 512)
  283b49:	81 ff 00 02 00 00    	cmp    $0x200,%edi
  283b4f:	7e 29                	jle    283b7a <file_loadfile+0x43>
  283b51:	8d 87 ff fd ff ff    	lea    -0x201(%edi),%eax
  283b57:	c1 e8 09             	shr    $0x9,%eax
  283b5a:	89 45 f0             	mov    %eax,-0x10(%ebp)
  283b5d:	8d 70 01             	lea    0x1(%eax),%esi
  283b60:	c1 e6 09             	shl    $0x9,%esi
  283b63:	01 d6                	add    %edx,%esi
  283b65:	8b 7d 14             	mov    0x14(%ebp),%edi
			}
			return;
		}
		for(i=0;i<512;i++)
		{
			buf[i] = img[clustno*512 + i];
  283b68:	89 d9                	mov    %ebx,%ecx
  283b6a:	c1 e1 09             	shl    $0x9,%ecx
  283b6d:	b8 00 00 00 00       	mov    $0x0,%eax
  283b72:	03 4d 18             	add    0x18(%ebp),%ecx
  283b75:	89 5d 08             	mov    %ebx,0x8(%ebp)
  283b78:	eb 23                	jmp    283b9d <file_loadfile+0x66>
void file_loadfile(int clustno,int size,char *buf,int *fat,char *img)
{
	int i;
	for(;;)
	{
		if(size <= 512)
  283b7a:	89 d6                	mov    %edx,%esi
		{
			for(i=0;i<size;i++)
  283b7c:	85 ff                	test   %edi,%edi
  283b7e:	7e 52                	jle    283bd2 <file_loadfile+0x9b>
			{
				buf[i] = img[clustno*512 + i];
  283b80:	89 d9                	mov    %ebx,%ecx
  283b82:	c1 e1 09             	shl    $0x9,%ecx
  283b85:	b8 00 00 00 00       	mov    $0x0,%eax
  283b8a:	03 4d 18             	add    0x18(%ebp),%ecx
  283b8d:	0f b6 14 01          	movzbl (%ecx,%eax,1),%edx
  283b91:	88 14 06             	mov    %dl,(%esi,%eax,1)
	int i;
	for(;;)
	{
		if(size <= 512)
		{
			for(i=0;i<size;i++)
  283b94:	83 c0 01             	add    $0x1,%eax
  283b97:	39 f8                	cmp    %edi,%eax
  283b99:	75 f2                	jne    283b8d <file_loadfile+0x56>
  283b9b:	eb 35                	jmp    283bd2 <file_loadfile+0x9b>
			}
			return;
		}
		for(i=0;i<512;i++)
		{
			buf[i] = img[clustno*512 + i];
  283b9d:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
  283ba1:	88 1c 02             	mov    %bl,(%edx,%eax,1)
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
		}
		for(i=0;i<512;i++)
  283ba4:	83 c0 01             	add    $0x1,%eax
  283ba7:	3d 00 02 00 00       	cmp    $0x200,%eax
  283bac:	75 ef                	jne    283b9d <file_loadfile+0x66>
  283bae:	8b 5d 08             	mov    0x8(%ebp),%ebx
		{
			buf[i] = img[clustno*512 + i];
		}
		size -= 512;
		buf += 512;
  283bb1:	81 c2 00 02 00 00    	add    $0x200,%edx
		clustno = fat[clustno];
  283bb7:	8b 1c 9f             	mov    (%edi,%ebx,4),%ebx
void file_loadfile(int clustno,int size,char *buf,int *fat,char *img)
{
	int i;
	for(;;)
	{
		if(size <= 512)
  283bba:	39 d6                	cmp    %edx,%esi
  283bbc:	75 aa                	jne    283b68 <file_loadfile+0x31>
  283bbe:	8b 7d 0c             	mov    0xc(%ebp),%edi
  283bc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  283bc4:	f7 d8                	neg    %eax
  283bc6:	c1 e0 09             	shl    $0x9,%eax
  283bc9:	8d bc 07 00 fe ff ff 	lea    -0x200(%edi,%eax,1),%edi
  283bd0:	eb aa                	jmp    283b7c <file_loadfile+0x45>
		size -= 512;
		buf += 512;
		clustno = fat[clustno];
	}
	return;
}
  283bd2:	83 c4 04             	add    $0x4,%esp
  283bd5:	5b                   	pop    %ebx
  283bd6:	5e                   	pop    %esi
  283bd7:	5f                   	pop    %edi
  283bd8:	5d                   	pop    %ebp
  283bd9:	c3                   	ret    

00283bda <test>:
#include "test.h"
int test(int screenx, int screeny)
{
  283bda:	55                   	push   %ebp
  283bdb:	89 e5                	mov    %esp,%ebp
	return screenx*screeny;
  283bdd:	8b 45 0c             	mov    0xc(%ebp),%eax
  283be0:	0f af 45 08          	imul   0x8(%ebp),%eax
}
  283be4:	5d                   	pop    %ebp
  283be5:	c3                   	ret    
