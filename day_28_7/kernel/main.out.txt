
main.out.o：     文件格式 elf32-i386


Disassembly of section .text:

00280000 <bootmain>:
#include "header.h"


int bootmain()
{
  280000:	55                   	push   %ebp
	//the buf for all strings.
	char s[50] = {0};
  280001:	31 c0                	xor    %eax,%eax
  280003:	b9 32 00 00 00       	mov    $0x32,%ecx
#include "header.h"


int bootmain()
{
  280008:	89 e5                	mov    %esp,%ebp
  28000a:	57                   	push   %edi
  28000b:	56                   	push   %esi
	//the buf for all strings.
	char s[50] = {0};
  28000c:	8d bd 36 fc ff ff    	lea    -0x3ca(%ebp),%edi
#include "header.h"


int bootmain()
{
  280012:	53                   	push   %ebx
	struct BOOTINFO *binfo = (struct BOOTINFO *)0xff0;

	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
  280013:	8d 9d fc fb ff ff    	lea    -0x404(%ebp),%ebx
	fifo32_init(&keycmd,32,keycmd_buf,0);
  280019:	8d b5 18 fc ff ff    	lea    -0x3e8(%ebp),%esi
#include "header.h"


int bootmain()
{
  28001f:	81 ec 6c 04 00 00    	sub    $0x46c,%esp
	//the buf for all strings.
	char s[50] = {0};
  280025:	f3 aa                	rep stos %al,%es:(%edi)
	struct BOOTINFO *binfo = (struct BOOTINFO *)0xff0;

	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
  280027:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
  28002d:	6a 00                	push   $0x0
  28002f:	50                   	push   %eax
  280030:	68 80 00 00 00       	push   $0x80
  280035:	53                   	push   %ebx
  280036:	e8 9d 1c 00 00       	call   281cd8 <fifo32_init>
	fifo32_init(&keycmd,32,keycmd_buf,0);
  28003b:	8d 85 68 fc ff ff    	lea    -0x398(%ebp),%eax
  280041:	6a 00                	push   $0x0
  280043:	50                   	push   %eax
  280044:	6a 20                	push   $0x20
  280046:	56                   	push   %esi
  280047:	e8 8c 1c 00 00       	call   281cd8 <fifo32_init>
	*((int *)0x0fec) = (int) &fifo;

	int key_leds = (binfo->leds>>4)&7;
  28004c:	a0 f1 0f 00 00       	mov    0xff1,%al

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280051:	83 c4 18             	add    $0x18,%esp
	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
	fifo32_init(&keycmd,32,keycmd_buf,0);
	*((int *)0x0fec) = (int) &fifo;
  280054:	89 1d ec 0f 00 00    	mov    %ebx,0xfec

	int key_leds = (binfo->leds>>4)&7;

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  28005a:	68 ed 00 00 00       	push   $0xed
  28005f:	56                   	push   %esi
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
	fifo32_init(&keycmd,32,keycmd_buf,0);
	*((int *)0x0fec) = (int) &fifo;

	int key_leds = (binfo->leds>>4)&7;
  280060:	c0 f8 04             	sar    $0x4,%al
  280063:	83 e0 07             	and    $0x7,%eax
  280066:	89 85 cc fb ff ff    	mov    %eax,-0x434(%ebp)

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  28006c:	e8 98 1c 00 00       	call   281d09 <fifo32_put>
	fifo32_put(&keycmd,key_leds);
  280071:	59                   	pop    %ecx
  280072:	5f                   	pop    %edi
  280073:	ff b5 cc fb ff ff    	pushl  -0x434(%ebp)
  280079:	56                   	push   %esi
  28007a:	e8 8a 1c 00 00       	call   281d09 <fifo32_put>

	//init gdt idt pic and enable cpu interrupt
	init_gdtidt();
  28007f:	e8 ad 15 00 00       	call   281631 <init_gdtidt>
	init_pic();
  280084:	e8 6c 17 00 00       	call   2817f5 <init_pic>
	io_sti();
  280089:	e8 36 0a 00 00       	call   280ac4 <io_sti>

	//init keyboard and mouse
	init_keyboard(&fifo,256);
  28008e:	58                   	pop    %eax
  28008f:	5a                   	pop    %edx
  280090:	68 00 01 00 00       	push   $0x100
  280095:	53                   	push   %ebx
  280096:	e8 77 1e 00 00       	call   281f12 <init_keyboard>
	struct MOUSE_DEC mdec;
	enable_mouse(&fifo,512,&mdec);
  28009b:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  2800a1:	83 c4 0c             	add    $0xc,%esp
  2800a4:	50                   	push   %eax
  2800a5:	68 00 02 00 00       	push   $0x200
  2800aa:	53                   	push   %ebx
  2800ab:	e8 14 1d 00 00       	call   281dc4 <enable_mouse>

	//init timer
	init_pit();
  2800b0:	e8 7b 2b 00 00       	call   282c30 <init_pit>

	io_out8(PIC0_IMR,0xf8);
  2800b5:	59                   	pop    %ecx
  2800b6:	5f                   	pop    %edi
  2800b7:	68 f8 00 00 00       	push   $0xf8
  2800bc:	6a 21                	push   $0x21
  2800be:	e8 33 0a 00 00       	call   280af6 <io_out8>
	io_out8(PIC1_IMR,0xef);
  2800c3:	58                   	pop    %eax
  2800c4:	5a                   	pop    %edx
  2800c5:	68 ef 00 00 00       	push   $0xef
  2800ca:	68 a1 00 00 00       	push   $0xa1
  2800cf:	e8 22 0a 00 00       	call   280af6 <io_out8>

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800d4:	59                   	pop    %ecx
  2800d5:	5f                   	pop    %edi
  2800d6:	68 ff ff ff bf       	push   $0xbfffffff
  2800db:	68 00 00 40 00       	push   $0x400000
  2800e0:	e8 c7 1e 00 00       	call   281fac <memtest>
	memman_init(memman);
  2800e5:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
	io_out8(PIC1_IMR,0xef);

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800ec:	89 85 a0 fb ff ff    	mov    %eax,-0x460(%ebp)
	memman_init(memman);
  2800f2:	e8 f4 1f 00 00       	call   2820eb <memman_init>
	//init memman with two mem block:0x00001000-0x0009efff and 0x00400000-memtotal
	memman_free(memman,0x00001000,0x0009e000);
  2800f7:	83 c4 0c             	add    $0xc,%esp
  2800fa:	68 00 e0 09 00       	push   $0x9e000
  2800ff:	68 00 10 00 00       	push   $0x1000
  280104:	68 00 00 3c 00       	push   $0x3c0000
  280109:	e8 2c 21 00 00       	call   28223a <memman_free>
	memman_free(memman,0x00400000,memtotal-0x00400000);
  28010e:	8b 85 a0 fb ff ff    	mov    -0x460(%ebp),%eax
  280114:	83 c4 0c             	add    $0xc,%esp
  280117:	2d 00 00 40 00       	sub    $0x400000,%eax
  28011c:	50                   	push   %eax
  28011d:	68 00 00 40 00       	push   $0x400000
  280122:	68 00 00 3c 00       	push   $0x3c0000
  280127:	e8 0e 21 00 00       	call   28223a <memman_free>

	load_hanyu();
  28012c:	e8 7b 52 00 00       	call   2853ac <load_hanyu>
	struct SHTCTL *shtctl;
	struct SHEET *sht_bg, *sht_mouse;
	unsigned char *buf_bg,buf_mouse[256];
	struct TASK *task_a;

	init_palette();
  280131:	e8 f5 0a 00 00       	call   280c2b <init_palette>
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  280136:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  28013d:	50                   	push   %eax
  28013e:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280145:	50                   	push   %eax
  280146:	ff 35 f8 0f 00 00    	pushl  0xff8
  28014c:	68 00 00 3c 00       	push   $0x3c0000
  280151:	e8 92 23 00 00       	call   2824e8 <shtctl_init>
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  280156:	83 c4 14             	add    $0x14,%esp
	struct SHEET *sht_bg, *sht_mouse;
	unsigned char *buf_bg,buf_mouse[256];
	struct TASK *task_a;

	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  280159:	89 85 d8 fb ff ff    	mov    %eax,-0x428(%ebp)
	*((int *)0x0fe4) = (int)shtctl;
  28015f:	a3 e4 0f 00 00       	mov    %eax,0xfe4
	task_a = task_init(memman); //main task
  280164:	68 00 00 3c 00       	push   $0x3c0000
  280169:	e8 fb 2f 00 00       	call   283169 <task_init>
	task_a->langmode = 0;
	fifo.task = task_a;
	task_run(task_a,1,0);
  28016e:	83 c4 0c             	add    $0xc,%esp

	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
	task_a->langmode = 0;
  280171:	c6 80 bc 00 00 00 00 	movb   $0x0,0xbc(%eax)
	struct TASK *task_a;

	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  280178:	89 85 b0 fb ff ff    	mov    %eax,-0x450(%ebp)
	task_a->langmode = 0;
	fifo.task = task_a;
	task_run(task_a,1,0);
  28017e:	6a 00                	push   $0x0
  280180:	6a 01                	push   $0x1
  280182:	50                   	push   %eax
	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
	task_a->langmode = 0;
	fifo.task = task_a;
  280183:	89 85 14 fc ff ff    	mov    %eax,-0x3ec(%ebp)
	task_run(task_a,1,0);
  280189:	e8 48 2f 00 00       	call   2830d6 <task_run>

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
  28018e:	58                   	pop    %eax
  28018f:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280195:	e8 e2 23 00 00       	call   28257c <sheet_alloc>
  28019a:	89 85 ac fb ff ff    	mov    %eax,-0x454(%ebp)
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  2801a0:	58                   	pop    %eax
  2801a1:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801a8:	5a                   	pop    %edx
  2801a9:	0f bf 15 f4 0f 00 00 	movswl 0xff4,%edx
  2801b0:	0f af c2             	imul   %edx,%eax
  2801b3:	50                   	push   %eax
  2801b4:	68 00 00 3c 00       	push   $0x3c0000
  2801b9:	e8 cf 22 00 00       	call   28248d <memman_alloc_4k>
  2801be:	89 c7                	mov    %eax,%edi
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
  2801c0:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801c7:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  2801ce:	50                   	push   %eax
  2801cf:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801d6:	50                   	push   %eax
  2801d7:	57                   	push   %edi
  2801d8:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  2801de:	e8 0c 24 00 00       	call   2825ef <sheet_setbuf>
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
  2801e3:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801ea:	83 c4 1c             	add    $0x1c,%esp
  2801ed:	50                   	push   %eax
  2801ee:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801f5:	50                   	push   %eax
  2801f6:	57                   	push   %edi

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  2801f7:	8d bd e8 fc ff ff    	lea    -0x318(%ebp),%edi

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
  2801fd:	e8 1f 0b 00 00       	call   280d21 <init_screen8>

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  280202:	59                   	pop    %ecx
  280203:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280209:	e8 6e 23 00 00       	call   28257c <sheet_alloc>
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  28020e:	c7 04 24 63 00 00 00 	movl   $0x63,(%esp)
  280215:	6a 10                	push   $0x10
  280217:	6a 10                	push   $0x10
  280219:	57                   	push   %edi
  28021a:	50                   	push   %eax
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  28021b:	89 85 a8 fb ff ff    	mov    %eax,-0x458(%ebp)
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  280221:	e8 c9 23 00 00       	call   2825ef <sheet_setbuf>
	init_mouse_cursor8(buf_mouse,99);
  280226:	83 c4 18             	add    $0x18,%esp
  280229:	6a 63                	push   $0x63
  28022b:	57                   	push   %edi
  28022c:	e8 5f 0c 00 00       	call   280e90 <init_mouse_cursor8>
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  280231:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280238:	b9 02 00 00 00       	mov    $0x2,%ecx
	int new_mx = -1,new_my = 0,new_wx = 0x7fffffff,new_wy=0;

	//console sheet
	struct SHEET *key_win,*sht = 0;
	//init window focus
	key_win = open_console(shtctl,memtotal);
  28023d:	5f                   	pop    %edi
	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  28023e:	83 e8 10             	sub    $0x10,%eax
  280241:	99                   	cltd   
  280242:	f7 f9                	idiv   %ecx
  280244:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
	int my = (binfo->scrny-28-16)/2;
  28024a:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  280251:	83 e8 2c             	sub    $0x2c,%eax
  280254:	99                   	cltd   
  280255:	f7 f9                	idiv   %ecx
  280257:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
	int new_mx = -1,new_my = 0,new_wx = 0x7fffffff,new_wy=0;

	//console sheet
	struct SHEET *key_win,*sht = 0;
	//init window focus
	key_win = open_console(shtctl,memtotal);
  28025d:	58                   	pop    %eax
  28025e:	ff b5 a0 fb ff ff    	pushl  -0x460(%ebp)
  280264:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  28026a:	e8 47 40 00 00       	call   2842b6 <open_console>
  28026f:	89 c7                	mov    %eax,%edi
	keywin_on(key_win);
  280271:	89 04 24             	mov    %eax,(%esp)
  280274:	e8 ff 50 00 00       	call   285378 <keywin_on>

	sheet_slide(sht_bg,0,0);
  280279:	83 c4 0c             	add    $0xc,%esp
  28027c:	6a 00                	push   $0x0
  28027e:	6a 00                	push   $0x0
  280280:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280286:	e8 c8 28 00 00       	call   282b53 <sheet_slide>
	sheet_slide(key_win,32,4);
  28028b:	83 c4 0c             	add    $0xc,%esp
  28028e:	6a 04                	push   $0x4
  280290:	6a 20                	push   $0x20
  280292:	57                   	push   %edi
  280293:	e8 bb 28 00 00       	call   282b53 <sheet_slide>
	sheet_slide(sht_mouse,mx,my);
  280298:	83 c4 0c             	add    $0xc,%esp
  28029b:	ff b5 d0 fb ff ff    	pushl  -0x430(%ebp)
  2802a1:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  2802a7:	ff b5 a8 fb ff ff    	pushl  -0x458(%ebp)
  2802ad:	e8 a1 28 00 00       	call   282b53 <sheet_slide>
	sheet_updown(sht_bg,		0);
  2802b2:	58                   	pop    %eax
  2802b3:	5a                   	pop    %edx
  2802b4:	6a 00                	push   $0x0
  2802b6:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  2802bc:	e8 a9 27 00 00       	call   282a6a <sheet_updown>
	sheet_updown(key_win,1);
  2802c1:	59                   	pop    %ecx
  2802c2:	58                   	pop    %eax
  2802c3:	6a 01                	push   $0x1
  2802c5:	57                   	push   %edi
  2802c6:	e8 9f 27 00 00       	call   282a6a <sheet_updown>
	sheet_updown(sht_mouse,		2);
  2802cb:	58                   	pop    %eax
  2802cc:	5a                   	pop    %edx
  2802cd:	6a 02                	push   $0x2
  2802cf:	ff b5 a8 fb ff ff    	pushl  -0x458(%ebp)
  2802d5:	e8 90 27 00 00       	call   282a6a <sheet_updown>
  2802da:	83 c4 10             	add    $0x10,%esp

	extern struct TIMERCTL timerctl;
	
	int key_shift = 0,keycmd_wait = -1;
  2802dd:	c7 85 b8 fb ff ff ff 	movl   $0xffffffff,-0x448(%ebp)
  2802e4:	ff ff ff 
  2802e7:	c7 85 c8 fb ff ff 00 	movl   $0x0,-0x438(%ebp)
  2802ee:	00 00 00 
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1,mmx2 = 0;
	int new_mx = -1,new_my = 0,new_wx = 0x7fffffff,new_wy=0;

	//console sheet
	struct SHEET *key_win,*sht = 0;
  2802f1:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  2802f8:	00 00 00 
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1,mmx2 = 0;
	int new_mx = -1,new_my = 0,new_wx = 0x7fffffff,new_wy=0;
  2802fb:	c7 85 b4 fb ff ff 00 	movl   $0x0,-0x44c(%ebp)
  280302:	00 00 00 
  280305:	c7 85 c0 fb ff ff ff 	movl   $0x7fffffff,-0x440(%ebp)
  28030c:	ff ff 7f 
  28030f:	c7 85 dc fb ff ff 00 	movl   $0x0,-0x424(%ebp)
  280316:	00 00 00 
  280319:	c7 85 e0 fb ff ff ff 	movl   $0xffffffff,-0x420(%ebp)
  280320:	ff ff ff 
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1,mmx2 = 0;
  280323:	c7 85 9c fb ff ff 00 	movl   $0x0,-0x464(%ebp)
  28032a:	00 00 00 
  28032d:	c7 85 a4 fb ff ff ff 	movl   $0xffffffff,-0x45c(%ebp)
  280334:	ff ff ff 
  280337:	c7 85 bc fb ff ff ff 	movl   $0xffffffff,-0x444(%ebp)
  28033e:	ff ff ff 
	
	int key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  280341:	89 b5 c4 fb ff ff    	mov    %esi,-0x43c(%ebp)
			keycmd_wait = fifo32_get(&keycmd);
			wait_KBC_sendready();
			io_out8(PORT_KEYDAT,keycmd_wait);
		}
		io_cli();
		if(fifo32_status(&fifo) == 0)
  280347:	89 9d 98 fb ff ff    	mov    %ebx,-0x468(%ebp)
	
	int key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  28034d:	83 ec 0c             	sub    $0xc,%esp
  280350:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  280356:	e8 5b 1a 00 00       	call   281db6 <fifo32_status>
  28035b:	8b 8d b8 fb ff ff    	mov    -0x448(%ebp),%ecx
  280361:	83 c4 10             	add    $0x10,%esp
  280364:	c1 e9 1f             	shr    $0x1f,%ecx
  280367:	74 2f                	je     280398 <bootmain+0x398>
  280369:	85 c0                	test   %eax,%eax
  28036b:	7e 2b                	jle    280398 <bootmain+0x398>
		{
			keycmd_wait = fifo32_get(&keycmd);
  28036d:	83 ec 0c             	sub    $0xc,%esp
  280370:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  280376:	e8 00 1a 00 00       	call   281d7b <fifo32_get>
  28037b:	89 85 b8 fb ff ff    	mov    %eax,-0x448(%ebp)
			wait_KBC_sendready();
  280381:	e8 73 1b 00 00       	call   281ef9 <wait_KBC_sendready>
			io_out8(PORT_KEYDAT,keycmd_wait);
  280386:	58                   	pop    %eax
  280387:	5a                   	pop    %edx
  280388:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  28038e:	6a 60                	push   $0x60
  280390:	e8 61 07 00 00       	call   280af6 <io_out8>
  280395:	83 c4 10             	add    $0x10,%esp
		}
		io_cli();
  280398:	e8 25 07 00 00       	call   280ac2 <io_cli>
		if(fifo32_status(&fifo) == 0)
  28039d:	83 ec 0c             	sub    $0xc,%esp
  2803a0:	ff b5 98 fb ff ff    	pushl  -0x468(%ebp)
  2803a6:	e8 0b 1a 00 00       	call   281db6 <fifo32_status>
  2803ab:	83 c4 10             	add    $0x10,%esp
  2803ae:	85 c0                	test   %eax,%eax
  2803b0:	0f 85 8b 00 00 00    	jne    280441 <bootmain+0x441>
		{	
			if(new_mx >= 0)
  2803b6:	83 bd e0 fb ff ff 00 	cmpl   $0x0,-0x420(%ebp)
  2803bd:	78 2f                	js     2803ee <bootmain+0x3ee>
			{
				io_sti();
  2803bf:	e8 00 07 00 00       	call   280ac4 <io_sti>
				sheet_slide(sht_mouse,new_mx,new_my);
  2803c4:	50                   	push   %eax
  2803c5:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  2803cb:	ff b5 e0 fb ff ff    	pushl  -0x420(%ebp)
  2803d1:	ff b5 a8 fb ff ff    	pushl  -0x458(%ebp)
  2803d7:	e8 77 27 00 00       	call   282b53 <sheet_slide>
  2803dc:	83 c4 10             	add    $0x10,%esp
				new_mx = -1;
  2803df:	c7 85 e0 fb ff ff ff 	movl   $0xffffffff,-0x420(%ebp)
  2803e6:	ff ff ff 
  2803e9:	e9 5f ff ff ff       	jmp    28034d <bootmain+0x34d>
			}
			else if(new_wx!=0x7fffffff)
  2803ee:	81 bd c0 fb ff ff ff 	cmpl   $0x7fffffff,-0x440(%ebp)
  2803f5:	ff ff 7f 
  2803f8:	74 2f                	je     280429 <bootmain+0x429>
			{
				io_sti();
  2803fa:	e8 c5 06 00 00       	call   280ac4 <io_sti>
				sheet_slide(sht,new_wx,new_wy);
  2803ff:	50                   	push   %eax
  280400:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  280406:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  28040c:	ff b5 e4 fb ff ff    	pushl  -0x41c(%ebp)
  280412:	e8 3c 27 00 00       	call   282b53 <sheet_slide>
  280417:	83 c4 10             	add    $0x10,%esp
				new_wx = 0x7fffffff;
  28041a:	c7 85 c0 fb ff ff ff 	movl   $0x7fffffff,-0x440(%ebp)
  280421:	ff ff 7f 
  280424:	e9 24 ff ff ff       	jmp    28034d <bootmain+0x34d>
			}
			else
			{
				task_sleep(task_a);
  280429:	83 ec 0c             	sub    $0xc,%esp
  28042c:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  280432:	e8 4f 2f 00 00       	call   283386 <task_sleep>
				io_sti();
  280437:	e8 88 06 00 00       	call   280ac4 <io_sti>
  28043c:	e9 73 06 00 00       	jmp    280ab4 <bootmain+0xab4>
			}
		}
		else
		{
			int i = fifo32_get(&fifo);
  280441:	83 ec 0c             	sub    $0xc,%esp
  280444:	ff b5 98 fb ff ff    	pushl  -0x468(%ebp)
  28044a:	e8 2c 19 00 00       	call   281d7b <fifo32_get>
  28044f:	89 c6                	mov    %eax,%esi
			io_sti();
  280451:	e8 6e 06 00 00       	call   280ac4 <io_sti>
			if(key_win != 0 && key_win->flags == 0) //key_win already closed
  280456:	83 c4 10             	add    $0x10,%esp
  280459:	85 ff                	test   %edi,%edi
  28045b:	74 2c                	je     280489 <bootmain+0x489>
  28045d:	83 7f 1c 00          	cmpl   $0x0,0x1c(%edi)
  280461:	75 26                	jne    280489 <bootmain+0x489>
			{
				if(shtctl->top == 1)
  280463:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  280469:	31 ff                	xor    %edi,%edi
  28046b:	8b 40 10             	mov    0x10(%eax),%eax
  28046e:	83 f8 01             	cmp    $0x1,%eax
  280471:	74 16                	je     280489 <bootmain+0x489>
				{
					key_win = 0;
				}
				else
				{
					key_win = shtctl->sheets[shtctl->top - 1];
  280473:	8b 8d d8 fb ff ff    	mov    -0x428(%ebp),%ecx
					keywin_on(key_win);
  280479:	83 ec 0c             	sub    $0xc,%esp
				{
					key_win = 0;
				}
				else
				{
					key_win = shtctl->sheets[shtctl->top - 1];
  28047c:	8b 7c 81 10          	mov    0x10(%ecx,%eax,4),%edi
					keywin_on(key_win);
  280480:	57                   	push   %edi
  280481:	e8 f2 4e 00 00       	call   285378 <keywin_on>
  280486:	83 c4 10             	add    $0x10,%esp
				}
			}
			if(256<=i && i<=511)
  280489:	8d 9e 00 ff ff ff    	lea    -0x100(%esi),%ebx
  28048f:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  280495:	0f 87 cc 02 00 00    	ja     280767 <bootmain+0x767>
			{
				xtoa(i-256,s);
  28049b:	50                   	push   %eax
  28049c:	50                   	push   %eax
  28049d:	8d 85 36 fc ff ff    	lea    -0x3ca(%ebp),%eax
  2804a3:	50                   	push   %eax
  2804a4:	53                   	push   %ebx
  2804a5:	89 85 94 fb ff ff    	mov    %eax,-0x46c(%ebp)
  2804ab:	e8 d6 15 00 00       	call   281a86 <xtoa>
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);
  2804b0:	8b 85 94 fb ff ff    	mov    -0x46c(%ebp),%eax
  2804b6:	83 c4 0c             	add    $0xc,%esp
  2804b9:	6a 04                	push   $0x4
  2804bb:	50                   	push   %eax
  2804bc:	6a 00                	push   $0x0
  2804be:	6a 07                	push   $0x7
  2804c0:	6a 10                	push   $0x10
  2804c2:	6a 00                	push   $0x0
  2804c4:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  2804ca:	e8 41 0c 00 00       	call   281110 <putfonts8_asc_sht>

				s[0] = key_char(i-256,key_shift);
  2804cf:	83 c4 18             	add    $0x18,%esp
  2804d2:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2804d8:	53                   	push   %ebx
  2804d9:	e8 a6 1a 00 00       	call   281f84 <key_char>
				s[1] = 0;

				if('A' <= s[0] && s[0] <= 'Z')
  2804de:	8d 50 bf             	lea    -0x41(%eax),%edx
  2804e1:	83 c4 10             	add    $0x10,%esp
			if(256<=i && i<=511)
			{
				xtoa(i-256,s);
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);

				s[0] = key_char(i-256,key_shift);
  2804e4:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				s[1] = 0;
  2804ea:	c6 85 37 fc ff ff 00 	movb   $0x0,-0x3c9(%ebp)

				if('A' <= s[0] && s[0] <= 'Z')
  2804f1:	80 fa 19             	cmp    $0x19,%dl
  2804f4:	77 26                	ja     28051c <bootmain+0x51c>
				{
					if((key_leds&4) == 0 && key_shift != 0 ||	//keyboard led off and shift on
  2804f6:	f6 85 cc fb ff ff 04 	testb  $0x4,-0x434(%ebp)
  2804fd:	75 0b                	jne    28050a <bootmain+0x50a>
  2804ff:	83 bd c8 fb ff ff 00 	cmpl   $0x0,-0x438(%ebp)
  280506:	75 0b                	jne    280513 <bootmain+0x513>
  280508:	eb 12                	jmp    28051c <bootmain+0x51c>
							(key_leds&4) != 0 && key_shift == 0)			//keyboard led on and shift off
  28050a:	83 bd c8 fb ff ff 00 	cmpl   $0x0,-0x438(%ebp)
  280511:	75 09                	jne    28051c <bootmain+0x51c>
						s[0] += 0x20;		//uppercase 2 lowercases					
  280513:	83 c0 20             	add    $0x20,%eax
  280516:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				}
				if(s[0]!=0 && key_win != 0)//visible char,return key and back key
  28051c:	0f be 85 36 fc ff ff 	movsbl -0x3ca(%ebp),%eax
  280523:	85 ff                	test   %edi,%edi
  280525:	0f 95 c3             	setne  %bl
  280528:	84 c0                	test   %al,%al
  28052a:	74 1b                	je     280547 <bootmain+0x547>
  28052c:	84 db                	test   %bl,%bl
  28052e:	74 17                	je     280547 <bootmain+0x547>
				{
					fifo32_put(&key_win->task->fifo,s[0]+256); //send key to console fifo
  280530:	05 00 01 00 00       	add    $0x100,%eax
  280535:	51                   	push   %ecx
  280536:	51                   	push   %ecx
  280537:	50                   	push   %eax
  280538:	8b 47 24             	mov    0x24(%edi),%eax
  28053b:	83 c0 10             	add    $0x10,%eax
  28053e:	50                   	push   %eax
  28053f:	e8 c5 17 00 00       	call   281d09 <fifo32_put>
  280544:	83 c4 10             	add    $0x10,%esp
				}
				if(i == 256 + 0x0f && key_win != 0) //tab key
  280547:	81 fe 0f 01 00 00    	cmp    $0x10f,%esi
  28054d:	75 39                	jne    280588 <bootmain+0x588>
  28054f:	84 db                	test   %bl,%bl
  280551:	74 35                	je     280588 <bootmain+0x588>
				{
					keywin_off(key_win);
  280553:	83 ec 0c             	sub    $0xc,%esp
  280556:	57                   	push   %edi
  280557:	e8 e8 4d 00 00       	call   285344 <keywin_off>
					int j=key_win->height - 1;
  28055c:	8b 47 18             	mov    0x18(%edi),%eax
					if(j==0)
  28055f:	83 c4 10             	add    $0x10,%esp
  280562:	48                   	dec    %eax
  280563:	75 10                	jne    280575 <bootmain+0x575>
					{
						j = shtctl->top-1;
  280565:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  28056b:	8b 40 10             	mov    0x10(%eax),%eax
  28056e:	89 85 94 fb ff ff    	mov    %eax,-0x46c(%ebp)
  280574:	48                   	dec    %eax
					}
					key_win = shtctl->sheets[j];
  280575:	8b 95 d8 fb ff ff    	mov    -0x428(%ebp),%edx
					keywin_on(key_win);
  28057b:	83 ec 0c             	sub    $0xc,%esp
					int j=key_win->height - 1;
					if(j==0)
					{
						j = shtctl->top-1;
					}
					key_win = shtctl->sheets[j];
  28057e:	8b 7c 82 14          	mov    0x14(%edx,%eax,4),%edi
					keywin_on(key_win);
  280582:	57                   	push   %edi
  280583:	e9 a0 01 00 00       	jmp    280728 <bootmain+0x728>
				}
				else if(i == 256 + 0x2a)  //left shift on
  280588:	81 fe 2a 01 00 00    	cmp    $0x12a,%esi
  28058e:	75 0c                	jne    28059c <bootmain+0x59c>
				{
					key_shift |= 1;
  280590:	83 8d c8 fb ff ff 01 	orl    $0x1,-0x438(%ebp)
  280597:	e9 b1 fd ff ff       	jmp    28034d <bootmain+0x34d>
				} 
				else if(i == 256 + 0x36) //right shift on
  28059c:	81 fe 36 01 00 00    	cmp    $0x136,%esi
  2805a2:	75 0c                	jne    2805b0 <bootmain+0x5b0>
				{
					key_shift |= 2;
  2805a4:	83 8d c8 fb ff ff 02 	orl    $0x2,-0x438(%ebp)
  2805ab:	e9 9d fd ff ff       	jmp    28034d <bootmain+0x34d>
				}
				else if(i == 256 + 0xaa)  //left shift off
  2805b0:	81 fe aa 01 00 00    	cmp    $0x1aa,%esi
  2805b6:	75 0c                	jne    2805c4 <bootmain+0x5c4>
				{
					key_shift &= ~1;
  2805b8:	83 a5 c8 fb ff ff fe 	andl   $0xfffffffe,-0x438(%ebp)
  2805bf:	e9 89 fd ff ff       	jmp    28034d <bootmain+0x34d>
				} 
				else if(i == 256 + 0xb6) //right shift off
  2805c4:	81 fe b6 01 00 00    	cmp    $0x1b6,%esi
  2805ca:	75 0c                	jne    2805d8 <bootmain+0x5d8>
				{
					key_shift &= ~2;
  2805cc:	83 a5 c8 fb ff ff fd 	andl   $0xfffffffd,-0x438(%ebp)
  2805d3:	e9 75 fd ff ff       	jmp    28034d <bootmain+0x34d>
				}
				else if(i == 256 + 0x3a) //CapsLock
  2805d8:	81 fe 3a 01 00 00    	cmp    $0x13a,%esi
  2805de:	75 09                	jne    2805e9 <bootmain+0x5e9>
				{
					key_leds ^= 4;
  2805e0:	83 b5 cc fb ff ff 04 	xorl   $0x4,-0x434(%ebp)
  2805e7:	eb 20                	jmp    280609 <bootmain+0x609>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x45) //NumLock
  2805e9:	81 fe 45 01 00 00    	cmp    $0x145,%esi
  2805ef:	75 09                	jne    2805fa <bootmain+0x5fa>
				{
					key_leds ^= 2;
  2805f1:	83 b5 cc fb ff ff 02 	xorl   $0x2,-0x434(%ebp)
  2805f8:	eb 0f                	jmp    280609 <bootmain+0x609>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x46) //ScrollLock
  2805fa:	81 fe 46 01 00 00    	cmp    $0x146,%esi
  280600:	75 31                	jne    280633 <bootmain+0x633>
				{
					key_leds ^= 1;
  280602:	83 b5 cc fb ff ff 01 	xorl   $0x1,-0x434(%ebp)
					fifo32_put(&keycmd,KEYCMD_LED);
  280609:	50                   	push   %eax
  28060a:	50                   	push   %eax
  28060b:	68 ed 00 00 00       	push   $0xed
  280610:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  280616:	e8 ee 16 00 00       	call   281d09 <fifo32_put>
					fifo32_put(&keycmd,key_leds);
  28061b:	58                   	pop    %eax
  28061c:	5a                   	pop    %edx
  28061d:	ff b5 cc fb ff ff    	pushl  -0x434(%ebp)
  280623:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  280629:	e8 db 16 00 00       	call   281d09 <fifo32_put>
  28062e:	e9 81 04 00 00       	jmp    280ab4 <bootmain+0xab4>
				}
				else if(i == 256 + 0xfa)
  280633:	81 fe fa 01 00 00    	cmp    $0x1fa,%esi
  280639:	75 0f                	jne    28064a <bootmain+0x64a>
				{
					keycmd_wait = -1;
  28063b:	c7 85 b8 fb ff ff ff 	movl   $0xffffffff,-0x448(%ebp)
  280642:	ff ff ff 
  280645:	e9 03 fd ff ff       	jmp    28034d <bootmain+0x34d>
				}
				else if(i == 256 + 0xfe)
  28064a:	81 fe fe 01 00 00    	cmp    $0x1fe,%esi
  280650:	75 19                	jne    28066b <bootmain+0x66b>
				{
					wait_KBC_sendready();
  280652:	e8 a2 18 00 00       	call   281ef9 <wait_KBC_sendready>
					io_out8(PORT_KEYDAT,keycmd_wait);
  280657:	50                   	push   %eax
  280658:	50                   	push   %eax
  280659:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  28065f:	6a 60                	push   $0x60
  280661:	e8 90 04 00 00       	call   280af6 <io_out8>
  280666:	e9 49 04 00 00       	jmp    280ab4 <bootmain+0xab4>
				}
				else if(i == 256 + 0x3b && key_shift != 0 && key_win != 0)	//shift + F1
  28066b:	83 bd c8 fb ff ff 00 	cmpl   $0x0,-0x438(%ebp)
  280672:	0f 95 c0             	setne  %al
  280675:	81 fe 3b 01 00 00    	cmp    $0x13b,%esi
  28067b:	0f 94 c2             	sete   %dl
  28067e:	84 c2                	test   %al,%dl
  280680:	74 54                	je     2806d6 <bootmain+0x6d6>
  280682:	84 db                	test   %bl,%bl
  280684:	74 50                	je     2806d6 <bootmain+0x6d6>
				{
					struct TASK *task = key_win->task;
  280686:	8b 5f 24             	mov    0x24(%edi),%ebx
					if(task!=0 && task->tss.ss0 != 0)
  280689:	85 db                	test   %ebx,%ebx
  28068b:	0f 84 bc fc ff ff    	je     28034d <bootmain+0x34d>
  280691:	83 7b 34 00          	cmpl   $0x0,0x34(%ebx)
  280695:	0f 84 b2 fc ff ff    	je     28034d <bootmain+0x34d>
					{
						extern void asm_end_app();
						cons_putstr0(task->cons,"\nBreak(key):\n");
  28069b:	50                   	push   %eax
  28069c:	50                   	push   %eax
  28069d:	68 a0 54 28 00       	push   $0x2854a0
  2806a2:	ff b3 a4 00 00 00    	pushl  0xa4(%ebx)
  2806a8:	e8 26 38 00 00       	call   283ed3 <cons_putstr0>
						io_cli();
  2806ad:	e8 10 04 00 00       	call   280ac2 <io_cli>
						task->tss.eax = (int)&(task->tss.esp0);
  2806b2:	8d 43 30             	lea    0x30(%ebx),%eax
						task->tss.eip = (int)asm_end_app - 0x280000;
  2806b5:	c7 43 4c d0 2e 00 00 	movl   $0x2ed0,0x4c(%ebx)
					if(task!=0 && task->tss.ss0 != 0)
					{
						extern void asm_end_app();
						cons_putstr0(task->cons,"\nBreak(key):\n");
						io_cli();
						task->tss.eax = (int)&(task->tss.esp0);
  2806bc:	89 43 54             	mov    %eax,0x54(%ebx)
						task->tss.eip = (int)asm_end_app - 0x280000;
						io_sti();
  2806bf:	e8 00 04 00 00       	call   280ac4 <io_sti>
						task_run(task,-1,0);
  2806c4:	83 c4 0c             	add    $0xc,%esp
  2806c7:	6a 00                	push   $0x0
  2806c9:	6a ff                	push   $0xffffffff
  2806cb:	53                   	push   %ebx
  2806cc:	e8 05 2a 00 00       	call   2830d6 <task_run>
  2806d1:	e9 de 03 00 00       	jmp    280ab4 <bootmain+0xab4>
					}
				}
				else if(i == 256 + 0x3c && key_shift != 0)	//shift + F2 to open new console
  2806d6:	81 fe 3c 01 00 00    	cmp    $0x13c,%esi
  2806dc:	75 54                	jne    280732 <bootmain+0x732>
  2806de:	84 c0                	test   %al,%al
  2806e0:	74 50                	je     280732 <bootmain+0x732>
				{
					if(key_win != 0) keywin_off(key_win);
  2806e2:	85 ff                	test   %edi,%edi
  2806e4:	74 0c                	je     2806f2 <bootmain+0x6f2>
  2806e6:	83 ec 0c             	sub    $0xc,%esp
  2806e9:	57                   	push   %edi
  2806ea:	e8 55 4c 00 00       	call   285344 <keywin_off>
  2806ef:	83 c4 10             	add    $0x10,%esp
					key_win = open_console(shtctl,memtotal);
  2806f2:	51                   	push   %ecx
  2806f3:	51                   	push   %ecx
  2806f4:	ff b5 a0 fb ff ff    	pushl  -0x460(%ebp)
  2806fa:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280700:	e8 b1 3b 00 00       	call   2842b6 <open_console>
					sheet_slide(key_win,32,4);
  280705:	83 c4 0c             	add    $0xc,%esp
					}
				}
				else if(i == 256 + 0x3c && key_shift != 0)	//shift + F2 to open new console
				{
					if(key_win != 0) keywin_off(key_win);
					key_win = open_console(shtctl,memtotal);
  280708:	89 c7                	mov    %eax,%edi
					sheet_slide(key_win,32,4);
  28070a:	6a 04                	push   $0x4
  28070c:	6a 20                	push   $0x20
  28070e:	50                   	push   %eax
  28070f:	e8 3f 24 00 00       	call   282b53 <sheet_slide>
					sheet_updown(key_win,shtctl->top);
  280714:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  28071a:	5b                   	pop    %ebx
  28071b:	5e                   	pop    %esi
  28071c:	ff 70 10             	pushl  0x10(%eax)
  28071f:	57                   	push   %edi
  280720:	e8 45 23 00 00       	call   282a6a <sheet_updown>
					keywin_on(key_win);
  280725:	89 3c 24             	mov    %edi,(%esp)
  280728:	e8 4b 4c 00 00       	call   285378 <keywin_on>
  28072d:	e9 82 03 00 00       	jmp    280ab4 <bootmain+0xab4>
				}
				else if(i == 256 + 0x57 && shtctl->top > 2)
  280732:	81 fe 57 01 00 00    	cmp    $0x157,%esi
  280738:	0f 85 0f fc ff ff    	jne    28034d <bootmain+0x34d>
  28073e:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  280744:	8b 40 10             	mov    0x10(%eax),%eax
  280747:	83 f8 02             	cmp    $0x2,%eax
  28074a:	0f 8e fd fb ff ff    	jle    28034d <bootmain+0x34d>
				{
					//F11 to pop the bottom window
					sheet_updown(shtctl->sheets[1],shtctl->top - 1);
  280750:	48                   	dec    %eax
  280751:	52                   	push   %edx
  280752:	52                   	push   %edx
  280753:	50                   	push   %eax
  280754:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  28075a:	ff 70 18             	pushl  0x18(%eax)
  28075d:	e8 08 23 00 00       	call   282a6a <sheet_updown>
  280762:	e9 4d 03 00 00       	jmp    280ab4 <bootmain+0xab4>
				}

			}
			else if(512<=i && i<=767)
  280767:	8d 86 00 fe ff ff    	lea    -0x200(%esi),%eax
  28076d:	3d ff 00 00 00       	cmp    $0xff,%eax
  280772:	0f 87 e8 02 00 00    	ja     280a60 <bootmain+0xa60>
			{
				if(mouse_decode(&mdec,i-512)!=0)
  280778:	50                   	push   %eax
  280779:	50                   	push   %eax
  28077a:	89 f0                	mov    %esi,%eax
  28077c:	0f b6 f0             	movzbl %al,%esi
  28077f:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  280785:	56                   	push   %esi
  280786:	50                   	push   %eax
  280787:	e8 82 16 00 00       	call   281e0e <mouse_decode>
  28078c:	83 c4 10             	add    $0x10,%esp
  28078f:	85 c0                	test   %eax,%eax
  280791:	0f 84 b6 fb ff ff    	je     28034d <bootmain+0x34d>
  280797:	31 c9                	xor    %ecx,%ecx
  280799:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  28079f:	03 85 f0 fb ff ff    	add    -0x410(%ebp),%eax
  2807a5:	0f 48 c1             	cmovs  %ecx,%eax
  2807a8:	89 85 e0 fb ff ff    	mov    %eax,-0x420(%ebp)
  2807ae:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  2807b4:	03 85 f4 fb ff ff    	add    -0x40c(%ebp),%eax
  2807ba:	0f 49 c8             	cmovns %eax,%ecx
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  2807bd:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2807c4:	3b 85 e0 fb ff ff    	cmp    -0x420(%ebp),%eax
  2807ca:	8d 50 ff             	lea    -0x1(%eax),%edx
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2807cd:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  2807d4:	0f 4f 95 e0 fb ff ff 	cmovg  -0x420(%ebp),%edx
  2807db:	89 95 e0 fb ff ff    	mov    %edx,-0x420(%ebp)
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2807e1:	8d 50 ff             	lea    -0x1(%eax),%edx
  2807e4:	39 c8                	cmp    %ecx,%eax
  2807e6:	0f 4f d1             	cmovg  %ecx,%edx
					//sheet_slide(sht_mouse,mx,my);
					new_mx = mx;
					new_my = my;
					if(mdec.btn & 0x01)
  2807e9:	f6 85 f8 fb ff ff 01 	testb  $0x1,-0x408(%ebp)
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2807f0:	89 95 dc fb ff ff    	mov    %edx,-0x424(%ebp)
					//sheet_slide(sht_mouse,mx,my);
					new_mx = mx;
					new_my = my;
					if(mdec.btn & 0x01)
  2807f6:	0f 84 f2 01 00 00    	je     2809ee <bootmain+0x9ee>
					{
						if(mmx < 0) 
  2807fc:	83 bd bc fb ff ff 00 	cmpl   $0x0,-0x444(%ebp)
  280803:	0f 89 91 01 00 00    	jns    28099a <bootmain+0x99a>
						{
							for(int j=shtctl->top-1;j>0;j--)
  280809:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  28080f:	8b 40 10             	mov    0x10(%eax),%eax
  280812:	48                   	dec    %eax
  280813:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
  280819:	85 c0                	test   %eax,%eax
  28081b:	0f 8e 71 01 00 00    	jle    280992 <bootmain+0x992>
							{
								sht = shtctl->sheets[j];
  280821:	8b 95 d8 fb ff ff    	mov    -0x428(%ebp),%edx
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280827:	8b b5 e0 fb ff ff    	mov    -0x420(%ebp),%esi
					{
						if(mmx < 0) 
						{
							for(int j=shtctl->top-1;j>0;j--)
							{
								sht = shtctl->sheets[j];
  28082d:	8b 54 82 14          	mov    0x14(%edx,%eax,4),%edx
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280831:	2b 72 0c             	sub    0xc(%edx),%esi
					{
						if(mmx < 0) 
						{
							for(int j=shtctl->top-1;j>0;j--)
							{
								sht = shtctl->sheets[j];
  280834:	89 95 e4 fb ff ff    	mov    %edx,-0x41c(%ebp)
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  28083a:	0f 88 4c 01 00 00    	js     28098c <bootmain+0x98c>
  280840:	8b 9d dc fb ff ff    	mov    -0x424(%ebp),%ebx
  280846:	2b 5a 10             	sub    0x10(%edx),%ebx
  280849:	8b 4a 04             	mov    0x4(%edx),%ecx
  28084c:	0f 88 3a 01 00 00    	js     28098c <bootmain+0x98c>
  280852:	39 ce                	cmp    %ecx,%esi
  280854:	0f 8d 32 01 00 00    	jge    28098c <bootmain+0x98c>
  28085a:	3b 5a 08             	cmp    0x8(%edx),%ebx
  28085d:	0f 8d 29 01 00 00    	jge    28098c <bootmain+0x98c>
								{
									if(sht->buf[y*sht->bxsize+x] != sht->col_inv )
  280863:	8b 12                	mov    (%edx),%edx
  280865:	0f af cb             	imul   %ebx,%ecx
  280868:	01 f2                	add    %esi,%edx
  28086a:	89 8d d0 fb ff ff    	mov    %ecx,-0x430(%ebp)
  280870:	89 d1                	mov    %edx,%ecx
  280872:	8b 95 d0 fb ff ff    	mov    -0x430(%ebp),%edx
  280878:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  28087c:	8b 95 e4 fb ff ff    	mov    -0x41c(%ebp),%edx
  280882:	3b 4a 14             	cmp    0x14(%edx),%ecx
  280885:	0f 84 01 01 00 00    	je     28098c <bootmain+0x98c>
									{
										sheet_updown(sht,shtctl->top-1);
  28088b:	50                   	push   %eax
  28088c:	50                   	push   %eax
  28088d:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280893:	52                   	push   %edx
  280894:	e8 d1 21 00 00       	call   282a6a <sheet_updown>
										if(sht!=key_win)
  280899:	83 c4 10             	add    $0x10,%esp
  28089c:	3b bd e4 fb ff ff    	cmp    -0x41c(%ebp),%edi
  2808a2:	74 18                	je     2808bc <bootmain+0x8bc>
										{
											keywin_off(key_win);
  2808a4:	83 ec 0c             	sub    $0xc,%esp
  2808a7:	57                   	push   %edi
  2808a8:	e8 97 4a 00 00       	call   285344 <keywin_off>
											key_win = sht;
											keywin_on(key_win);
  2808ad:	5f                   	pop    %edi
  2808ae:	ff b5 e4 fb ff ff    	pushl  -0x41c(%ebp)
  2808b4:	e8 bf 4a 00 00       	call   285378 <keywin_on>
  2808b9:	83 c4 10             	add    $0x10,%esp
  2808bc:	8b 85 e4 fb ff ff    	mov    -0x41c(%ebp),%eax
										}
										if(x>=3 && x<sht->bxsize-3 && y>=3 && y<21)
  2808c2:	83 fe 02             	cmp    $0x2,%esi
  2808c5:	8b 40 04             	mov    0x4(%eax),%eax
  2808c8:	7e 3f                	jle    280909 <bootmain+0x909>
  2808ca:	8d 50 fd             	lea    -0x3(%eax),%edx
  2808cd:	39 d6                	cmp    %edx,%esi
  2808cf:	7d 38                	jge    280909 <bootmain+0x909>
  2808d1:	8d 53 fd             	lea    -0x3(%ebx),%edx
  2808d4:	83 fa 11             	cmp    $0x11,%edx
  2808d7:	77 30                	ja     280909 <bootmain+0x909>
										{
											mmx = mx;
											mmy = my;
											mmx2 = sht->vx0;
  2808d9:	8b 8d e4 fb ff ff    	mov    -0x41c(%ebp),%ecx
  2808df:	8b 79 0c             	mov    0xc(%ecx),%edi
  2808e2:	89 bd 9c fb ff ff    	mov    %edi,-0x464(%ebp)
											new_wy = sht->vy0;
  2808e8:	8b 79 10             	mov    0x10(%ecx),%edi
											keywin_on(key_win);
										}
										if(x>=3 && x<sht->bxsize-3 && y>=3 && y<21)
										{
											mmx = mx;
											mmy = my;
  2808eb:	8b 8d dc fb ff ff    	mov    -0x424(%ebp),%ecx
											mmx2 = sht->vx0;
											new_wy = sht->vy0;
  2808f1:	89 bd b4 fb ff ff    	mov    %edi,-0x44c(%ebp)
											key_win = sht;
											keywin_on(key_win);
										}
										if(x>=3 && x<sht->bxsize-3 && y>=3 && y<21)
										{
											mmx = mx;
  2808f7:	8b bd e0 fb ff ff    	mov    -0x420(%ebp),%edi
											mmy = my;
  2808fd:	89 8d a4 fb ff ff    	mov    %ecx,-0x45c(%ebp)
											key_win = sht;
											keywin_on(key_win);
										}
										if(x>=3 && x<sht->bxsize-3 && y>=3 && y<21)
										{
											mmx = mx;
  280903:	89 bd bc fb ff ff    	mov    %edi,-0x444(%ebp)
											mmy = my;
											mmx2 = sht->vx0;
											new_wy = sht->vy0;
										}
										if(sht->bxsize - 21 <= x && x<sht->bxsize - 5 && y>=5 && y<19) //click the close button
  280909:	8d 50 eb             	lea    -0x15(%eax),%edx
  28090c:	39 d6                	cmp    %edx,%esi
  28090e:	7c 74                	jl     280984 <bootmain+0x984>
  280910:	83 e8 05             	sub    $0x5,%eax
  280913:	39 c6                	cmp    %eax,%esi
  280915:	7d 6d                	jge    280984 <bootmain+0x984>
  280917:	83 eb 05             	sub    $0x5,%ebx
  28091a:	83 fb 0d             	cmp    $0xd,%ebx
  28091d:	77 65                	ja     280984 <bootmain+0x984>
										{
											if(sht->flags & 0x10)	//app window
  28091f:	8b 85 e4 fb ff ff    	mov    -0x41c(%ebp),%eax
  280925:	f6 40 1c 10          	testb  $0x10,0x1c(%eax)
  280929:	8b 58 24             	mov    0x24(%eax),%ebx
  28092c:	74 3c                	je     28096a <bootmain+0x96a>
											{
												if(sht->task != 0)
  28092e:	85 db                	test   %ebx,%ebx
  280930:	74 52                	je     280984 <bootmain+0x984>
												{
													struct TASK *task = sht->task;
													struct CONSOLE *cons = task->cons;
													cons_putstr0(cons,"\nBreak(mouse) :\n");
  280932:	51                   	push   %ecx
  280933:	51                   	push   %ecx
  280934:	68 ae 54 28 00       	push   $0x2854ae
  280939:	ff b3 a4 00 00 00    	pushl  0xa4(%ebx)
  28093f:	e8 8f 35 00 00       	call   283ed3 <cons_putstr0>
													io_cli();
  280944:	e8 79 01 00 00       	call   280ac2 <io_cli>
													task->tss.eax = (int)&(task->tss.esp0);
  280949:	8d 43 30             	lea    0x30(%ebx),%eax
													extern void asm_end_app();
													task->tss.eip = (int)&asm_end_app - 0x280000;
  28094c:	c7 43 4c d0 2e 00 00 	movl   $0x2ed0,0x4c(%ebx)
												{
													struct TASK *task = sht->task;
													struct CONSOLE *cons = task->cons;
													cons_putstr0(cons,"\nBreak(mouse) :\n");
													io_cli();
													task->tss.eax = (int)&(task->tss.esp0);
  280953:	89 43 54             	mov    %eax,0x54(%ebx)
													extern void asm_end_app();
													task->tss.eip = (int)&asm_end_app - 0x280000;
													io_sti();
  280956:	e8 69 01 00 00       	call   280ac4 <io_sti>
													task_run(task,-1,0);
  28095b:	83 c4 0c             	add    $0xc,%esp
  28095e:	6a 00                	push   $0x0
  280960:	6a ff                	push   $0xffffffff
  280962:	53                   	push   %ebx
  280963:	e8 6e 27 00 00       	call   2830d6 <task_run>
  280968:	eb 17                	jmp    280981 <bootmain+0x981>
											}
											else				//console window
											{
												struct TASK *task = sht->task;
												io_cli();
												fifo32_put(&task->fifo,4);
  28096a:	83 c3 10             	add    $0x10,%ebx
												}
											}
											else				//console window
											{
												struct TASK *task = sht->task;
												io_cli();
  28096d:	e8 50 01 00 00       	call   280ac2 <io_cli>
												fifo32_put(&task->fifo,4);
  280972:	52                   	push   %edx
  280973:	52                   	push   %edx
  280974:	6a 04                	push   $0x4
  280976:	53                   	push   %ebx
  280977:	e8 8d 13 00 00       	call   281d09 <fifo32_put>
												io_sti();
  28097c:	e8 43 01 00 00       	call   280ac4 <io_sti>
  280981:	83 c4 10             	add    $0x10,%esp
  280984:	8b bd e4 fb ff ff    	mov    -0x41c(%ebp),%edi
  28098a:	eb 06                	jmp    280992 <bootmain+0x992>
					new_my = my;
					if(mdec.btn & 0x01)
					{
						if(mmx < 0) 
						{
							for(int j=shtctl->top-1;j>0;j--)
  28098c:	48                   	dec    %eax
  28098d:	e9 87 fe ff ff       	jmp    280819 <bootmain+0x819>
  280992:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  280998:	eb 3d                	jmp    2809d7 <bootmain+0x9d7>
						}
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							new_wx = (mmx2+x+2)&~3;
  28099a:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
  2809a0:	2b 85 bc fb ff ff    	sub    -0x444(%ebp),%eax
  2809a6:	8b b5 9c fb ff ff    	mov    -0x464(%ebp),%esi
  2809ac:	8d 44 06 02          	lea    0x2(%esi,%eax,1),%eax
  2809b0:	83 e0 fc             	and    $0xfffffffc,%eax
  2809b3:	89 85 c0 fb ff ff    	mov    %eax,-0x440(%ebp)
							new_wy = new_wy+y;
  2809b9:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  2809bf:	2b 85 a4 fb ff ff    	sub    -0x45c(%ebp),%eax
  2809c5:	01 85 b4 fb ff ff    	add    %eax,-0x44c(%ebp)
							//sheet_slide(sht,(mmx2+x+2)&~3,sht->vy0+y);
							mmy = my;
  2809cb:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  2809d1:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							new_wx = (mmx2+x+2)&~3;
							new_wy = new_wy+y;
  2809d7:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
  2809dd:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
  2809e3:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
  2809e9:	e9 5f f9 ff ff       	jmp    28034d <bootmain+0x34d>
						}
					}
					else
					{
						mmx = -1;
						if(new_wx != 0x7fffffff)
  2809ee:	81 bd c0 fb ff ff ff 	cmpl   $0x7fffffff,-0x440(%ebp)
  2809f5:	ff ff 7f 
  2809f8:	75 27                	jne    280a21 <bootmain+0xa21>
  2809fa:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  280a00:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
  280a06:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
  280a0c:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
							mmy = my;
						}
					}
					else
					{
						mmx = -1;
  280a12:	c7 85 bc fb ff ff ff 	movl   $0xffffffff,-0x444(%ebp)
  280a19:	ff ff ff 
  280a1c:	e9 2c f9 ff ff       	jmp    28034d <bootmain+0x34d>
						if(new_wx != 0x7fffffff)
						{
							sheet_slide(sht,new_wx,new_wy);
  280a21:	50                   	push   %eax
  280a22:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  280a28:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  280a2e:	ff b5 e4 fb ff ff    	pushl  -0x41c(%ebp)
  280a34:	e8 1a 21 00 00       	call   282b53 <sheet_slide>
  280a39:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  280a3f:	83 c4 10             	add    $0x10,%esp
							new_wx = 0x7fffffff;
  280a42:	c7 85 c0 fb ff ff ff 	movl   $0x7fffffff,-0x440(%ebp)
  280a49:	ff ff 7f 
					else
					{
						mmx = -1;
						if(new_wx != 0x7fffffff)
						{
							sheet_slide(sht,new_wx,new_wy);
  280a4c:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
  280a52:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
  280a58:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
  280a5e:	eb b2                	jmp    280a12 <bootmain+0xa12>
							new_wx = 0x7fffffff;
						}
					}
				}
			}
			else if(768<=i && i<=1023)
  280a60:	8d 86 00 fd ff ff    	lea    -0x300(%esi),%eax
  280a66:	3d ff 00 00 00       	cmp    $0xff,%eax
  280a6b:	77 1b                	ja     280a88 <bootmain+0xa88>
			{
				close_console(shtctl->sheets0 + (i-768));
  280a6d:	6b f6 28             	imul   $0x28,%esi,%esi
  280a70:	8b 85 d8 fb ff ff    	mov    -0x428(%ebp),%eax
  280a76:	83 ec 0c             	sub    $0xc,%esp
  280a79:	8d 84 30 14 8c ff ff 	lea    -0x73ec(%eax,%esi,1),%eax
  280a80:	50                   	push   %eax
  280a81:	e8 09 39 00 00       	call   28438f <close_console>
  280a86:	eb 2c                	jmp    280ab4 <bootmain+0xab4>
			}
			else if(1024<=i && i<=2023)
  280a88:	8d 86 00 fc ff ff    	lea    -0x400(%esi),%eax
  280a8e:	3d e7 03 00 00       	cmp    $0x3e7,%eax
  280a93:	0f 87 b4 f8 ff ff    	ja     28034d <bootmain+0x34d>
			{
				extern struct TASKCTL *taskctl;
				close_constask(taskctl->tasks0 + (i-1024));
  280a99:	69 f6 c0 00 00 00    	imul   $0xc0,%esi,%esi
  280a9f:	a1 bc a9 28 00       	mov    0x28a9bc,%eax
  280aa4:	83 ec 0c             	sub    $0xc,%esp
  280aa7:	8d 84 30 f8 0f fd ff 	lea    -0x2f008(%eax,%esi,1),%eax
  280aae:	50                   	push   %eax
  280aaf:	e8 8f 38 00 00       	call   284343 <close_constask>
  280ab4:	83 c4 10             	add    $0x10,%esp
  280ab7:	e9 91 f8 ff ff       	jmp    28034d <bootmain+0x34d>
  280abc:	66 90                	xchg   %ax,%ax
  280abe:	66 90                	xchg   %ax,%ax

00280ac0 <io_hlt>:
  280ac0:	f4                   	hlt    
  280ac1:	c3                   	ret    

00280ac2 <io_cli>:
  280ac2:	fa                   	cli    
  280ac3:	c3                   	ret    

00280ac4 <io_sti>:
  280ac4:	fb                   	sti    
  280ac5:	c3                   	ret    

00280ac6 <io_stihlt>:
  280ac6:	fb                   	sti    
  280ac7:	f4                   	hlt    
  280ac8:	c3                   	ret    

00280ac9 <write_mem8>:
  280ac9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  280acd:	8a 44 24 08          	mov    0x8(%esp),%al
  280ad1:	88 01                	mov    %al,(%ecx)
  280ad3:	c3                   	ret    

00280ad4 <io_in8>:
  280ad4:	8b 54 24 04          	mov    0x4(%esp),%edx
  280ad8:	b8 00 00 00 00       	mov    $0x0,%eax
  280add:	ec                   	in     (%dx),%al
  280ade:	c3                   	ret    

00280adf <io_in16>:
  280adf:	8b 54 24 04          	mov    0x4(%esp),%edx
  280ae3:	b8 00 00 00 00       	mov    $0x0,%eax
  280ae8:	66 ed                	in     (%dx),%ax
  280aea:	c3                   	ret    

00280aeb <io_in32>:
  280aeb:	8b 54 24 04          	mov    0x4(%esp),%edx
  280aef:	b8 00 00 00 00       	mov    $0x0,%eax
  280af4:	ed                   	in     (%dx),%eax
  280af5:	c3                   	ret    

00280af6 <io_out8>:
  280af6:	8b 54 24 04          	mov    0x4(%esp),%edx
  280afa:	8b 44 24 08          	mov    0x8(%esp),%eax
  280afe:	ee                   	out    %al,(%dx)
  280aff:	c3                   	ret    

00280b00 <io_out16>:
  280b00:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b04:	8b 44 24 08          	mov    0x8(%esp),%eax
  280b08:	66 ef                	out    %ax,(%dx)
  280b0a:	c3                   	ret    

00280b0b <io_out32>:
  280b0b:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b0f:	8b 44 24 08          	mov    0x8(%esp),%eax
  280b13:	ef                   	out    %eax,(%dx)
  280b14:	c3                   	ret    

00280b15 <io_load_eflags>:
  280b15:	9c                   	pushf  
  280b16:	58                   	pop    %eax
  280b17:	c3                   	ret    

00280b18 <io_store_eflags>:
  280b18:	8b 44 24 04          	mov    0x4(%esp),%eax
  280b1c:	50                   	push   %eax
  280b1d:	9d                   	popf   
  280b1e:	c3                   	ret    

00280b1f <load_gdtr>:
  280b1f:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280b24:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280b29:	0f 01 54 24 06       	lgdtl  0x6(%esp)
  280b2e:	c3                   	ret    

00280b2f <load_idtr>:
  280b2f:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280b34:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280b39:	0f 01 5c 24 06       	lidtl  0x6(%esp)
  280b3e:	c3                   	ret    

00280b3f <load_cr0>:
  280b3f:	0f 20 c0             	mov    %cr0,%eax
  280b42:	c3                   	ret    

00280b43 <store_cr0>:
  280b43:	8b 44 24 04          	mov    0x4(%esp),%eax
  280b47:	0f 22 c0             	mov    %eax,%cr0
  280b4a:	c3                   	ret    

00280b4b <_memtest_sub>:
  280b4b:	57                   	push   %edi
  280b4c:	56                   	push   %esi
  280b4d:	53                   	push   %ebx
  280b4e:	be 55 aa 55 aa       	mov    $0xaa55aa55,%esi
  280b53:	bf aa 55 aa 55       	mov    $0x55aa55aa,%edi
  280b58:	8b 44 24 10          	mov    0x10(%esp),%eax

00280b5c <mts_loop>:
  280b5c:	89 c3                	mov    %eax,%ebx
  280b5e:	81 c3 fc 0f 00 00    	add    $0xffc,%ebx
  280b64:	8b 13                	mov    (%ebx),%edx
  280b66:	89 33                	mov    %esi,(%ebx)
  280b68:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280b6b:	3b 3b                	cmp    (%ebx),%edi
  280b6d:	75 18                	jne    280b87 <mts_qit>
  280b6f:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280b72:	3b 33                	cmp    (%ebx),%esi
  280b74:	75 11                	jne    280b87 <mts_qit>
  280b76:	89 13                	mov    %edx,(%ebx)
  280b78:	05 00 10 00 00       	add    $0x1000,%eax
  280b7d:	3b 44 24 14          	cmp    0x14(%esp),%eax
  280b81:	76 d9                	jbe    280b5c <mts_loop>

00280b83 <mts_ret>:
  280b83:	5b                   	pop    %ebx
  280b84:	5e                   	pop    %esi
  280b85:	5f                   	pop    %edi
  280b86:	c3                   	ret    

00280b87 <mts_qit>:
  280b87:	89 13                	mov    %edx,(%ebx)
  280b89:	5b                   	pop    %ebx
  280b8a:	5e                   	pop    %esi
  280b8b:	5f                   	pop    %edi
  280b8c:	c3                   	ret    

00280b8d <set_palette>:
	set_palette(16,231,table2);
	return;	
}

void set_palette(int start, int end, unsigned char *rgb)
{
  280b8d:	55                   	push   %ebp
  280b8e:	89 e5                	mov    %esp,%ebp
  280b90:	57                   	push   %edi
  280b91:	56                   	push   %esi
  280b92:	53                   	push   %ebx
  280b93:	83 ec 1c             	sub    $0x1c,%esp
  280b96:	8b 75 08             	mov    0x8(%ebp),%esi
  280b99:	8b 7d 0c             	mov    0xc(%ebp),%edi
  280b9c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int i,eflags;
	eflags = io_load_eflags();
  280b9f:	e8 71 ff ff ff       	call   280b15 <io_load_eflags>
  280ba4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	io_cli();
  280ba7:	e8 16 ff ff ff       	call   280ac2 <io_cli>
	io_out8(0x03c8,start);
  280bac:	83 ec 08             	sub    $0x8,%esp
  280baf:	56                   	push   %esi
  280bb0:	68 c8 03 00 00       	push   $0x3c8
  280bb5:	e8 3c ff ff ff       	call   280af6 <io_out8>
	for(i=start;i<=end;i++)
  280bba:	83 c4 10             	add    $0x10,%esp
  280bbd:	39 fe                	cmp    %edi,%esi
  280bbf:	7f 54                	jg     280c15 <set_palette+0x88>
	{
		io_out8(0x03c9,rgb[0]/4);
  280bc1:	83 ec 08             	sub    $0x8,%esp
  280bc4:	0f b6 03             	movzbl (%ebx),%eax
  280bc7:	c0 e8 02             	shr    $0x2,%al
  280bca:	0f b6 c0             	movzbl %al,%eax
  280bcd:	50                   	push   %eax
  280bce:	68 c9 03 00 00       	push   $0x3c9
  280bd3:	e8 1e ff ff ff       	call   280af6 <io_out8>
		io_out8(0x03c9,rgb[1]/4);
  280bd8:	83 c4 08             	add    $0x8,%esp
  280bdb:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  280bdf:	c0 e8 02             	shr    $0x2,%al
  280be2:	0f b6 c0             	movzbl %al,%eax
  280be5:	50                   	push   %eax
  280be6:	68 c9 03 00 00       	push   $0x3c9
  280beb:	e8 06 ff ff ff       	call   280af6 <io_out8>
		io_out8(0x03c9,rgb[2]/4);
  280bf0:	83 c4 08             	add    $0x8,%esp
  280bf3:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
  280bf7:	c0 e8 02             	shr    $0x2,%al
  280bfa:	0f b6 c0             	movzbl %al,%eax
  280bfd:	50                   	push   %eax
  280bfe:	68 c9 03 00 00       	push   $0x3c9
  280c03:	e8 ee fe ff ff       	call   280af6 <io_out8>
		rgb+=3;
  280c08:	83 c3 03             	add    $0x3,%ebx
{
	int i,eflags;
	eflags = io_load_eflags();
	io_cli();
	io_out8(0x03c8,start);
	for(i=start;i<=end;i++)
  280c0b:	83 c6 01             	add    $0x1,%esi
  280c0e:	83 c4 10             	add    $0x10,%esp
  280c11:	39 f7                	cmp    %esi,%edi
  280c13:	7d ac                	jge    280bc1 <set_palette+0x34>
		io_out8(0x03c9,rgb[0]/4);
		io_out8(0x03c9,rgb[1]/4);
		io_out8(0x03c9,rgb[2]/4);
		rgb+=3;
	}
	io_store_eflags(eflags);
  280c15:	83 ec 0c             	sub    $0xc,%esp
  280c18:	ff 75 e4             	pushl  -0x1c(%ebp)
  280c1b:	e8 f8 fe ff ff       	call   280b18 <io_store_eflags>
	return;
  280c20:	83 c4 10             	add    $0x10,%esp
}
  280c23:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280c26:	5b                   	pop    %ebx
  280c27:	5e                   	pop    %esi
  280c28:	5f                   	pop    %edi
  280c29:	5d                   	pop    %ebp
  280c2a:	c3                   	ret    

00280c2b <init_palette>:
#include "graphics.h"

void init_palette(void)
{
  280c2b:	55                   	push   %ebp
  280c2c:	89 e5                	mov    %esp,%ebp
  280c2e:	57                   	push   %edi
  280c2f:	56                   	push   %esi
  280c30:	53                   	push   %ebx
  280c31:	81 ec a0 02 00 00    	sub    $0x2a0,%esp
		0x00, 0x84, 0x84,	//dark light blue
		0x84, 0x84, 0x84,	//dark gray
	};
	unsigned char table2[216*3];
	int r,g,b;
	set_palette(0,15,table_rgb);
  280c37:	68 60 68 28 00       	push   $0x286860
  280c3c:	6a 0f                	push   $0xf
  280c3e:	6a 00                	push   $0x0
  280c40:	e8 48 ff ff ff       	call   280b8d <set_palette>
  280c45:	8d bd 60 fd ff ff    	lea    -0x2a0(%ebp),%edi
  280c4b:	83 c4 10             	add    $0x10,%esp
  280c4e:	bb 00 00 00 00       	mov    $0x0,%ebx
  280c53:	eb 32                	jmp    280c87 <init_palette+0x5c>
	{
		for(g=0;g<6;g++)
		{
			for(r=0;r<6;r++)
			{
				table2[(r+g*6+b*36)*3+0] = r*51;
  280c55:	88 10                	mov    %dl,(%eax)
				table2[(r+g*6+b*36)*3+1] = g*51;
  280c57:	88 48 01             	mov    %cl,0x1(%eax)
				table2[(r+g*6+b*36)*3+2] = b*51;
  280c5a:	88 58 02             	mov    %bl,0x2(%eax)
  280c5d:	83 c2 33             	add    $0x33,%edx
  280c60:	83 c0 03             	add    $0x3,%eax
	set_palette(0,15,table_rgb);
	for(b=0;b<6;b++)
	{
		for(g=0;g<6;g++)
		{
			for(r=0;r<6;r++)
  280c63:	80 fa 32             	cmp    $0x32,%dl
  280c66:	75 ed                	jne    280c55 <init_palette+0x2a>
  280c68:	83 c6 12             	add    $0x12,%esi
  280c6b:	83 c1 33             	add    $0x33,%ecx
	unsigned char table2[216*3];
	int r,g,b;
	set_palette(0,15,table_rgb);
	for(b=0;b<6;b++)
	{
		for(g=0;g<6;g++)
  280c6e:	80 f9 32             	cmp    $0x32,%cl
  280c71:	74 09                	je     280c7c <init_palette+0x51>
#include "graphics.h"

void init_palette(void)
{
  280c73:	89 f0                	mov    %esi,%eax
  280c75:	ba 00 00 00 00       	mov    $0x0,%edx
  280c7a:	eb d9                	jmp    280c55 <init_palette+0x2a>
  280c7c:	83 c3 33             	add    $0x33,%ebx
  280c7f:	83 c7 6c             	add    $0x6c,%edi
		0x84, 0x84, 0x84,	//dark gray
	};
	unsigned char table2[216*3];
	int r,g,b;
	set_palette(0,15,table_rgb);
	for(b=0;b<6;b++)
  280c82:	80 fb 32             	cmp    $0x32,%bl
  280c85:	74 09                	je     280c90 <init_palette+0x65>
#include "graphics.h"

void init_palette(void)
{
  280c87:	89 fe                	mov    %edi,%esi
  280c89:	b9 00 00 00 00       	mov    $0x0,%ecx
  280c8e:	eb e3                	jmp    280c73 <init_palette+0x48>
				table2[(r+g*6+b*36)*3+1] = g*51;
				table2[(r+g*6+b*36)*3+2] = b*51;
			}
		}
	}
	set_palette(16,231,table2);
  280c90:	83 ec 04             	sub    $0x4,%esp
  280c93:	8d 85 60 fd ff ff    	lea    -0x2a0(%ebp),%eax
  280c99:	50                   	push   %eax
  280c9a:	68 e7 00 00 00       	push   $0xe7
  280c9f:	6a 10                	push   $0x10
  280ca1:	e8 e7 fe ff ff       	call   280b8d <set_palette>
	return;	
  280ca6:	83 c4 10             	add    $0x10,%esp
}
  280ca9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280cac:	5b                   	pop    %ebx
  280cad:	5e                   	pop    %esi
  280cae:	5f                   	pop    %edi
  280caf:	5d                   	pop    %ebp
  280cb0:	c3                   	ret    

00280cb1 <boxfill8>:
	io_store_eflags(eflags);
	return;
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
  280cb1:	55                   	push   %ebp
  280cb2:	89 e5                	mov    %esp,%ebp
  280cb4:	57                   	push   %edi
  280cb5:	56                   	push   %esi
  280cb6:	53                   	push   %ebx
  280cb7:	83 ec 04             	sub    $0x4,%esp
  280cba:	8b 55 0c             	mov    0xc(%ebp),%edx
  280cbd:	8b 7d 14             	mov    0x14(%ebp),%edi
  280cc0:	8b 75 18             	mov    0x18(%ebp),%esi
  280cc3:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  280cc6:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
	int x,y;
	for(y=y0;y<=y1;y++)
  280cca:	3b 75 20             	cmp    0x20(%ebp),%esi
  280ccd:	7f 28                	jg     280cf7 <boxfill8+0x46>
  280ccf:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280cd2:	0f af d6             	imul   %esi,%edx
  280cd5:	03 55 08             	add    0x8(%ebp),%edx
  280cd8:	eb 15                	jmp    280cef <boxfill8+0x3e>
	{
		for(x=x0;x<=x1;x++)
			vram[y*xsize+x]=c;
  280cda:	88 1c 02             	mov    %bl,(%edx,%eax,1)
void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
	{
		for(x=x0;x<=x1;x++)
  280cdd:	83 c0 01             	add    $0x1,%eax
  280ce0:	39 c1                	cmp    %eax,%ecx
  280ce2:	7d f6                	jge    280cda <boxfill8+0x29>
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
  280ce4:	83 c6 01             	add    $0x1,%esi
  280ce7:	03 55 f0             	add    -0x10(%ebp),%edx
  280cea:	39 75 20             	cmp    %esi,0x20(%ebp)
  280ced:	7c 08                	jl     280cf7 <boxfill8+0x46>
	{
		for(x=x0;x<=x1;x++)
  280cef:	89 f8                	mov    %edi,%eax
  280cf1:	39 cf                	cmp    %ecx,%edi
  280cf3:	7e e5                	jle    280cda <boxfill8+0x29>
  280cf5:	eb ed                	jmp    280ce4 <boxfill8+0x33>
			vram[y*xsize+x]=c;
	}
		
	return;
}
  280cf7:	83 c4 04             	add    $0x4,%esp
  280cfa:	5b                   	pop    %ebx
  280cfb:	5e                   	pop    %esi
  280cfc:	5f                   	pop    %edi
  280cfd:	5d                   	pop    %ebp
  280cfe:	c3                   	ret    

00280cff <boxfill8_test>:

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
  280cff:	55                   	push   %ebp
  280d00:	89 e5                	mov    %esp,%ebp
  280d02:	53                   	push   %ebx
  280d03:	8b 5d 08             	mov    0x8(%ebp),%ebx
  280d06:	8b 55 10             	mov    0x10(%ebp),%edx
  280d09:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	int i;
	for(i=0;i<size;i++)
  280d0d:	85 d2                	test   %edx,%edx
  280d0f:	7e 0d                	jle    280d1e <boxfill8_test+0x1f>
  280d11:	89 d8                	mov    %ebx,%eax
  280d13:	01 da                	add    %ebx,%edx
	{
		vram[i] = c;
  280d15:	88 08                	mov    %cl,(%eax)
  280d17:	83 c0 01             	add    $0x1,%eax
}

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
	int i;
	for(i=0;i<size;i++)
  280d1a:	39 d0                	cmp    %edx,%eax
  280d1c:	75 f7                	jne    280d15 <boxfill8_test+0x16>
	{
		vram[i] = c;
	}
	//vram[TRY_BG_SIZE-1] = c;
}
  280d1e:	5b                   	pop    %ebx
  280d1f:	5d                   	pop    %ebp
  280d20:	c3                   	ret    

00280d21 <init_screen8>:

void init_screen8(unsigned char *vram, int xsize, int ysize)
{
  280d21:	55                   	push   %ebp
  280d22:	89 e5                	mov    %esp,%ebp
  280d24:	57                   	push   %edi
  280d25:	56                   	push   %esi
  280d26:	53                   	push   %ebx
  280d27:	83 ec 14             	sub    $0x14,%esp
  280d2a:	8b 7d 08             	mov    0x8(%ebp),%edi
  280d2d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280d30:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(vram,310,COL8_008484,0,0,310,190);
  280d33:	68 be 00 00 00       	push   $0xbe
  280d38:	68 36 01 00 00       	push   $0x136
  280d3d:	6a 00                	push   $0x0
  280d3f:	6a 00                	push   $0x0
  280d41:	6a 0e                	push   $0xe
  280d43:	68 36 01 00 00       	push   $0x136
  280d48:	57                   	push   %edi
  280d49:	e8 63 ff ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_008484,0,      0,          xsize-1,    ysize-29);
  280d4e:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280d51:	89 c2                	mov    %eax,%edx
  280d53:	8d 46 e3             	lea    -0x1d(%esi),%eax
  280d56:	50                   	push   %eax
  280d57:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280d5a:	52                   	push   %edx
  280d5b:	6a 00                	push   $0x0
  280d5d:	6a 00                	push   $0x0
  280d5f:	6a 0e                	push   $0xe
  280d61:	53                   	push   %ebx
  280d62:	57                   	push   %edi
  280d63:	e8 49 ff ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-28,   xsize-1,    ysize-28);
  280d68:	8d 46 e4             	lea    -0x1c(%esi),%eax
  280d6b:	83 c4 38             	add    $0x38,%esp
  280d6e:	50                   	push   %eax
  280d6f:	ff 75 f0             	pushl  -0x10(%ebp)
  280d72:	50                   	push   %eax
  280d73:	6a 00                	push   $0x0
  280d75:	6a 08                	push   $0x8
  280d77:	53                   	push   %ebx
  280d78:	57                   	push   %edi
  280d79:	e8 33 ff ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,0,      ysize-27,   xsize-1,    ysize-27);
  280d7e:	8d 46 e5             	lea    -0x1b(%esi),%eax
  280d81:	50                   	push   %eax
  280d82:	ff 75 f0             	pushl  -0x10(%ebp)
  280d85:	50                   	push   %eax
  280d86:	6a 00                	push   $0x0
  280d88:	6a 07                	push   $0x7
  280d8a:	53                   	push   %ebx
  280d8b:	57                   	push   %edi
  280d8c:	e8 20 ff ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-26,   xsize-1,    ysize- 1);
  280d91:	83 c4 38             	add    $0x38,%esp
  280d94:	8d 46 ff             	lea    -0x1(%esi),%eax
  280d97:	50                   	push   %eax
  280d98:	ff 75 f0             	pushl  -0x10(%ebp)
  280d9b:	8d 46 e6             	lea    -0x1a(%esi),%eax
  280d9e:	50                   	push   %eax
  280d9f:	6a 00                	push   $0x0
  280da1:	6a 08                	push   $0x8
  280da3:	53                   	push   %ebx
  280da4:	57                   	push   %edi
  280da5:	e8 07 ff ff ff       	call   280cb1 <boxfill8>
	
	
	boxfill8(vram,xsize,COL8_FFFFFF,3,      ysize-24,   59,         ysize-24);
  280daa:	8d 46 e8             	lea    -0x18(%esi),%eax
  280dad:	50                   	push   %eax
  280dae:	6a 3b                	push   $0x3b
  280db0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  280db3:	50                   	push   %eax
  280db4:	6a 03                	push   $0x3
  280db6:	6a 07                	push   $0x7
  280db8:	53                   	push   %ebx
  280db9:	57                   	push   %edi
  280dba:	e8 f2 fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,2,      ysize-24,    2,         ysize- 4);
  280dbf:	8d 4e fc             	lea    -0x4(%esi),%ecx
  280dc2:	83 c4 38             	add    $0x38,%esp
  280dc5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  280dc8:	51                   	push   %ecx
  280dc9:	6a 02                	push   $0x2
  280dcb:	ff 75 f0             	pushl  -0x10(%ebp)
  280dce:	6a 02                	push   $0x2
  280dd0:	6a 07                	push   $0x7
  280dd2:	53                   	push   %ebx
  280dd3:	57                   	push   %edi
  280dd4:	e8 d8 fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,3,      ysize- 4,   59,         ysize- 4);
  280dd9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  280ddc:	51                   	push   %ecx
  280ddd:	6a 3b                	push   $0x3b
  280ddf:	51                   	push   %ecx
  280de0:	6a 03                	push   $0x3
  280de2:	6a 0f                	push   $0xf
  280de4:	53                   	push   %ebx
  280de5:	57                   	push   %edi
  280de6:	e8 c6 fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,59,     ysize-23,   59,         ysize- 5);
  280deb:	8d 56 e9             	lea    -0x17(%esi),%edx
  280dee:	83 c4 38             	add    $0x38,%esp
  280df1:	8d 46 fb             	lea    -0x5(%esi),%eax
  280df4:	50                   	push   %eax
  280df5:	6a 3b                	push   $0x3b
  280df7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  280dfa:	52                   	push   %edx
  280dfb:	6a 3b                	push   $0x3b
  280dfd:	6a 0f                	push   $0xf
  280dff:	53                   	push   %ebx
  280e00:	57                   	push   %edi
  280e01:	e8 ab fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,2,      ysize- 3,   59,         ysize- 3);
  280e06:	83 ee 03             	sub    $0x3,%esi
  280e09:	56                   	push   %esi
  280e0a:	6a 3b                	push   $0x3b
  280e0c:	56                   	push   %esi
  280e0d:	6a 02                	push   $0x2
  280e0f:	6a 00                	push   $0x0
  280e11:	53                   	push   %ebx
  280e12:	57                   	push   %edi
  280e13:	e8 99 fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,60,     ysize-24,   60,         ysize- 3);
  280e18:	83 c4 38             	add    $0x38,%esp
  280e1b:	56                   	push   %esi
  280e1c:	6a 3c                	push   $0x3c
  280e1e:	ff 75 f0             	pushl  -0x10(%ebp)
  280e21:	6a 3c                	push   $0x3c
  280e23:	6a 00                	push   $0x0
  280e25:	53                   	push   %ebx
  280e26:	57                   	push   %edi
  280e27:	e8 85 fe ff ff       	call   280cb1 <boxfill8>
	
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-24,   xsize- 4,   ysize-24);
  280e2c:	8d 4b fc             	lea    -0x4(%ebx),%ecx
  280e2f:	8d 53 d1             	lea    -0x2f(%ebx),%edx
  280e32:	8b 45 f0             	mov    -0x10(%ebp),%eax
  280e35:	50                   	push   %eax
  280e36:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  280e39:	51                   	push   %ecx
  280e3a:	50                   	push   %eax
  280e3b:	89 55 e8             	mov    %edx,-0x18(%ebp)
  280e3e:	52                   	push   %edx
  280e3f:	6a 0f                	push   $0xf
  280e41:	53                   	push   %ebx
  280e42:	57                   	push   %edi
  280e43:	e8 69 fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-23,   xsize-47,   ysize- 4);
  280e48:	83 c4 38             	add    $0x38,%esp
  280e4b:	ff 75 ec             	pushl  -0x14(%ebp)
  280e4e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  280e51:	52                   	push   %edx
  280e52:	ff 75 e4             	pushl  -0x1c(%ebp)
  280e55:	52                   	push   %edx
  280e56:	6a 0f                	push   $0xf
  280e58:	53                   	push   %ebx
  280e59:	57                   	push   %edi
  280e5a:	e8 52 fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize-47,       ysize- 3,   xsize- 4,   ysize- 3);
  280e5f:	56                   	push   %esi
  280e60:	ff 75 e0             	pushl  -0x20(%ebp)
  280e63:	56                   	push   %esi
  280e64:	ff 75 e8             	pushl  -0x18(%ebp)
  280e67:	6a 07                	push   $0x7
  280e69:	53                   	push   %ebx
  280e6a:	57                   	push   %edi
  280e6b:	e8 41 fe ff ff       	call   280cb1 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
  280e70:	8d 43 fd             	lea    -0x3(%ebx),%eax
  280e73:	83 c4 38             	add    $0x38,%esp
  280e76:	56                   	push   %esi
  280e77:	50                   	push   %eax
  280e78:	ff 75 f0             	pushl  -0x10(%ebp)
  280e7b:	50                   	push   %eax
  280e7c:	6a 07                	push   $0x7
  280e7e:	53                   	push   %ebx
  280e7f:	57                   	push   %edi
  280e80:	e8 2c fe ff ff       	call   280cb1 <boxfill8>
}
  280e85:	83 c4 1c             	add    $0x1c,%esp
  280e88:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280e8b:	5b                   	pop    %ebx
  280e8c:	5e                   	pop    %esi
  280e8d:	5f                   	pop    %edi
  280e8e:	5d                   	pop    %ebp
  280e8f:	c3                   	ret    

00280e90 <init_mouse_cursor8>:


void init_mouse_cursor8(char *mouse, char bc)
{
  280e90:	55                   	push   %ebp
  280e91:	89 e5                	mov    %esp,%ebp
  280e93:	57                   	push   %edi
  280e94:	56                   	push   %esi
  280e95:	53                   	push   %ebx
  280e96:	83 ec 08             	sub    $0x8,%esp
  280e99:	8b 75 08             	mov    0x8(%ebp),%esi
  280e9c:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
  280ea0:	89 75 f0             	mov    %esi,-0x10(%ebp)
  280ea3:	8d 86 00 01 00 00    	lea    0x100(%esi),%eax
  280ea9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  280eac:	eb 38                	jmp    280ee6 <init_mouse_cursor8+0x56>
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280eae:	0f b6 94 03 a0 55 28 	movzbl 0x2855a0(%ebx,%eax,1),%edx
  280eb5:	00 
  280eb6:	80 fa 2a             	cmp    $0x2a,%dl
  280eb9:	75 06                	jne    280ec1 <init_mouse_cursor8+0x31>
				mouse[y*16+x] = COL8_000000;
  280ebb:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
  280ebf:	eb 15                	jmp    280ed6 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == 'O')
  280ec1:	80 fa 4f             	cmp    $0x4f,%dl
  280ec4:	75 06                	jne    280ecc <init_mouse_cursor8+0x3c>
				mouse[y*16+x] = COL8_FFFFFF;
  280ec6:	c6 04 06 07          	movb   $0x7,(%esi,%eax,1)
  280eca:	eb 0a                	jmp    280ed6 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == '.')
  280ecc:	80 fa 2e             	cmp    $0x2e,%dl
  280ecf:	75 05                	jne    280ed6 <init_mouse_cursor8+0x46>
				mouse[y*16+x] = bc;
  280ed1:	89 fa                	mov    %edi,%edx
  280ed3:	88 14 06             	mov    %dl,(%esi,%eax,1)
	};
	int x,y;
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
  280ed6:	83 c0 01             	add    $0x1,%eax
  280ed9:	83 f8 10             	cmp    $0x10,%eax
  280edc:	75 d0                	jne    280eae <init_mouse_cursor8+0x1e>
  280ede:	83 c6 10             	add    $0x10,%esi
        "............*OO*",
        ".............***"
	};
	int x,y;
	
	for(y=0;y<16;y++)
  280ee1:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  280ee4:	74 0c                	je     280ef2 <init_mouse_cursor8+0x62>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
}


void init_mouse_cursor8(char *mouse, char bc)
{
  280ee6:	b8 00 00 00 00       	mov    $0x0,%eax
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280eeb:	89 f3                	mov    %esi,%ebx
  280eed:	2b 5d f0             	sub    -0x10(%ebp),%ebx
  280ef0:	eb bc                	jmp    280eae <init_mouse_cursor8+0x1e>
			else if(cursor[y][x] == '.')
				mouse[y*16+x] = bc;
		}
	}
	return;
}
  280ef2:	83 c4 08             	add    $0x8,%esp
  280ef5:	5b                   	pop    %ebx
  280ef6:	5e                   	pop    %esi
  280ef7:	5f                   	pop    %edi
  280ef8:	5d                   	pop    %ebp
  280ef9:	c3                   	ret    

00280efa <make_wtitle8>:
	make_wtitle8(buf,xsize,title,act);
	return;
}

void make_wtitle8(unsigned char *buf,int xsize,char *title,char act)
{
  280efa:	55                   	push   %ebp
  280efb:	89 e5                	mov    %esp,%ebp
  280efd:	57                   	push   %edi
  280efe:	56                   	push   %esi
  280eff:	53                   	push   %ebx
  280f00:	83 ec 1c             	sub    $0x1c,%esp
  280f03:	8b 75 08             	mov    0x8(%ebp),%esi
  280f06:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280f09:	8b 55 14             	mov    0x14(%ebp),%edx
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
		tbc= COL8_848484;
  280f0c:	80 fa 01             	cmp    $0x1,%dl
  280f0f:	19 c0                	sbb    %eax,%eax
  280f11:	83 e0 03             	and    $0x3,%eax
  280f14:	83 c0 0c             	add    $0xc,%eax
  280f17:	80 fa 01             	cmp    $0x1,%dl
  280f1a:	19 ff                	sbb    %edi,%edi
  280f1c:	f7 d7                	not    %edi
  280f1e:	83 c7 08             	add    $0x8,%edi
	}
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
  280f21:	6a 14                	push   $0x14
  280f23:	8d 53 fc             	lea    -0x4(%ebx),%edx
  280f26:	52                   	push   %edx
  280f27:	6a 03                	push   $0x3
  280f29:	6a 03                	push   $0x3
  280f2b:	0f b6 c0             	movzbl %al,%eax
  280f2e:	50                   	push   %eax
  280f2f:	53                   	push   %ebx
  280f30:	56                   	push   %esi
  280f31:	e8 7b fd ff ff       	call   280cb1 <boxfill8>
	putfonts8_asc(buf,xsize,24,4,tc,title);
  280f36:	83 c4 04             	add    $0x4,%esp
  280f39:	ff 75 10             	pushl  0x10(%ebp)
  280f3c:	89 f8                	mov    %edi,%eax
  280f3e:	0f be f8             	movsbl %al,%edi
  280f41:	57                   	push   %edi
  280f42:	6a 04                	push   $0x4
  280f44:	6a 18                	push   $0x18
  280f46:	53                   	push   %ebx
  280f47:	56                   	push   %esi
  280f48:	e8 35 05 00 00       	call   281482 <putfonts8_asc>
  280f4d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  280f50:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
  280f53:	01 fb                	add    %edi,%ebx
  280f55:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
  280f58:	83 c4 30             	add    $0x30,%esp
  280f5b:	be 00 00 00 00       	mov    $0x0,%esi
  280f60:	eb 41                	jmp    280fa3 <make_wtitle8+0xa9>
  280f62:	89 c1                	mov    %eax,%ecx
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
		{
			c=closebtn[y][x];
  280f64:	0f b6 9c 06 c0 54 28 	movzbl 0x2854c0(%esi,%eax,1),%ebx
  280f6b:	00 
			if(c == '@') c=COL8_000000;
  280f6c:	ba 00 00 00 00       	mov    $0x0,%edx
  280f71:	80 fb 40             	cmp    $0x40,%bl
  280f74:	74 13                	je     280f89 <make_wtitle8+0x8f>
			else if(c == '$') c=COL8_848484;
  280f76:	ba 0f 00 00 00       	mov    $0xf,%edx
  280f7b:	80 fb 24             	cmp    $0x24,%bl
  280f7e:	74 09                	je     280f89 <make_wtitle8+0x8f>
			else if(c == 'Q') c=COL8_C6C6C6;
			else c=COL8_FFFFFF;
  280f80:	80 fb 51             	cmp    $0x51,%bl
  280f83:	0f 94 c2             	sete   %dl
  280f86:	83 c2 07             	add    $0x7,%edx
			buf[(5+y)*xsize+(xsize-21+x)] = c;
  280f89:	88 54 0f eb          	mov    %dl,-0x15(%edi,%ecx,1)
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
  280f8d:	83 c0 01             	add    $0x1,%eax
  280f90:	83 f8 10             	cmp    $0x10,%eax
  280f93:	75 cd                	jne    280f62 <make_wtitle8+0x68>
  280f95:	03 7d e4             	add    -0x1c(%ebp),%edi
  280f98:	83 c6 10             	add    $0x10,%esi
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
  280f9b:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
  280fa1:	74 07                	je     280faa <make_wtitle8+0xb0>
		tc = COL8_FFFFFF;
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
  280fa3:	b8 00 00 00 00       	mov    $0x0,%eax
  280fa8:	eb b8                	jmp    280f62 <make_wtitle8+0x68>
			else c=COL8_FFFFFF;
			buf[(5+y)*xsize+(xsize-21+x)] = c;
		}
	}
	return;
}
  280faa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280fad:	5b                   	pop    %ebx
  280fae:	5e                   	pop    %esi
  280faf:	5f                   	pop    %edi
  280fb0:	5d                   	pop    %ebp
  280fb1:	c3                   	ret    

00280fb2 <make_window8>:
	}
	return;
}

void make_window8(unsigned char *buf,int xsize,int ysize,char *title,char act)
{
  280fb2:	55                   	push   %ebp
  280fb3:	89 e5                	mov    %esp,%ebp
  280fb5:	57                   	push   %edi
  280fb6:	56                   	push   %esi
  280fb7:	53                   	push   %ebx
  280fb8:	83 ec 1c             	sub    $0x1c,%esp
  280fbb:	8b 75 08             	mov    0x8(%ebp),%esi
  280fbe:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280fc1:	8b 45 18             	mov    0x18(%ebp),%eax
  280fc4:	89 45 d8             	mov    %eax,-0x28(%ebp)
	boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , xsize - 1, 0  );
  280fc7:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280fca:	6a 00                	push   $0x0
  280fcc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  280fcf:	50                   	push   %eax
  280fd0:	6a 00                	push   $0x0
  280fd2:	6a 00                	push   $0x0
  280fd4:	6a 08                	push   $0x8
  280fd6:	53                   	push   %ebx
  280fd7:	56                   	push   %esi
  280fd8:	e8 d4 fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , xsize - 2, 1  );
  280fdd:	8d 53 fe             	lea    -0x2(%ebx),%edx
  280fe0:	6a 01                	push   $0x1
  280fe2:	89 55 e0             	mov    %edx,-0x20(%ebp)
  280fe5:	52                   	push   %edx
  280fe6:	6a 01                	push   $0x1
  280fe8:	6a 01                	push   $0x1
  280fea:	6a 07                	push   $0x7
  280fec:	53                   	push   %ebx
  280fed:	56                   	push   %esi
  280fee:	e8 be fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , 0     , ysize-1);
  280ff3:	8b 7d 10             	mov    0x10(%ebp),%edi
  280ff6:	8d 4f ff             	lea    -0x1(%edi),%ecx
  280ff9:	83 c4 38             	add    $0x38,%esp
  280ffc:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  280fff:	51                   	push   %ecx
  281000:	6a 00                	push   $0x0
  281002:	6a 00                	push   $0x0
  281004:	6a 00                	push   $0x0
  281006:	6a 08                	push   $0x8
  281008:	53                   	push   %ebx
  281009:	56                   	push   %esi
  28100a:	e8 a2 fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , 1     , ysize-2);
  28100f:	8b 7d 10             	mov    0x10(%ebp),%edi
  281012:	83 ef 02             	sub    $0x2,%edi
  281015:	57                   	push   %edi
  281016:	6a 01                	push   $0x1
  281018:	6a 01                	push   $0x1
  28101a:	6a 01                	push   $0x1
  28101c:	6a 07                	push   $0x7
  28101e:	53                   	push   %ebx
  28101f:	56                   	push   %esi
  281020:	e8 8c fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, xsize-2,1     , xsize-2,ysize-2);
  281025:	83 c4 38             	add    $0x38,%esp
  281028:	57                   	push   %edi
  281029:	8b 55 e0             	mov    -0x20(%ebp),%edx
  28102c:	52                   	push   %edx
  28102d:	6a 01                	push   $0x1
  28102f:	52                   	push   %edx
  281030:	6a 0f                	push   $0xf
  281032:	53                   	push   %ebx
  281033:	56                   	push   %esi
  281034:	e8 78 fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, xsize-1,0     , xsize-1,ysize-1);
  281039:	ff 75 dc             	pushl  -0x24(%ebp)
  28103c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  28103f:	50                   	push   %eax
  281040:	6a 00                	push   $0x0
  281042:	50                   	push   %eax
  281043:	6a 00                	push   $0x0
  281045:	53                   	push   %ebx
  281046:	56                   	push   %esi
  281047:	e8 65 fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 2     , 2     , xsize-3,ysize-3);
  28104c:	83 c4 38             	add    $0x38,%esp
  28104f:	8b 55 10             	mov    0x10(%ebp),%edx
  281052:	8d 42 fd             	lea    -0x3(%edx),%eax
  281055:	50                   	push   %eax
  281056:	8d 43 fd             	lea    -0x3(%ebx),%eax
  281059:	50                   	push   %eax
  28105a:	6a 02                	push   $0x2
  28105c:	6a 02                	push   $0x2
  28105e:	6a 08                	push   $0x8
  281060:	53                   	push   %ebx
  281061:	56                   	push   %esi
  281062:	e8 4a fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, 1     , ysize-2,xsize-2,ysize-2);
  281067:	57                   	push   %edi
  281068:	ff 75 e0             	pushl  -0x20(%ebp)
  28106b:	57                   	push   %edi
  28106c:	6a 01                	push   $0x1
  28106e:	6a 0f                	push   $0xf
  281070:	53                   	push   %ebx
  281071:	56                   	push   %esi
  281072:	e8 3a fc ff ff       	call   280cb1 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, 0     , ysize-1,xsize-1,ysize-1);
  281077:	83 c4 38             	add    $0x38,%esp
  28107a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  28107d:	51                   	push   %ecx
  28107e:	ff 75 e4             	pushl  -0x1c(%ebp)
  281081:	51                   	push   %ecx
  281082:	6a 00                	push   $0x0
  281084:	6a 00                	push   $0x0
  281086:	53                   	push   %ebx
  281087:	56                   	push   %esi
  281088:	e8 24 fc ff ff       	call   280cb1 <boxfill8>
	make_wtitle8(buf,xsize,title,act);
  28108d:	83 c4 1c             	add    $0x1c,%esp
  281090:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  281094:	50                   	push   %eax
  281095:	ff 75 14             	pushl  0x14(%ebp)
  281098:	53                   	push   %ebx
  281099:	56                   	push   %esi
  28109a:	e8 5b fe ff ff       	call   280efa <make_wtitle8>
	return;
  28109f:	83 c4 10             	add    $0x10,%esp
}
  2810a2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2810a5:	5b                   	pop    %ebx
  2810a6:	5e                   	pop    %esi
  2810a7:	5f                   	pop    %edi
  2810a8:	5d                   	pop    %ebp
  2810a9:	c3                   	ret    

002810aa <putblock8_8>:
	}
	return;
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
  2810aa:	55                   	push   %ebp
  2810ab:	89 e5                	mov    %esp,%ebp
  2810ad:	57                   	push   %edi
  2810ae:	56                   	push   %esi
  2810af:	53                   	push   %ebx
  2810b0:	83 ec 04             	sub    $0x4,%esp
  2810b3:	8b 45 0c             	mov    0xc(%ebp),%eax
  2810b6:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int x,y;
	for(y=0;y<pysize;y++)
  2810b9:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  2810bd:	7e 49                	jle    281108 <putblock8_8+0x5e>
  2810bf:	8b 7d 24             	mov    0x24(%ebp),%edi
  2810c2:	8b 4d 20             	mov    0x20(%ebp),%ecx
  2810c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  2810c8:	0f af 45 1c          	imul   0x1c(%ebp),%eax
  2810cc:	03 45 18             	add    0x18(%ebp),%eax
  2810cf:	89 c2                	mov    %eax,%edx
  2810d1:	03 55 08             	add    0x8(%ebp),%edx
  2810d4:	be 00 00 00 00       	mov    $0x0,%esi
  2810d9:	eb 22                	jmp    2810fd <putblock8_8+0x53>
  2810db:	89 5d 10             	mov    %ebx,0x10(%ebp)
		for(x=0;x<pxsize;x++)
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];
  2810de:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
  2810e2:	88 1c 02             	mov    %bl,(%edx,%eax,1)

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
		for(x=0;x<pxsize;x++)
  2810e5:	83 c0 01             	add    $0x1,%eax
  2810e8:	39 45 10             	cmp    %eax,0x10(%ebp)
  2810eb:	75 f1                	jne    2810de <putblock8_8+0x34>
  2810ed:	8b 5d 10             	mov    0x10(%ebp),%ebx
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
  2810f0:	83 c6 01             	add    $0x1,%esi
  2810f3:	01 f9                	add    %edi,%ecx
  2810f5:	03 55 f0             	add    -0x10(%ebp),%edx
  2810f8:	39 75 14             	cmp    %esi,0x14(%ebp)
  2810fb:	74 0b                	je     281108 <putblock8_8+0x5e>
		for(x=0;x<pxsize;x++)
  2810fd:	b8 00 00 00 00       	mov    $0x0,%eax
  281102:	85 db                	test   %ebx,%ebx
  281104:	7f d5                	jg     2810db <putblock8_8+0x31>
  281106:	eb e8                	jmp    2810f0 <putblock8_8+0x46>
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];

	return;
}
  281108:	83 c4 04             	add    $0x4,%esp
  28110b:	5b                   	pop    %ebx
  28110c:	5e                   	pop    %esi
  28110d:	5f                   	pop    %edi
  28110e:	5d                   	pop    %ebp
  28110f:	c3                   	ret    

00281110 <putfonts8_asc_sht>:
//b background color
//c font color
void putfonts8_asc_sht(struct SHEET *sht,int x,int y,int c,int b,char *s,int l)
{
  281110:	55                   	push   %ebp
  281111:	89 e5                	mov    %esp,%ebp
  281113:	57                   	push   %edi
  281114:	56                   	push   %esi
  281115:	53                   	push   %ebx
  281116:	83 ec 0c             	sub    $0xc,%esp
  281119:	8b 5d 08             	mov    0x8(%ebp),%ebx
  28111c:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(sht->buf,sht->bxsize,b,x,y,x+l*8-1,y+15);
  28111f:	8b 45 20             	mov    0x20(%ebp),%eax
  281122:	8b 55 0c             	mov    0xc(%ebp),%edx
  281125:	8d 3c c2             	lea    (%edx,%eax,8),%edi
  281128:	8d 46 0f             	lea    0xf(%esi),%eax
  28112b:	50                   	push   %eax
  28112c:	8d 47 ff             	lea    -0x1(%edi),%eax
  28112f:	50                   	push   %eax
  281130:	56                   	push   %esi
  281131:	52                   	push   %edx
  281132:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  281136:	50                   	push   %eax
  281137:	ff 73 04             	pushl  0x4(%ebx)
  28113a:	ff 33                	pushl  (%ebx)
  28113c:	e8 70 fb ff ff       	call   280cb1 <boxfill8>
	putfonts8_asc(sht->buf,sht->bxsize,x,y,c,s);
  281141:	83 c4 04             	add    $0x4,%esp
  281144:	ff 75 1c             	pushl  0x1c(%ebp)
  281147:	ff 75 14             	pushl  0x14(%ebp)
  28114a:	56                   	push   %esi
  28114b:	ff 75 0c             	pushl  0xc(%ebp)
  28114e:	ff 73 04             	pushl  0x4(%ebx)
  281151:	ff 33                	pushl  (%ebx)
  281153:	e8 2a 03 00 00       	call   281482 <putfonts8_asc>
	sheet_refresh(sht,x,y,x+l*8,y+16);
  281158:	83 c4 24             	add    $0x24,%esp
  28115b:	8d 46 10             	lea    0x10(%esi),%eax
  28115e:	50                   	push   %eax
  28115f:	57                   	push   %edi
  281160:	56                   	push   %esi
  281161:	ff 75 0c             	pushl  0xc(%ebp)
  281164:	53                   	push   %ebx
  281165:	e8 cc 18 00 00       	call   282a36 <sheet_refresh>
}
  28116a:	83 c4 20             	add    $0x20,%esp
  28116d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281170:	5b                   	pop    %ebx
  281171:	5e                   	pop    %esi
  281172:	5f                   	pop    %edi
  281173:	5d                   	pop    %ebp
  281174:	c3                   	ret    

00281175 <make_textbox8>:

void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c)
{
  281175:	55                   	push   %ebp
  281176:	89 e5                	mov    %esp,%ebp
  281178:	57                   	push   %edi
  281179:	56                   	push   %esi
  28117a:	53                   	push   %ebx
  28117b:	83 ec 18             	sub    $0x18,%esp
  28117e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int x1 = x0 + sx, y1 = y0 + sy;
  281181:	8b 45 0c             	mov    0xc(%ebp),%eax
  281184:	03 45 14             	add    0x14(%ebp),%eax
  281187:	8b 55 10             	mov    0x10(%ebp),%edx
  28118a:	03 55 18             	add    0x18(%ebp),%edx
  28118d:	89 d7                	mov    %edx,%edi
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 2, y0 - 3, x1 + 1, y0 - 3);
  28118f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  281192:	8d 48 01             	lea    0x1(%eax),%ecx
  281195:	8b 75 10             	mov    0x10(%ebp),%esi
  281198:	83 ee 03             	sub    $0x3,%esi
  28119b:	8b 55 0c             	mov    0xc(%ebp),%edx
  28119e:	83 ea 02             	sub    $0x2,%edx
  2811a1:	56                   	push   %esi
  2811a2:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  2811a5:	51                   	push   %ecx
  2811a6:	56                   	push   %esi
  2811a7:	89 55 f0             	mov    %edx,-0x10(%ebp)
  2811aa:	52                   	push   %edx
  2811ab:	6a 0f                	push   $0xf
  2811ad:	ff 73 04             	pushl  0x4(%ebx)
  2811b0:	ff 33                	pushl  (%ebx)
  2811b2:	e8 fa fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 3, y0 - 3, x0 - 3, y1 + 1);
  2811b7:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  2811ba:	8d 7f 01             	lea    0x1(%edi),%edi
  2811bd:	89 f9                	mov    %edi,%ecx
  2811bf:	8b 7d 0c             	mov    0xc(%ebp),%edi
  2811c2:	83 ef 03             	sub    $0x3,%edi
  2811c5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  2811c8:	51                   	push   %ecx
  2811c9:	57                   	push   %edi
  2811ca:	56                   	push   %esi
  2811cb:	57                   	push   %edi
  2811cc:	6a 0f                	push   $0xf
  2811ce:	ff 73 04             	pushl  0x4(%ebx)
  2811d1:	ff 33                	pushl  (%ebx)
  2811d3:	e8 d9 fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x0 - 3, y1 + 2, x1 + 1, y1 + 2);
  2811d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  2811db:	8d 4a 02             	lea    0x2(%edx),%ecx
  2811de:	83 c4 38             	add    $0x38,%esp
  2811e1:	51                   	push   %ecx
  2811e2:	ff 75 e0             	pushl  -0x20(%ebp)
  2811e5:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  2811e8:	51                   	push   %ecx
  2811e9:	57                   	push   %edi
  2811ea:	6a 07                	push   $0x7
  2811ec:	ff 73 04             	pushl  0x4(%ebx)
  2811ef:	ff 33                	pushl  (%ebx)
  2811f1:	e8 bb fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x1 + 2, y0 - 3, x1 + 2, y1 + 2);
  2811f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  2811f9:	83 c0 02             	add    $0x2,%eax
  2811fc:	ff 75 dc             	pushl  -0x24(%ebp)
  2811ff:	50                   	push   %eax
  281200:	56                   	push   %esi
  281201:	50                   	push   %eax
  281202:	6a 07                	push   $0x7
  281204:	ff 73 04             	pushl  0x4(%ebx)
  281207:	ff 33                	pushl  (%ebx)
  281209:	e8 a3 fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 1, y0 - 2, x1 + 0, y0 - 2);
  28120e:	8b 75 10             	mov    0x10(%ebp),%esi
  281211:	8d 7e fe             	lea    -0x2(%esi),%edi
  281214:	8b 75 0c             	mov    0xc(%ebp),%esi
  281217:	83 ee 01             	sub    $0x1,%esi
  28121a:	83 c4 38             	add    $0x38,%esp
  28121d:	57                   	push   %edi
  28121e:	ff 75 e8             	pushl  -0x18(%ebp)
  281221:	57                   	push   %edi
  281222:	56                   	push   %esi
  281223:	6a 00                	push   $0x0
  281225:	ff 73 04             	pushl  0x4(%ebx)
  281228:	ff 33                	pushl  (%ebx)
  28122a:	e8 82 fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 2, y0 - 2, x0 - 2, y1 + 0);
  28122f:	ff 75 e4             	pushl  -0x1c(%ebp)
  281232:	8b 55 f0             	mov    -0x10(%ebp),%edx
  281235:	52                   	push   %edx
  281236:	57                   	push   %edi
  281237:	52                   	push   %edx
  281238:	6a 00                	push   $0x0
  28123a:	ff 73 04             	pushl  0x4(%ebx)
  28123d:	ff 33                	pushl  (%ebx)
  28123f:	e8 6d fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x0 - 2, y1 + 1, x1 + 0, y1 + 1);
  281244:	83 c4 38             	add    $0x38,%esp
  281247:	8b 45 ec             	mov    -0x14(%ebp),%eax
  28124a:	50                   	push   %eax
  28124b:	ff 75 e8             	pushl  -0x18(%ebp)
  28124e:	50                   	push   %eax
  28124f:	ff 75 f0             	pushl  -0x10(%ebp)
  281252:	6a 08                	push   $0x8
  281254:	ff 73 04             	pushl  0x4(%ebx)
  281257:	ff 33                	pushl  (%ebx)
  281259:	e8 53 fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x1 + 1, y0 - 2, x1 + 1, y1 + 1);
  28125e:	ff 75 ec             	pushl  -0x14(%ebp)
  281261:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  281264:	51                   	push   %ecx
  281265:	57                   	push   %edi
  281266:	51                   	push   %ecx
  281267:	6a 08                	push   $0x8
  281269:	ff 73 04             	pushl  0x4(%ebx)
  28126c:	ff 33                	pushl  (%ebx)
  28126e:	e8 3e fa ff ff       	call   280cb1 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, c,           x0 - 1, y0 - 1, x1 + 0, y1 + 0);
  281273:	83 c4 38             	add    $0x38,%esp
  281276:	ff 75 e4             	pushl  -0x1c(%ebp)
  281279:	ff 75 e8             	pushl  -0x18(%ebp)
  28127c:	8b 45 10             	mov    0x10(%ebp),%eax
  28127f:	83 e8 01             	sub    $0x1,%eax
  281282:	50                   	push   %eax
  281283:	56                   	push   %esi
  281284:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  281288:	50                   	push   %eax
  281289:	ff 73 04             	pushl  0x4(%ebx)
  28128c:	ff 33                	pushl  (%ebx)
  28128e:	e8 1e fa ff ff       	call   280cb1 <boxfill8>
    return;
  281293:	83 c4 1c             	add    $0x1c,%esp
}
  281296:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281299:	5b                   	pop    %ebx
  28129a:	5e                   	pop    %esi
  28129b:	5f                   	pop    %edi
  28129c:	5d                   	pop    %ebp
  28129d:	c3                   	ret    

0028129e <drawline8_sht>:

void drawline8_sht(struct SHEET *sht,int x0,int y0,int x1,int y1,int col)
{
  28129e:	55                   	push   %ebp
  28129f:	89 e5                	mov    %esp,%ebp
  2812a1:	57                   	push   %edi
  2812a2:	56                   	push   %esi
  2812a3:	53                   	push   %ebx
  2812a4:	83 ec 10             	sub    $0x10,%esp
  2812a7:	8b 75 08             	mov    0x8(%ebp),%esi
	int i,x,y,len,dx,dy;
	dx = x1-x0;
  2812aa:	8b 7d 14             	mov    0x14(%ebp),%edi
  2812ad:	2b 7d 0c             	sub    0xc(%ebp),%edi
	dy = y1-y0;
  2812b0:	8b 45 18             	mov    0x18(%ebp),%eax
  2812b3:	2b 45 10             	sub    0x10(%ebp),%eax
  2812b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	x = x0 << 10;
  2812b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  2812bc:	c1 e1 0a             	shl    $0xa,%ecx
	y = y0 << 10;
  2812bf:	8b 5d 10             	mov    0x10(%ebp),%ebx
  2812c2:	c1 e3 0a             	shl    $0xa,%ebx
  2812c5:	89 fa                	mov    %edi,%edx
  2812c7:	c1 fa 1f             	sar    $0x1f,%edx
  2812ca:	89 d0                	mov    %edx,%eax
  2812cc:	31 fa                	xor    %edi,%edx
  2812ce:	29 c2                	sub    %eax,%edx
  2812d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2812d3:	c1 f8 1f             	sar    $0x1f,%eax
  2812d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  2812d9:	33 45 f0             	xor    -0x10(%ebp),%eax
  2812dc:	2b 45 ec             	sub    -0x14(%ebp),%eax
	}
	if (dy<0) 
	{
		dy = -dy;
	}
	if(dx >= dy)
  2812df:	39 c2                	cmp    %eax,%edx
  2812e1:	7c 4a                	jl     28132d <drawline8_sht+0x8f>
	{
		len=dx+1;
  2812e3:	83 c2 01             	add    $0x1,%edx
  2812e6:	89 55 ec             	mov    %edx,-0x14(%ebp)
		if(x0 >x1)
			dx = -1024;
		else
			dx = 1024;
  2812e9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  2812ec:	39 7d 14             	cmp    %edi,0x14(%ebp)
  2812ef:	b8 00 04 00 00       	mov    $0x400,%eax
  2812f4:	ba 00 fc ff ff       	mov    $0xfffffc00,%edx
  2812f9:	89 c7                	mov    %eax,%edi
  2812fb:	0f 4c fa             	cmovl  %edx,%edi
  2812fe:	89 7d e8             	mov    %edi,-0x18(%ebp)
		if(y0<=y1)
  281301:	8b 7d 10             	mov    0x10(%ebp),%edi
  281304:	39 7d 18             	cmp    %edi,0x18(%ebp)
  281307:	7c 12                	jl     28131b <drawline8_sht+0x7d>
			dy = ((y1 - y0 + 1)<<10)/len;
  281309:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28130c:	83 c0 01             	add    $0x1,%eax
  28130f:	c1 e0 0a             	shl    $0xa,%eax
  281312:	99                   	cltd   
  281313:	f7 7d ec             	idivl  -0x14(%ebp)
  281316:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  281319:	eb 52                	jmp    28136d <drawline8_sht+0xcf>
		else
			dy = ((y1 - y0 - 1)<<10)/len;
  28131b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28131e:	83 e8 01             	sub    $0x1,%eax
  281321:	c1 e0 0a             	shl    $0xa,%eax
  281324:	99                   	cltd   
  281325:	f7 7d ec             	idivl  -0x14(%ebp)
  281328:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  28132b:	eb 40                	jmp    28136d <drawline8_sht+0xcf>
	}
	else
	{
		len=dy+1;
  28132d:	83 c0 01             	add    $0x1,%eax
  281330:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(y0>y1)
			dy = -1024;
		else
			dy = 1024;
  281333:	8b 55 10             	mov    0x10(%ebp),%edx
  281336:	39 55 18             	cmp    %edx,0x18(%ebp)
  281339:	b8 00 04 00 00       	mov    $0x400,%eax
  28133e:	ba 00 fc ff ff       	mov    $0xfffffc00,%edx
  281343:	0f 4c c2             	cmovl  %edx,%eax
  281346:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(x0<=x1)
  281349:	8b 55 0c             	mov    0xc(%ebp),%edx
  28134c:	39 55 14             	cmp    %edx,0x14(%ebp)
  28134f:	7c 0f                	jl     281360 <drawline8_sht+0xc2>
			dx = ((x1 - x0 + 1)<<10)/len;
  281351:	8d 47 01             	lea    0x1(%edi),%eax
  281354:	c1 e0 0a             	shl    $0xa,%eax
  281357:	99                   	cltd   
  281358:	f7 7d ec             	idivl  -0x14(%ebp)
  28135b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  28135e:	eb 0d                	jmp    28136d <drawline8_sht+0xcf>
		else
			dx = ((x1 - x0 - 1)<<10)/len;
  281360:	8d 47 ff             	lea    -0x1(%edi),%eax
  281363:	c1 e0 0a             	shl    $0xa,%eax
  281366:	99                   	cltd   
  281367:	f7 7d ec             	idivl  -0x14(%ebp)
  28136a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
	for(i=0;i<len;i++)
  28136d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  281371:	7e 31                	jle    2813a4 <drawline8_sht+0x106>
  281373:	ba 00 00 00 00       	mov    $0x0,%edx
  281378:	89 55 f0             	mov    %edx,-0x10(%ebp)
	{
		sht->buf[(y>>10)*sht->bxsize+(x>>10)] = col;
  28137b:	89 d8                	mov    %ebx,%eax
  28137d:	c1 f8 0a             	sar    $0xa,%eax
  281380:	0f af 46 04          	imul   0x4(%esi),%eax
  281384:	89 cf                	mov    %ecx,%edi
  281386:	c1 ff 0a             	sar    $0xa,%edi
  281389:	03 06                	add    (%esi),%eax
  28138b:	0f b6 55 1c          	movzbl 0x1c(%ebp),%edx
  28138f:	88 14 38             	mov    %dl,(%eax,%edi,1)
		x += dx;
  281392:	03 4d e8             	add    -0x18(%ebp),%ecx
		y += dy;
  281395:	03 5d e4             	add    -0x1c(%ebp),%ebx
		if(x0<=x1)
			dx = ((x1 - x0 + 1)<<10)/len;
		else
			dx = ((x1 - x0 - 1)<<10)/len;
	}
	for(i=0;i<len;i++)
  281398:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  28139c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28139f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  2813a2:	75 d7                	jne    28137b <drawline8_sht+0xdd>
		sht->buf[(y>>10)*sht->bxsize+(x>>10)] = col;
		x += dx;
		y += dy;
	}
	return;
}
  2813a4:	83 c4 10             	add    $0x10,%esp
  2813a7:	5b                   	pop    %ebx
  2813a8:	5e                   	pop    %esi
  2813a9:	5f                   	pop    %edi
  2813aa:	5d                   	pop    %ebp
  2813ab:	c3                   	ret    

002813ac <putfont8>:

#define HZ_TABLE_COL 16
#define HZ_TABLE_ROW 16

void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
  2813ac:	55                   	push   %ebp
  2813ad:	89 e5                	mov    %esp,%ebp
  2813af:	57                   	push   %edi
  2813b0:	56                   	push   %esi
  2813b1:	53                   	push   %ebx
  2813b2:	83 ec 08             	sub    $0x8,%esp
  2813b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  2813b8:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  2813bb:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  2813bf:	89 fb                	mov    %edi,%ebx
  2813c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  2813c4:	0f af 45 14          	imul   0x14(%ebp),%eax
  2813c8:	03 45 10             	add    0x10(%ebp),%eax
  2813cb:	89 c1                	mov    %eax,%ecx
  2813cd:	03 4d 08             	add    0x8(%ebp),%ecx
  2813d0:	83 c7 10             	add    $0x10,%edi
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
  2813d3:	0f b6 13             	movzbl (%ebx),%edx
		int col = HKK_TABLE_COL-1;
  2813d6:	b8 07 00 00 00       	mov    $0x7,%eax
  2813db:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  2813de:	89 f1                	mov    %esi,%ecx
  2813e0:	89 de                	mov    %ebx,%esi
  2813e2:	89 cb                	mov    %ecx,%ebx
		for(;col>=0;col--)
		{
			if(d&0x1) p[col] = c;
  2813e4:	f6 c2 01             	test   $0x1,%dl
  2813e7:	74 06                	je     2813ef <putfont8+0x43>
  2813e9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  2813ec:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
			d=d>>1;
  2813ef:	d0 ea                	shr    %dl
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
		int col = HKK_TABLE_COL-1;
		for(;col>=0;col--)
  2813f1:	83 e8 01             	sub    $0x1,%eax
  2813f4:	83 f8 ff             	cmp    $0xffffffff,%eax
  2813f7:	75 eb                	jne    2813e4 <putfont8+0x38>
  2813f9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  2813fc:	89 d8                	mov    %ebx,%eax
  2813fe:	89 f3                	mov    %esi,%ebx
  281400:	89 c6                	mov    %eax,%esi
  281402:	83 c3 01             	add    $0x1,%ebx
  281405:	03 4d ec             	add    -0x14(%ebp),%ecx
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
	int i;
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
  281408:	39 fb                	cmp    %edi,%ebx
  28140a:	75 c7                	jne    2813d3 <putfont8+0x27>
			if(d&0x1) p[col] = c;
			d=d>>1;
		}
	}

}
  28140c:	83 c4 08             	add    $0x8,%esp
  28140f:	5b                   	pop    %ebx
  281410:	5e                   	pop    %esi
  281411:	5f                   	pop    %edi
  281412:	5d                   	pop    %ebp
  281413:	c3                   	ret    

00281414 <putfont16>:

void putfont16(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
  281414:	55                   	push   %ebp
  281415:	89 e5                	mov    %esp,%ebp
  281417:	57                   	push   %edi
  281418:	56                   	push   %esi
  281419:	53                   	push   %ebx
  28141a:	83 ec 0c             	sub    $0xc,%esp
  28141d:	8b 45 0c             	mov    0xc(%ebp),%eax
  281420:	8b 55 1c             	mov    0x1c(%ebp),%edx
  281423:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  281427:	89 d7                	mov    %edx,%edi
  281429:	89 45 ec             	mov    %eax,-0x14(%ebp)
  28142c:	0f af 45 14          	imul   0x14(%ebp),%eax
  281430:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281433:	8d 5c 01 07          	lea    0x7(%ecx,%eax,1),%ebx
  281437:	03 5d 08             	add    0x8(%ebp),%ebx
  28143a:	8d 42 20             	lea    0x20(%edx),%eax
  28143d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	char *p;
	unsigned char d,b;
	for(i=0;i<HZ_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[2*i];
  281440:	0f b6 0f             	movzbl (%edi),%ecx
		b = font[2*i+1];
  281443:	0f b6 57 01          	movzbl 0x1(%edi),%edx
  281447:	8d 43 08             	lea    0x8(%ebx),%eax
  28144a:	89 5d f0             	mov    %ebx,-0x10(%ebp)
		int col = HZ_TABLE_COL/2-1;
		for(;col>=0;col--)
		{
			if(d&0x1) p[col] = c;
  28144d:	f6 c1 01             	test   $0x1,%cl
  281450:	74 05                	je     281457 <putfont16+0x43>
  281452:	89 f3                	mov    %esi,%ebx
  281454:	88 58 f8             	mov    %bl,-0x8(%eax)
			d=d>>1;
  281457:	d0 e9                	shr    %cl
			if(b&0x1) p[col+8] = c;
  281459:	f6 c2 01             	test   $0x1,%dl
  28145c:	74 04                	je     281462 <putfont16+0x4e>
  28145e:	89 f3                	mov    %esi,%ebx
  281460:	88 18                	mov    %bl,(%eax)
			b=b>>1;
  281462:	d0 ea                	shr    %dl
  281464:	83 e8 01             	sub    $0x1,%eax
	{
		p = vram + (y+i)*xsize+x;
		d = font[2*i];
		b = font[2*i+1];
		int col = HZ_TABLE_COL/2-1;
		for(;col>=0;col--)
  281467:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  28146a:	75 e1                	jne    28144d <putfont16+0x39>
  28146c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  28146f:	83 c7 02             	add    $0x2,%edi
  281472:	03 5d ec             	add    -0x14(%ebp),%ebx
void putfont16(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
	int i;
	char *p;
	unsigned char d,b;
	for(i=0;i<HZ_TABLE_ROW;i++)
  281475:	3b 7d e8             	cmp    -0x18(%ebp),%edi
  281478:	75 c6                	jne    281440 <putfont16+0x2c>
			if(b&0x1) p[col+8] = c;
			b=b>>1;
		}
	}

}
  28147a:	83 c4 0c             	add    $0xc,%esp
  28147d:	5b                   	pop    %ebx
  28147e:	5e                   	pop    %esi
  28147f:	5f                   	pop    %edi
  281480:	5d                   	pop    %ebp
  281481:	c3                   	ret    

00281482 <putfonts8_asc>:

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
  281482:	55                   	push   %ebp
  281483:	89 e5                	mov    %esp,%ebp
  281485:	57                   	push   %edi
  281486:	56                   	push   %esi
  281487:	53                   	push   %ebx
  281488:	83 ec 1c             	sub    $0x1c,%esp
  28148b:	8b 75 10             	mov    0x10(%ebp),%esi
  28148e:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  281491:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  281495:	88 45 e4             	mov    %al,-0x1c(%ebp)
	extern char hankaku[];
	struct TASK *task = task_now();
  281498:	e8 44 1b 00 00       	call   282fe1 <task_now>
  28149d:	89 c7                	mov    %eax,%edi
	char *hanyu = (char *)*((int *)0x0fe8);
	if(task->langmode == 0)
  28149f:	0f b6 80 bc 00 00 00 	movzbl 0xbc(%eax),%eax
  2814a6:	84 c0                	test   %al,%al
  2814a8:	75 43                	jne    2814ed <putfonts8_asc+0x6b>
	{
		for(;*s !=0x00;s++)
  2814aa:	0f b6 03             	movzbl (%ebx),%eax
  2814ad:	84 c0                	test   %al,%al
  2814af:	0f 84 f1 00 00 00    	je     2815a6 <putfonts8_asc+0x124>
		{
			putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
  2814b5:	0f be 7d e4          	movsbl -0x1c(%ebp),%edi
  2814b9:	83 ec 08             	sub    $0x8,%esp
  2814bc:	0f b6 c0             	movzbl %al,%eax
  2814bf:	c1 e0 04             	shl    $0x4,%eax
  2814c2:	05 a0 68 28 00       	add    $0x2868a0,%eax
  2814c7:	50                   	push   %eax
  2814c8:	57                   	push   %edi
  2814c9:	ff 75 14             	pushl  0x14(%ebp)
  2814cc:	56                   	push   %esi
  2814cd:	ff 75 0c             	pushl  0xc(%ebp)
  2814d0:	ff 75 08             	pushl  0x8(%ebp)
  2814d3:	e8 d4 fe ff ff       	call   2813ac <putfont8>
			x+=HKK_TABLE_COL;
  2814d8:	83 c6 08             	add    $0x8,%esi
	extern char hankaku[];
	struct TASK *task = task_now();
	char *hanyu = (char *)*((int *)0x0fe8);
	if(task->langmode == 0)
	{
		for(;*s !=0x00;s++)
  2814db:	83 c3 01             	add    $0x1,%ebx
  2814de:	0f b6 03             	movzbl (%ebx),%eax
  2814e1:	83 c4 20             	add    $0x20,%esp
  2814e4:	84 c0                	test   %al,%al
  2814e6:	75 d1                	jne    2814b9 <putfonts8_asc+0x37>
  2814e8:	e9 b9 00 00 00       	jmp    2815a6 <putfonts8_asc+0x124>
		{
			putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
			x+=HKK_TABLE_COL;
		}
	}
	else if(task->langmode == 1)
  2814ed:	3c 01                	cmp    $0x1,%al
  2814ef:	0f 85 b1 00 00 00    	jne    2815a6 <putfonts8_asc+0x124>
	{
		for(;*s != 0x00;s++)
  2814f5:	0f b6 03             	movzbl (%ebx),%eax
  2814f8:	84 c0                	test   %al,%al
  2814fa:	0f 84 a6 00 00 00    	je     2815a6 <putfonts8_asc+0x124>

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
	extern char hankaku[];
	struct TASK *task = task_now();
	char *hanyu = (char *)*((int *)0x0fe8);
  281500:	8b 0d e8 0f 00 00    	mov    0xfe8,%ecx
  281506:	89 4d e0             	mov    %ecx,-0x20(%ebp)
			{
				int k=task->langbyte1 - 0xa1;
				int t=*s - 0xa1;
				task->langbyte1 = 0;
				char *font = hanyu + 256 *16 + (k*94+t)*32;
				putfont16(vram,xsize,x-8,y,c,font);
  281509:	0f be 4d e4          	movsbl -0x1c(%ebp),%ecx
  28150d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
	}
	else if(task->langmode == 1)
	{
		for(;*s != 0x00;s++)
		{
			if(task->langbyte1 == 0)
  281510:	0f b6 97 bd 00 00 00 	movzbl 0xbd(%edi),%edx
  281517:	84 d2                	test   %dl,%dl
  281519:	75 34                	jne    28154f <putfonts8_asc+0xcd>
			{
				if(0x81<=*s && *s<=0xfe)
  28151b:	8d 50 7f             	lea    0x7f(%eax),%edx
  28151e:	80 fa 7d             	cmp    $0x7d,%dl
  281521:	77 08                	ja     28152b <putfonts8_asc+0xa9>
					task->langbyte1 = *s;
  281523:	88 87 bd 00 00 00    	mov    %al,0xbd(%edi)
  281529:	eb 6a                	jmp    281595 <putfonts8_asc+0x113>
				else
					putfont8(vram,xsize,x,y,c,hanyu+*s*16);
  28152b:	83 ec 08             	sub    $0x8,%esp
  28152e:	0f b6 c0             	movzbl %al,%eax
  281531:	c1 e0 04             	shl    $0x4,%eax
  281534:	03 45 e0             	add    -0x20(%ebp),%eax
  281537:	50                   	push   %eax
  281538:	ff 75 e4             	pushl  -0x1c(%ebp)
  28153b:	ff 75 14             	pushl  0x14(%ebp)
  28153e:	56                   	push   %esi
  28153f:	ff 75 0c             	pushl  0xc(%ebp)
  281542:	ff 75 08             	pushl  0x8(%ebp)
  281545:	e8 62 fe ff ff       	call   2813ac <putfont8>
  28154a:	83 c4 20             	add    $0x20,%esp
  28154d:	eb 46                	jmp    281595 <putfonts8_asc+0x113>
			}
			else
			{
				int k=task->langbyte1 - 0xa1;
				int t=*s - 0xa1;
				task->langbyte1 = 0;
  28154f:	c6 87 bd 00 00 00 00 	movb   $0x0,0xbd(%edi)
				char *font = hanyu + 256 *16 + (k*94+t)*32;
				putfont16(vram,xsize,x-8,y,c,font);
  281556:	83 ec 08             	sub    $0x8,%esp
  281559:	0f b6 d2             	movzbl %dl,%edx
  28155c:	81 ea a1 00 00 00    	sub    $0xa1,%edx
  281562:	6b d2 5e             	imul   $0x5e,%edx,%edx
  281565:	0f b6 c0             	movzbl %al,%eax
  281568:	8d 84 02 5f ff ff ff 	lea    -0xa1(%edx,%eax,1),%eax
  28156f:	c1 e0 05             	shl    $0x5,%eax
  281572:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  281575:	8d 84 01 00 10 00 00 	lea    0x1000(%ecx,%eax,1),%eax
  28157c:	50                   	push   %eax
  28157d:	ff 75 e4             	pushl  -0x1c(%ebp)
  281580:	ff 75 14             	pushl  0x14(%ebp)
  281583:	8d 46 f8             	lea    -0x8(%esi),%eax
  281586:	50                   	push   %eax
  281587:	ff 75 0c             	pushl  0xc(%ebp)
  28158a:	ff 75 08             	pushl  0x8(%ebp)
  28158d:	e8 82 fe ff ff       	call   281414 <putfont16>
  281592:	83 c4 20             	add    $0x20,%esp
				//x+=HZ_TABLE_COL;
			}
			x+=HZ_TABLE_COL/2;
  281595:	83 c6 08             	add    $0x8,%esi
			x+=HKK_TABLE_COL;
		}
	}
	else if(task->langmode == 1)
	{
		for(;*s != 0x00;s++)
  281598:	83 c3 01             	add    $0x1,%ebx
  28159b:	0f b6 03             	movzbl (%ebx),%eax
  28159e:	84 c0                	test   %al,%al
  2815a0:	0f 85 6a ff ff ff    	jne    281510 <putfonts8_asc+0x8e>
			}
			x+=HZ_TABLE_COL/2;
		}
	}
	return; 
}
  2815a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2815a9:	5b                   	pop    %ebx
  2815aa:	5e                   	pop    %esi
  2815ab:	5f                   	pop    %edi
  2815ac:	5d                   	pop    %ebp
  2815ad:	c3                   	ret    

002815ae <set_segmdesc>:
#include "dsctbl.h"
#include "io.h"

void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit,int base,int ar)
{
  2815ae:	55                   	push   %ebp
  2815af:	89 e5                	mov    %esp,%ebp
  2815b1:	57                   	push   %edi
  2815b2:	56                   	push   %esi
  2815b3:	53                   	push   %ebx
  2815b4:	8b 55 08             	mov    0x8(%ebp),%edx
  2815b7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  2815ba:	8b 4d 10             	mov    0x10(%ebp),%ecx
  2815bd:	8b 7d 14             	mov    0x14(%ebp),%edi
	if(limit>0xfffff)
  2815c0:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
  2815c6:	76 09                	jbe    2815d1 <set_segmdesc+0x23>
	{
		ar |= 0x8000;
  2815c8:	81 cf 00 80 00 00    	or     $0x8000,%edi
		limit /= 0x1000;
  2815ce:	c1 eb 0c             	shr    $0xc,%ebx
	}
	sd->limit_low = limit&0xffff;
  2815d1:	66 89 1a             	mov    %bx,(%edx)
	sd->base_low = base&0xffff;
  2815d4:	66 89 4a 02          	mov    %cx,0x2(%edx)
	sd->base_mid = (base>>16) & 0xff;
  2815d8:	89 ce                	mov    %ecx,%esi
  2815da:	c1 fe 10             	sar    $0x10,%esi
  2815dd:	89 f0                	mov    %esi,%eax
  2815df:	88 42 04             	mov    %al,0x4(%edx)
	sd->access_right = ar & 0xff;
  2815e2:	89 f8                	mov    %edi,%eax
  2815e4:	88 42 05             	mov    %al,0x5(%edx)
	sd->limit_high = ((limit>>16)&0x0f) | ((ar>>8)&0xf0);
  2815e7:	c1 eb 10             	shr    $0x10,%ebx
  2815ea:	83 e3 0f             	and    $0xf,%ebx
  2815ed:	89 f8                	mov    %edi,%eax
  2815ef:	c1 f8 08             	sar    $0x8,%eax
  2815f2:	83 e0 f0             	and    $0xfffffff0,%eax
  2815f5:	09 d8                	or     %ebx,%eax
  2815f7:	88 42 06             	mov    %al,0x6(%edx)
	sd->base_high = (base>>24)&0xff;
  2815fa:	c1 e9 18             	shr    $0x18,%ecx
  2815fd:	88 4a 07             	mov    %cl,0x7(%edx)
	return;
}
  281600:	5b                   	pop    %ebx
  281601:	5e                   	pop    %esi
  281602:	5f                   	pop    %edi
  281603:	5d                   	pop    %ebp
  281604:	c3                   	ret    

00281605 <set_gatedesc>:

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
  281605:	55                   	push   %ebp
  281606:	89 e5                	mov    %esp,%ebp
  281608:	53                   	push   %ebx
  281609:	8b 45 08             	mov    0x8(%ebp),%eax
  28160c:	8b 55 0c             	mov    0xc(%ebp),%edx
  28160f:	8b 4d 14             	mov    0x14(%ebp),%ecx
	gd->offset_low = offset & 0xffff;
  281612:	66 89 10             	mov    %dx,(%eax)
	gd->selector = selector;
  281615:	8b 5d 10             	mov    0x10(%ebp),%ebx
  281618:	66 89 58 02          	mov    %bx,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  28161c:	89 cb                	mov    %ecx,%ebx
  28161e:	c1 fb 08             	sar    $0x8,%ebx
  281621:	88 58 04             	mov    %bl,0x4(%eax)
	gd->access_right = ar&0xff;
  281624:	88 48 05             	mov    %cl,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  281627:	c1 ea 10             	shr    $0x10,%edx
  28162a:	66 89 50 06          	mov    %dx,0x6(%eax)
	return;
}
  28162e:	5b                   	pop    %ebx
  28162f:	5d                   	pop    %ebp
  281630:	c3                   	ret    

00281631 <init_gdtidt>:

void init_gdtidt(void)
{
  281631:	55                   	push   %ebp
  281632:	89 e5                	mov    %esp,%ebp
  281634:	53                   	push   %ebx
  281635:	83 ec 04             	sub    $0x4,%esp
  281638:	bb 00 00 27 00       	mov    $0x270000,%ebx
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
	{
		set_segmdesc(gdt+i,0,0,0);
  28163d:	6a 00                	push   $0x0
  28163f:	6a 00                	push   $0x0
  281641:	6a 00                	push   $0x0
  281643:	53                   	push   %ebx
  281644:	e8 65 ff ff ff       	call   2815ae <set_segmdesc>
  281649:	83 c3 08             	add    $0x8,%ebx
{
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
  28164c:	83 c4 10             	add    $0x10,%esp
  28164f:	81 fb 00 00 28 00    	cmp    $0x280000,%ebx
  281655:	75 e6                	jne    28163d <init_gdtidt+0xc>
	{
		set_segmdesc(gdt+i,0,0,0);
	}
	//must be similiar with bootstrap gdt.
	//otherwise the code will run with different segment descriptor.
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
  281657:	68 92 40 00 00       	push   $0x4092
  28165c:	6a 00                	push   $0x0
  28165e:	6a ff                	push   $0xffffffff
  281660:	68 08 00 27 00       	push   $0x270008
  281665:	e8 44 ff ff ff       	call   2815ae <set_segmdesc>
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
  28166a:	68 9a 40 00 00       	push   $0x409a
  28166f:	6a 00                	push   $0x0
  281671:	68 ff ff 0f 00       	push   $0xfffff
  281676:	68 10 00 27 00       	push   $0x270010
  28167b:	e8 2e ff ff ff       	call   2815ae <set_segmdesc>
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
  281680:	83 c4 20             	add    $0x20,%esp
  281683:	68 9a 40 00 00       	push   $0x409a
  281688:	68 00 00 28 00       	push   $0x280000
  28168d:	68 ff ff 07 00       	push   $0x7ffff
  281692:	68 18 00 27 00       	push   $0x270018
  281697:	e8 12 ff ff ff       	call   2815ae <set_segmdesc>
	load_gdtr(LIMIT_GDT,ADR_GDT);
  28169c:	83 c4 08             	add    $0x8,%esp
  28169f:	68 00 00 27 00       	push   $0x270000
  2816a4:	68 ff ff 00 00       	push   $0xffff
  2816a9:	e8 71 f4 ff ff       	call   280b1f <load_gdtr>
  2816ae:	83 c4 10             	add    $0x10,%esp
  2816b1:	b8 00 f8 26 00       	mov    $0x26f800,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2816b6:	66 c7 00 00 00       	movw   $0x0,(%eax)
	gd->selector = selector;
  2816bb:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  2816c1:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	gd->access_right = ar&0xff;
  2816c5:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  2816c9:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
  2816cf:	83 c0 08             	add    $0x8,%eax
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
	load_gdtr(LIMIT_GDT,ADR_GDT);

	for(i=0;i<256;i++)
  2816d2:	3d 00 00 27 00       	cmp    $0x270000,%eax
  2816d7:	75 dd                	jne    2816b6 <init_gdtidt+0x85>
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
  2816d9:	b8 7e 19 00 00       	mov    $0x197e,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2816de:	66 a3 00 f9 26 00    	mov    %ax,0x26f900
	gd->selector = selector;
  2816e4:	66 c7 05 02 f9 26 00 	movw   $0x18,0x26f902
  2816eb:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2816ed:	c6 05 04 f9 26 00 00 	movb   $0x0,0x26f904
	gd->access_right = ar&0xff;
  2816f4:	c6 05 05 f9 26 00 8e 	movb   $0x8e,0x26f905
	gd->offset_high = (offset>>16)&0xffff;
  2816fb:	c1 e8 10             	shr    $0x10,%eax
  2816fe:	66 a3 06 f9 26 00    	mov    %ax,0x26f906
	for(i=0;i<256;i++)
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
  281704:	b8 50 19 00 00       	mov    $0x1950,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281709:	66 a3 08 f9 26 00    	mov    %ax,0x26f908
	gd->selector = selector;
  28170f:	66 c7 05 0a f9 26 00 	movw   $0x18,0x26f90a
  281716:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281718:	c6 05 0c f9 26 00 00 	movb   $0x0,0x26f90c
	gd->access_right = ar&0xff;
  28171f:	c6 05 0d f9 26 00 8e 	movb   $0x8e,0x26f90d
	gd->offset_high = (offset>>16)&0xffff;
  281726:	c1 e8 10             	shr    $0x10,%eax
  281729:	66 a3 0e f9 26 00    	mov    %ax,0x26f90e
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
  28172f:	b8 67 19 00 00       	mov    $0x1967,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281734:	66 a3 60 f9 26 00    	mov    %ax,0x26f960
	gd->selector = selector;
  28173a:	66 c7 05 62 f9 26 00 	movw   $0x18,0x26f962
  281741:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281743:	c6 05 64 f9 26 00 00 	movb   $0x0,0x26f964
	gd->access_right = ar&0xff;
  28174a:	c6 05 65 f9 26 00 8e 	movb   $0x8e,0x26f965
	gd->offset_high = (offset>>16)&0xffff;
  281751:	c1 e8 10             	shr    $0x10,%eax
  281754:	66 a3 66 f9 26 00    	mov    %ax,0x26f966
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
  28175a:	b8 95 19 00 00       	mov    $0x1995,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28175f:	66 a3 00 fa 26 00    	mov    %ax,0x26fa00
	gd->selector = selector;
  281765:	66 c7 05 02 fa 26 00 	movw   $0x18,0x26fa02
  28176c:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  28176e:	c6 05 04 fa 26 00 00 	movb   $0x0,0x26fa04
	gd->access_right = ar&0xff;
  281775:	c6 05 05 fa 26 00 ee 	movb   $0xee,0x26fa05
	gd->offset_high = (offset>>16)&0xffff;
  28177c:	c1 e8 10             	shr    $0x10,%eax
  28177f:	66 a3 06 fa 26 00    	mov    %ax,0x26fa06
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
  281785:	b8 b6 19 00 00       	mov    $0x19b6,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28178a:	66 a3 68 f8 26 00    	mov    %ax,0x26f868
	gd->selector = selector;
  281790:	66 c7 05 6a f8 26 00 	movw   $0x18,0x26f86a
  281797:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281799:	c6 05 6c f8 26 00 00 	movb   $0x0,0x26f86c
	gd->access_right = ar&0xff;
  2817a0:	c6 05 6d f8 26 00 8e 	movb   $0x8e,0x26f86d
	gd->offset_high = (offset>>16)&0xffff;
  2817a7:	c1 e8 10             	shr    $0x10,%eax
  2817aa:	66 a3 6e f8 26 00    	mov    %ax,0x26f86e
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
  2817b0:	b8 d6 19 00 00       	mov    $0x19d6,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2817b5:	66 a3 60 f8 26 00    	mov    %ax,0x26f860
	gd->selector = selector;
  2817bb:	66 c7 05 62 f8 26 00 	movw   $0x18,0x26f862
  2817c2:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2817c4:	c6 05 64 f8 26 00 00 	movb   $0x0,0x26f864
	gd->access_right = ar&0xff;
  2817cb:	c6 05 65 f8 26 00 8e 	movb   $0x8e,0x26f865
	gd->offset_high = (offset>>16)&0xffff;
  2817d2:	c1 e8 10             	shr    $0x10,%eax
  2817d5:	66 a3 66 f8 26 00    	mov    %ax,0x26f866
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
	load_idtr(LIMIT_IDT,ADR_IDT);
  2817db:	83 ec 08             	sub    $0x8,%esp
  2817de:	68 00 f8 26 00       	push   $0x26f800
  2817e3:	68 ff 07 00 00       	push   $0x7ff
  2817e8:	e8 42 f3 ff ff       	call   280b2f <load_idtr>

	return;
  2817ed:	83 c4 10             	add    $0x10,%esp
}
  2817f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2817f3:	c9                   	leave  
  2817f4:	c3                   	ret    

002817f5 <init_pic>:
#include "const.h"
#include "fifo.h"
#include "timer.h"
#include "string.h"
void init_pic(void)
{
  2817f5:	55                   	push   %ebp
  2817f6:	89 e5                	mov    %esp,%ebp
  2817f8:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIC0_IMR, 0xff);	//disable all pic0 int
  2817fb:	68 ff 00 00 00       	push   $0xff
  281800:	6a 21                	push   $0x21
  281802:	e8 ef f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC1_IMR, 0xff);	//disable all pic1 int
  281807:	83 c4 08             	add    $0x8,%esp
  28180a:	68 ff 00 00 00       	push   $0xff
  28180f:	68 a1 00 00 00       	push   $0xa1
  281814:	e8 dd f2 ff ff       	call   280af6 <io_out8>

	io_out8(PIC0_ICW1, 0x11);	
  281819:	83 c4 08             	add    $0x8,%esp
  28181c:	6a 11                	push   $0x11
  28181e:	6a 20                	push   $0x20
  281820:	e8 d1 f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC0_ICW2, 0x20);
  281825:	83 c4 08             	add    $0x8,%esp
  281828:	6a 20                	push   $0x20
  28182a:	6a 21                	push   $0x21
  28182c:	e8 c5 f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC0_ICW3, 1 << 2);
  281831:	83 c4 08             	add    $0x8,%esp
  281834:	6a 04                	push   $0x4
  281836:	6a 21                	push   $0x21
  281838:	e8 b9 f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC0_ICW4, 0x01);
  28183d:	83 c4 08             	add    $0x8,%esp
  281840:	6a 01                	push   $0x1
  281842:	6a 21                	push   $0x21
  281844:	e8 ad f2 ff ff       	call   280af6 <io_out8>

	io_out8(PIC1_ICW1, 0x11);
  281849:	83 c4 08             	add    $0x8,%esp
  28184c:	6a 11                	push   $0x11
  28184e:	68 a0 00 00 00       	push   $0xa0
  281853:	e8 9e f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC1_ICW2, 0x28);
  281858:	83 c4 08             	add    $0x8,%esp
  28185b:	6a 28                	push   $0x28
  28185d:	68 a1 00 00 00       	push   $0xa1
  281862:	e8 8f f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC1_ICW3, 2);
  281867:	83 c4 08             	add    $0x8,%esp
  28186a:	6a 02                	push   $0x2
  28186c:	68 a1 00 00 00       	push   $0xa1
  281871:	e8 80 f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC1_ICW4, 0x01);
  281876:	83 c4 08             	add    $0x8,%esp
  281879:	6a 01                	push   $0x1
  28187b:	68 a1 00 00 00       	push   $0xa1
  281880:	e8 71 f2 ff ff       	call   280af6 <io_out8>

	io_out8(PIC0_IMR, 0xfb);
  281885:	83 c4 08             	add    $0x8,%esp
  281888:	68 fb 00 00 00       	push   $0xfb
  28188d:	6a 21                	push   $0x21
  28188f:	e8 62 f2 ff ff       	call   280af6 <io_out8>
	io_out8(PIC1_IMR, 0xff);
  281894:	83 c4 08             	add    $0x8,%esp
  281897:	68 ff 00 00 00       	push   $0xff
  28189c:	68 a1 00 00 00       	push   $0xa1
  2818a1:	e8 50 f2 ff ff       	call   280af6 <io_out8>
}
  2818a6:	83 c4 10             	add    $0x10,%esp
  2818a9:	c9                   	leave  
  2818aa:	c3                   	ret    

002818ab <inthandler0d>:

//when app code execute or access sys code or mem
int *inthandler0d(int *esp)
{
  2818ab:	55                   	push   %ebp
  2818ac:	89 e5                	mov    %esp,%ebp
  2818ae:	57                   	push   %edi
  2818af:	56                   	push   %esi
  2818b0:	53                   	push   %ebx
  2818b1:	83 ec 2c             	sub    $0x2c,%esp
	struct TASK *task = task_now();
  2818b4:	e8 28 17 00 00       	call   282fe1 <task_now>
  2818b9:	89 c3                	mov    %eax,%ebx
	struct CONSOLE *cons = task->cons;
  2818bb:	8b b0 a4 00 00 00    	mov    0xa4(%eax),%esi
	cons_putstr0(cons,"\nINT 0D:\n General Protected Exception.\n");
  2818c1:	83 ec 08             	sub    $0x8,%esp
  2818c4:	68 a0 56 28 00       	push   $0x2856a0
  2818c9:	56                   	push   %esi
  2818ca:	e8 04 26 00 00       	call   283ed3 <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  2818cf:	83 c4 0c             	add    $0xc,%esp
  2818d2:	8b 45 08             	mov    0x8(%ebp),%eax
  2818d5:	ff 70 2c             	pushl  0x2c(%eax)
  2818d8:	68 c8 56 28 00       	push   $0x2856c8
  2818dd:	8d 7d ca             	lea    -0x36(%ebp),%edi
  2818e0:	57                   	push   %edi
  2818e1:	e8 37 02 00 00       	call   281b1d <sprintf>
	cons_putstr0(cons,s);
  2818e6:	83 c4 08             	add    $0x8,%esp
  2818e9:	57                   	push   %edi
  2818ea:	56                   	push   %esi
  2818eb:	e8 e3 25 00 00       	call   283ed3 <cons_putstr0>
	return &(task->tss.esp0);
  2818f0:	8d 43 30             	lea    0x30(%ebx),%eax
}
  2818f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2818f6:	5b                   	pop    %ebx
  2818f7:	5e                   	pop    %esi
  2818f8:	5f                   	pop    %edi
  2818f9:	5d                   	pop    %ebp
  2818fa:	c3                   	ret    

002818fb <inthandler0c>:


//when code write beyond stack too much
int *inthandler0c(int *esp)
{
  2818fb:	55                   	push   %ebp
  2818fc:	89 e5                	mov    %esp,%ebp
  2818fe:	57                   	push   %edi
  2818ff:	56                   	push   %esi
  281900:	53                   	push   %ebx
  281901:	83 ec 2c             	sub    $0x2c,%esp
	struct TASK *task = task_now();
  281904:	e8 d8 16 00 00       	call   282fe1 <task_now>
  281909:	89 c3                	mov    %eax,%ebx
	struct CONSOLE *cons = task->cons;
  28190b:	8b b0 a4 00 00 00    	mov    0xa4(%eax),%esi
	cons_putstr0(cons,"\nINT 0C:\n Stack Exception.\n");
  281911:	83 ec 08             	sub    $0x8,%esp
  281914:	68 d0 56 28 00       	push   $0x2856d0
  281919:	56                   	push   %esi
  28191a:	e8 b4 25 00 00       	call   283ed3 <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  28191f:	83 c4 0c             	add    $0xc,%esp
  281922:	8b 45 08             	mov    0x8(%ebp),%eax
  281925:	ff 70 2c             	pushl  0x2c(%eax)
  281928:	68 c8 56 28 00       	push   $0x2856c8
  28192d:	8d 7d ca             	lea    -0x36(%ebp),%edi
  281930:	57                   	push   %edi
  281931:	e8 e7 01 00 00       	call   281b1d <sprintf>
	cons_putstr0(cons,s);
  281936:	83 c4 08             	add    $0x8,%esp
  281939:	57                   	push   %edi
  28193a:	56                   	push   %esi
  28193b:	e8 93 25 00 00       	call   283ed3 <cons_putstr0>
	return &(task->tss.esp0);
  281940:	8d 43 30             	lea    0x30(%ebx),%eax
}
  281943:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281946:	5b                   	pop    %ebx
  281947:	5e                   	pop    %esi
  281948:	5f                   	pop    %edi
  281949:	5d                   	pop    %ebp
  28194a:	c3                   	ret    
  28194b:	66 90                	xchg   %ax,%ax
  28194d:	66 90                	xchg   %ax,%ax
  28194f:	90                   	nop

00281950 <asm_inthandler21>:
  281950:	06                   	push   %es
  281951:	1e                   	push   %ds
  281952:	60                   	pusha  
  281953:	89 e0                	mov    %esp,%eax
  281955:	50                   	push   %eax
  281956:	66 8c d0             	mov    %ss,%ax
  281959:	8e d8                	mov    %eax,%ds
  28195b:	8e c0                	mov    %eax,%es
  28195d:	e8 ed 05 00 00       	call   281f4f <inthandler21>
  281962:	58                   	pop    %eax
  281963:	61                   	popa   
  281964:	1f                   	pop    %ds
  281965:	07                   	pop    %es
  281966:	cf                   	iret   

00281967 <asm_inthandler2c>:
  281967:	06                   	push   %es
  281968:	1e                   	push   %ds
  281969:	60                   	pusha  
  28196a:	89 e0                	mov    %esp,%eax
  28196c:	50                   	push   %eax
  28196d:	66 8c d0             	mov    %ss,%ax
  281970:	8e d8                	mov    %eax,%ds
  281972:	8e c0                	mov    %eax,%es
  281974:	e8 3c 05 00 00       	call   281eb5 <inthandler2c>
  281979:	58                   	pop    %eax
  28197a:	61                   	popa   
  28197b:	1f                   	pop    %ds
  28197c:	07                   	pop    %es
  28197d:	cf                   	iret   

0028197e <asm_inthandler20>:
  28197e:	06                   	push   %es
  28197f:	1e                   	push   %ds
  281980:	60                   	pusha  
  281981:	89 e0                	mov    %esp,%eax
  281983:	50                   	push   %eax
  281984:	66 8c d0             	mov    %ss,%ax
  281987:	8e d8                	mov    %eax,%ds
  281989:	8e c0                	mov    %eax,%es
  28198b:	e8 c1 13 00 00       	call   282d51 <inthandler20>
  281990:	58                   	pop    %eax
  281991:	61                   	popa   
  281992:	1f                   	pop    %ds
  281993:	07                   	pop    %es
  281994:	cf                   	iret   

00281995 <asm_sys_api>:
  281995:	fb                   	sti    
  281996:	1e                   	push   %ds
  281997:	06                   	push   %es
  281998:	60                   	pusha  
  281999:	60                   	pusha  
  28199a:	66 8c d0             	mov    %ss,%ax
  28199d:	8e d8                	mov    %eax,%ds
  28199f:	8e c0                	mov    %eax,%es
  2819a1:	e8 18 2d 00 00       	call   2846be <sys_api>
  2819a6:	83 f8 00             	cmp    $0x0,%eax
  2819a9:	75 07                	jne    2819b2 <end_app>
  2819ab:	83 c4 20             	add    $0x20,%esp
  2819ae:	61                   	popa   
  2819af:	07                   	pop    %es
  2819b0:	1f                   	pop    %ds
  2819b1:	cf                   	iret   

002819b2 <end_app>:
  2819b2:	8b 20                	mov    (%eax),%esp
  2819b4:	61                   	popa   
  2819b5:	c3                   	ret    

002819b6 <asm_inthandler0d>:
  2819b6:	fb                   	sti    
  2819b7:	06                   	push   %es
  2819b8:	1e                   	push   %ds
  2819b9:	60                   	pusha  
  2819ba:	89 e0                	mov    %esp,%eax
  2819bc:	50                   	push   %eax
  2819bd:	66 8c d0             	mov    %ss,%ax
  2819c0:	8e d8                	mov    %eax,%ds
  2819c2:	8e c0                	mov    %eax,%es
  2819c4:	e8 e2 fe ff ff       	call   2818ab <inthandler0d>
  2819c9:	83 f8 00             	cmp    $0x0,%eax
  2819cc:	75 e4                	jne    2819b2 <end_app>
  2819ce:	58                   	pop    %eax
  2819cf:	61                   	popa   
  2819d0:	1f                   	pop    %ds
  2819d1:	07                   	pop    %es
  2819d2:	83 c4 04             	add    $0x4,%esp
  2819d5:	cf                   	iret   

002819d6 <asm_inthandler0c>:
  2819d6:	fb                   	sti    
  2819d7:	06                   	push   %es
  2819d8:	1e                   	push   %ds
  2819d9:	60                   	pusha  
  2819da:	89 e0                	mov    %esp,%eax
  2819dc:	50                   	push   %eax
  2819dd:	66 8c d0             	mov    %ss,%ax
  2819e0:	8e d8                	mov    %eax,%ds
  2819e2:	8e c0                	mov    %eax,%es
  2819e4:	e8 12 ff ff ff       	call   2818fb <inthandler0c>
  2819e9:	83 f8 00             	cmp    $0x0,%eax
  2819ec:	75 c4                	jne    2819b2 <end_app>
  2819ee:	58                   	pop    %eax
  2819ef:	61                   	popa   
  2819f0:	1f                   	pop    %ds
  2819f1:	07                   	pop    %es
  2819f2:	83 c4 04             	add    $0x4,%esp
  2819f5:	cf                   	iret   

002819f6 <itoa>:
#include"string.h"
void itoa(int value,char *buf){
  2819f6:	55                   	push   %ebp
  2819f7:	89 e5                	mov    %esp,%ebp
  2819f9:	57                   	push   %edi
  2819fa:	56                   	push   %esi
  2819fb:	53                   	push   %ebx
  2819fc:	83 ec 10             	sub    $0x10,%esp
  2819ff:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281a02:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char tmp_buf[10] = {0};
  281a05:	c7 45 ea 00 00 00 00 	movl   $0x0,-0x16(%ebp)
  281a0c:	c7 45 ee 00 00 00 00 	movl   $0x0,-0x12(%ebp)
  281a13:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
  281a19:	85 c9                	test   %ecx,%ecx
  281a1b:	79 08                	jns    281a25 <itoa+0x2f>
		*buf++ = '-';
  281a1d:	c6 07 2d             	movb   $0x2d,(%edi)
		value = ~value + 1; 
  281a20:	f7 d9                	neg    %ecx
#include"string.h"
void itoa(int value,char *buf){
	char tmp_buf[10] = {0};
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
		*buf++ = '-';
  281a22:	8d 7f 01             	lea    0x1(%edi),%edi
  281a25:	8d 5d ea             	lea    -0x16(%ebp),%ebx
		value = ~value + 1; 
	}

	do{
		*tbp++ = ('0' + (char)(value % 10));
  281a28:	be 67 66 66 66       	mov    $0x66666667,%esi
  281a2d:	83 c3 01             	add    $0x1,%ebx
  281a30:	89 c8                	mov    %ecx,%eax
  281a32:	f7 ee                	imul   %esi
  281a34:	c1 fa 02             	sar    $0x2,%edx
  281a37:	89 c8                	mov    %ecx,%eax
  281a39:	c1 f8 1f             	sar    $0x1f,%eax
  281a3c:	29 c2                	sub    %eax,%edx
  281a3e:	8d 04 92             	lea    (%edx,%edx,4),%eax
  281a41:	01 c0                	add    %eax,%eax
  281a43:	29 c1                	sub    %eax,%ecx
  281a45:	83 c1 30             	add    $0x30,%ecx
  281a48:	88 4b ff             	mov    %cl,-0x1(%ebx)
		value /= 10;
  281a4b:	89 d1                	mov    %edx,%ecx
	}while(value);
  281a4d:	85 d2                	test   %edx,%edx
  281a4f:	75 dc                	jne    281a2d <itoa+0x37>
	while(tmp_buf != tbp--)
  281a51:	8d 73 ff             	lea    -0x1(%ebx),%esi
  281a54:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281a57:	39 c3                	cmp    %eax,%ebx
  281a59:	74 20                	je     281a7b <itoa+0x85>
  281a5b:	89 f0                	mov    %esi,%eax
  281a5d:	89 fa                	mov    %edi,%edx
  281a5f:	8d 5d e9             	lea    -0x17(%ebp),%ebx
		*buf++ = *tbp;
  281a62:	83 c2 01             	add    $0x1,%edx
  281a65:	0f b6 08             	movzbl (%eax),%ecx
  281a68:	88 4a ff             	mov    %cl,-0x1(%edx)

	do{
		*tbp++ = ('0' + (char)(value % 10));
		value /= 10;
	}while(value);
	while(tmp_buf != tbp--)
  281a6b:	83 e8 01             	sub    $0x1,%eax
  281a6e:	39 d8                	cmp    %ebx,%eax
  281a70:	75 f0                	jne    281a62 <itoa+0x6c>
  281a72:	8d 45 f4             	lea    -0xc(%ebp),%eax
  281a75:	29 c6                	sub    %eax,%esi
  281a77:	8d 7c 37 0b          	lea    0xb(%edi,%esi,1),%edi
		*buf++ = *tbp;
	*buf='\0';
  281a7b:	c6 07 00             	movb   $0x0,(%edi)
}
  281a7e:	83 c4 10             	add    $0x10,%esp
  281a81:	5b                   	pop    %ebx
  281a82:	5e                   	pop    %esi
  281a83:	5f                   	pop    %edi
  281a84:	5d                   	pop    %ebp
  281a85:	c3                   	ret    

00281a86 <xtoa>:
    else
        value = value + 48;
    return value;
}

void xtoa(unsigned int value,char *buf){
  281a86:	55                   	push   %ebp
  281a87:	89 e5                	mov    %esp,%ebp
  281a89:	57                   	push   %edi
  281a8a:	56                   	push   %esi
  281a8b:	53                   	push   %ebx
  281a8c:	83 ec 20             	sub    $0x20,%esp
  281a8f:	8b 45 08             	mov    0x8(%ebp),%eax
    char tmp_buf[30] = {0};
  281a92:	bb 00 00 00 00       	mov    $0x0,%ebx
  281a97:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
  281a9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  281aa5:	b9 1c 00 00 00       	mov    $0x1c,%ecx
  281aaa:	ba 00 00 00 00       	mov    $0x0,%edx
  281aaf:	89 5c 15 d8          	mov    %ebx,-0x28(%ebp,%edx,1)
  281ab3:	83 c2 04             	add    $0x4,%edx
  281ab6:	39 ca                	cmp    %ecx,%edx
  281ab8:	72 f5                	jb     281aaf <xtoa+0x29>
    char *tbp = tmp_buf;

    *buf++='0';
  281aba:	8b 75 0c             	mov    0xc(%ebp),%esi
  281abd:	c6 06 30             	movb   $0x30,(%esi)
    *buf++='x';
  281ac0:	83 c6 02             	add    $0x2,%esi
  281ac3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281ac6:	c6 43 01 78          	movb   $0x78,0x1(%ebx)
    return value;
}

void xtoa(unsigned int value,char *buf){
    char tmp_buf[30] = {0};
    char *tbp = tmp_buf;
  281aca:	8d 5d d6             	lea    -0x2a(%ebp),%ebx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  281acd:	83 c3 01             	add    $0x1,%ebx
  281ad0:	89 c1                	mov    %eax,%ecx
  281ad2:	83 e1 0f             	and    $0xf,%ecx
	*str='\0';
}

static  inline char fourbtoc(int value){
    if(value >= 10)
        value = value - 10 + 65;
  281ad5:	8d 79 37             	lea    0x37(%ecx),%edi
  281ad8:	8d 51 30             	lea    0x30(%ecx),%edx
  281adb:	83 f9 0a             	cmp    $0xa,%ecx
  281ade:	0f 4d d7             	cmovge %edi,%edx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  281ae1:	88 53 ff             	mov    %dl,-0x1(%ebx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
  281ae4:	c1 e8 04             	shr    $0x4,%eax
    }while(value);
  281ae7:	85 c0                	test   %eax,%eax
  281ae9:	75 e2                	jne    281acd <xtoa+0x47>
    
    while(tmp_buf != tbp){
  281aeb:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  281aee:	39 c3                	cmp    %eax,%ebx
  281af0:	74 20                	je     281b12 <xtoa+0x8c>
  281af2:	89 d8                	mov    %ebx,%eax
  281af4:	89 f1                	mov    %esi,%ecx
  281af6:	8d 7d d6             	lea    -0x2a(%ebp),%edi
      tbp--;
  281af9:	83 e8 01             	sub    $0x1,%eax
      *buf++ = *tbp;
  281afc:	83 c1 01             	add    $0x1,%ecx
  281aff:	0f b6 10             	movzbl (%eax),%edx
  281b02:	88 51 ff             	mov    %dl,-0x1(%ecx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
    }while(value);
    
    while(tmp_buf != tbp){
  281b05:	39 f8                	cmp    %edi,%eax
  281b07:	75 f0                	jne    281af9 <xtoa+0x73>
  281b09:	8d 45 f4             	lea    -0xc(%ebp),%eax
  281b0c:	29 c3                	sub    %eax,%ebx
  281b0e:	8d 74 1e 1e          	lea    0x1e(%esi,%ebx,1),%esi
      tbp--;
      *buf++ = *tbp;
    }
    *buf='\0';
  281b12:	c6 06 00             	movb   $0x0,(%esi)
}
  281b15:	83 c4 20             	add    $0x20,%esp
  281b18:	5b                   	pop    %ebx
  281b19:	5e                   	pop    %esi
  281b1a:	5f                   	pop    %edi
  281b1b:	5d                   	pop    %ebp
  281b1c:	c3                   	ret    

00281b1d <sprintf>:
	while(tmp_buf != tbp--)
		*buf++ = *tbp;
	*buf='\0';
}

void sprintf(char *str,char *format ,...){
  281b1d:	55                   	push   %ebp
  281b1e:	89 e5                	mov    %esp,%ebp
  281b20:	57                   	push   %edi
  281b21:	56                   	push   %esi
  281b22:	53                   	push   %ebx
  281b23:	83 ec 10             	sub    $0x10,%esp
  281b26:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
  281b29:	8d 7d 10             	lea    0x10(%ebp),%edi
	char buffer[10];
	char *buf=buffer;
	while(*format){
  281b2c:	e9 a8 00 00 00       	jmp    281bd9 <sprintf+0xbc>
		if(*format!='%'){
  281b31:	3c 25                	cmp    $0x25,%al
  281b33:	74 10                	je     281b45 <sprintf+0x28>
			*str++=*format++;
  281b35:	83 c6 01             	add    $0x1,%esi
  281b38:	89 75 0c             	mov    %esi,0xc(%ebp)
  281b3b:	88 03                	mov    %al,(%ebx)
  281b3d:	8d 5b 01             	lea    0x1(%ebx),%ebx
			continue;
  281b40:	e9 94 00 00 00       	jmp    281bd9 <sprintf+0xbc>
		}
		else{
			format++;
  281b45:	8d 46 01             	lea    0x1(%esi),%eax
  281b48:	89 45 0c             	mov    %eax,0xc(%ebp)
			switch (*format){
  281b4b:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  281b4f:	3c 73                	cmp    $0x73,%al
  281b51:	74 5e                	je     281bb1 <sprintf+0x94>
  281b53:	3c 78                	cmp    $0x78,%al
  281b55:	74 2f                	je     281b86 <sprintf+0x69>
  281b57:	3c 64                	cmp    $0x64,%al
  281b59:	75 75                	jne    281bd0 <sprintf+0xb3>
				case 'd':itoa(*var,buf);while(*buf){*str++=*buf++;};break;
  281b5b:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281b5e:	50                   	push   %eax
  281b5f:	ff 37                	pushl  (%edi)
  281b61:	e8 90 fe ff ff       	call   2819f6 <itoa>
  281b66:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281b6a:	83 c4 08             	add    $0x8,%esp
  281b6d:	84 c0                	test   %al,%al
  281b6f:	74 5f                	je     281bd0 <sprintf+0xb3>
  281b71:	8d 55 ea             	lea    -0x16(%ebp),%edx
  281b74:	83 c3 01             	add    $0x1,%ebx
  281b77:	83 c2 01             	add    $0x1,%edx
  281b7a:	88 43 ff             	mov    %al,-0x1(%ebx)
  281b7d:	0f b6 02             	movzbl (%edx),%eax
  281b80:	84 c0                	test   %al,%al
  281b82:	75 f0                	jne    281b74 <sprintf+0x57>
  281b84:	eb 4a                	jmp    281bd0 <sprintf+0xb3>
				case 'x':xtoa(*var,buf);while(*buf){*str++=*buf++;};break;
  281b86:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281b89:	50                   	push   %eax
  281b8a:	ff 37                	pushl  (%edi)
  281b8c:	e8 f5 fe ff ff       	call   281a86 <xtoa>
  281b91:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281b95:	83 c4 08             	add    $0x8,%esp
  281b98:	84 c0                	test   %al,%al
  281b9a:	74 34                	je     281bd0 <sprintf+0xb3>
  281b9c:	8d 55 ea             	lea    -0x16(%ebp),%edx
  281b9f:	83 c3 01             	add    $0x1,%ebx
  281ba2:	83 c2 01             	add    $0x1,%edx
  281ba5:	88 43 ff             	mov    %al,-0x1(%ebx)
  281ba8:	0f b6 02             	movzbl (%edx),%eax
  281bab:	84 c0                	test   %al,%al
  281bad:	75 f0                	jne    281b9f <sprintf+0x82>
  281baf:	eb 1f                	jmp    281bd0 <sprintf+0xb3>
				case 's':buf=(char*)(*var);while(*buf){*str++=*buf++;};break;
  281bb1:	8b 0f                	mov    (%edi),%ecx
  281bb3:	0f b6 11             	movzbl (%ecx),%edx
  281bb6:	84 d2                	test   %dl,%dl
  281bb8:	74 16                	je     281bd0 <sprintf+0xb3>
  281bba:	89 d8                	mov    %ebx,%eax
  281bbc:	83 c0 01             	add    $0x1,%eax
  281bbf:	88 50 ff             	mov    %dl,-0x1(%eax)
  281bc2:	89 c2                	mov    %eax,%edx
  281bc4:	29 da                	sub    %ebx,%edx
  281bc6:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
  281bca:	84 d2                	test   %dl,%dl
  281bcc:	75 ee                	jne    281bbc <sprintf+0x9f>
  281bce:	89 c3                	mov    %eax,%ebx
			}
			buf=buffer;
			var++;
  281bd0:	83 c7 04             	add    $0x4,%edi
			format++;
  281bd3:	83 c6 02             	add    $0x2,%esi
  281bd6:	89 75 0c             	mov    %esi,0xc(%ebp)

void sprintf(char *str,char *format ,...){
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
	char buffer[10];
	char *buf=buffer;
	while(*format){
  281bd9:	8b 75 0c             	mov    0xc(%ebp),%esi
  281bdc:	0f b6 06             	movzbl (%esi),%eax
  281bdf:	84 c0                	test   %al,%al
  281be1:	0f 85 4a ff ff ff    	jne    281b31 <sprintf+0x14>
			buf=buffer;
			var++;
			format++;
		}
	}
	*str='\0';
  281be7:	c6 03 00             	movb   $0x0,(%ebx)
}
  281bea:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281bed:	5b                   	pop    %ebx
  281bee:	5e                   	pop    %esi
  281bef:	5f                   	pop    %edi
  281bf0:	5d                   	pop    %ebp
  281bf1:	c3                   	ret    

00281bf2 <strcmp>:
    }
    *buf='\0';
}

int strcmp(const char *str1,const char *str2)
{
  281bf2:	55                   	push   %ebp
  281bf3:	89 e5                	mov    %esp,%ebp
  281bf5:	57                   	push   %edi
  281bf6:	56                   	push   %esi
  281bf7:	53                   	push   %ebx
  281bf8:	8b 7d 08             	mov    0x8(%ebp),%edi
  281bfb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281bfe:	0f b6 17             	movzbl (%edi),%edx
  281c01:	be 00 00 00 00       	mov    $0x0,%esi
  281c06:	84 d2                	test   %dl,%dl
  281c08:	74 40                	je     281c4a <strcmp+0x58>
  281c0a:	eb 1d                	jmp    281c29 <strcmp+0x37>
	{
		if(c1==c2) i++;
  281c0c:	38 ca                	cmp    %cl,%dl
  281c0e:	75 0f                	jne    281c1f <strcmp+0x2d>
  281c10:	83 c0 01             	add    $0x1,%eax

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281c13:	89 c6                	mov    %eax,%esi
  281c15:	0f b6 14 07          	movzbl (%edi,%eax,1),%edx
  281c19:	84 d2                	test   %dl,%dl
  281c1b:	75 1e                	jne    281c3b <strcmp+0x49>
  281c1d:	eb 2b                	jmp    281c4a <strcmp+0x58>
	{
		if(c1==c2) i++;
		else return c1-c2;
  281c1f:	0f be c2             	movsbl %dl,%eax
  281c22:	0f be c9             	movsbl %cl,%ecx
  281c25:	29 c8                	sub    %ecx,%eax
  281c27:	eb 2a                	jmp    281c53 <strcmp+0x61>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281c29:	0f b6 0b             	movzbl (%ebx),%ecx
  281c2c:	84 c9                	test   %cl,%cl
  281c2e:	74 15                	je     281c45 <strcmp+0x53>
	{
		if(c1==c2) i++;
  281c30:	b8 00 00 00 00       	mov    $0x0,%eax
  281c35:	38 ca                	cmp    %cl,%dl
  281c37:	74 d7                	je     281c10 <strcmp+0x1e>
  281c39:	eb e4                	jmp    281c1f <strcmp+0x2d>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281c3b:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  281c3f:	84 c9                	test   %cl,%cl
  281c41:	75 c9                	jne    281c0c <strcmp+0x1a>
  281c43:	eb 05                	jmp    281c4a <strcmp+0x58>
  281c45:	be 00 00 00 00       	mov    $0x0,%esi
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281c4a:	0f be c2             	movsbl %dl,%eax
  281c4d:	0f be 14 33          	movsbl (%ebx,%esi,1),%edx
  281c51:	29 d0                	sub    %edx,%eax
}
  281c53:	5b                   	pop    %ebx
  281c54:	5e                   	pop    %esi
  281c55:	5f                   	pop    %edi
  281c56:	5d                   	pop    %ebp
  281c57:	c3                   	ret    

00281c58 <strncmp>:

int strncmp(const char *str1,const char *str2,unsigned int n)
{
  281c58:	55                   	push   %ebp
  281c59:	89 e5                	mov    %esp,%ebp
  281c5b:	57                   	push   %edi
  281c5c:	56                   	push   %esi
  281c5d:	53                   	push   %ebx
  281c5e:	8b 75 08             	mov    0x8(%ebp),%esi
  281c61:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281c64:	8b 7d 10             	mov    0x10(%ebp),%edi
	if(n == 0) return 0;
  281c67:	b8 00 00 00 00       	mov    $0x0,%eax
  281c6c:	85 ff                	test   %edi,%edi
  281c6e:	74 63                	je     281cd3 <strncmp+0x7b>
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281c70:	83 ef 01             	sub    $0x1,%edi
  281c73:	89 fa                	mov    %edi,%edx
  281c75:	74 52                	je     281cc9 <strncmp+0x71>
  281c77:	eb 19                	jmp    281c92 <strncmp+0x3a>
	{
		if(c1==c2) i++;
  281c79:	38 c8                	cmp    %cl,%al
  281c7b:	75 0b                	jne    281c88 <strncmp+0x30>
  281c7d:	83 c2 01             	add    $0x1,%edx
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281c80:	39 fa                	cmp    %edi,%edx
  281c82:	75 27                	jne    281cab <strncmp+0x53>
	{
		if(c1==c2) i++;
  281c84:	89 fa                	mov    %edi,%edx
  281c86:	eb 41                	jmp    281cc9 <strncmp+0x71>
		else return c1-c2;
  281c88:	0f be c0             	movsbl %al,%eax
  281c8b:	0f be c9             	movsbl %cl,%ecx
  281c8e:	29 c8                	sub    %ecx,%eax
  281c90:	eb 41                	jmp    281cd3 <strncmp+0x7b>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281c92:	0f b6 06             	movzbl (%esi),%eax
  281c95:	84 c0                	test   %al,%al
  281c97:	74 24                	je     281cbd <strncmp+0x65>
  281c99:	0f b6 0b             	movzbl (%ebx),%ecx
  281c9c:	84 c9                	test   %cl,%cl
  281c9e:	74 24                	je     281cc4 <strncmp+0x6c>
	{
		if(c1==c2) i++;
  281ca0:	ba 00 00 00 00       	mov    $0x0,%edx
  281ca5:	38 c8                	cmp    %cl,%al
  281ca7:	74 d4                	je     281c7d <strncmp+0x25>
  281ca9:	eb dd                	jmp    281c88 <strncmp+0x30>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281cab:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
  281caf:	84 c0                	test   %al,%al
  281cb1:	74 16                	je     281cc9 <strncmp+0x71>
  281cb3:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  281cb7:	84 c9                	test   %cl,%cl
  281cb9:	75 be                	jne    281c79 <strncmp+0x21>
  281cbb:	eb 0c                	jmp    281cc9 <strncmp+0x71>
  281cbd:	ba 00 00 00 00       	mov    $0x0,%edx
  281cc2:	eb 05                	jmp    281cc9 <strncmp+0x71>
  281cc4:	ba 00 00 00 00       	mov    $0x0,%edx
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281cc9:	0f be 04 16          	movsbl (%esi,%edx,1),%eax
  281ccd:	0f be 14 13          	movsbl (%ebx,%edx,1),%edx
  281cd1:	29 d0                	sub    %edx,%eax
}
  281cd3:	5b                   	pop    %ebx
  281cd4:	5e                   	pop    %esi
  281cd5:	5f                   	pop    %edi
  281cd6:	5d                   	pop    %ebp
  281cd7:	c3                   	ret    

00281cd8 <fifo32_init>:
#include "fifo.h"
#include "task.h"
void fifo32_init(struct FIFO32 *fifo,int size,int *buf,struct TASK *task)
{
  281cd8:	55                   	push   %ebp
  281cd9:	89 e5                	mov    %esp,%ebp
  281cdb:	8b 45 08             	mov    0x8(%ebp),%eax
  281cde:	8b 55 0c             	mov    0xc(%ebp),%edx
	fifo->size=size;
  281ce1:	89 50 0c             	mov    %edx,0xc(%eax)
	fifo->buf=buf;
  281ce4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281ce7:	89 08                	mov    %ecx,(%eax)
	fifo->free = size;
  281ce9:	89 50 10             	mov    %edx,0x10(%eax)
	fifo->flags = 0;
  281cec:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	fifo->p = 0;
  281cf3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->q = 0;
  281cfa:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	fifo->task = task;
  281d01:	8b 55 14             	mov    0x14(%ebp),%edx
  281d04:	89 50 18             	mov    %edx,0x18(%eax)
	return;
}
  281d07:	5d                   	pop    %ebp
  281d08:	c3                   	ret    

00281d09 <fifo32_put>:
#define FLAGS_OVERRUN 0x0001
#include "timer.h"
extern struct TIMERCTL timerctl;

int fifo32_put(struct FIFO32 *fifo,int data)
{
  281d09:	55                   	push   %ebp
  281d0a:	89 e5                	mov    %esp,%ebp
  281d0c:	53                   	push   %ebx
  281d0d:	83 ec 04             	sub    $0x4,%esp
  281d10:	8b 45 08             	mov    0x8(%ebp),%eax
	if(fifo->free == 0)
  281d13:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  281d17:	75 0b                	jne    281d24 <fifo32_put+0x1b>
	{
		fifo->flags |= FLAGS_OVERRUN;
  281d19:	83 48 14 01          	orl    $0x1,0x14(%eax)
		return -1;
  281d1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  281d22:	eb 52                	jmp    281d76 <fifo32_put+0x6d>
	}
	fifo->buf[fifo->p] = data;
  281d24:	8b 48 04             	mov    0x4(%eax),%ecx
  281d27:	8b 10                	mov    (%eax),%edx
  281d29:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281d2c:	89 1c 8a             	mov    %ebx,(%edx,%ecx,4)
	fifo->p++;
  281d2f:	8b 48 04             	mov    0x4(%eax),%ecx
  281d32:	8d 51 01             	lea    0x1(%ecx),%edx
  281d35:	89 50 04             	mov    %edx,0x4(%eax)
	if(fifo->p == fifo->size)
  281d38:	3b 50 0c             	cmp    0xc(%eax),%edx
  281d3b:	75 07                	jne    281d44 <fifo32_put+0x3b>
		fifo->p = 0;
  281d3d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->free--;
  281d44:	83 68 10 01          	subl   $0x1,0x10(%eax)

	//wake up task
	if(fifo->task!=0)
  281d48:	8b 50 18             	mov    0x18(%eax),%edx
  281d4b:	85 d2                	test   %edx,%edx
  281d4d:	74 22                	je     281d71 <fifo32_put+0x68>
		if(fifo->task->flags!=2)
		{
			task_run(fifo->task,-1,0);
		}
	}
	return 0;
  281d4f:	b8 00 00 00 00       	mov    $0x0,%eax
	fifo->free--;

	//wake up task
	if(fifo->task!=0)
	{
		if(fifo->task->flags!=2)
  281d54:	83 7a 04 02          	cmpl   $0x2,0x4(%edx)
  281d58:	74 1c                	je     281d76 <fifo32_put+0x6d>
		{
			task_run(fifo->task,-1,0);
  281d5a:	83 ec 04             	sub    $0x4,%esp
  281d5d:	6a 00                	push   $0x0
  281d5f:	6a ff                	push   $0xffffffff
  281d61:	52                   	push   %edx
  281d62:	e8 6f 13 00 00       	call   2830d6 <task_run>
  281d67:	83 c4 10             	add    $0x10,%esp
		}
	}
	return 0;
  281d6a:	b8 00 00 00 00       	mov    $0x0,%eax
  281d6f:	eb 05                	jmp    281d76 <fifo32_put+0x6d>
  281d71:	b8 00 00 00 00       	mov    $0x0,%eax
}
  281d76:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  281d79:	c9                   	leave  
  281d7a:	c3                   	ret    

00281d7b <fifo32_get>:

int fifo32_get(struct FIFO32 *fifo)
{
  281d7b:	55                   	push   %ebp
  281d7c:	89 e5                	mov    %esp,%ebp
  281d7e:	56                   	push   %esi
  281d7f:	53                   	push   %ebx
  281d80:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if(fifo->free == fifo->size)
  281d83:	8b 59 10             	mov    0x10(%ecx),%ebx
  281d86:	8b 71 0c             	mov    0xc(%ecx),%esi
  281d89:	39 f3                	cmp    %esi,%ebx
  281d8b:	74 20                	je     281dad <fifo32_get+0x32>
		return -1;
	int data = fifo->buf[fifo->q];
  281d8d:	8b 51 08             	mov    0x8(%ecx),%edx
  281d90:	8b 01                	mov    (%ecx),%eax
  281d92:	8b 04 90             	mov    (%eax,%edx,4),%eax
	fifo->q++;
  281d95:	83 c2 01             	add    $0x1,%edx
	if(fifo->q == fifo->size)
  281d98:	39 d6                	cmp    %edx,%esi
int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
	int data = fifo->buf[fifo->q];
	fifo->q++;
  281d9a:	be 00 00 00 00       	mov    $0x0,%esi
  281d9f:	0f 44 d6             	cmove  %esi,%edx
  281da2:	89 51 08             	mov    %edx,0x8(%ecx)
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
  281da5:	83 c3 01             	add    $0x1,%ebx
  281da8:	89 59 10             	mov    %ebx,0x10(%ecx)
	return data;
  281dab:	eb 05                	jmp    281db2 <fifo32_get+0x37>
}

int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
  281dad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	fifo->q++;
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
	return data;
}
  281db2:	5b                   	pop    %ebx
  281db3:	5e                   	pop    %esi
  281db4:	5d                   	pop    %ebp
  281db5:	c3                   	ret    

00281db6 <fifo32_status>:

int fifo32_status(struct FIFO32 *fifo)
{
  281db6:	55                   	push   %ebp
  281db7:	89 e5                	mov    %esp,%ebp
  281db9:	8b 55 08             	mov    0x8(%ebp),%edx
	return fifo->size - fifo->free;
  281dbc:	8b 42 0c             	mov    0xc(%edx),%eax
  281dbf:	2b 42 10             	sub    0x10(%edx),%eax
}
  281dc2:	5d                   	pop    %ebp
  281dc3:	c3                   	ret    

00281dc4 <enable_mouse>:
#include "mouse.h"
struct FIFO32 *mousefifo;
int mousedata0;
void enable_mouse(struct FIFO32 *fifo,int data0,struct MOUSE_DEC *mdec)
{
  281dc4:	55                   	push   %ebp
  281dc5:	89 e5                	mov    %esp,%ebp
  281dc7:	83 ec 08             	sub    $0x8,%esp
	mousefifo = fifo;
  281dca:	8b 45 08             	mov    0x8(%ebp),%eax
  281dcd:	a3 84 82 28 00       	mov    %eax,0x288284
	mousedata0 = data0;
  281dd2:	8b 45 0c             	mov    0xc(%ebp),%eax
  281dd5:	a3 80 82 28 00       	mov    %eax,0x288280

	wait_KBC_sendready();
  281dda:	e8 1a 01 00 00       	call   281ef9 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_SENDTO_MOUSE);
  281ddf:	83 ec 08             	sub    $0x8,%esp
  281de2:	68 d4 00 00 00       	push   $0xd4
  281de7:	6a 64                	push   $0x64
  281de9:	e8 08 ed ff ff       	call   280af6 <io_out8>
	wait_KBC_sendready();
  281dee:	e8 06 01 00 00       	call   281ef9 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,MOUSECMD_ENABLE);
  281df3:	83 c4 08             	add    $0x8,%esp
  281df6:	68 f4 00 00 00       	push   $0xf4
  281dfb:	6a 60                	push   $0x60
  281dfd:	e8 f4 ec ff ff       	call   280af6 <io_out8>
	mdec->phase = 0;
  281e02:	8b 45 10             	mov    0x10(%ebp),%eax
  281e05:	c6 40 03 00          	movb   $0x0,0x3(%eax)
	return;
  281e09:	83 c4 10             	add    $0x10,%esp
}
  281e0c:	c9                   	leave  
  281e0d:	c3                   	ret    

00281e0e <mouse_decode>:

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
  281e0e:	55                   	push   %ebp
  281e0f:	89 e5                	mov    %esp,%ebp
  281e11:	56                   	push   %esi
  281e12:	53                   	push   %ebx
  281e13:	8b 55 08             	mov    0x8(%ebp),%edx
  281e16:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if(mdec->phase == 0)
  281e19:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  281e1d:	84 c0                	test   %al,%al
  281e1f:	75 14                	jne    281e35 <mouse_decode+0x27>
	{
		if(dat == 0xfa)
			mdec->phase = 1;
		return 0;
  281e21:	b8 00 00 00 00       	mov    $0x0,%eax

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
	if(mdec->phase == 0)
	{
		if(dat == 0xfa)
  281e26:	80 f9 fa             	cmp    $0xfa,%cl
  281e29:	0f 85 82 00 00 00    	jne    281eb1 <mouse_decode+0xa3>
			mdec->phase = 1;
  281e2f:	c6 42 03 01          	movb   $0x1,0x3(%edx)
  281e33:	eb 7c                	jmp    281eb1 <mouse_decode+0xa3>
		return 0;
	}
	if(mdec->phase == 1)
  281e35:	3c 01                	cmp    $0x1,%al
  281e37:	75 17                	jne    281e50 <mouse_decode+0x42>
	{
		if((dat&0xc8) == 0x08)
  281e39:	89 cb                	mov    %ecx,%ebx
  281e3b:	83 e3 c8             	and    $0xffffffc8,%ebx
		{
			mdec->buf[0] = dat;
			mdec->phase = 2;
		}
		return 0;
  281e3e:	b8 00 00 00 00       	mov    $0x0,%eax
			mdec->phase = 1;
		return 0;
	}
	if(mdec->phase == 1)
	{
		if((dat&0xc8) == 0x08)
  281e43:	80 fb 08             	cmp    $0x8,%bl
  281e46:	75 69                	jne    281eb1 <mouse_decode+0xa3>
		{
			mdec->buf[0] = dat;
  281e48:	88 0a                	mov    %cl,(%edx)
			mdec->phase = 2;
  281e4a:	c6 42 03 02          	movb   $0x2,0x3(%edx)
  281e4e:	eb 61                	jmp    281eb1 <mouse_decode+0xa3>
		}
		return 0;
	}
	if(mdec->phase == 2)
  281e50:	3c 02                	cmp    $0x2,%al
  281e52:	75 0e                	jne    281e62 <mouse_decode+0x54>
	{
		mdec->buf[1] = dat;
  281e54:	88 4a 01             	mov    %cl,0x1(%edx)
		mdec->phase = 3;
  281e57:	c6 42 03 03          	movb   $0x3,0x3(%edx)
		return 0;
  281e5b:	b8 00 00 00 00       	mov    $0x0,%eax
  281e60:	eb 4f                	jmp    281eb1 <mouse_decode+0xa3>
	}
	if(mdec->phase == 3)
  281e62:	3c 03                	cmp    $0x3,%al
  281e64:	75 46                	jne    281eac <mouse_decode+0x9e>
	{
		mdec->buf[2] = dat;
  281e66:	88 4a 02             	mov    %cl,0x2(%edx)
		mdec->phase = 1;
  281e69:	c6 42 03 01          	movb   $0x1,0x3(%edx)
		mdec->btn = mdec->buf[0] & 0x07;
  281e6d:	0f b6 02             	movzbl (%edx),%eax
  281e70:	89 c3                	mov    %eax,%ebx
  281e72:	83 e3 07             	and    $0x7,%ebx
  281e75:	89 5a 0c             	mov    %ebx,0xc(%edx)
		mdec->x = mdec->buf[1];
  281e78:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
  281e7c:	0f b6 f3             	movzbl %bl,%esi
  281e7f:	89 72 04             	mov    %esi,0x4(%edx)
		
		mdec->y = mdec->buf[2];
  281e82:	0f b6 f1             	movzbl %cl,%esi
  281e85:	89 72 08             	mov    %esi,0x8(%edx)
		if((mdec->buf[0] & 0x10)!=0)
  281e88:	a8 10                	test   $0x10,%al
  281e8a:	74 09                	je     281e95 <mouse_decode+0x87>
		{
			mdec->x |= 0xffffff00;
  281e8c:	81 cb 00 ff ff ff    	or     $0xffffff00,%ebx
  281e92:	89 5a 04             	mov    %ebx,0x4(%edx)
		}
		if((mdec->buf[0] & 0x20)!=0)
  281e95:	a8 20                	test   $0x20,%al
  281e97:	74 09                	je     281ea2 <mouse_decode+0x94>
		{
			mdec->y |= 0xffffff00;
  281e99:	81 c9 00 ff ff ff    	or     $0xffffff00,%ecx
  281e9f:	89 4a 08             	mov    %ecx,0x8(%edx)
		}
		mdec->y = -mdec->y;
  281ea2:	f7 5a 08             	negl   0x8(%edx)
		return 1;
  281ea5:	b8 01 00 00 00       	mov    $0x1,%eax
  281eaa:	eb 05                	jmp    281eb1 <mouse_decode+0xa3>
	}
	return -1;
  281eac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  281eb1:	5b                   	pop    %ebx
  281eb2:	5e                   	pop    %esi
  281eb3:	5d                   	pop    %ebp
  281eb4:	c3                   	ret    

00281eb5 <inthandler2c>:
#include "fifo.h"


//hanlder for int 2c (mouse interrupts)
void inthandler2c(int *esp)
{
  281eb5:	55                   	push   %ebp
  281eb6:	89 e5                	mov    %esp,%ebp
  281eb8:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic continue watch 2c int
	io_out8(PIC1_OCW2,0X64);
  281ebb:	6a 64                	push   $0x64
  281ebd:	68 a0 00 00 00       	push   $0xa0
  281ec2:	e8 2f ec ff ff       	call   280af6 <io_out8>
	io_out8(PIC0_OCW2,0x62);
  281ec7:	83 c4 08             	add    $0x8,%esp
  281eca:	6a 62                	push   $0x62
  281ecc:	6a 20                	push   $0x20
  281ece:	e8 23 ec ff ff       	call   280af6 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281ed3:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281eda:	e8 f5 eb ff ff       	call   280ad4 <io_in8>
	fifo32_put(mousefifo,data+mousedata0);
  281edf:	83 c4 08             	add    $0x8,%esp
  281ee2:	03 05 80 82 28 00    	add    0x288280,%eax
  281ee8:	50                   	push   %eax
  281ee9:	ff 35 84 82 28 00    	pushl  0x288284
  281eef:	e8 15 fe ff ff       	call   281d09 <fifo32_put>
	return;
  281ef4:	83 c4 10             	add    $0x10,%esp
}
  281ef7:	c9                   	leave  
  281ef8:	c3                   	ret    

00281ef9 <wait_KBC_sendready>:

struct FIFO32 *keyfifo;
int keydata0;

void wait_KBC_sendready(void)
{
  281ef9:	55                   	push   %ebp
  281efa:	89 e5                	mov    %esp,%ebp
  281efc:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		if((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0)
  281eff:	83 ec 0c             	sub    $0xc,%esp
  281f02:	6a 64                	push   $0x64
  281f04:	e8 cb eb ff ff       	call   280ad4 <io_in8>
  281f09:	83 c4 10             	add    $0x10,%esp
  281f0c:	a8 02                	test   $0x2,%al
  281f0e:	75 ef                	jne    281eff <wait_KBC_sendready+0x6>
			break;
	}
	return;
}
  281f10:	c9                   	leave  
  281f11:	c3                   	ret    

00281f12 <init_keyboard>:

void init_keyboard(struct FIFO32 *fifo,int data0)
{
  281f12:	55                   	push   %ebp
  281f13:	89 e5                	mov    %esp,%ebp
  281f15:	83 ec 08             	sub    $0x8,%esp
	keyfifo = fifo;
  281f18:	8b 45 08             	mov    0x8(%ebp),%eax
  281f1b:	a3 88 82 28 00       	mov    %eax,0x288288
	keydata0 = data0;
  281f20:	8b 45 0c             	mov    0xc(%ebp),%eax
  281f23:	a3 8c 82 28 00       	mov    %eax,0x28828c
	wait_KBC_sendready();
  281f28:	e8 cc ff ff ff       	call   281ef9 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_WRITE_MODE);
  281f2d:	83 ec 08             	sub    $0x8,%esp
  281f30:	6a 60                	push   $0x60
  281f32:	6a 64                	push   $0x64
  281f34:	e8 bd eb ff ff       	call   280af6 <io_out8>
	wait_KBC_sendready();
  281f39:	e8 bb ff ff ff       	call   281ef9 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,KBC_MODE);
  281f3e:	83 c4 08             	add    $0x8,%esp
  281f41:	6a 47                	push   $0x47
  281f43:	6a 60                	push   $0x60
  281f45:	e8 ac eb ff ff       	call   280af6 <io_out8>
	return;
  281f4a:	83 c4 10             	add    $0x10,%esp
}
  281f4d:	c9                   	leave  
  281f4e:	c3                   	ret    

00281f4f <inthandler21>:
#include "fifo.h"


//handler for int 21 (keyboard interrupts)
void inthandler21(int *esp)
{
  281f4f:	55                   	push   %ebp
  281f50:	89 e5                	mov    %esp,%ebp
  281f52:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic contine watch 21 int
	io_out8(PIC0_OCW2,0x61);
  281f55:	6a 61                	push   $0x61
  281f57:	6a 20                	push   $0x20
  281f59:	e8 98 eb ff ff       	call   280af6 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281f5e:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281f65:	e8 6a eb ff ff       	call   280ad4 <io_in8>
	fifo32_put(keyfifo,data + keydata0);
  281f6a:	83 c4 08             	add    $0x8,%esp
  281f6d:	03 05 8c 82 28 00    	add    0x28828c,%eax
  281f73:	50                   	push   %eax
  281f74:	ff 35 88 82 28 00    	pushl  0x288288
  281f7a:	e8 8a fd ff ff       	call   281d09 <fifo32_put>
	return;
  281f7f:	83 c4 10             	add    $0x10,%esp
}
  281f82:	c9                   	leave  
  281f83:	c3                   	ret    

00281f84 <key_char>:
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
  281f84:	55                   	push   %ebp
  281f85:	89 e5                	mov    %esp,%ebp
  281f87:	8b 55 08             	mov    0x8(%ebp),%edx
	if(key>=0 && key<0x80)
	{
		if(key_shift==0) return keytable0[key];
		else return keytable1[key];
	}
	else return 0;
  281f8a:	b8 00 00 00 00       	mov    $0x0,%eax
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
	if(key>=0 && key<0x80)
  281f8f:	83 fa 7f             	cmp    $0x7f,%edx
  281f92:	77 16                	ja     281faa <key_char+0x26>
	{
		if(key_shift==0) return keytable0[key];
  281f94:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  281f98:	75 09                	jne    281fa3 <key_char+0x1f>
  281f9a:	0f b6 82 80 57 28 00 	movzbl 0x285780(%edx),%eax
  281fa1:	eb 07                	jmp    281faa <key_char+0x26>
		else return keytable1[key];
  281fa3:	0f b6 82 00 57 28 00 	movzbl 0x285700(%edx),%eax
	}
	else return 0;
}
  281faa:	5d                   	pop    %ebp
  281fab:	c3                   	ret    

00281fac <memtest>:
#include "memory.h"
#include "io.h"

extern unsigned int _memtest_sub(unsigned int start,unsigned int end);
unsigned int memtest(unsigned int start,unsigned int end)
{
  281fac:	55                   	push   %ebp
  281fad:	89 e5                	mov    %esp,%ebp
  281faf:	83 ec 18             	sub    $0x18,%esp
	char flg486 = 0;
  281fb2:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	unsigned int eflg,cr0,i;
	
	//check cpu type
	eflg = io_load_eflags();
  281fb6:	e8 5a eb ff ff       	call   280b15 <io_load_eflags>
  281fbb:	89 45 f0             	mov    %eax,-0x10(%ebp)
	eflg != EFLAGS_AC_BIT;
	io_store_eflags(eflg);
  281fbe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281fc1:	83 ec 0c             	sub    $0xc,%esp
  281fc4:	50                   	push   %eax
  281fc5:	e8 4e eb ff ff       	call   280b18 <io_store_eflags>
  281fca:	83 c4 10             	add    $0x10,%esp
	eflg = io_load_eflags();
  281fcd:	e8 43 eb ff ff       	call   280b15 <io_load_eflags>
  281fd2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if((eflg & EFLAGS_AC_BIT) !=0)
  281fd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281fd8:	25 00 00 04 00       	and    $0x40000,%eax
  281fdd:	85 c0                	test   %eax,%eax
  281fdf:	74 04                	je     281fe5 <memtest+0x39>
		flg486 = 1;
  281fe1:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
	eflg &= ~EFLAGS_AC_BIT;
  281fe5:	81 65 f0 ff ff fb ff 	andl   $0xfffbffff,-0x10(%ebp)
	io_store_eflags(eflg);
  281fec:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281fef:	83 ec 0c             	sub    $0xc,%esp
  281ff2:	50                   	push   %eax
  281ff3:	e8 20 eb ff ff       	call   280b18 <io_store_eflags>
  281ff8:	83 c4 10             	add    $0x10,%esp
	
	//disable cpu cache
	if(flg486)
  281ffb:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  281fff:	74 1d                	je     28201e <memtest+0x72>
	{
		cr0 = load_cr0;
  282001:	c7 45 ec 3f 0b 28 00 	movl   $0x280b3f,-0x14(%ebp)
		cr0 |= CR0_CACHE_DISABLE;
  282008:	81 4d ec 00 00 00 60 	orl    $0x60000000,-0x14(%ebp)
		store_cr0(cr0);
  28200f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  282012:	83 ec 0c             	sub    $0xc,%esp
  282015:	50                   	push   %eax
  282016:	e8 28 eb ff ff       	call   280b43 <store_cr0>
  28201b:	83 c4 10             	add    $0x10,%esp
	}
	
	//i = memtest_sub(start,end);
	i = _memtest_sub(start,end);
  28201e:	83 ec 08             	sub    $0x8,%esp
  282021:	ff 75 0c             	pushl  0xc(%ebp)
  282024:	ff 75 08             	pushl  0x8(%ebp)
  282027:	e8 1f eb ff ff       	call   280b4b <_memtest_sub>
  28202c:	83 c4 10             	add    $0x10,%esp
  28202f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	
	//enable cpu cache
	if(flg486)
  282032:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  282036:	74 1e                	je     282056 <memtest+0xaa>
	{
		cr0 = load_cr0();
  282038:	e8 02 eb ff ff       	call   280b3f <load_cr0>
  28203d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cr0 &= ~CR0_CACHE_DISABLE;
  282040:	81 65 ec ff ff ff 9f 	andl   $0x9fffffff,-0x14(%ebp)
		store_cr0(cr0);
  282047:	8b 45 ec             	mov    -0x14(%ebp),%eax
  28204a:	83 ec 0c             	sub    $0xc,%esp
  28204d:	50                   	push   %eax
  28204e:	e8 f0 ea ff ff       	call   280b43 <store_cr0>
  282053:	83 c4 10             	add    $0x10,%esp
	}

	return i;
  282056:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  282059:	c9                   	leave  
  28205a:	c3                   	ret    

0028205b <memtest_sub>:

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
  28205b:	55                   	push   %ebp
  28205c:	89 e5                	mov    %esp,%ebp
  28205e:	83 ec 20             	sub    $0x20,%esp
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
  282061:	c7 45 f8 55 aa 55 aa 	movl   $0xaa55aa55,-0x8(%ebp)
  282068:	c7 45 f4 aa 55 aa 55 	movl   $0x55aa55aa,-0xc(%ebp)
	for(i=start;i<=end;i+=0x1000)
  28206f:	8b 45 08             	mov    0x8(%ebp),%eax
  282072:	89 45 fc             	mov    %eax,-0x4(%ebp)
  282075:	eb 67                	jmp    2820de <memtest_sub+0x83>
	{
		p = (unsigned int *) (i+0xffc);
  282077:	8b 45 fc             	mov    -0x4(%ebp),%eax
  28207a:	05 fc 0f 00 00       	add    $0xffc,%eax
  28207f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		old = *p;
  282082:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282085:	8b 00                	mov    (%eax),%eax
  282087:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*p = pat0;
  28208a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28208d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282090:	89 10                	mov    %edx,(%eax)
		*p ^= 0xffffffff;
  282092:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282095:	8b 00                	mov    (%eax),%eax
  282097:	f7 d0                	not    %eax
  282099:	89 c2                	mov    %eax,%edx
  28209b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28209e:	89 10                	mov    %edx,(%eax)
		if(*p != pat1)
  2820a0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820a3:	8b 00                	mov    (%eax),%eax
  2820a5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  2820a8:	74 0d                	je     2820b7 <memtest_sub+0x5c>
  2820aa:	eb 01                	jmp    2820ad <memtest_sub+0x52>
			break;
		}
		*p ^= 0xffffffff;
		if(*p != pat0)
		{
			goto not_memory;
  2820ac:	90                   	nop
		*p = pat0;
		*p ^= 0xffffffff;
		if(*p != pat1)
		{
not_memory:
			*p = old;
  2820ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820b0:	8b 55 ec             	mov    -0x14(%ebp),%edx
  2820b3:	89 10                	mov    %edx,(%eax)
			break;
  2820b5:	eb 2f                	jmp    2820e6 <memtest_sub+0x8b>
		}
		*p ^= 0xffffffff;
  2820b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820ba:	8b 00                	mov    (%eax),%eax
  2820bc:	f7 d0                	not    %eax
  2820be:	89 c2                	mov    %eax,%edx
  2820c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820c3:	89 10                	mov    %edx,(%eax)
		if(*p != pat0)
  2820c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820c8:	8b 00                	mov    (%eax),%eax
  2820ca:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  2820cd:	75 dd                	jne    2820ac <memtest_sub+0x51>
		{
			goto not_memory;
		}
		*p = old;
  2820cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820d2:	8b 55 ec             	mov    -0x14(%ebp),%edx
  2820d5:	89 10                	mov    %edx,(%eax)

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
	for(i=start;i<=end;i+=0x1000)
  2820d7:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%ebp)
  2820de:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2820e1:	3b 45 0c             	cmp    0xc(%ebp),%eax
  2820e4:	76 91                	jbe    282077 <memtest_sub+0x1c>
		{
			goto not_memory;
		}
		*p = old;
	}
	return i;
  2820e6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  2820e9:	c9                   	leave  
  2820ea:	c3                   	ret    

002820eb <memman_init>:

void memman_init(struct MEMMAN *man)
{
  2820eb:	55                   	push   %ebp
  2820ec:	89 e5                	mov    %esp,%ebp
	man->frees = 0;
  2820ee:	8b 45 08             	mov    0x8(%ebp),%eax
  2820f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	man->maxfrees = 0;
  2820f7:	8b 45 08             	mov    0x8(%ebp),%eax
  2820fa:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	man->lostsize = 0;
  282101:	8b 45 08             	mov    0x8(%ebp),%eax
  282104:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	man->losts = 0;
  28210b:	8b 45 08             	mov    0x8(%ebp),%eax
  28210e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return;
  282115:	90                   	nop
}
  282116:	5d                   	pop    %ebp
  282117:	c3                   	ret    

00282118 <memman_total>:

unsigned int memman_total(struct MEMMAN *man)
{
  282118:	55                   	push   %ebp
  282119:	89 e5                	mov    %esp,%ebp
  28211b:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,t = 0;
  28211e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;i<man->frees;i++)
  282125:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  28212c:	eb 14                	jmp    282142 <memman_total+0x2a>
	{
		t+=man->free[i].size;
  28212e:	8b 45 08             	mov    0x8(%ebp),%eax
  282131:	8b 55 fc             	mov    -0x4(%ebp),%edx
  282134:	83 c2 02             	add    $0x2,%edx
  282137:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  28213b:	01 45 f8             	add    %eax,-0x8(%ebp)
}

unsigned int memman_total(struct MEMMAN *man)
{
	unsigned int i,t = 0;
	for(i=0;i<man->frees;i++)
  28213e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  282142:	8b 45 08             	mov    0x8(%ebp),%eax
  282145:	8b 00                	mov    (%eax),%eax
  282147:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  28214a:	77 e2                	ja     28212e <memman_total+0x16>
	{
		t+=man->free[i].size;
	}
	return t;
  28214c:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  28214f:	c9                   	leave  
  282150:	c3                   	ret    

00282151 <memman_alloc>:

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
  282151:	55                   	push   %ebp
  282152:	89 e5                	mov    %esp,%ebp
  282154:	53                   	push   %ebx
  282155:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  282158:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  28215f:	e9 bd 00 00 00       	jmp    282221 <memman_alloc+0xd0>
	{
		if(man->free[i].size >= size)
  282164:	8b 45 08             	mov    0x8(%ebp),%eax
  282167:	8b 55 f8             	mov    -0x8(%ebp),%edx
  28216a:	83 c2 02             	add    $0x2,%edx
  28216d:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  282171:	3b 45 0c             	cmp    0xc(%ebp),%eax
  282174:	0f 82 a3 00 00 00    	jb     28221d <memman_alloc+0xcc>
		{
			a = man->free[i].addr;
  28217a:	8b 45 08             	mov    0x8(%ebp),%eax
  28217d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282180:	83 c2 02             	add    $0x2,%edx
  282183:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282186:	89 45 f4             	mov    %eax,-0xc(%ebp)
			man->free[i].addr+=size;
  282189:	8b 45 08             	mov    0x8(%ebp),%eax
  28218c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  28218f:	83 c2 02             	add    $0x2,%edx
  282192:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  282195:	8b 45 0c             	mov    0xc(%ebp),%eax
  282198:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28219b:	8b 45 08             	mov    0x8(%ebp),%eax
  28219e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821a1:	83 c2 02             	add    $0x2,%edx
  2821a4:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
			man->free[i].size-=size;
  2821a7:	8b 45 08             	mov    0x8(%ebp),%eax
  2821aa:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821ad:	83 c2 02             	add    $0x2,%edx
  2821b0:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  2821b4:	2b 45 0c             	sub    0xc(%ebp),%eax
  2821b7:	89 c2                	mov    %eax,%edx
  2821b9:	8b 45 08             	mov    0x8(%ebp),%eax
  2821bc:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  2821bf:	83 c1 02             	add    $0x2,%ecx
  2821c2:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
			if(man->free[i].size == 0)
  2821c6:	8b 45 08             	mov    0x8(%ebp),%eax
  2821c9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821cc:	83 c2 02             	add    $0x2,%edx
  2821cf:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  2821d3:	85 c0                	test   %eax,%eax
  2821d5:	75 41                	jne    282218 <memman_alloc+0xc7>
			{
				man->frees--;
  2821d7:	8b 45 08             	mov    0x8(%ebp),%eax
  2821da:	8b 00                	mov    (%eax),%eax
  2821dc:	8d 50 ff             	lea    -0x1(%eax),%edx
  2821df:	8b 45 08             	mov    0x8(%ebp),%eax
  2821e2:	89 10                	mov    %edx,(%eax)
				for(;i<man->frees;i++)
  2821e4:	eb 28                	jmp    28220e <memman_alloc+0xbd>
				{
					man->free[i] = man->free[i+1];
  2821e6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2821e9:	8d 50 01             	lea    0x1(%eax),%edx
  2821ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2821ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2821f2:	8d 58 02             	lea    0x2(%eax),%ebx
  2821f5:	8b 45 08             	mov    0x8(%ebp),%eax
  2821f8:	83 c2 02             	add    $0x2,%edx
  2821fb:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  2821fe:	8b 02                	mov    (%edx),%eax
  282200:	8b 52 04             	mov    0x4(%edx),%edx
  282203:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  282206:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
			man->free[i].addr+=size;
			man->free[i].size-=size;
			if(man->free[i].size == 0)
			{
				man->frees--;
				for(;i<man->frees;i++)
  28220a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  28220e:	8b 45 08             	mov    0x8(%ebp),%eax
  282211:	8b 00                	mov    (%eax),%eax
  282213:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282216:	77 ce                	ja     2821e6 <memman_alloc+0x95>
				{
					man->free[i] = man->free[i+1];
				}
			}
			return a;
  282218:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28221b:	eb 17                	jmp    282234 <memman_alloc+0xe3>
}

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  28221d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  282221:	8b 45 08             	mov    0x8(%ebp),%eax
  282224:	8b 00                	mov    (%eax),%eax
  282226:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282229:	0f 87 35 ff ff ff    	ja     282164 <memman_alloc+0x13>
				}
			}
			return a;
		}
	}
	return 0;
  28222f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282234:	83 c4 10             	add    $0x10,%esp
  282237:	5b                   	pop    %ebx
  282238:	5d                   	pop    %ebp
  282239:	c3                   	ret    

0028223a <memman_free>:

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  28223a:	55                   	push   %ebp
  28223b:	89 e5                	mov    %esp,%ebp
  28223d:	53                   	push   %ebx
  28223e:	83 ec 10             	sub    $0x10,%esp
	int i,j;
	
	for(i=0;i<man->frees;i++)
  282241:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  282248:	eb 15                	jmp    28225f <memman_free+0x25>
	{
		if(man->free[i].addr>addr) break;
  28224a:	8b 45 08             	mov    0x8(%ebp),%eax
  28224d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282250:	83 c2 02             	add    $0x2,%edx
  282253:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282256:	3b 45 0c             	cmp    0xc(%ebp),%eax
  282259:	77 10                	ja     28226b <memman_free+0x31>

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
	int i,j;
	
	for(i=0;i<man->frees;i++)
  28225b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  28225f:	8b 45 08             	mov    0x8(%ebp),%eax
  282262:	8b 00                	mov    (%eax),%eax
  282264:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282267:	7f e1                	jg     28224a <memman_free+0x10>
  282269:	eb 01                	jmp    28226c <memman_free+0x32>
	{
		if(man->free[i].addr>addr) break;
  28226b:	90                   	nop
	}

	//if prev combinable.
	if(i>0 && (man->free[i-1].addr+man->free[i-1].size == addr))
  28226c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  282270:	0f 8e f2 00 00 00    	jle    282368 <memman_free+0x12e>
  282276:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282279:	8d 50 ff             	lea    -0x1(%eax),%edx
  28227c:	8b 45 08             	mov    0x8(%ebp),%eax
  28227f:	83 c2 02             	add    $0x2,%edx
  282282:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  282285:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282288:	8d 48 ff             	lea    -0x1(%eax),%ecx
  28228b:	8b 45 08             	mov    0x8(%ebp),%eax
  28228e:	83 c1 02             	add    $0x2,%ecx
  282291:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  282295:	01 d0                	add    %edx,%eax
  282297:	3b 45 0c             	cmp    0xc(%ebp),%eax
  28229a:	0f 85 c8 00 00 00    	jne    282368 <memman_free+0x12e>
	{
		//combine with prev
		man->free[i-1].size += size;
  2822a0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2822a3:	8d 58 ff             	lea    -0x1(%eax),%ebx
  2822a6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2822a9:	8d 50 ff             	lea    -0x1(%eax),%edx
  2822ac:	8b 45 08             	mov    0x8(%ebp),%eax
  2822af:	83 c2 02             	add    $0x2,%edx
  2822b2:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  2822b6:	8b 45 10             	mov    0x10(%ebp),%eax
  2822b9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2822bc:	8b 45 08             	mov    0x8(%ebp),%eax
  2822bf:	8d 53 02             	lea    0x2(%ebx),%edx
  2822c2:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)

		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
  2822c6:	8b 45 08             	mov    0x8(%ebp),%eax
  2822c9:	8b 00                	mov    (%eax),%eax
  2822cb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  2822ce:	0f 8e 8a 00 00 00    	jle    28235e <memman_free+0x124>
  2822d4:	8b 55 0c             	mov    0xc(%ebp),%edx
  2822d7:	8b 45 10             	mov    0x10(%ebp),%eax
  2822da:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2822dd:	8b 45 08             	mov    0x8(%ebp),%eax
  2822e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2822e3:	83 c2 02             	add    $0x2,%edx
  2822e6:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  2822e9:	39 c1                	cmp    %eax,%ecx
  2822eb:	75 71                	jne    28235e <memman_free+0x124>
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
  2822ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2822f0:	8d 58 ff             	lea    -0x1(%eax),%ebx
  2822f3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2822f6:	8d 50 ff             	lea    -0x1(%eax),%edx
  2822f9:	8b 45 08             	mov    0x8(%ebp),%eax
  2822fc:	83 c2 02             	add    $0x2,%edx
  2822ff:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282303:	8b 45 08             	mov    0x8(%ebp),%eax
  282306:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  282309:	83 c1 02             	add    $0x2,%ecx
  28230c:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  282310:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282313:	8b 45 08             	mov    0x8(%ebp),%eax
  282316:	8d 53 02             	lea    0x2(%ebx),%edx
  282319:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
			for(;i<man->frees;i++)
  28231d:	eb 28                	jmp    282347 <memman_free+0x10d>
				man->free[i] = man->free[i+1];
  28231f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282322:	8d 50 01             	lea    0x1(%eax),%edx
  282325:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282328:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28232b:	8d 58 02             	lea    0x2(%eax),%ebx
  28232e:	8b 45 08             	mov    0x8(%ebp),%eax
  282331:	83 c2 02             	add    $0x2,%edx
  282334:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  282337:	8b 02                	mov    (%edx),%eax
  282339:	8b 52 04             	mov    0x4(%edx),%edx
  28233c:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  28233f:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
			for(;i<man->frees;i++)
  282343:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  282347:	8b 45 08             	mov    0x8(%ebp),%eax
  28234a:	8b 00                	mov    (%eax),%eax
  28234c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28234f:	7f ce                	jg     28231f <memman_free+0xe5>
				man->free[i] = man->free[i+1];
			man->frees--;
  282351:	8b 45 08             	mov    0x8(%ebp),%eax
  282354:	8b 00                	mov    (%eax),%eax
  282356:	8d 50 ff             	lea    -0x1(%eax),%edx
  282359:	8b 45 08             	mov    0x8(%ebp),%eax
  28235c:	89 10                	mov    %edx,(%eax)
		}
		
		return 0;
  28235e:	b8 00 00 00 00       	mov    $0x0,%eax
  282363:	e9 1f 01 00 00       	jmp    282487 <memman_free+0x24d>
	}

	//if next combinable
	if(i<man->frees && (addr + size == man->free[i].addr))
  282368:	8b 45 08             	mov    0x8(%ebp),%eax
  28236b:	8b 00                	mov    (%eax),%eax
  28236d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282370:	7e 52                	jle    2823c4 <memman_free+0x18a>
  282372:	8b 55 0c             	mov    0xc(%ebp),%edx
  282375:	8b 45 10             	mov    0x10(%ebp),%eax
  282378:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28237b:	8b 45 08             	mov    0x8(%ebp),%eax
  28237e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282381:	83 c2 02             	add    $0x2,%edx
  282384:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282387:	39 c1                	cmp    %eax,%ecx
  282389:	75 39                	jne    2823c4 <memman_free+0x18a>
	{
		man->free[i].addr = addr;
  28238b:	8b 45 08             	mov    0x8(%ebp),%eax
  28238e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282391:	8d 4a 02             	lea    0x2(%edx),%ecx
  282394:	8b 55 0c             	mov    0xc(%ebp),%edx
  282397:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size += size;
  28239a:	8b 45 08             	mov    0x8(%ebp),%eax
  28239d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2823a0:	83 c2 02             	add    $0x2,%edx
  2823a3:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  2823a7:	8b 45 10             	mov    0x10(%ebp),%eax
  2823aa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2823ad:	8b 45 08             	mov    0x8(%ebp),%eax
  2823b0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2823b3:	83 c2 02             	add    $0x2,%edx
  2823b6:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
		return 0;
  2823ba:	b8 00 00 00 00       	mov    $0x0,%eax
  2823bf:	e9 c3 00 00 00       	jmp    282487 <memman_free+0x24d>
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
  2823c4:	8b 45 08             	mov    0x8(%ebp),%eax
  2823c7:	8b 00                	mov    (%eax),%eax
  2823c9:	3d f9 0f 00 00       	cmp    $0xff9,%eax
  2823ce:	0f 8f 8a 00 00 00    	jg     28245e <memman_free+0x224>
	{
		for(j=man->frees-1;j>=i;j--)
  2823d4:	8b 45 08             	mov    0x8(%ebp),%eax
  2823d7:	8b 00                	mov    (%eax),%eax
  2823d9:	83 e8 01             	sub    $0x1,%eax
  2823dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  2823df:	eb 28                	jmp    282409 <memman_free+0x1cf>
			man->free[j+1] = man->free[j];
  2823e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2823e4:	83 c0 01             	add    $0x1,%eax
  2823e7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2823ea:	8d 58 02             	lea    0x2(%eax),%ebx
  2823ed:	8b 45 08             	mov    0x8(%ebp),%eax
  2823f0:	8b 55 f4             	mov    -0xc(%ebp),%edx
  2823f3:	83 c2 02             	add    $0x2,%edx
  2823f6:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  2823f9:	8b 02                	mov    (%edx),%eax
  2823fb:	8b 52 04             	mov    0x4(%edx),%edx
  2823fe:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  282401:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
	{
		for(j=man->frees-1;j>=i;j--)
  282405:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  282409:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28240c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28240f:	7d d0                	jge    2823e1 <memman_free+0x1a7>
			man->free[j+1] = man->free[j];
		if(man->maxfrees < man->frees) man->maxfrees = man->frees;
  282411:	8b 45 08             	mov    0x8(%ebp),%eax
  282414:	8b 50 04             	mov    0x4(%eax),%edx
  282417:	8b 45 08             	mov    0x8(%ebp),%eax
  28241a:	8b 00                	mov    (%eax),%eax
  28241c:	39 c2                	cmp    %eax,%edx
  28241e:	7d 0b                	jge    28242b <memman_free+0x1f1>
  282420:	8b 45 08             	mov    0x8(%ebp),%eax
  282423:	8b 10                	mov    (%eax),%edx
  282425:	8b 45 08             	mov    0x8(%ebp),%eax
  282428:	89 50 04             	mov    %edx,0x4(%eax)
		man->free[i].addr = addr;
  28242b:	8b 45 08             	mov    0x8(%ebp),%eax
  28242e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282431:	8d 4a 02             	lea    0x2(%edx),%ecx
  282434:	8b 55 0c             	mov    0xc(%ebp),%edx
  282437:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size = size;
  28243a:	8b 45 08             	mov    0x8(%ebp),%eax
  28243d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282440:	8d 4a 02             	lea    0x2(%edx),%ecx
  282443:	8b 55 10             	mov    0x10(%ebp),%edx
  282446:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
		man->frees++;
  28244a:	8b 45 08             	mov    0x8(%ebp),%eax
  28244d:	8b 00                	mov    (%eax),%eax
  28244f:	8d 50 01             	lea    0x1(%eax),%edx
  282452:	8b 45 08             	mov    0x8(%ebp),%eax
  282455:	89 10                	mov    %edx,(%eax)
		return 0;
  282457:	b8 00 00 00 00       	mov    $0x0,%eax
  28245c:	eb 29                	jmp    282487 <memman_free+0x24d>
	}

	//no room for new free
	man->losts++;
  28245e:	8b 45 08             	mov    0x8(%ebp),%eax
  282461:	8b 40 0c             	mov    0xc(%eax),%eax
  282464:	8d 50 01             	lea    0x1(%eax),%edx
  282467:	8b 45 08             	mov    0x8(%ebp),%eax
  28246a:	89 50 0c             	mov    %edx,0xc(%eax)
	man->lostsize += size;
  28246d:	8b 45 08             	mov    0x8(%ebp),%eax
  282470:	8b 40 08             	mov    0x8(%eax),%eax
  282473:	89 c2                	mov    %eax,%edx
  282475:	8b 45 10             	mov    0x10(%ebp),%eax
  282478:	01 d0                	add    %edx,%eax
  28247a:	89 c2                	mov    %eax,%edx
  28247c:	8b 45 08             	mov    0x8(%ebp),%eax
  28247f:	89 50 08             	mov    %edx,0x8(%eax)
	return -1;
  282482:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  282487:	83 c4 10             	add    $0x10,%esp
  28248a:	5b                   	pop    %ebx
  28248b:	5d                   	pop    %ebp
  28248c:	c3                   	ret    

0028248d <memman_alloc_4k>:

unsigned int memman_alloc_4k(struct MEMMAN *man,unsigned int size)
{
  28248d:	55                   	push   %ebp
  28248e:	89 e5                	mov    %esp,%ebp
  282490:	83 ec 10             	sub    $0x10,%esp
	unsigned int a;
	size = (size+0xfff) & 0xfffff000;
  282493:	8b 45 0c             	mov    0xc(%ebp),%eax
  282496:	05 ff 0f 00 00       	add    $0xfff,%eax
  28249b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  2824a0:	89 45 0c             	mov    %eax,0xc(%ebp)
	a = memman_alloc(man,size);
  2824a3:	ff 75 0c             	pushl  0xc(%ebp)
  2824a6:	ff 75 08             	pushl  0x8(%ebp)
  2824a9:	e8 a3 fc ff ff       	call   282151 <memman_alloc>
  2824ae:	83 c4 08             	add    $0x8,%esp
  2824b1:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return a;
  2824b4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  2824b7:	c9                   	leave  
  2824b8:	c3                   	ret    

002824b9 <memman_free_4k>:

int memman_free_4k(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  2824b9:	55                   	push   %ebp
  2824ba:	89 e5                	mov    %esp,%ebp
  2824bc:	83 ec 10             	sub    $0x10,%esp
	int i;
	size = (size+0xfff) & 0xfffff000;
  2824bf:	8b 45 10             	mov    0x10(%ebp),%eax
  2824c2:	05 ff 0f 00 00       	add    $0xfff,%eax
  2824c7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  2824cc:	89 45 10             	mov    %eax,0x10(%ebp)
	i = memman_free(man,addr,size);
  2824cf:	ff 75 10             	pushl  0x10(%ebp)
  2824d2:	ff 75 0c             	pushl  0xc(%ebp)
  2824d5:	ff 75 08             	pushl  0x8(%ebp)
  2824d8:	e8 5d fd ff ff       	call   28223a <memman_free>
  2824dd:	83 c4 0c             	add    $0xc,%esp
  2824e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return i;
  2824e3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  2824e6:	c9                   	leave  
  2824e7:	c3                   	ret    

002824e8 <shtctl_init>:
#include "map_sheet.h"

struct SHTCTL* shtctl_init(struct MEMMAN *man,unsigned char *vram,int xsize,int ysize)
{
  2824e8:	55                   	push   %ebp
  2824e9:	89 e5                	mov    %esp,%ebp
  2824eb:	57                   	push   %edi
  2824ec:	56                   	push   %esi
  2824ed:	53                   	push   %ebx
  2824ee:	83 ec 14             	sub    $0x14,%esp
  2824f1:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct SHTCTL *ctl;
	int i;
	ctl = (struct SHTCTL *)memman_alloc_4k(man,sizeof(struct SHTCTL));
  2824f4:	68 14 2c 00 00       	push   $0x2c14
  2824f9:	57                   	push   %edi
  2824fa:	e8 8e ff ff ff       	call   28248d <memman_alloc_4k>
  2824ff:	89 c6                	mov    %eax,%esi
	if(ctl == 0)
  282501:	83 c4 10             	add    $0x10,%esp
  282504:	85 c0                	test   %eax,%eax
  282506:	74 6a                	je     282572 <shtctl_init+0x8a>
  282508:	89 c3                	mov    %eax,%ebx
		goto err;
	ctl->vram = vram;
  28250a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28250d:	89 06                	mov    %eax,(%esi)
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
  28250f:	83 ec 08             	sub    $0x8,%esp
  282512:	8b 45 10             	mov    0x10(%ebp),%eax
  282515:	0f af 45 14          	imul   0x14(%ebp),%eax
  282519:	50                   	push   %eax
  28251a:	57                   	push   %edi
  28251b:	e8 6d ff ff ff       	call   28248d <memman_alloc_4k>
  282520:	89 46 04             	mov    %eax,0x4(%esi)
	if(ctl->map == 0)
  282523:	83 c4 10             	add    $0x10,%esp
  282526:	85 c0                	test   %eax,%eax
  282528:	75 19                	jne    282543 <shtctl_init+0x5b>
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
  28252a:	83 ec 04             	sub    $0x4,%esp
  28252d:	68 14 2c 00 00       	push   $0x2c14
  282532:	56                   	push   %esi
  282533:	57                   	push   %edi
  282534:	e8 80 ff ff ff       	call   2824b9 <memman_free_4k>
		ctl = 0;
		goto err;
  282539:	83 c4 10             	add    $0x10,%esp
	ctl->vram = vram;
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
	if(ctl->map == 0)
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
		ctl = 0;
  28253c:	be 00 00 00 00       	mov    $0x0,%esi
		goto err;
  282541:	eb 2f                	jmp    282572 <shtctl_init+0x8a>
	}
	ctl->xsize= xsize;
  282543:	8b 45 10             	mov    0x10(%ebp),%eax
  282546:	89 46 08             	mov    %eax,0x8(%esi)
	ctl->ysize= ysize;
  282549:	8b 45 14             	mov    0x14(%ebp),%eax
  28254c:	89 46 0c             	mov    %eax,0xc(%esi)
	ctl->top = -1;
  28254f:	c7 46 10 ff ff ff ff 	movl   $0xffffffff,0x10(%esi)
  282556:	8d 86 30 04 00 00    	lea    0x430(%esi),%eax
  28255c:	81 c3 30 2c 00 00    	add    $0x2c30,%ebx
	for(i=0;i<MAX_SHEETS;i++)
	{
		ctl->sheets0[i].flags = 0;
  282562:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ctl->sheets0[i].ctl = ctl;
  282568:	89 70 04             	mov    %esi,0x4(%eax)
  28256b:	83 c0 28             	add    $0x28,%eax
		goto err;
	}
	ctl->xsize= xsize;
	ctl->ysize= ysize;
	ctl->top = -1;
	for(i=0;i<MAX_SHEETS;i++)
  28256e:	39 d8                	cmp    %ebx,%eax
  282570:	75 f0                	jne    282562 <shtctl_init+0x7a>
		ctl->sheets0[i].flags = 0;
		ctl->sheets0[i].ctl = ctl;
	}
err:
	return ctl;
}
  282572:	89 f0                	mov    %esi,%eax
  282574:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282577:	5b                   	pop    %ebx
  282578:	5e                   	pop    %esi
  282579:	5f                   	pop    %edi
  28257a:	5d                   	pop    %ebp
  28257b:	c3                   	ret    

0028257c <sheet_alloc>:

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
  28257c:	55                   	push   %ebp
  28257d:	89 e5                	mov    %esp,%ebp
  28257f:	56                   	push   %esi
  282580:	53                   	push   %ebx
  282581:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
	{
		if(ctl->sheets0[i].flags == 0)
  282584:	83 b9 30 04 00 00 00 	cmpl   $0x0,0x430(%ecx)
  28258b:	74 12                	je     28259f <sheet_alloc+0x23>
  28258d:	8d 91 58 04 00 00    	lea    0x458(%ecx),%edx

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  282593:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(ctl->sheets0[i].flags == 0)
  282598:	83 3a 00             	cmpl   $0x0,(%edx)
  28259b:	75 3c                	jne    2825d9 <sheet_alloc+0x5d>
  28259d:	eb 05                	jmp    2825a4 <sheet_alloc+0x28>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  28259f:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(ctl->sheets0[i].flags == 0)
		{
			sht = &ctl->sheets0[i];
  2825a4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  2825ab:	8d 34 02             	lea    (%edx,%eax,1),%esi
			sht->flags = SHEET_USE;
  2825ae:	8d 1c f1             	lea    (%ecx,%esi,8),%ebx
  2825b1:	c7 83 30 04 00 00 01 	movl   $0x1,0x430(%ebx)
  2825b8:	00 00 00 
			sht->height = -1;
  2825bb:	c7 83 2c 04 00 00 ff 	movl   $0xffffffff,0x42c(%ebx)
  2825c2:	ff ff ff 
			sht->task = 0;
  2825c5:	c7 84 f1 38 04 00 00 	movl   $0x0,0x438(%ecx,%esi,8)
  2825cc:	00 00 00 00 
			return sht;
  2825d0:	8d 84 f1 14 04 00 00 	lea    0x414(%ecx,%esi,8),%eax
  2825d7:	eb 12                	jmp    2825eb <sheet_alloc+0x6f>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  2825d9:	83 c0 01             	add    $0x1,%eax
  2825dc:	83 c2 28             	add    $0x28,%edx
  2825df:	3d 00 01 00 00       	cmp    $0x100,%eax
  2825e4:	75 b2                	jne    282598 <sheet_alloc+0x1c>
			sht->height = -1;
			sht->task = 0;
			return sht;
		}
	}
	return 0;
  2825e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2825eb:	5b                   	pop    %ebx
  2825ec:	5e                   	pop    %esi
  2825ed:	5d                   	pop    %ebp
  2825ee:	c3                   	ret    

002825ef <sheet_setbuf>:

void sheet_setbuf(struct SHEET *sht,unsigned char *buf,int xsize,int ysize,int col_inv)
{
  2825ef:	55                   	push   %ebp
  2825f0:	89 e5                	mov    %esp,%ebp
  2825f2:	8b 45 08             	mov    0x8(%ebp),%eax
	sht->buf = buf;
  2825f5:	8b 55 0c             	mov    0xc(%ebp),%edx
  2825f8:	89 10                	mov    %edx,(%eax)
	sht->bxsize = xsize;
  2825fa:	8b 55 10             	mov    0x10(%ebp),%edx
  2825fd:	89 50 04             	mov    %edx,0x4(%eax)
	sht->bysize = ysize;
  282600:	8b 55 14             	mov    0x14(%ebp),%edx
  282603:	89 50 08             	mov    %edx,0x8(%eax)
	sht->col_inv = col_inv;
  282606:	8b 55 18             	mov    0x18(%ebp),%edx
  282609:	89 50 14             	mov    %edx,0x14(%eax)
	return;
}
  28260c:	5d                   	pop    %ebp
  28260d:	c3                   	ret    

0028260e <sheet_refresh_ob>:
}

//not good refresh
//obsolete
void sheet_refresh_ob(struct SHTCTL *ctl)
{
  28260e:	55                   	push   %ebp
  28260f:	89 e5                	mov    %esp,%ebp
  282611:	57                   	push   %edi
  282612:	56                   	push   %esi
  282613:	53                   	push   %ebx
  282614:	83 ec 10             	sub    $0x10,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
  282617:	8b 45 08             	mov    0x8(%ebp),%eax
  28261a:	8b 00                	mov    (%eax),%eax
  28261c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  28261f:	8b 45 08             	mov    0x8(%ebp),%eax
  282622:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  282626:	0f 88 80 00 00 00    	js     2826ac <sheet_refresh_ob+0x9e>
  28262c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	{
		sht = ctl->sheets[h];
  282633:	8b 45 08             	mov    0x8(%ebp),%eax
  282636:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  282639:	8b 54 b8 14          	mov    0x14(%eax,%edi,4),%edx
		buf = sht->buf;
  28263d:	8b 02                	mov    (%edx),%eax
  28263f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		for(by=0;by<sht->bysize;by++)
  282642:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  282646:	7e 55                	jle    28269d <sheet_refresh_ob+0x8f>
  282648:	bf 00 00 00 00       	mov    $0x0,%edi
		{
			vy = sht->vy0+by;
  28264d:	89 f8                	mov    %edi,%eax
  28264f:	03 42 10             	add    0x10(%edx),%eax
  282652:	89 45 ec             	mov    %eax,-0x14(%ebp)
			for(bx=0;bx<sht->bxsize;bx++)
  282655:	8b 4a 04             	mov    0x4(%edx),%ecx
  282658:	85 c9                	test   %ecx,%ecx
  28265a:	7e 39                	jle    282695 <sheet_refresh_ob+0x87>
  28265c:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				vx = sht->vx0+bx;
				c=buf[by*sht->bxsize+bx];
  282661:	0f af cf             	imul   %edi,%ecx
  282664:	8b 75 f0             	mov    -0x10(%ebp),%esi
  282667:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  28266a:	0f b6 1c 0b          	movzbl (%ebx,%ecx,1),%ebx
				if(c!=sht->col_inv)
  28266e:	0f b6 cb             	movzbl %bl,%ecx
  282671:	3b 4a 14             	cmp    0x14(%edx),%ecx
  282674:	74 15                	je     28268b <sheet_refresh_ob+0x7d>
					vram[vy*ctl->xsize+vx] = c;
  282676:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282679:	8b 75 ec             	mov    -0x14(%ebp),%esi
  28267c:	0f af 71 08          	imul   0x8(%ecx),%esi
  282680:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  282683:	01 c1                	add    %eax,%ecx
  282685:	03 4a 0c             	add    0xc(%edx),%ecx
  282688:	88 1c 31             	mov    %bl,(%ecx,%esi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0+by;
			for(bx=0;bx<sht->bxsize;bx++)
  28268b:	83 c0 01             	add    $0x1,%eax
  28268e:	8b 4a 04             	mov    0x4(%edx),%ecx
  282691:	39 c1                	cmp    %eax,%ecx
  282693:	7f cc                	jg     282661 <sheet_refresh_ob+0x53>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  282695:	83 c7 01             	add    $0x1,%edi
  282698:	39 7a 08             	cmp    %edi,0x8(%edx)
  28269b:	7f b0                	jg     28264d <sheet_refresh_ob+0x3f>
void sheet_refresh_ob(struct SHTCTL *ctl)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  28269d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  2826a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  2826a4:	8b 7d 08             	mov    0x8(%ebp),%edi
  2826a7:	39 47 10             	cmp    %eax,0x10(%edi)
  2826aa:	7d 87                	jge    282633 <sheet_refresh_ob+0x25>
					vram[vy*ctl->xsize+vx] = c;
			}
		}
	}
	return;
}
  2826ac:	83 c4 10             	add    $0x10,%esp
  2826af:	5b                   	pop    %ebx
  2826b0:	5e                   	pop    %esi
  2826b1:	5f                   	pop    %edi
  2826b2:	5d                   	pop    %ebp
  2826b3:	c3                   	ret    

002826b4 <sheet_refreshsub1>:



void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
  2826b4:	55                   	push   %ebp
  2826b5:	89 e5                	mov    %esp,%ebp
  2826b7:	57                   	push   %edi
  2826b8:	56                   	push   %esi
  2826b9:	53                   	push   %ebx
  2826ba:	83 ec 14             	sub    $0x14,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
  2826bd:	8b 45 08             	mov    0x8(%ebp),%eax
  2826c0:	8b 00                	mov    (%eax),%eax
  2826c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  2826c5:	8b 45 08             	mov    0x8(%ebp),%eax
  2826c8:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  2826cc:	0f 88 a7 00 00 00    	js     282779 <sheet_refreshsub1+0xc5>
  2826d2:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	{
		sht = ctl->sheets[h];
  2826d9:	8b 45 08             	mov    0x8(%ebp),%eax
  2826dc:	8b 7d e0             	mov    -0x20(%ebp),%edi
  2826df:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  2826e3:	8b 01                	mov    (%ecx),%eax
  2826e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(by=0;by<sht->bysize;by++)
  2826e8:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  2826ec:	7e 78                	jle    282766 <sheet_refreshsub1+0xb2>
  2826ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		{
			vy = sht->vy0 + by;
  2826f5:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  2826f8:	03 59 10             	add    0x10(%ecx),%ebx
			for(bx=0;bx<sht->bxsize;bx++)
  2826fb:	8b 71 04             	mov    0x4(%ecx),%esi
  2826fe:	85 f6                	test   %esi,%esi
  282700:	7e 58                	jle    28275a <sheet_refreshsub1+0xa6>
  282702:	b8 00 00 00 00       	mov    $0x0,%eax
  282707:	89 5d f0             	mov    %ebx,-0x10(%ebp)
			{
				vx = sht->vx0 + bx;
  28270a:	89 c2                	mov    %eax,%edx
  28270c:	03 51 0c             	add    0xc(%ecx),%edx
				if(vx0<=vx && vx<vx1 && vy0<=vy && vy<vy1)
  28270f:	3b 55 0c             	cmp    0xc(%ebp),%edx
  282712:	7c 3c                	jl     282750 <sheet_refreshsub1+0x9c>
  282714:	3b 55 14             	cmp    0x14(%ebp),%edx
  282717:	7d 37                	jge    282750 <sheet_refreshsub1+0x9c>
  282719:	8b 7d f0             	mov    -0x10(%ebp),%edi
  28271c:	3b 7d 10             	cmp    0x10(%ebp),%edi
  28271f:	7c 2f                	jl     282750 <sheet_refreshsub1+0x9c>
  282721:	3b 7d 18             	cmp    0x18(%ebp),%edi
  282724:	7d 2a                	jge    282750 <sheet_refreshsub1+0x9c>
				{
					c = buf[by*sht->bxsize+bx];
  282726:	0f af 75 ec          	imul   -0x14(%ebp),%esi
  28272a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  28272d:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
  282730:	0f b6 34 37          	movzbl (%edi,%esi,1),%esi
					if(c!=sht->col_inv)
  282734:	89 f3                	mov    %esi,%ebx
  282736:	0f b6 fb             	movzbl %bl,%edi
  282739:	3b 79 14             	cmp    0x14(%ecx),%edi
  28273c:	74 12                	je     282750 <sheet_refreshsub1+0x9c>
						vram[vy*ctl->xsize+vx] = c;
  28273e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282741:	8b 7d f0             	mov    -0x10(%ebp),%edi
  282744:	0f af 7b 08          	imul   0x8(%ebx),%edi
  282748:	03 55 e4             	add    -0x1c(%ebp),%edx
  28274b:	89 f3                	mov    %esi,%ebx
  28274d:	88 1c 3a             	mov    %bl,(%edx,%edi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0 + by;
			for(bx=0;bx<sht->bxsize;bx++)
  282750:	83 c0 01             	add    $0x1,%eax
  282753:	8b 71 04             	mov    0x4(%ecx),%esi
  282756:	39 c6                	cmp    %eax,%esi
  282758:	7f b0                	jg     28270a <sheet_refreshsub1+0x56>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  28275a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  28275e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  282761:	39 41 08             	cmp    %eax,0x8(%ecx)
  282764:	7f 8f                	jg     2826f5 <sheet_refreshsub1+0x41>
void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282766:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  28276a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  28276d:	8b 7d 08             	mov    0x8(%ebp),%edi
  282770:	39 47 10             	cmp    %eax,0x10(%edi)
  282773:	0f 8d 60 ff ff ff    	jge    2826d9 <sheet_refreshsub1+0x25>
						vram[vy*ctl->xsize+vx] = c;
				}
			}
		}
	}
}
  282779:	83 c4 14             	add    $0x14,%esp
  28277c:	5b                   	pop    %ebx
  28277d:	5e                   	pop    %esi
  28277e:	5f                   	pop    %edi
  28277f:	5d                   	pop    %ebp
  282780:	c3                   	ret    

00282781 <sheet_refreshsub2>:

void sheet_refreshsub2(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1,int h0)
{
  282781:	55                   	push   %ebp
  282782:	89 e5                	mov    %esp,%ebp
  282784:	57                   	push   %edi
  282785:	56                   	push   %esi
  282786:	53                   	push   %ebx
  282787:	83 ec 34             	sub    $0x34,%esp
  28278a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  28278d:	8b 55 10             	mov    0x10(%ebp),%edx
  282790:	8b 75 14             	mov    0x14(%ebp),%esi
  282793:	8b 7d 18             	mov    0x18(%ebp),%edi
  282796:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	int h,bx,by,vx,vy,bx0,by0,bx1,by1;
	unsigned char *buf,c,*vram = ctl->vram,*map = ctl->map;
  282799:	8b 45 08             	mov    0x8(%ebp),%eax
  28279c:	8b 00                	mov    (%eax),%eax
  28279e:	89 45 c0             	mov    %eax,-0x40(%ebp)
  2827a1:	8b 45 08             	mov    0x8(%ebp),%eax
  2827a4:	8b 40 04             	mov    0x4(%eax),%eax
  2827a7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  2827aa:	b8 00 00 00 00       	mov    $0x0,%eax
  2827af:	85 c9                	test   %ecx,%ecx
  2827b1:	0f 48 c8             	cmovs  %eax,%ecx
  2827b4:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  2827b7:	85 d2                	test   %edx,%edx
  2827b9:	0f 48 d0             	cmovs  %eax,%edx
  2827bc:	89 55 c8             	mov    %edx,-0x38(%ebp)
	struct SHEET *sht;

	//limit the refresh rect in the visible rect.
	if(vx0<0) vx0 = 0;
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
  2827bf:	8b 55 08             	mov    0x8(%ebp),%edx
  2827c2:	8b 52 08             	mov    0x8(%edx),%edx
  2827c5:	39 f2                	cmp    %esi,%edx
  2827c7:	0f 4e f2             	cmovle %edx,%esi
  2827ca:	89 75 d0             	mov    %esi,-0x30(%ebp)
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
  2827cd:	8b 55 08             	mov    0x8(%ebp),%edx
  2827d0:	8b 52 0c             	mov    0xc(%edx),%edx
  2827d3:	39 fa                	cmp    %edi,%edx
  2827d5:	0f 4e fa             	cmovle %edx,%edi
  2827d8:	89 7d cc             	mov    %edi,-0x34(%ebp)
  2827db:	85 db                	test   %ebx,%ebx
  2827dd:	0f 49 c3             	cmovns %ebx,%eax
  2827e0:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  2827e3:	8b 7d 08             	mov    0x8(%ebp),%edi
  2827e6:	3b 47 10             	cmp    0x10(%edi),%eax
  2827e9:	0f 8f 9c 01 00 00    	jg     28298b <sheet_refreshsub2+0x20a>
	{
		//calculate the need-refresh rect of each sheet.
		sht = ctl->sheets[h];
  2827ef:	8b 45 08             	mov    0x8(%ebp),%eax
  2827f2:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  2827f5:	8b 54 b8 14          	mov    0x14(%eax,%edi,4),%edx
		buf = sht->buf;
  2827f9:	8b 02                	mov    (%edx),%eax
  2827fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		bx0 = vx0 - sht->vx0;
  2827fe:	8b 72 0c             	mov    0xc(%edx),%esi
		by0 = vy0 - sht->vy0;
  282801:	8b 7a 10             	mov    0x10(%edx),%edi
		bx1 = vx1 - sht->vx0;
  282804:	8b 45 d0             	mov    -0x30(%ebp),%eax
  282807:	29 f0                	sub    %esi,%eax
		by1 = vy1 - sht->vy0;
  282809:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  28280c:	89 7d f0             	mov    %edi,-0x10(%ebp)
  28280f:	29 fb                	sub    %edi,%ebx
  282811:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  282814:	29 f1                	sub    %esi,%ecx
  282816:	bf 00 00 00 00       	mov    $0x0,%edi
  28281b:	0f 48 cf             	cmovs  %edi,%ecx
  28281e:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  282821:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  282824:	2b 4d f0             	sub    -0x10(%ebp),%ecx
  282827:	0f 49 f9             	cmovns %ecx,%edi

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
  28282a:	8b 4a 04             	mov    0x4(%edx),%ecx
  28282d:	39 c8                	cmp    %ecx,%eax
  28282f:	0f 4e c8             	cmovle %eax,%ecx
  282832:	89 4d f0             	mov    %ecx,-0x10(%ebp)
		if(by1>sht->bysize) by1=sht->bysize;
  282835:	8b 42 08             	mov    0x8(%edx),%eax
  282838:	39 c3                	cmp    %eax,%ebx
  28283a:	0f 4e c3             	cmovle %ebx,%eax
  28283d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if(sht->col_inv == -1)
  282840:	83 7a 14 ff          	cmpl   $0xffffffff,0x14(%edx)
  282844:	74 0d                	je     282853 <sheet_refreshsub2+0xd2>
				}
			}
		}
		else
		{
			for(by=by0;by<by1;by++)
  282846:	39 f8                	cmp    %edi,%eax
  282848:	0f 8f dd 00 00 00    	jg     28292b <sheet_refreshsub2+0x1aa>
  28284e:	e9 25 01 00 00       	jmp    282978 <sheet_refreshsub2+0x1f7>
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		if(sht->col_inv == -1)
		{
			if((sht->vx0 & 3)==0 && (bx0 & 3)==0 && (bx1 & 3)==0) 
  282853:	8b 45 d8             	mov    -0x28(%ebp),%eax
  282856:	09 f0                	or     %esi,%eax
  282858:	a8 03                	test   $0x3,%al
  28285a:	75 06                	jne    282862 <sheet_refreshsub2+0xe1>
  28285c:	f6 45 f0 03          	testb  $0x3,-0x10(%ebp)
  282860:	74 0c                	je     28286e <sheet_refreshsub2+0xed>
  282862:	89 fe                	mov    %edi,%esi
					}
				}
			}
			else
			{
				for(by=by0;by<by1;by++)
  282864:	39 7d dc             	cmp    %edi,-0x24(%ebp)
  282867:	7f 71                	jg     2828da <sheet_refreshsub2+0x159>
  282869:	e9 0a 01 00 00       	jmp    282978 <sheet_refreshsub2+0x1f7>
		if(by1>sht->bysize) by1=sht->bysize;
		if(sht->col_inv == -1)
		{
			if((sht->vx0 & 3)==0 && (bx0 & 3)==0 && (bx1 & 3)==0) 
			{
				vx = sht->vx0+bx0;
  28286e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  282871:	01 c6                	add    %eax,%esi
  282873:	89 75 e4             	mov    %esi,-0x1c(%ebp)
				bx1 = (bx1-bx0)/4;
  282876:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  282879:	29 c3                	sub    %eax,%ebx
  28287b:	89 d8                	mov    %ebx,%eax
  28287d:	8d 4b 03             	lea    0x3(%ebx),%ecx
  282880:	85 db                	test   %ebx,%ebx
  282882:	0f 48 c1             	cmovs  %ecx,%eax
  282885:	c1 f8 02             	sar    $0x2,%eax
  282888:	89 c6                	mov    %eax,%esi
				for(by=by0;by<by1;by++)
  28288a:	39 7d dc             	cmp    %edi,-0x24(%ebp)
  28288d:	0f 8e e5 00 00 00    	jle    282978 <sheet_refreshsub2+0x1f7>
				{

					vy = sht->vy0+by;
					int *p = (int *) &map[vy*ctl->xsize+vx];
  282893:	89 f9                	mov    %edi,%ecx
  282895:	03 4a 10             	add    0x10(%edx),%ecx
  282898:	8b 45 08             	mov    0x8(%ebp),%eax
  28289b:	0f af 48 08          	imul   0x8(%eax),%ecx
  28289f:	03 4d e4             	add    -0x1c(%ebp),%ecx
					int *q = (int *) &buf[by*sht->bxsize+bx0];
  2828a2:	89 fb                	mov    %edi,%ebx
  2828a4:	0f af 5a 04          	imul   0x4(%edx),%ebx
  2828a8:	03 5d d8             	add    -0x28(%ebp),%ebx

					for(bx=0;bx<bx1;bx++)
  2828ab:	85 f6                	test   %esi,%esi
  2828ad:	7e 1e                	jle    2828cd <sheet_refreshsub2+0x14c>
  2828af:	b8 00 00 00 00       	mov    $0x0,%eax
					{
						p[bx]=q[bx];
  2828b4:	03 5d ec             	add    -0x14(%ebp),%ebx
  2828b7:	03 4d e8             	add    -0x18(%ebp),%ecx
  2828ba:	89 55 f0             	mov    %edx,-0x10(%ebp)
  2828bd:	8b 14 83             	mov    (%ebx,%eax,4),%edx
  2828c0:	89 14 81             	mov    %edx,(%ecx,%eax,4)

					vy = sht->vy0+by;
					int *p = (int *) &map[vy*ctl->xsize+vx];
					int *q = (int *) &buf[by*sht->bxsize+bx0];

					for(bx=0;bx<bx1;bx++)
  2828c3:	83 c0 01             	add    $0x1,%eax
  2828c6:	39 c6                	cmp    %eax,%esi
  2828c8:	75 f3                	jne    2828bd <sheet_refreshsub2+0x13c>
  2828ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
		{
			if((sht->vx0 & 3)==0 && (bx0 & 3)==0 && (bx1 & 3)==0) 
			{
				vx = sht->vx0+bx0;
				bx1 = (bx1-bx0)/4;
				for(by=by0;by<by1;by++)
  2828cd:	83 c7 01             	add    $0x1,%edi
  2828d0:	3b 7d dc             	cmp    -0x24(%ebp),%edi
  2828d3:	75 be                	jne    282893 <sheet_refreshsub2+0x112>
  2828d5:	e9 9e 00 00 00       	jmp    282978 <sheet_refreshsub2+0x1f7>
			}
			else
			{
				for(by=by0;by<by1;by++)
				{
					vy = sht->vy0+by;
  2828da:	89 f7                	mov    %esi,%edi
  2828dc:	03 7a 10             	add    0x10(%edx),%edi
					for(bx=bx0;bx<bx1;bx++)
  2828df:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2828e2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  2828e5:	7e 3a                	jle    282921 <sheet_refreshsub2+0x1a0>
  2828e7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  2828ea:	89 7d e0             	mov    %edi,-0x20(%ebp)
					{
						vx = sht->vx0+bx;
						map[vy*ctl->xsize+vx] = buf[by*sht->bxsize+bx];
  2828ed:	89 f1                	mov    %esi,%ecx
  2828ef:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  2828f2:	0f af 4f 04          	imul   0x4(%edi),%ecx
  2828f6:	8b 55 ec             	mov    -0x14(%ebp),%edx
  2828f9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  2828fc:	0f b6 1c 0b          	movzbl (%ebx,%ecx,1),%ebx
  282900:	89 da                	mov    %ebx,%edx
  282902:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282905:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  282908:	0f af 59 08          	imul   0x8(%ecx),%ebx
  28290c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  28290f:	01 c1                	add    %eax,%ecx
  282911:	03 4f 0c             	add    0xc(%edi),%ecx
  282914:	88 14 19             	mov    %dl,(%ecx,%ebx,1)
			else
			{
				for(by=by0;by<by1;by++)
				{
					vy = sht->vy0+by;
					for(bx=bx0;bx<bx1;bx++)
  282917:	83 c0 01             	add    $0x1,%eax
  28291a:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  28291d:	75 ce                	jne    2828ed <sheet_refreshsub2+0x16c>
  28291f:	89 fa                	mov    %edi,%edx
					}
				}
			}
			else
			{
				for(by=by0;by<by1;by++)
  282921:	83 c6 01             	add    $0x1,%esi
  282924:	3b 75 dc             	cmp    -0x24(%ebp),%esi
  282927:	75 b1                	jne    2828da <sheet_refreshsub2+0x159>
  282929:	eb 4d                	jmp    282978 <sheet_refreshsub2+0x1f7>
		}
		else
		{
			for(by=by0;by<by1;by++)
			{
				vy = sht->vy0+by;
  28292b:	89 f8                	mov    %edi,%eax
  28292d:	03 42 10             	add    0x10(%edx),%eax
  282930:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				for(bx=bx0;bx<bx1;bx++)
  282933:	8b 45 d8             	mov    -0x28(%ebp),%eax
  282936:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  282939:	7e 35                	jle    282970 <sheet_refreshsub2+0x1ef>
				{
					vx = sht->vx0+bx;
					c  = buf[by*sht->bxsize+bx];
  28293b:	89 f9                	mov    %edi,%ecx
  28293d:	0f af 4a 04          	imul   0x4(%edx),%ecx
  282941:	8b 75 ec             	mov    -0x14(%ebp),%esi
  282944:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  282947:	0f b6 1c 0b          	movzbl (%ebx,%ecx,1),%ebx
					if(c!=sht->col_inv)
  28294b:	0f b6 cb             	movzbl %bl,%ecx
  28294e:	3b 4a 14             	cmp    0x14(%edx),%ecx
  282951:	74 15                	je     282968 <sheet_refreshsub2+0x1e7>
						map[vy*ctl->xsize+vx] = c;
  282953:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282956:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  282959:	0f af 71 08          	imul   0x8(%ecx),%esi
  28295d:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  282960:	01 c1                	add    %eax,%ecx
  282962:	03 4a 0c             	add    0xc(%edx),%ecx
  282965:	88 1c 31             	mov    %bl,(%ecx,%esi,1)
		else
		{
			for(by=by0;by<by1;by++)
			{
				vy = sht->vy0+by;
				for(bx=bx0;bx<bx1;bx++)
  282968:	83 c0 01             	add    $0x1,%eax
  28296b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  28296e:	75 cb                	jne    28293b <sheet_refreshsub2+0x1ba>
				}
			}
		}
		else
		{
			for(by=by0;by<by1;by++)
  282970:	83 c7 01             	add    $0x1,%edi
  282973:	3b 7d dc             	cmp    -0x24(%ebp),%edi
  282976:	75 b3                	jne    28292b <sheet_refreshsub2+0x1aa>
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
	if(vy1>ctl->ysize) vy1 = ctl->ysize;

	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  282978:	83 45 d4 01          	addl   $0x1,-0x2c(%ebp)
  28297c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  28297f:	8b 7d 08             	mov    0x8(%ebp),%edi
  282982:	39 47 10             	cmp    %eax,0x10(%edi)
  282985:	0f 8d 64 fe ff ff    	jge    2827ef <sheet_refreshsub2+0x6e>
				}
			}
		}

	}
	if(((vx1-vx0)&3)==0)
  28298b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  28298e:	2b 45 c4             	sub    -0x3c(%ebp),%eax
  282991:	a8 03                	test   $0x3,%al
  282993:	74 0d                	je     2829a2 <sheet_refreshsub2+0x221>
				d[vx] = s[vx];
		}
	}
	else
	{
		for(vy=vy0;vy<vy1;vy++)
  282995:	8b 7d c8             	mov    -0x38(%ebp),%edi
  282998:	39 7d cc             	cmp    %edi,-0x34(%ebp)
  28299b:	7f 79                	jg     282a16 <sheet_refreshsub2+0x295>
  28299d:	e9 8c 00 00 00       	jmp    282a2e <sheet_refreshsub2+0x2ad>
		}

	}
	if(((vx1-vx0)&3)==0)
	{
		vx1 = (vx1-vx0)/4;
  2829a2:	8d 50 03             	lea    0x3(%eax),%edx
  2829a5:	85 c0                	test   %eax,%eax
  2829a7:	0f 48 c2             	cmovs  %edx,%eax
  2829aa:	c1 f8 02             	sar    $0x2,%eax
  2829ad:	89 c3                	mov    %eax,%ebx
		for(vy=vy0;vy<vy1;vy++)
  2829af:	8b 45 c8             	mov    -0x38(%ebp),%eax
  2829b2:	39 45 cc             	cmp    %eax,-0x34(%ebp)
  2829b5:	7e 77                	jle    282a2e <sheet_refreshsub2+0x2ad>
  2829b7:	89 c1                	mov    %eax,%ecx
		{

			int *s = (int *) &map[vy*ctl->xsize+vx0];
  2829b9:	8b 45 08             	mov    0x8(%ebp),%eax
  2829bc:	89 ca                	mov    %ecx,%edx
  2829be:	0f af 50 08          	imul   0x8(%eax),%edx
  2829c2:	03 55 c4             	add    -0x3c(%ebp),%edx
			int *d = (int *) &vram[vy*ctl->xsize+vx0];
			for(vx=0;vx<vx1;vx++)
  2829c5:	85 db                	test   %ebx,%ebx
  2829c7:	7e 1b                	jle    2829e4 <sheet_refreshsub2+0x263>
  2829c9:	b8 00 00 00 00       	mov    $0x0,%eax
				d[vx] = s[vx];
  2829ce:	8b 7d e8             	mov    -0x18(%ebp),%edi
  2829d1:	8d 34 17             	lea    (%edi,%edx,1),%esi
  2829d4:	03 55 c0             	add    -0x40(%ebp),%edx
  2829d7:	8b 3c 86             	mov    (%esi,%eax,4),%edi
  2829da:	89 3c 82             	mov    %edi,(%edx,%eax,4)
		for(vy=vy0;vy<vy1;vy++)
		{

			int *s = (int *) &map[vy*ctl->xsize+vx0];
			int *d = (int *) &vram[vy*ctl->xsize+vx0];
			for(vx=0;vx<vx1;vx++)
  2829dd:	83 c0 01             	add    $0x1,%eax
  2829e0:	39 c3                	cmp    %eax,%ebx
  2829e2:	75 f3                	jne    2829d7 <sheet_refreshsub2+0x256>

	}
	if(((vx1-vx0)&3)==0)
	{
		vx1 = (vx1-vx0)/4;
		for(vy=vy0;vy<vy1;vy++)
  2829e4:	83 c1 01             	add    $0x1,%ecx
  2829e7:	3b 4d cc             	cmp    -0x34(%ebp),%ecx
  2829ea:	75 cd                	jne    2829b9 <sheet_refreshsub2+0x238>
  2829ec:	eb 40                	jmp    282a2e <sheet_refreshsub2+0x2ad>
  2829ee:	89 4d f0             	mov    %ecx,-0x10(%ebp)
	}
	else
	{
		for(vy=vy0;vy<vy1;vy++)
			for(vx=vx0;vx<vx1;vx++)
				vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
  2829f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2829f4:	0f af 47 08          	imul   0x8(%edi),%eax
  2829f8:	01 d0                	add    %edx,%eax
  2829fa:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  2829fe:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
		}
	}
	else
	{
		for(vy=vy0;vy<vy1;vy++)
			for(vx=vx0;vx<vx1;vx++)
  282a01:	83 c2 01             	add    $0x1,%edx
  282a04:	3b 55 d0             	cmp    -0x30(%ebp),%edx
  282a07:	75 e8                	jne    2829f1 <sheet_refreshsub2+0x270>
  282a09:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				d[vx] = s[vx];
		}
	}
	else
	{
		for(vy=vy0;vy<vy1;vy++)
  282a0c:	83 c1 01             	add    $0x1,%ecx
  282a0f:	3b 4d cc             	cmp    -0x34(%ebp),%ecx
  282a12:	74 1a                	je     282a2e <sheet_refreshsub2+0x2ad>
  282a14:	eb 0c                	jmp    282a22 <sheet_refreshsub2+0x2a1>
  282a16:	8b 5d c0             	mov    -0x40(%ebp),%ebx
  282a19:	8b 75 e8             	mov    -0x18(%ebp),%esi
  282a1c:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  282a1f:	8b 7d 08             	mov    0x8(%ebp),%edi
			for(vx=vx0;vx<vx1;vx++)
  282a22:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  282a25:	89 c2                	mov    %eax,%edx
  282a27:	39 45 d0             	cmp    %eax,-0x30(%ebp)
  282a2a:	7f c2                	jg     2829ee <sheet_refreshsub2+0x26d>
  282a2c:	eb de                	jmp    282a0c <sheet_refreshsub2+0x28b>
				vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
	}
}
  282a2e:	83 c4 34             	add    $0x34,%esp
  282a31:	5b                   	pop    %ebx
  282a32:	5e                   	pop    %esi
  282a33:	5f                   	pop    %edi
  282a34:	5d                   	pop    %ebp
  282a35:	c3                   	ret    

00282a36 <sheet_refresh>:

void sheet_refresh(struct SHEET *sht,int bx0,int by0,int bx1,int by1)
{
  282a36:	55                   	push   %ebp
  282a37:	89 e5                	mov    %esp,%ebp
  282a39:	53                   	push   %ebx
  282a3a:	8b 45 08             	mov    0x8(%ebp),%eax
	//if(sht->height >= 0)
	//{
	struct SHTCTL *ctl = sht->ctl;
	sheet_refreshsub2(ctl,sht->vx0+bx0,sht->vy0+by0,sht->vx0+bx1,sht->vy0+by1,sht->height);
  282a3d:	8b 48 10             	mov    0x10(%eax),%ecx
  282a40:	8b 50 0c             	mov    0xc(%eax),%edx
  282a43:	ff 70 18             	pushl  0x18(%eax)
  282a46:	89 cb                	mov    %ecx,%ebx
  282a48:	03 5d 18             	add    0x18(%ebp),%ebx
  282a4b:	53                   	push   %ebx
  282a4c:	89 d3                	mov    %edx,%ebx
  282a4e:	03 5d 14             	add    0x14(%ebp),%ebx
  282a51:	53                   	push   %ebx
  282a52:	03 4d 10             	add    0x10(%ebp),%ecx
  282a55:	51                   	push   %ecx
  282a56:	03 55 0c             	add    0xc(%ebp),%edx
  282a59:	52                   	push   %edx
  282a5a:	ff 70 20             	pushl  0x20(%eax)
  282a5d:	e8 1f fd ff ff       	call   282781 <sheet_refreshsub2>
	//}
	return;
  282a62:	83 c4 18             	add    $0x18,%esp
}
  282a65:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  282a68:	c9                   	leave  
  282a69:	c3                   	ret    

00282a6a <sheet_updown>:
}


//update the sheet with new height
void sheet_updown(struct SHEET *sht,int height)
{
  282a6a:	55                   	push   %ebp
  282a6b:	89 e5                	mov    %esp,%ebp
  282a6d:	57                   	push   %edi
  282a6e:	56                   	push   %esi
  282a6f:	53                   	push   %ebx
  282a70:	8b 75 08             	mov    0x8(%ebp),%esi
  282a73:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct SHTCTL *ctl = sht->ctl;
  282a76:	8b 4e 20             	mov    0x20(%esi),%ecx
	int h,old = sht->height;
  282a79:	8b 46 18             	mov    0x18(%esi),%eax
	if(height>ctl->top+1) height = ctl->top + 1;
  282a7c:	8b 79 10             	mov    0x10(%ecx),%edi
  282a7f:	8d 57 01             	lea    0x1(%edi),%edx
  282a82:	39 da                	cmp    %ebx,%edx
  282a84:	0f 4f d3             	cmovg  %ebx,%edx
  282a87:	85 d2                	test   %edx,%edx
  282a89:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  282a8e:	0f 49 da             	cmovns %edx,%ebx
	if(height<-1) height = -1;
	sht->height = height;
  282a91:	89 5e 18             	mov    %ebx,0x18(%esi)

	//push down the sheet
	if(old>height)
  282a94:	39 d8                	cmp    %ebx,%eax
  282a96:	7e 59                	jle    282af1 <sheet_updown+0x87>
	{
		//if the sheet still shows
		if(height >=0 )
  282a98:	85 db                	test   %ebx,%ebx
  282a9a:	79 09                	jns    282aa5 <sheet_updown+0x3b>
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  282a9c:	8b 59 10             	mov    0x10(%ecx),%ebx
  282a9f:	39 d8                	cmp    %ebx,%eax
  282aa1:	7c 1c                	jl     282abf <sheet_updown+0x55>
  282aa3:	eb 31                	jmp    282ad6 <sheet_updown+0x6c>
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  282aa5:	8d 50 ff             	lea    -0x1(%eax),%edx
  282aa8:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  282aac:	89 7c 91 18          	mov    %edi,0x18(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282ab0:	89 47 18             	mov    %eax,0x18(%edi)
	if(old>height)
	{
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
  282ab3:	89 d0                	mov    %edx,%eax
  282ab5:	39 d3                	cmp    %edx,%ebx
  282ab7:	75 ec                	jne    282aa5 <sheet_updown+0x3b>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;	
  282ab9:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  282abd:	eb 1d                	jmp    282adc <sheet_updown+0x72>
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  282abf:	8d 50 01             	lea    0x1(%eax),%edx
  282ac2:	8b 5c 91 14          	mov    0x14(%ecx,%edx,4),%ebx
  282ac6:	89 5c 91 10          	mov    %ebx,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282aca:	89 43 18             	mov    %eax,0x18(%ebx)
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  282acd:	8b 59 10             	mov    0x10(%ecx),%ebx
  282ad0:	89 d0                	mov    %edx,%eax
  282ad2:	39 d3                	cmp    %edx,%ebx
  282ad4:	7f e9                	jg     282abf <sheet_updown+0x55>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->top--;
  282ad6:	83 eb 01             	sub    $0x1,%ebx
  282ad9:	89 59 10             	mov    %ebx,0x10(%ecx)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  282adc:	ff 76 08             	pushl  0x8(%esi)
  282adf:	ff 76 04             	pushl  0x4(%esi)
  282ae2:	6a 00                	push   $0x0
  282ae4:	6a 00                	push   $0x0
  282ae6:	56                   	push   %esi
  282ae7:	e8 4a ff ff ff       	call   282a36 <sheet_refresh>
  282aec:	83 c4 14             	add    $0x14,%esp
  282aef:	eb 5a                	jmp    282b4b <sheet_updown+0xe1>
	}
	else if(old<height) //pop up the sheet
  282af1:	39 d8                	cmp    %ebx,%eax
  282af3:	7d 56                	jge    282b4b <sheet_updown+0xe1>
	{
		if(old >= 0) //the sheet still shows.
  282af5:	85 c0                	test   %eax,%eax
  282af7:	78 1a                	js     282b13 <sheet_updown+0xa9>
		{
			for(h=old;h<height;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  282af9:	8d 50 01             	lea    0x1(%eax),%edx
  282afc:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  282b00:	89 7c 91 10          	mov    %edi,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282b04:	89 47 18             	mov    %eax,0x18(%edi)
	}
	else if(old<height) //pop up the sheet
	{
		if(old >= 0) //the sheet still shows.
		{
			for(h=old;h<height;h++)
  282b07:	89 d0                	mov    %edx,%eax
  282b09:	39 d3                	cmp    %edx,%ebx
  282b0b:	75 ec                	jne    282af9 <sheet_updown+0x8f>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  282b0d:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  282b11:	eb 25                	jmp    282b38 <sheet_updown+0xce>
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
  282b13:	8b 41 10             	mov    0x10(%ecx),%eax
  282b16:	8d 50 01             	lea    0x1(%eax),%edx
  282b19:	89 51 10             	mov    %edx,0x10(%ecx)
			for(h=ctl->top;h>height;h--)
  282b1c:	39 d3                	cmp    %edx,%ebx
  282b1e:	7d 14                	jge    282b34 <sheet_updown+0xca>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  282b20:	8d 42 ff             	lea    -0x1(%edx),%eax
  282b23:	8b 7c 81 14          	mov    0x14(%ecx,%eax,4),%edi
  282b27:	89 7c 81 18          	mov    %edi,0x18(%ecx,%eax,4)
				ctl->sheets[h]->height = h;
  282b2b:	89 57 18             	mov    %edx,0x18(%edi)
			ctl->sheets[height] = sht;
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
			for(h=ctl->top;h>height;h--)
  282b2e:	89 c2                	mov    %eax,%edx
  282b30:	39 c3                	cmp    %eax,%ebx
  282b32:	75 ec                	jne    282b20 <sheet_updown+0xb6>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  282b34:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  282b38:	ff 76 08             	pushl  0x8(%esi)
  282b3b:	ff 76 04             	pushl  0x4(%esi)
  282b3e:	6a 00                	push   $0x0
  282b40:	6a 00                	push   $0x0
  282b42:	56                   	push   %esi
  282b43:	e8 ee fe ff ff       	call   282a36 <sheet_refresh>
  282b48:	83 c4 14             	add    $0x14,%esp
	}
	//else height not change.
	return;
}
  282b4b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282b4e:	5b                   	pop    %ebx
  282b4f:	5e                   	pop    %esi
  282b50:	5f                   	pop    %edi
  282b51:	5d                   	pop    %ebp
  282b52:	c3                   	ret    

00282b53 <sheet_slide>:
	//}
	return;
}

void sheet_slide(struct SHEET *sht,int vx0,int vy0)
{
  282b53:	55                   	push   %ebp
  282b54:	89 e5                	mov    %esp,%ebp
  282b56:	57                   	push   %edi
  282b57:	56                   	push   %esi
  282b58:	53                   	push   %ebx
  282b59:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282b5c:	8b 75 10             	mov    0x10(%ebp),%esi
	//(vx0,vy0): the sheet buf in the vram pos.
	int old_vx0 = sht->vx0,old_vy0 = sht->vy0;
  282b5f:	8b 43 0c             	mov    0xc(%ebx),%eax
  282b62:	8b 53 10             	mov    0x10(%ebx),%edx
	sht->vx0 = vx0;
  282b65:	8b 7d 0c             	mov    0xc(%ebp),%edi
  282b68:	89 7b 0c             	mov    %edi,0xc(%ebx)
	sht->vy0 = vy0;
  282b6b:	89 73 10             	mov    %esi,0x10(%ebx)
	if(sht->height >= 0)
  282b6e:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  282b72:	78 36                	js     282baa <sheet_slide+0x57>
	{
		struct SHTCTL *ctl = sht->ctl;
  282b74:	8b 7b 20             	mov    0x20(%ebx),%edi
		sheet_refreshsub2(ctl,old_vx0,old_vy0,old_vx0+sht->bxsize,old_vy0+sht->bysize, 0);
  282b77:	6a 00                	push   $0x0
  282b79:	89 d1                	mov    %edx,%ecx
  282b7b:	03 4b 08             	add    0x8(%ebx),%ecx
  282b7e:	51                   	push   %ecx
  282b7f:	89 c1                	mov    %eax,%ecx
  282b81:	03 4b 04             	add    0x4(%ebx),%ecx
  282b84:	51                   	push   %ecx
  282b85:	52                   	push   %edx
  282b86:	50                   	push   %eax
  282b87:	57                   	push   %edi
  282b88:	e8 f4 fb ff ff       	call   282781 <sheet_refreshsub2>
		sheet_refreshsub2(ctl,vx0,vy0,vx0+sht->bxsize,vy0+sht->bysize,sht->height);
  282b8d:	ff 73 18             	pushl  0x18(%ebx)
  282b90:	89 f0                	mov    %esi,%eax
  282b92:	03 43 08             	add    0x8(%ebx),%eax
  282b95:	50                   	push   %eax
  282b96:	8b 45 0c             	mov    0xc(%ebp),%eax
  282b99:	03 43 04             	add    0x4(%ebx),%eax
  282b9c:	50                   	push   %eax
  282b9d:	56                   	push   %esi
  282b9e:	ff 75 0c             	pushl  0xc(%ebp)
  282ba1:	57                   	push   %edi
  282ba2:	e8 da fb ff ff       	call   282781 <sheet_refreshsub2>
  282ba7:	83 c4 30             	add    $0x30,%esp
	}
	return;
}
  282baa:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282bad:	5b                   	pop    %ebx
  282bae:	5e                   	pop    %esi
  282baf:	5f                   	pop    %edi
  282bb0:	5d                   	pop    %ebp
  282bb1:	c3                   	ret    

00282bb2 <sheet_free>:

void sheet_free(struct SHEET *sht)
{
  282bb2:	55                   	push   %ebp
  282bb3:	89 e5                	mov    %esp,%ebp
  282bb5:	53                   	push   %ebx
  282bb6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(sht->height >= 0)
  282bb9:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  282bbd:	78 0b                	js     282bca <sheet_free+0x18>
	{
		sheet_updown(sht,-1); //hide the sheet
  282bbf:	6a ff                	push   $0xffffffff
  282bc1:	53                   	push   %ebx
  282bc2:	e8 a3 fe ff ff       	call   282a6a <sheet_updown>
  282bc7:	83 c4 08             	add    $0x8,%esp
	}
	sht->flags = 0; //set sheet unused.
  282bca:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	return;
}
  282bd1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  282bd4:	c9                   	leave  
  282bd5:	c3                   	ret    

00282bd6 <timer_alloc>:
	timerctl.next = 0xffffffff;
	return;
}

struct TIMER *timer_alloc(void)
{
  282bd6:	55                   	push   %ebp
  282bd7:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TIMER;i++)
	{
		if(timerctl.timers0[i].flags == 0)
  282bd9:	80 3d b0 82 28 00 00 	cmpb   $0x0,0x2882b0
  282be0:	74 11                	je     282bf3 <timer_alloc+0x1d>
  282be2:	ba c4 82 28 00       	mov    $0x2882c4,%edx
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282be7:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(timerctl.timers0[i].flags == 0)
  282bec:	80 3a 00             	cmpb   $0x0,(%edx)
  282bef:	75 2b                	jne    282c1c <timer_alloc+0x46>
  282bf1:	eb 05                	jmp    282bf8 <timer_alloc+0x22>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282bf3:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(timerctl.timers0[i].flags == 0)
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
  282bf8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  282bff:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282c02:	8d 0c 8d a0 82 28 00 	lea    0x2882a0(,%ecx,4),%ecx
  282c09:	c6 41 10 01          	movb   $0x1,0x10(%ecx)
			timerctl.timers0[i].flags2= 0;
  282c0d:	c6 41 11 00          	movb   $0x0,0x11(%ecx)
			return &timerctl.timers0[i];
  282c11:	01 d0                	add    %edx,%eax
  282c13:	8d 04 85 a8 82 28 00 	lea    0x2882a8(,%eax,4),%eax
  282c1a:	eb 12                	jmp    282c2e <timer_alloc+0x58>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282c1c:	83 c0 01             	add    $0x1,%eax
  282c1f:	83 c2 14             	add    $0x14,%edx
  282c22:	3d f4 01 00 00       	cmp    $0x1f4,%eax
  282c27:	75 c3                	jne    282bec <timer_alloc+0x16>
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
			timerctl.timers0[i].flags2= 0;
			return &timerctl.timers0[i];
		}
	}
	return 0;
  282c29:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282c2e:	5d                   	pop    %ebp
  282c2f:	c3                   	ret    

00282c30 <init_pit>:
#include "task.h"

struct TIMERCTL timerctl;

void init_pit(void)
{
  282c30:	55                   	push   %ebp
  282c31:	89 e5                	mov    %esp,%ebp
  282c33:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIT_CTRL,0X34);
  282c36:	6a 34                	push   $0x34
  282c38:	6a 43                	push   $0x43
  282c3a:	e8 b7 de ff ff       	call   280af6 <io_out8>
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
  282c3f:	83 c4 08             	add    $0x8,%esp
  282c42:	68 9c 00 00 00       	push   $0x9c
  282c47:	6a 40                	push   $0x40
  282c49:	e8 a8 de ff ff       	call   280af6 <io_out8>
	io_out8(PIT_CNT0,0x2e);
  282c4e:	83 c4 08             	add    $0x8,%esp
  282c51:	6a 2e                	push   $0x2e
  282c53:	6a 40                	push   $0x40
  282c55:	e8 9c de ff ff       	call   280af6 <io_out8>
  282c5a:	b8 b0 82 28 00       	mov    $0x2882b0,%eax
  282c5f:	ba c0 a9 28 00       	mov    $0x28a9c0,%edx
  282c64:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<MAX_TIMER;i++)
		timerctl.timers0[i].flags = 0;
  282c67:	c6 00 00             	movb   $0x0,(%eax)
  282c6a:	83 c0 14             	add    $0x14,%eax
{
	io_out8(PIT_CTRL,0X34);
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
	io_out8(PIT_CNT0,0x2e);
	for(int i=0;i<MAX_TIMER;i++)
  282c6d:	39 d0                	cmp    %edx,%eax
  282c6f:	75 f6                	jne    282c67 <init_pit+0x37>
		timerctl.timers0[i].flags = 0;
	struct TIMER *t = timer_alloc();
  282c71:	e8 60 ff ff ff       	call   282bd6 <timer_alloc>
	t->next = 0;
  282c76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	t->timeout = 0xffffffff;
  282c7c:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
	t->flags = TIMER_FLAGS_USING;
  282c83:	c6 40 08 02          	movb   $0x2,0x8(%eax)
	timerctl.t0 = t;
  282c87:	a3 b8 a9 28 00       	mov    %eax,0x28a9b8
	timerctl.next = 0xffffffff;
  282c8c:	c7 05 a4 82 28 00 ff 	movl   $0xffffffff,0x2882a4
  282c93:	ff ff ff 
	return;
}
  282c96:	c9                   	leave  
  282c97:	c3                   	ret    

00282c98 <timer_free>:
	}
	return 0;
}

void timer_free(struct TIMER *timer)
{
  282c98:	55                   	push   %ebp
  282c99:	89 e5                	mov    %esp,%ebp
	timer->flags = 0;
  282c9b:	8b 45 08             	mov    0x8(%ebp),%eax
  282c9e:	c6 40 08 00          	movb   $0x0,0x8(%eax)
	return;
}
  282ca2:	5d                   	pop    %ebp
  282ca3:	c3                   	ret    

00282ca4 <timer_init>:

void timer_init(struct TIMER *timer,struct FIFO32 *fifo,int data)
{
  282ca4:	55                   	push   %ebp
  282ca5:	89 e5                	mov    %esp,%ebp
  282ca7:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->fifo = fifo;
  282caa:	8b 55 0c             	mov    0xc(%ebp),%edx
  282cad:	89 50 0c             	mov    %edx,0xc(%eax)
	timer->data = data;
  282cb0:	8b 55 10             	mov    0x10(%ebp),%edx
  282cb3:	89 50 10             	mov    %edx,0x10(%eax)
	return ;
}
  282cb6:	5d                   	pop    %ebp
  282cb7:	c3                   	ret    

00282cb8 <timer_settime>:

void timer_settime(struct TIMER *timer,unsigned int timeout)
{
  282cb8:	55                   	push   %ebp
  282cb9:	89 e5                	mov    %esp,%ebp
  282cbb:	57                   	push   %edi
  282cbc:	56                   	push   %esi
  282cbd:	53                   	push   %ebx
  282cbe:	83 ec 0c             	sub    $0xc,%esp
  282cc1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	timer->timeout = timeout + timerctl.count;
  282cc4:	a1 a0 82 28 00       	mov    0x2882a0,%eax
  282cc9:	03 45 0c             	add    0xc(%ebp),%eax
  282ccc:	89 43 04             	mov    %eax,0x4(%ebx)
	timer->flags = TIMER_FLAGS_USING;
  282ccf:	c6 43 08 02          	movb   $0x2,0x8(%ebx)
	int e = io_load_eflags();
  282cd3:	e8 3d de ff ff       	call   280b15 <io_load_eflags>
  282cd8:	89 c6                	mov    %eax,%esi
	io_cli();
  282cda:	e8 e3 dd ff ff       	call   280ac2 <io_cli>
	struct TIMER *t, *s;
	if(timer->timeout<=timerctl.t0->timeout)
  282cdf:	8b 4b 04             	mov    0x4(%ebx),%ecx
  282ce2:	8b 3d b8 a9 28 00    	mov    0x28a9b8,%edi
  282ce8:	3b 4f 04             	cmp    0x4(%edi),%ecx
  282ceb:	77 1e                	ja     282d0b <timer_settime+0x53>
	{
		timer->next = timerctl.t0;
  282ced:	89 3b                	mov    %edi,(%ebx)
		timerctl.t0 = timer;
  282cef:	89 1d b8 a9 28 00    	mov    %ebx,0x28a9b8
		timerctl.next = timer->timeout;
  282cf5:	8b 43 04             	mov    0x4(%ebx),%eax
  282cf8:	a3 a4 82 28 00       	mov    %eax,0x2882a4
		io_store_eflags(e);
  282cfd:	83 ec 0c             	sub    $0xc,%esp
  282d00:	56                   	push   %esi
  282d01:	e8 12 de ff ff       	call   280b18 <io_store_eflags>
		return;
  282d06:	83 c4 10             	add    $0x10,%esp
  282d09:	eb 3e                	jmp    282d49 <timer_settime+0x91>
	}
	t = timerctl.t0->next;
  282d0b:	8b 17                	mov    (%edi),%edx
	s = timerctl.t0;
	while(t)
  282d0d:	85 d2                	test   %edx,%edx
  282d0f:	74 2c                	je     282d3d <timer_settime+0x85>
	{
		if(timer->timeout<=t->timeout)
  282d11:	3b 4a 04             	cmp    0x4(%edx),%ecx
  282d14:	77 21                	ja     282d37 <timer_settime+0x7f>
  282d16:	eb 07                	jmp    282d1f <timer_settime+0x67>
  282d18:	3b 48 04             	cmp    0x4(%eax),%ecx
  282d1b:	77 18                	ja     282d35 <timer_settime+0x7d>
  282d1d:	eb 04                	jmp    282d23 <timer_settime+0x6b>
		timerctl.t0 = timer;
		timerctl.next = timer->timeout;
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
  282d1f:	89 d0                	mov    %edx,%eax
	s = timerctl.t0;
  282d21:	89 fa                	mov    %edi,%edx
	while(t)
	{
		if(timer->timeout<=t->timeout)
		{
			timer->next = t;
  282d23:	89 03                	mov    %eax,(%ebx)
			s->next = timer;
  282d25:	89 1a                	mov    %ebx,(%edx)
			io_store_eflags(e);
  282d27:	83 ec 0c             	sub    $0xc,%esp
  282d2a:	56                   	push   %esi
  282d2b:	e8 e8 dd ff ff       	call   280b18 <io_store_eflags>
			return;
  282d30:	83 c4 10             	add    $0x10,%esp
  282d33:	eb 14                	jmp    282d49 <timer_settime+0x91>
		}
		s = t;
		t = t->next;
  282d35:	89 c2                	mov    %eax,%edx
  282d37:	8b 02                	mov    (%edx),%eax
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
	s = timerctl.t0;
	while(t)
  282d39:	85 c0                	test   %eax,%eax
  282d3b:	75 db                	jne    282d18 <timer_settime+0x60>
			return;
		}
		s = t;
		t = t->next;
	}
	io_store_eflags(e);
  282d3d:	83 ec 0c             	sub    $0xc,%esp
  282d40:	56                   	push   %esi
  282d41:	e8 d2 dd ff ff       	call   280b18 <io_store_eflags>
	return;
  282d46:	83 c4 10             	add    $0x10,%esp
}
  282d49:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282d4c:	5b                   	pop    %ebx
  282d4d:	5e                   	pop    %esi
  282d4e:	5f                   	pop    %edi
  282d4f:	5d                   	pop    %ebp
  282d50:	c3                   	ret    

00282d51 <inthandler20>:

extern struct TIMER *task_timer;

//handler for int 20 (timer interrupts)
void inthandler20(int *esp)
{
  282d51:	55                   	push   %ebp
  282d52:	89 e5                	mov    %esp,%ebp
  282d54:	56                   	push   %esi
  282d55:	53                   	push   %ebx
	char ts = 0;

	io_out8(PIC0_OCW2,0x60); //tell pic continue watch 20 int
  282d56:	83 ec 08             	sub    $0x8,%esp
  282d59:	6a 60                	push   $0x60
  282d5b:	6a 20                	push   $0x20
  282d5d:	e8 94 dd ff ff       	call   280af6 <io_out8>
	timerctl.count ++;
  282d62:	a1 a0 82 28 00       	mov    0x2882a0,%eax
  282d67:	8d 50 01             	lea    0x1(%eax),%edx
  282d6a:	89 15 a0 82 28 00    	mov    %edx,0x2882a0
	
	if(timerctl.count >= timerctl.next)
  282d70:	83 c4 10             	add    $0x10,%esp
  282d73:	3b 15 a4 82 28 00    	cmp    0x2882a4,%edx
  282d79:	72 69                	jb     282de4 <inthandler20+0x93>
	{
		struct TIMER *t = timerctl.t0;
  282d7b:	8b 1d b8 a9 28 00    	mov    0x28a9b8,%ebx
		while(t)
  282d81:	85 db                	test   %ebx,%ebx
  282d83:	75 46                	jne    282dcb <inthandler20+0x7a>
  282d85:	eb 5d                	jmp    282de4 <inthandler20+0x93>
		{
			if(t->timeout <= timerctl.count)
  282d87:	8b 43 04             	mov    0x4(%ebx),%eax
  282d8a:	3b 05 a0 82 28 00    	cmp    0x2882a0,%eax
  282d90:	77 2c                	ja     282dbe <inthandler20+0x6d>
			{
				t->flags = TIMER_FLAGS_ALLOC;
  282d92:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
				if(t!=task_timer) fifo32_put(t->fifo,t->data);
  282d96:	39 1d c0 a9 28 00    	cmp    %ebx,0x28a9c0
  282d9c:	74 13                	je     282db1 <inthandler20+0x60>
  282d9e:	83 ec 08             	sub    $0x8,%esp
  282da1:	ff 73 10             	pushl  0x10(%ebx)
  282da4:	ff 73 0c             	pushl  0xc(%ebx)
  282da7:	e8 5d ef ff ff       	call   281d09 <fifo32_put>
  282dac:	83 c4 10             	add    $0x10,%esp
  282daf:	eb 05                	jmp    282db6 <inthandler20+0x65>
				else ts=1;
  282db1:	be 01 00 00 00       	mov    $0x1,%esi
				t = t->next;
  282db6:	8b 1b                	mov    (%ebx),%ebx
	timerctl.count ++;
	
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
  282db8:	85 db                	test   %ebx,%ebx
  282dba:	75 cb                	jne    282d87 <inthandler20+0x36>
  282dbc:	eb 1b                	jmp    282dd9 <inthandler20+0x88>
				else ts=1;
				t = t->next;
			}
			else
			{
				timerctl.next = t->timeout;
  282dbe:	a3 a4 82 28 00       	mov    %eax,0x2882a4
				timerctl.t0 = t;
  282dc3:	89 1d b8 a9 28 00    	mov    %ebx,0x28a9b8
				break;
  282dc9:	eb 0e                	jmp    282dd9 <inthandler20+0x88>
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
		{
			if(t->timeout <= timerctl.count)
  282dcb:	8b 43 04             	mov    0x4(%ebx),%eax
  282dce:	be 00 00 00 00       	mov    $0x0,%esi
  282dd3:	39 c2                	cmp    %eax,%edx
  282dd5:	73 bb                	jae    282d92 <inthandler20+0x41>
  282dd7:	eb e5                	jmp    282dbe <inthandler20+0x6d>
				break;
			}
		}
	}

	if(ts!=0)task_switch();
  282dd9:	89 f0                	mov    %esi,%eax
  282ddb:	84 c0                	test   %al,%al
  282ddd:	74 05                	je     282de4 <inthandler20+0x93>
  282ddf:	e8 14 05 00 00       	call   2832f8 <task_switch>
	return;
}
  282de4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282de7:	5b                   	pop    %ebx
  282de8:	5e                   	pop    %esi
  282de9:	5d                   	pop    %ebp
  282dea:	c3                   	ret    

00282deb <timer_cancel>:

int timer_cancel(struct TIMER *timer)
{
  282deb:	55                   	push   %ebp
  282dec:	89 e5                	mov    %esp,%ebp
  282dee:	56                   	push   %esi
  282def:	53                   	push   %ebx
  282df0:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int e;
	struct TIMER *t;
	e = io_load_eflags();
  282df3:	e8 1d dd ff ff       	call   280b15 <io_load_eflags>
  282df8:	89 c6                	mov    %eax,%esi
	io_cli();
  282dfa:	e8 c3 dc ff ff       	call   280ac2 <io_cli>
	if(timer->flags == TIMER_FLAGS_USING)
  282dff:	80 7b 08 02          	cmpb   $0x2,0x8(%ebx)
  282e03:	75 3e                	jne    282e43 <timer_cancel+0x58>
	{
		if(timer == timerctl.t0)
  282e05:	8b 15 b8 a9 28 00    	mov    0x28a9b8,%edx
  282e0b:	39 d3                	cmp    %edx,%ebx
  282e0d:	75 13                	jne    282e22 <timer_cancel+0x37>
		{
			t = timer->next;
  282e0f:	8b 03                	mov    (%ebx),%eax
			timerctl.t0 = t;
  282e11:	a3 b8 a9 28 00       	mov    %eax,0x28a9b8
			timerctl.next = t->timeout;
  282e16:	8b 40 04             	mov    0x4(%eax),%eax
  282e19:	a3 a4 82 28 00       	mov    %eax,0x2882a4
  282e1e:	eb 0c                	jmp    282e2c <timer_cancel+0x41>
			{
				if(t->next == timer)
				{
					break;
				}
				t = t->next;
  282e20:	89 c2                	mov    %eax,%edx
		else
		{
			t = timerctl.t0;
			for(;;)
			{
				if(t->next == timer)
  282e22:	8b 02                	mov    (%edx),%eax
  282e24:	39 c3                	cmp    %eax,%ebx
  282e26:	75 f8                	jne    282e20 <timer_cancel+0x35>
				{
					break;
				}
				t = t->next;
			}
			t->next = timer->next;
  282e28:	8b 03                	mov    (%ebx),%eax
  282e2a:	89 02                	mov    %eax,(%edx)
		}
		timer->flags = TIMER_FLAGS_ALLOC;
  282e2c:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
		io_store_eflags(e);
  282e30:	83 ec 0c             	sub    $0xc,%esp
  282e33:	56                   	push   %esi
  282e34:	e8 df dc ff ff       	call   280b18 <io_store_eflags>
		return 1;
  282e39:	83 c4 10             	add    $0x10,%esp
  282e3c:	b8 01 00 00 00       	mov    $0x1,%eax
  282e41:	eb 11                	jmp    282e54 <timer_cancel+0x69>
	}
	io_store_eflags(e);
  282e43:	83 ec 0c             	sub    $0xc,%esp
  282e46:	56                   	push   %esi
  282e47:	e8 cc dc ff ff       	call   280b18 <io_store_eflags>
	return 0;
  282e4c:	83 c4 10             	add    $0x10,%esp
  282e4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282e54:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282e57:	5b                   	pop    %ebx
  282e58:	5e                   	pop    %esi
  282e59:	5d                   	pop    %ebp
  282e5a:	c3                   	ret    

00282e5b <timer_cancelall>:

void timer_cancelall(struct FIFO32 *fifo)
{
  282e5b:	55                   	push   %ebp
  282e5c:	89 e5                	mov    %esp,%ebp
  282e5e:	57                   	push   %edi
  282e5f:	56                   	push   %esi
  282e60:	53                   	push   %ebx
  282e61:	83 ec 1c             	sub    $0x1c,%esp
	int e,i;
	struct TIMER *t;
	e = io_load_eflags();
  282e64:	e8 ac dc ff ff       	call   280b15 <io_load_eflags>
  282e69:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	io_cli();
  282e6c:	e8 51 dc ff ff       	call   280ac2 <io_cli>
  282e71:	bb a8 82 28 00       	mov    $0x2882a8,%ebx
  282e76:	bf b8 a9 28 00       	mov    $0x28a9b8,%edi
	for(i=0;i<MAX_TIMER;i++)
	{
		t = &timerctl.timers0[i];
		if(t->flags != 0 && t->flags2 != 0 && t->fifo == fifo)
  282e7b:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  282e7f:	74 1e                	je     282e9f <timer_cancelall+0x44>
  282e81:	80 7b 09 00          	cmpb   $0x0,0x9(%ebx)
  282e85:	74 18                	je     282e9f <timer_cancelall+0x44>
  282e87:	8b 45 08             	mov    0x8(%ebp),%eax
  282e8a:	39 43 0c             	cmp    %eax,0xc(%ebx)
  282e8d:	75 10                	jne    282e9f <timer_cancelall+0x44>
		{
			timer_cancel(t);
  282e8f:	83 ec 0c             	sub    $0xc,%esp
  282e92:	53                   	push   %ebx
  282e93:	e8 53 ff ff ff       	call   282deb <timer_cancel>
	return 0;
}

void timer_free(struct TIMER *timer)
{
	timer->flags = 0;
  282e98:	c6 43 08 00          	movb   $0x0,0x8(%ebx)
  282e9c:	83 c4 10             	add    $0x10,%esp
  282e9f:	83 c3 14             	add    $0x14,%ebx
{
	int e,i;
	struct TIMER *t;
	e = io_load_eflags();
	io_cli();
	for(i=0;i<MAX_TIMER;i++)
  282ea2:	39 fb                	cmp    %edi,%ebx
  282ea4:	75 d5                	jne    282e7b <timer_cancelall+0x20>
		{
			timer_cancel(t);
			timer_free(t);
		}
	}
	io_store_eflags(e);
  282ea6:	83 ec 0c             	sub    $0xc,%esp
  282ea9:	ff 75 e4             	pushl  -0x1c(%ebp)
  282eac:	e8 67 dc ff ff       	call   280b18 <io_store_eflags>
	return;
  282eb1:	83 c4 10             	add    $0x10,%esp
}
  282eb4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282eb7:	5b                   	pop    %ebx
  282eb8:	5e                   	pop    %esi
  282eb9:	5f                   	pop    %edi
  282eba:	5d                   	pop    %ebp
  282ebb:	c3                   	ret    
  282ebc:	66 90                	xchg   %ax,%ax
  282ebe:	66 90                	xchg   %ax,%ax

00282ec0 <load_tr>:
  282ec0:	0f 00 5c 24 04       	ltr    0x4(%esp)
  282ec5:	c3                   	ret    

00282ec6 <farjmp>:
  282ec6:	ff 6c 24 04          	ljmp   *0x4(%esp)
  282eca:	c3                   	ret    

00282ecb <farcall>:
  282ecb:	ff 5c 24 04          	lcall  *0x4(%esp)
  282ecf:	c3                   	ret    

00282ed0 <asm_end_app>:
  282ed0:	8b 20                	mov    (%eax),%esp
  282ed2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  282ed9:	61                   	popa   
  282eda:	c3                   	ret    

00282edb <task_idle>:

struct TASKCTL *taskctl;
struct TIMER *task_timer;

void task_idle(void)
{
  282edb:	55                   	push   %ebp
  282edc:	89 e5                	mov    %esp,%ebp
  282ede:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		io_hlt();
  282ee1:	e8 da db ff ff       	call   280ac0 <io_hlt>
  282ee6:	eb f9                	jmp    282ee1 <task_idle+0x6>

00282ee8 <task_alloc>:
	task_run(idle,MAX_TASKLEVELS-1,1);
	return task;
}

struct TASK *task_alloc(void)
{
  282ee8:	55                   	push   %ebp
  282ee9:	89 e5                	mov    %esp,%ebp
  282eeb:	56                   	push   %esi
  282eec:	53                   	push   %ebx
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
	{
		if(taskctl->tasks0[i].flags == 0)
  282eed:	8b 0d bc a9 28 00    	mov    0x28a9bc,%ecx
  282ef3:	83 b9 fc 0f 00 00 00 	cmpl   $0x0,0xffc(%ecx)
  282efa:	74 16                	je     282f12 <task_alloc+0x2a>
  282efc:	8d 91 bc 10 00 00    	lea    0x10bc(%ecx),%edx

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282f02:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
  282f07:	83 3a 00             	cmpl   $0x0,(%edx)
  282f0a:	0f 85 b4 00 00 00    	jne    282fc4 <task_alloc+0xdc>
  282f10:	eb 05                	jmp    282f17 <task_alloc+0x2f>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282f12:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
		{
			task = &taskctl->tasks0[i];
  282f17:	8d 34 00             	lea    (%eax,%eax,1),%esi
  282f1a:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  282f1d:	c1 e3 06             	shl    $0x6,%ebx
			task->flags = 1;
  282f20:	89 da                	mov    %ebx,%edx
  282f22:	01 ca                	add    %ecx,%edx
  282f24:	c7 82 fc 0f 00 00 01 	movl   $0x1,0xffc(%edx)
  282f2b:	00 00 00 
			task->tss.eflags = 0x202;
  282f2e:	c7 82 48 10 00 00 02 	movl   $0x202,0x1048(%edx)
  282f35:	02 00 00 
			task->tss.eax = 0;
  282f38:	c7 82 4c 10 00 00 00 	movl   $0x0,0x104c(%edx)
  282f3f:	00 00 00 
			task->tss.ecx = 0;
  282f42:	c7 82 50 10 00 00 00 	movl   $0x0,0x1050(%edx)
  282f49:	00 00 00 
			task->tss.edx = 0;
  282f4c:	c7 82 54 10 00 00 00 	movl   $0x0,0x1054(%edx)
  282f53:	00 00 00 
			task->tss.ebx = 0;
  282f56:	c7 82 58 10 00 00 00 	movl   $0x0,0x1058(%edx)
  282f5d:	00 00 00 
			task->tss.ebp = 0;
  282f60:	c7 82 60 10 00 00 00 	movl   $0x0,0x1060(%edx)
  282f67:	00 00 00 
			task->tss.esi = 0;
  282f6a:	c7 82 64 10 00 00 00 	movl   $0x0,0x1064(%edx)
  282f71:	00 00 00 
			task->tss.edi = 0;
  282f74:	c7 82 68 10 00 00 00 	movl   $0x0,0x1068(%edx)
  282f7b:	00 00 00 
			task->tss.es  = 0;
  282f7e:	c7 82 6c 10 00 00 00 	movl   $0x0,0x106c(%edx)
  282f85:	00 00 00 
			task->tss.ds  = 0;
  282f88:	c7 82 78 10 00 00 00 	movl   $0x0,0x1078(%edx)
  282f8f:	00 00 00 
			task->tss.fs  = 0;
  282f92:	c7 82 7c 10 00 00 00 	movl   $0x0,0x107c(%edx)
  282f99:	00 00 00 
			task->tss.gs  = 0;
  282f9c:	c7 82 80 10 00 00 00 	movl   $0x0,0x1080(%edx)
  282fa3:	00 00 00 
			task->tss.iomap = 0x40000000;
  282fa6:	c7 82 88 10 00 00 00 	movl   $0x40000000,0x1088(%edx)
  282fad:	00 00 40 
			task->tss.ss0 = 0;
  282fb0:	c7 84 19 2c 10 00 00 	movl   $0x0,0x102c(%ecx,%ebx,1)
  282fb7:	00 00 00 00 
			return task;
  282fbb:	8d 84 19 f8 0f 00 00 	lea    0xff8(%ecx,%ebx,1),%eax
  282fc2:	eb 19                	jmp    282fdd <task_alloc+0xf5>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282fc4:	83 c0 01             	add    $0x1,%eax
  282fc7:	81 c2 c0 00 00 00    	add    $0xc0,%edx
  282fcd:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  282fd2:	0f 85 2f ff ff ff    	jne    282f07 <task_alloc+0x1f>
			task->tss.iomap = 0x40000000;
			task->tss.ss0 = 0;
			return task;
		}
	}
	return 0;
  282fd8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282fdd:	5b                   	pop    %ebx
  282fde:	5e                   	pop    %esi
  282fdf:	5d                   	pop    %ebp
  282fe0:	c3                   	ret    

00282fe1 <task_now>:
	}
	return;
}

struct TASK *task_now(void)
{
  282fe1:	55                   	push   %ebp
  282fe2:	89 e5                	mov    %esp,%ebp
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282fe4:	8b 15 bc a9 28 00    	mov    0x28a9bc,%edx
  282fea:	8b 02                	mov    (%edx),%eax
	return tl->tasks[tl->now];
  282fec:	69 c8 98 01 00 00    	imul   $0x198,%eax,%ecx
  282ff2:	6b c0 66             	imul   $0x66,%eax,%eax
  282ff5:	03 44 0a 0c          	add    0xc(%edx,%ecx,1),%eax
  282ff9:	8b 44 82 10          	mov    0x10(%edx,%eax,4),%eax
}
  282ffd:	5d                   	pop    %ebp
  282ffe:	c3                   	ret    

00282fff <task_add>:

void task_add(struct TASK *task)
{
  282fff:	55                   	push   %ebp
  283000:	89 e5                	mov    %esp,%ebp
  283002:	56                   	push   %esi
  283003:	53                   	push   %ebx
  283004:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  283007:	8b 35 bc a9 28 00    	mov    0x28a9bc,%esi
  28300d:	8b 4b 08             	mov    0x8(%ebx),%ecx
  283010:	69 c1 98 01 00 00    	imul   $0x198,%ecx,%eax
  283016:	01 f0                	add    %esi,%eax
	if(tl->running == MAX_TASKS_LV) return;
  283018:	8b 50 08             	mov    0x8(%eax),%edx
  28301b:	83 fa 64             	cmp    $0x64,%edx
  28301e:	74 14                	je     283034 <task_add+0x35>
	tl->tasks[tl->running] = task;
  283020:	6b c9 66             	imul   $0x66,%ecx,%ecx
  283023:	01 ca                	add    %ecx,%edx
  283025:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
	tl->running++;
  283029:	83 40 08 01          	addl   $0x1,0x8(%eax)
	task->flags = 2;	//alive
  28302d:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	return;
}
  283034:	5b                   	pop    %ebx
  283035:	5e                   	pop    %esi
  283036:	5d                   	pop    %ebp
  283037:	c3                   	ret    

00283038 <task_remove>:

void task_remove(struct TASK *task)
{
  283038:	55                   	push   %ebp
  283039:	89 e5                	mov    %esp,%ebp
  28303b:	57                   	push   %edi
  28303c:	56                   	push   %esi
  28303d:	53                   	push   %ebx
  28303e:	83 ec 04             	sub    $0x4,%esp
  283041:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  283044:	8b 3d bc a9 28 00    	mov    0x28a9bc,%edi
  28304a:	8b 43 08             	mov    0x8(%ebx),%eax
  28304d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  283050:	69 d0 98 01 00 00    	imul   $0x198,%eax,%edx
  283056:	01 fa                	add    %edi,%edx
	int i;
	for(i=0;i<tl->running;i++)
  283058:	8b 4a 08             	mov    0x8(%edx),%ecx
  28305b:	85 c9                	test   %ecx,%ecx
  28305d:	7e 1d                	jle    28307c <task_remove+0x44>
	{
		if(tl->tasks[i] == task)
  28305f:	3b 5a 10             	cmp    0x10(%edx),%ebx
  283062:	74 1f                	je     283083 <task_remove+0x4b>
  283064:	b8 00 00 00 00       	mov    $0x0,%eax
  283069:	eb 06                	jmp    283071 <task_remove+0x39>
  28306b:	3b 5c 82 10          	cmp    0x10(%edx,%eax,4),%ebx
  28306f:	74 17                	je     283088 <task_remove+0x50>

void task_remove(struct TASK *task)
{
	struct TASKLEVEL *tl = &taskctl->level[task->level];
	int i;
	for(i=0;i<tl->running;i++)
  283071:	83 c0 01             	add    $0x1,%eax
  283074:	39 c8                	cmp    %ecx,%eax
  283076:	75 f3                	jne    28306b <task_remove+0x33>
  283078:	89 c8                	mov    %ecx,%eax
  28307a:	eb 0c                	jmp    283088 <task_remove+0x50>
  28307c:	b8 00 00 00 00       	mov    $0x0,%eax
  283081:	eb 05                	jmp    283088 <task_remove+0x50>
  283083:	b8 00 00 00 00       	mov    $0x0,%eax
		if(tl->tasks[i] == task)
		{
			break;
		}
	}
	tl->running--;
  283088:	83 e9 01             	sub    $0x1,%ecx
  28308b:	89 4a 08             	mov    %ecx,0x8(%edx)
	if(i<tl->now)
  28308e:	8b 72 0c             	mov    0xc(%edx),%esi
  283091:	39 c6                	cmp    %eax,%esi
  283093:	7e 06                	jle    28309b <task_remove+0x63>
	{
		tl->now--;
  283095:	83 ee 01             	sub    $0x1,%esi
  283098:	89 72 0c             	mov    %esi,0xc(%edx)
	}
	if(tl->now >= tl->running)
  28309b:	3b 4a 0c             	cmp    0xc(%edx),%ecx
  28309e:	7f 07                	jg     2830a7 <task_remove+0x6f>
	{
		tl->now = 0;
  2830a0:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	}
	task->flags = 1; //sleep;
  2830a7:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	
	for(;i<tl->running;i++)
  2830ae:	39 42 08             	cmp    %eax,0x8(%edx)
  2830b1:	7e 1b                	jle    2830ce <task_remove+0x96>
  2830b3:	6b 4d f0 66          	imul   $0x66,-0x10(%ebp),%ecx
  2830b7:	8d 4c 08 05          	lea    0x5(%eax,%ecx,1),%ecx
  2830bb:	8d 0c 8f             	lea    (%edi,%ecx,4),%ecx
	{
		tl->tasks[i] = tl->tasks[i+1];
  2830be:	83 c0 01             	add    $0x1,%eax
  2830c1:	8b 19                	mov    (%ecx),%ebx
  2830c3:	89 59 fc             	mov    %ebx,-0x4(%ecx)
  2830c6:	83 c1 04             	add    $0x4,%ecx
	{
		tl->now = 0;
	}
	task->flags = 1; //sleep;
	
	for(;i<tl->running;i++)
  2830c9:	39 42 08             	cmp    %eax,0x8(%edx)
  2830cc:	7f f0                	jg     2830be <task_remove+0x86>
	{
		tl->tasks[i] = tl->tasks[i+1];
	}
	return;
}
  2830ce:	83 c4 04             	add    $0x4,%esp
  2830d1:	5b                   	pop    %ebx
  2830d2:	5e                   	pop    %esi
  2830d3:	5f                   	pop    %edi
  2830d4:	5d                   	pop    %ebp
  2830d5:	c3                   	ret    

002830d6 <task_run>:
	}
	return 0;
}

void task_run(struct TASK *task,int level,int priority)
{
  2830d6:	55                   	push   %ebp
  2830d7:	89 e5                	mov    %esp,%ebp
  2830d9:	56                   	push   %esi
  2830da:	53                   	push   %ebx
  2830db:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2830de:	8b 75 0c             	mov    0xc(%ebp),%esi
  2830e1:	8b 45 10             	mov    0x10(%ebp),%eax
	if(level < 0) level = task->level;
  2830e4:	85 f6                	test   %esi,%esi
  2830e6:	79 03                	jns    2830eb <task_run+0x15>
  2830e8:	8b 73 08             	mov    0x8(%ebx),%esi
	if(priority > 0) task->priority = priority;
  2830eb:	85 c0                	test   %eax,%eax
  2830ed:	7e 03                	jle    2830f2 <task_run+0x1c>
  2830ef:	89 43 0c             	mov    %eax,0xc(%ebx)
	if(task->flags == 2 && task->level != level)
  2830f2:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  2830f6:	75 14                	jne    28310c <task_run+0x36>
  2830f8:	3b 73 08             	cmp    0x8(%ebx),%esi
  2830fb:	74 1b                	je     283118 <task_run+0x42>
	{
		task_remove(task); //then task->flags = 1;
  2830fd:	53                   	push   %ebx
  2830fe:	e8 35 ff ff ff       	call   283038 <task_remove>
	}
	if(task->flags != 2)
  283103:	83 c4 04             	add    $0x4,%esp
  283106:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  28310a:	74 0c                	je     283118 <task_run+0x42>
	{
		task->level = level;
  28310c:	89 73 08             	mov    %esi,0x8(%ebx)
		task_add(task);
  28310f:	53                   	push   %ebx
  283110:	e8 ea fe ff ff       	call   282fff <task_add>
  283115:	83 c4 04             	add    $0x4,%esp
	}
	taskctl->lv_change = 1;
  283118:	a1 bc a9 28 00       	mov    0x28a9bc,%eax
  28311d:	c6 40 04 01          	movb   $0x1,0x4(%eax)
	return;
}
  283121:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283124:	5b                   	pop    %ebx
  283125:	5e                   	pop    %esi
  283126:	5d                   	pop    %ebp
  283127:	c3                   	ret    

00283128 <task_switchsub>:
	}
	return;
}

void task_switchsub(void)
{
  283128:	55                   	push   %ebp
  283129:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		if(taskctl->level[i].running>0) break;
  28312b:	8b 0d bc a9 28 00    	mov    0x28a9bc,%ecx
  283131:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  283135:	7f 20                	jg     283157 <task_switchsub+0x2f>
  283137:	8d 91 a0 01 00 00    	lea    0x1a0(%ecx),%edx
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  28313d:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->level[i].running>0) break;
  283142:	83 3a 00             	cmpl   $0x0,(%edx)
  283145:	7f 15                	jg     28315c <task_switchsub+0x34>
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  283147:	83 c0 01             	add    $0x1,%eax
  28314a:	81 c2 98 01 00 00    	add    $0x198,%edx
  283150:	83 f8 0a             	cmp    $0xa,%eax
  283153:	75 ed                	jne    283142 <task_switchsub+0x1a>
  283155:	eb 05                	jmp    28315c <task_switchsub+0x34>
  283157:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->level[i].running>0) break;
	}
	taskctl->now_lv = i;
  28315c:	89 01                	mov    %eax,(%ecx)
	taskctl->lv_change = 0;
  28315e:	a1 bc a9 28 00       	mov    0x28a9bc,%eax
  283163:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	return;
}
  283167:	5d                   	pop    %ebp
  283168:	c3                   	ret    

00283169 <task_init>:
		io_hlt();
	}
}

struct TASK *task_init(struct MEMMAN *memman)
{
  283169:	55                   	push   %ebp
  28316a:	89 e5                	mov    %esp,%ebp
  28316c:	57                   	push   %edi
  28316d:	56                   	push   %esi
  28316e:	53                   	push   %ebx
  28316f:	83 ec 14             	sub    $0x14,%esp
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
  283172:	68 f8 fd 02 00       	push   $0x2fdf8
  283177:	ff 75 08             	pushl  0x8(%ebp)
  28317a:	e8 0e f3 ff ff       	call   28248d <memman_alloc_4k>
  28317f:	a3 bc a9 28 00       	mov    %eax,0x28a9bc
  283184:	83 c4 10             	add    $0x10,%esp
  283187:	bf 20 00 00 00       	mov    $0x20,%edi
	for(i=0;i<MAX_TASKS;i++)
  28318c:	be 00 00 00 00       	mov    $0x0,%esi
	{
		taskctl->tasks0[i].flags = 0;
  283191:	8b 15 bc a9 28 00    	mov    0x28a9bc,%edx
  283197:	8d 1c 36             	lea    (%esi,%esi,1),%ebx
  28319a:	8d 04 33             	lea    (%ebx,%esi,1),%eax
  28319d:	c1 e0 06             	shl    $0x6,%eax
  2831a0:	01 d0                	add    %edx,%eax
  2831a2:	c7 80 fc 0f 00 00 00 	movl   $0x0,0xffc(%eax)
  2831a9:	00 00 00 
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
  2831ac:	89 b8 f8 0f 00 00    	mov    %edi,0xff8(%eax)
		taskctl->tasks0[i].tss.ldtr = (TASK_GDT0 + MAX_TASKS + i) * 8;
  2831b2:	8d 8f 40 1f 00 00    	lea    0x1f40(%edi),%ecx
  2831b8:	89 88 84 10 00 00    	mov    %ecx,0x1084(%eax)
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
  2831be:	68 89 00 00 00       	push   $0x89
  2831c3:	8d 04 33             	lea    (%ebx,%esi,1),%eax
  2831c6:	c1 e0 06             	shl    $0x6,%eax
  2831c9:	8d 84 02 24 10 00 00 	lea    0x1024(%edx,%eax,1),%eax
  2831d0:	50                   	push   %eax
  2831d1:	6a 67                	push   $0x67
  2831d3:	8d 87 00 00 27 00    	lea    0x270000(%edi),%eax
  2831d9:	50                   	push   %eax
  2831da:	e8 cf e3 ff ff       	call   2815ae <set_segmdesc>
		set_segmdesc(gdt+TASK_GDT0+MAX_TASKS+i,15,(int)taskctl->tasks0[i].ldt,AR_LDT);//2 LDTs
  2831df:	68 82 00 00 00       	push   $0x82
  2831e4:	01 f3                	add    %esi,%ebx
  2831e6:	c1 e3 06             	shl    $0x6,%ebx
  2831e9:	a1 bc a9 28 00       	mov    0x28a9bc,%eax
  2831ee:	8d 84 18 8c 10 00 00 	lea    0x108c(%eax,%ebx,1),%eax
  2831f5:	50                   	push   %eax
  2831f6:	6a 0f                	push   $0xf
  2831f8:	8d 87 40 1f 27 00    	lea    0x271f40(%edi),%eax
  2831fe:	50                   	push   %eax
  2831ff:	e8 aa e3 ff ff       	call   2815ae <set_segmdesc>
{
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
	for(i=0;i<MAX_TASKS;i++)
  283204:	83 c6 01             	add    $0x1,%esi
  283207:	83 c7 08             	add    $0x8,%edi
  28320a:	83 c4 20             	add    $0x20,%esp
  28320d:	81 fe e8 03 00 00    	cmp    $0x3e8,%esi
  283213:	0f 85 78 ff ff ff    	jne    283191 <task_init+0x28>
		set_segmdesc(gdt+TASK_GDT0+MAX_TASKS+i,15,(int)taskctl->tasks0[i].ldt,AR_LDT);//2 LDTs
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		taskctl->level[i].running = 0;
  283219:	8b 15 bc a9 28 00    	mov    0x28a9bc,%edx
  28321f:	8d 42 08             	lea    0x8(%edx),%eax
  283222:	81 c2 f8 0f 00 00    	add    $0xff8,%edx
  283228:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		taskctl->level[i].now = 0;
  28322e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  283235:	05 98 01 00 00       	add    $0x198,%eax
		taskctl->tasks0[i].tss.ldtr = (TASK_GDT0 + MAX_TASKS + i) * 8;
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
		set_segmdesc(gdt+TASK_GDT0+MAX_TASKS+i,15,(int)taskctl->tasks0[i].ldt,AR_LDT);//2 LDTs
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
  28323a:	39 d0                	cmp    %edx,%eax
  28323c:	75 ea                	jne    283228 <task_init+0xbf>
	{
		taskctl->level[i].running = 0;
		taskctl->level[i].now = 0;
	}
	task = task_alloc();
  28323e:	e8 a5 fc ff ff       	call   282ee8 <task_alloc>
  283243:	89 c6                	mov    %eax,%esi
	task->flags = 2;
  283245:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
	task->priority = 2;
  28324c:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	task->level = 0;
  283253:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	task_add(task);
  28325a:	83 ec 0c             	sub    $0xc,%esp
  28325d:	50                   	push   %eax
  28325e:	e8 9c fd ff ff       	call   282fff <task_add>
	
	task_switchsub();
  283263:	e8 c0 fe ff ff       	call   283128 <task_switchsub>
	load_tr(task->sel);
  283268:	83 c4 04             	add    $0x4,%esp
  28326b:	ff 36                	pushl  (%esi)
  28326d:	e8 4e fc ff ff       	call   282ec0 <load_tr>
	task_timer = timer_alloc();
  283272:	e8 5f f9 ff ff       	call   282bd6 <timer_alloc>
  283277:	a3 c0 a9 28 00       	mov    %eax,0x28a9c0
	timer_settime(task_timer,task->priority);
  28327c:	83 c4 08             	add    $0x8,%esp
  28327f:	ff 76 0c             	pushl  0xc(%esi)
  283282:	50                   	push   %eax
  283283:	e8 30 fa ff ff       	call   282cb8 <timer_settime>

	struct TASK *idle = task_alloc();
  283288:	e8 5b fc ff ff       	call   282ee8 <task_alloc>
  28328d:	89 c3                	mov    %eax,%ebx
	idle->tss.esp = memman_alloc(memman,64*1024)+64*1024;
  28328f:	83 c4 08             	add    $0x8,%esp
  283292:	68 00 00 01 00       	push   $0x10000
  283297:	ff 75 08             	pushl  0x8(%ebp)
  28329a:	e8 b2 ee ff ff       	call   282151 <memman_alloc>
  28329f:	05 00 00 01 00       	add    $0x10000,%eax
  2832a4:	89 43 64             	mov    %eax,0x64(%ebx)
	idle->tss.eip = (int)&task_idle-0x280000;
  2832a7:	c7 43 4c db 2e 00 00 	movl   $0x2edb,0x4c(%ebx)
	idle->tss.es = 1*8;
  2832ae:	c7 43 74 08 00 00 00 	movl   $0x8,0x74(%ebx)
	idle->tss.cs = 3*8;
  2832b5:	c7 43 78 18 00 00 00 	movl   $0x18,0x78(%ebx)
	idle->tss.ss = 1*8;
  2832bc:	c7 43 7c 08 00 00 00 	movl   $0x8,0x7c(%ebx)
	idle->tss.ds = 1*8;
  2832c3:	c7 83 80 00 00 00 08 	movl   $0x8,0x80(%ebx)
  2832ca:	00 00 00 
	idle->tss.fs = 1*8;
  2832cd:	c7 83 84 00 00 00 08 	movl   $0x8,0x84(%ebx)
  2832d4:	00 00 00 
	idle->tss.gs = 1*8;
  2832d7:	c7 83 88 00 00 00 08 	movl   $0x8,0x88(%ebx)
  2832de:	00 00 00 
	task_run(idle,MAX_TASKLEVELS-1,1);
  2832e1:	83 c4 0c             	add    $0xc,%esp
  2832e4:	6a 01                	push   $0x1
  2832e6:	6a 09                	push   $0x9
  2832e8:	53                   	push   %ebx
  2832e9:	e8 e8 fd ff ff       	call   2830d6 <task_run>
	return task;
}
  2832ee:	89 f0                	mov    %esi,%eax
  2832f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2832f3:	5b                   	pop    %ebx
  2832f4:	5e                   	pop    %esi
  2832f5:	5f                   	pop    %edi
  2832f6:	5d                   	pop    %ebp
  2832f7:	c3                   	ret    

002832f8 <task_switch>:
	taskctl->lv_change = 1;
	return;
}

void task_switch(void)
{
  2832f8:	55                   	push   %ebp
  2832f9:	89 e5                	mov    %esp,%ebp
  2832fb:	56                   	push   %esi
  2832fc:	53                   	push   %ebx
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  2832fd:	8b 0d bc a9 28 00    	mov    0x28a9bc,%ecx
  283303:	8b 31                	mov    (%ecx),%esi
  283305:	69 c6 98 01 00 00    	imul   $0x198,%esi,%eax
  28330b:	01 c8                	add    %ecx,%eax
	struct TASK *new_task,*now_task = tl->tasks[tl->now];
  28330d:	8b 50 0c             	mov    0xc(%eax),%edx
  283310:	6b de 66             	imul   $0x66,%esi,%ebx
  283313:	01 d3                	add    %edx,%ebx
  283315:	8b 5c 99 10          	mov    0x10(%ecx,%ebx,4),%ebx
	tl->now++;
  283319:	83 c2 01             	add    $0x1,%edx
  28331c:	89 50 0c             	mov    %edx,0xc(%eax)
	if(tl->now == tl->running)
  28331f:	3b 50 08             	cmp    0x8(%eax),%edx
  283322:	75 07                	jne    28332b <task_switch+0x33>
	{
		tl->now = 0;
  283324:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
	if(taskctl->lv_change!=0)
  28332b:	80 79 04 00          	cmpb   $0x0,0x4(%ecx)
  28332f:	75 0c                	jne    28333d <task_switch+0x45>
	return;
}

void task_switch(void)
{
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  283331:	69 f6 98 01 00 00    	imul   $0x198,%esi,%esi
  283337:	8d 44 31 08          	lea    0x8(%ecx,%esi,1),%eax
  28333b:	eb 14                	jmp    283351 <task_switch+0x59>
	{
		tl->now = 0;
	}
	if(taskctl->lv_change!=0)
	{
		task_switchsub();
  28333d:	e8 e6 fd ff ff       	call   283128 <task_switchsub>
		tl = &taskctl->level[taskctl->now_lv];
  283342:	a1 bc a9 28 00       	mov    0x28a9bc,%eax
  283347:	69 10 98 01 00 00    	imul   $0x198,(%eax),%edx
  28334d:	8d 44 10 08          	lea    0x8(%eax,%edx,1),%eax
	}
	new_task = tl->tasks[tl->now];
  283351:	8b 50 04             	mov    0x4(%eax),%edx
  283354:	8b 74 90 08          	mov    0x8(%eax,%edx,4),%esi
	timer_settime(task_timer,new_task->priority);
  283358:	83 ec 08             	sub    $0x8,%esp
  28335b:	ff 76 0c             	pushl  0xc(%esi)
  28335e:	ff 35 c0 a9 28 00    	pushl  0x28a9c0
  283364:	e8 4f f9 ff ff       	call   282cb8 <timer_settime>
	if(new_task != now_task)
  283369:	83 c4 10             	add    $0x10,%esp
  28336c:	39 f3                	cmp    %esi,%ebx
  28336e:	74 0f                	je     28337f <task_switch+0x87>
	{
		farjmp(0,new_task->sel);
  283370:	83 ec 08             	sub    $0x8,%esp
  283373:	ff 36                	pushl  (%esi)
  283375:	6a 00                	push   $0x0
  283377:	e8 4a fb ff ff       	call   282ec6 <farjmp>
  28337c:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  28337f:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283382:	5b                   	pop    %ebx
  283383:	5e                   	pop    %esi
  283384:	5d                   	pop    %ebp
  283385:	c3                   	ret    

00283386 <task_sleep>:

void task_sleep(struct TASK *task)
{
  283386:	55                   	push   %ebp
  283387:	89 e5                	mov    %esp,%ebp
  283389:	56                   	push   %esi
  28338a:	53                   	push   %ebx
  28338b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASK *now_task;
	if(task->flags == 2)
  28338e:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  283392:	75 2d                	jne    2833c1 <task_sleep+0x3b>
	{
		now_task = task_now();
  283394:	e8 48 fc ff ff       	call   282fe1 <task_now>
  283399:	89 c6                	mov    %eax,%esi
		task_remove(task);
  28339b:	53                   	push   %ebx
  28339c:	e8 97 fc ff ff       	call   283038 <task_remove>
		if(task == now_task)
  2833a1:	83 c4 04             	add    $0x4,%esp
  2833a4:	39 f3                	cmp    %esi,%ebx
  2833a6:	75 19                	jne    2833c1 <task_sleep+0x3b>
		{
			task_switchsub();
  2833a8:	e8 7b fd ff ff       	call   283128 <task_switchsub>
			now_task = task_now();
  2833ad:	e8 2f fc ff ff       	call   282fe1 <task_now>
			farjmp(0,now_task->sel);
  2833b2:	83 ec 08             	sub    $0x8,%esp
  2833b5:	ff 30                	pushl  (%eax)
  2833b7:	6a 00                	push   $0x0
  2833b9:	e8 08 fb ff ff       	call   282ec6 <farjmp>
  2833be:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  2833c1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2833c4:	5b                   	pop    %ebx
  2833c5:	5e                   	pop    %esi
  2833c6:	5d                   	pop    %ebp
  2833c7:	c3                   	ret    

002833c8 <console_task>:
#include "header.h"
void console_task(struct SHEET *sheet,unsigned int memtotal)
{
  2833c8:	55                   	push   %ebp
  2833c9:	89 e5                	mov    %esp,%ebp
  2833cb:	57                   	push   %edi
  2833cc:	56                   	push   %esi
  2833cd:	53                   	push   %ebx
  2833ce:	81 ec bc 00 00 00    	sub    $0xbc,%esp
  2833d4:	8b 7d 08             	mov    0x8(%ebp),%edi
	char s[50],cmdline[30];
	struct TASK *task = task_now();
  2833d7:	e8 05 fc ff ff       	call   282fe1 <task_now>
  2833dc:	89 c6                	mov    %eax,%esi
  2833de:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct CONSOLE cons;
	cons.sht = sheet;
  2833e4:	89 7d b4             	mov    %edi,-0x4c(%ebp)
	cons.cur_x = 8;
  2833e7:	c7 45 b8 08 00 00 00 	movl   $0x8,-0x48(%ebp)
	cons.cur_y = 28;
  2833ee:	c7 45 bc 1c 00 00 00 	movl   $0x1c,-0x44(%ebp)
	cons.cur_c = -1;
  2833f5:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
	//*((int *)0x0fec) = (int)&cons; //for api
	task->cons = &cons;
  2833fc:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2833ff:	89 86 a4 00 00 00    	mov    %eax,0xa4(%esi)
	task->cmdline = cmdline;
  283405:	8d 45 ca             	lea    -0x36(%ebp),%eax
  283408:	89 86 b8 00 00 00    	mov    %eax,0xb8(%esi)

	int i;
	cons.timer = timer_alloc();
  28340e:	e8 c3 f7 ff ff       	call   282bd6 <timer_alloc>
  283413:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	timer_init(cons.timer,&task->fifo,1);
  283416:	83 c6 10             	add    $0x10,%esi
  283419:	83 ec 04             	sub    $0x4,%esp
  28341c:	6a 01                	push   $0x1
  28341e:	56                   	push   %esi
  28341f:	50                   	push   %eax
  283420:	e8 7f f8 ff ff       	call   282ca4 <timer_init>
	timer_settime(cons.timer,50);
  283425:	83 c4 08             	add    $0x8,%esp
  283428:	6a 32                	push   $0x32
  28342a:	ff 75 c4             	pushl  -0x3c(%ebp)
  28342d:	e8 86 f8 ff ff       	call   282cb8 <timer_settime>
	
	int *fat = (int *)memman_alloc_4k(memman, 4*2880);
  283432:	83 c4 08             	add    $0x8,%esp
  283435:	68 00 2d 00 00       	push   $0x2d00
  28343a:	68 00 00 3c 00       	push   $0x3c0000
  28343f:	e8 49 f0 ff ff       	call   28248d <memman_alloc_4k>
  283444:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG+0x000200));
  28344a:	83 c4 08             	add    $0x8,%esp
  28344d:	68 00 02 10 00       	push   $0x100200
  283452:	50                   	push   %eax
  283453:	e8 b9 02 00 00       	call   283711 <file_readfat>
  283458:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
  28345e:	8d 55 b4             	lea    -0x4c(%ebp),%edx
  283461:	83 c4 10             	add    $0x10,%esp

	struct FILEHANDLE fhandle[8];
	for(i=0;i<8;i++)
	{
		fhandle[i].buf = 0;
  283464:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  28346a:	83 c0 0c             	add    $0xc,%eax
	
	int *fat = (int *)memman_alloc_4k(memman, 4*2880);
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG+0x000200));

	struct FILEHANDLE fhandle[8];
	for(i=0;i<8;i++)
  28346d:	39 d0                	cmp    %edx,%eax
  28346f:	75 f3                	jne    283464 <console_task+0x9c>
	{
		fhandle[i].buf = 0;
	}
	task->fhandle = fhandle;
  283471:	8d 85 54 ff ff ff    	lea    -0xac(%ebp),%eax
  283477:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
  28347d:	89 82 b0 00 00 00    	mov    %eax,0xb0(%edx)
	task->fat = fat;
  283483:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
  283489:	89 82 b4 00 00 00    	mov    %eax,0xb4(%edx)

	if(hanyu[4096] != 0xff)
  28348f:	a1 c4 a9 28 00       	mov    0x28a9c4,%eax
		task->langmode = 1;
  283494:	80 b8 00 10 00 00 ff 	cmpb   $0xff,0x1000(%eax)
  28349b:	0f 95 82 bc 00 00 00 	setne  0xbc(%edx)
	else
		task->langmode = 0;
	task->langbyte1 = 0;
  2834a2:	c6 82 bd 00 00 00 00 	movb   $0x0,0xbd(%edx)

	//draw prompt char
	cons_putchar(&cons,'>',1);
  2834a9:	83 ec 04             	sub    $0x4,%esp
  2834ac:	6a 01                	push   $0x1
  2834ae:	6a 3e                	push   $0x3e
  2834b0:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2834b3:	50                   	push   %eax
  2834b4:	e8 20 06 00 00       	call   283ad9 <cons_putchar>
  2834b9:	83 c4 10             	add    $0x10,%esp
	for(;;)
	{
		io_cli();
  2834bc:	e8 01 d6 ff ff       	call   280ac2 <io_cli>
		if(fifo32_status(&task->fifo)==0)
  2834c1:	83 ec 0c             	sub    $0xc,%esp
  2834c4:	56                   	push   %esi
  2834c5:	e8 ec e8 ff ff       	call   281db6 <fifo32_status>
  2834ca:	83 c4 10             	add    $0x10,%esp
  2834cd:	85 c0                	test   %eax,%eax
  2834cf:	75 18                	jne    2834e9 <console_task+0x121>
		{
			task_sleep(task);
  2834d1:	83 ec 0c             	sub    $0xc,%esp
  2834d4:	ff b5 44 ff ff ff    	pushl  -0xbc(%ebp)
  2834da:	e8 a7 fe ff ff       	call   283386 <task_sleep>
			io_sti();
  2834df:	e8 e0 d5 ff ff       	call   280ac4 <io_sti>
  2834e4:	83 c4 10             	add    $0x10,%esp
  2834e7:	eb d3                	jmp    2834bc <console_task+0xf4>
		}
		else
		{
			i=fifo32_get(&task->fifo);
  2834e9:	83 ec 0c             	sub    $0xc,%esp
  2834ec:	56                   	push   %esi
  2834ed:	e8 89 e8 ff ff       	call   281d7b <fifo32_get>
  2834f2:	89 c3                	mov    %eax,%ebx
			io_sti();
  2834f4:	e8 cb d5 ff ff       	call   280ac4 <io_sti>
			if(i<=1) //for cursor
  2834f9:	83 c4 10             	add    $0x10,%esp
  2834fc:	83 fb 01             	cmp    $0x1,%ebx
  2834ff:	7f 57                	jg     283558 <console_task+0x190>
			{
				if(i!=0)
  283501:	85 db                	test   %ebx,%ebx
  283503:	74 20                	je     283525 <console_task+0x15d>
				{
					timer_init(cons.timer,&task->fifo,0);
  283505:	83 ec 04             	sub    $0x4,%esp
  283508:	6a 00                	push   $0x0
  28350a:	56                   	push   %esi
  28350b:	ff 75 c4             	pushl  -0x3c(%ebp)
  28350e:	e8 91 f7 ff ff       	call   282ca4 <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_FFFFFF;
  283513:	83 c4 10             	add    $0x10,%esp
  283516:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  28351a:	78 27                	js     283543 <console_task+0x17b>
  28351c:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
  283523:	eb 1e                	jmp    283543 <console_task+0x17b>
				}
				else
				{
					timer_init(cons.timer,&task->fifo,1);
  283525:	83 ec 04             	sub    $0x4,%esp
  283528:	6a 01                	push   $0x1
  28352a:	56                   	push   %esi
  28352b:	ff 75 c4             	pushl  -0x3c(%ebp)
  28352e:	e8 71 f7 ff ff       	call   282ca4 <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_000000;
  283533:	83 c4 10             	add    $0x10,%esp
  283536:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  28353a:	78 07                	js     283543 <console_task+0x17b>
  28353c:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
				}
				timer_settime(cons.timer,50);
  283543:	83 ec 08             	sub    $0x8,%esp
  283546:	6a 32                	push   $0x32
  283548:	ff 75 c4             	pushl  -0x3c(%ebp)
  28354b:	e8 68 f7 ff ff       	call   282cb8 <timer_settime>
  283550:	83 c4 10             	add    $0x10,%esp
  283553:	e9 65 01 00 00       	jmp    2836bd <console_task+0x2f5>
							
			}
			else if(i == 2) //get show_cursor msg
  283558:	83 fb 02             	cmp    $0x2,%ebx
  28355b:	75 19                	jne    283576 <console_task+0x1ae>
			{
				cons.cur_c = COL8_FFFFFF;
  28355d:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
					}
				}
			}
			if(sheet != 0)
			{
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  283564:	b8 07 00 00 00       	mov    $0x7,%eax
						cmdline[cons.cur_x/8-2] = i-256;
						cons_putchar(&cons,i-256,1);
					}
				}
			}
			if(sheet != 0)
  283569:	85 ff                	test   %edi,%edi
  28356b:	0f 85 5b 01 00 00    	jne    2836cc <console_task+0x304>
  283571:	e9 46 ff ff ff       	jmp    2834bc <console_task+0xf4>
			}
			else if(i == 2) //get show_cursor msg
			{
				cons.cur_c = COL8_FFFFFF;
			}
			else if(i == 3) //get hide_cursor msg
  283576:	83 fb 03             	cmp    $0x3,%ebx
  283579:	75 36                	jne    2835b1 <console_task+0x1e9>
			{
				cons.cur_c = -1;
  28357b:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
				if(sheet != 0)boxfill8(sheet->buf,sheet->bxsize,COL8_000000,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  283582:	85 ff                	test   %edi,%edi
  283584:	0f 84 32 ff ff ff    	je     2834bc <console_task+0xf4>
  28358a:	8b 55 bc             	mov    -0x44(%ebp),%edx
  28358d:	8b 45 b8             	mov    -0x48(%ebp),%eax
  283590:	83 ec 04             	sub    $0x4,%esp
  283593:	8d 4a 0f             	lea    0xf(%edx),%ecx
  283596:	51                   	push   %ecx
  283597:	8d 48 07             	lea    0x7(%eax),%ecx
  28359a:	51                   	push   %ecx
  28359b:	52                   	push   %edx
  28359c:	50                   	push   %eax
  28359d:	6a 00                	push   $0x0
  28359f:	ff 77 04             	pushl  0x4(%edi)
  2835a2:	ff 37                	pushl  (%edi)
  2835a4:	e8 08 d7 ff ff       	call   280cb1 <boxfill8>
  2835a9:	83 c4 20             	add    $0x20,%esp
  2835ac:	e9 14 01 00 00       	jmp    2836c5 <console_task+0x2fd>
			}
			else if(i == 4) //close button clicked
  2835b1:	83 fb 04             	cmp    $0x4,%ebx
  2835b4:	75 1a                	jne    2835d0 <console_task+0x208>
			{
				cmd_exit(&cons,fat);
  2835b6:	83 ec 08             	sub    $0x8,%esp
  2835b9:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
  2835bf:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2835c2:	50                   	push   %eax
  2835c3:	e8 5a 08 00 00       	call   283e22 <cmd_exit>
  2835c8:	83 c4 10             	add    $0x10,%esp
  2835cb:	e9 ed 00 00 00       	jmp    2836bd <console_task+0x2f5>
			}
			else if(256<=i && i<=511)
  2835d0:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
  2835d6:	3d ff 00 00 00       	cmp    $0xff,%eax
  2835db:	0f 87 dc 00 00 00    	ja     2836bd <console_task+0x2f5>
			{
				if(i == 8+256) //back key
  2835e1:	81 fb 08 01 00 00    	cmp    $0x108,%ebx
  2835e7:	75 26                	jne    28360f <console_task+0x247>
				{
					if(cons.cur_x > 16)
  2835e9:	83 7d b8 10          	cmpl   $0x10,-0x48(%ebp)
  2835ed:	0f 8e ca 00 00 00    	jle    2836bd <console_task+0x2f5>
					{
						cons_putchar(&cons,' ',0);
  2835f3:	83 ec 04             	sub    $0x4,%esp
  2835f6:	6a 00                	push   $0x0
  2835f8:	6a 20                	push   $0x20
  2835fa:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2835fd:	50                   	push   %eax
  2835fe:	e8 d6 04 00 00       	call   283ad9 <cons_putchar>
						cons.cur_x -= 8;
  283603:	83 6d b8 08          	subl   $0x8,-0x48(%ebp)
  283607:	83 c4 10             	add    $0x10,%esp
  28360a:	e9 ae 00 00 00       	jmp    2836bd <console_task+0x2f5>
					}
				}
				else if(i == 10+256) //return key
  28360f:	81 fb 0a 01 00 00    	cmp    $0x10a,%ebx
  283615:	75 75                	jne    28368c <console_task+0x2c4>
				{
					cons_putchar(&cons,' ',0);
  283617:	83 ec 04             	sub    $0x4,%esp
  28361a:	6a 00                	push   $0x0
  28361c:	6a 20                	push   $0x20
  28361e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  283621:	50                   	push   %eax
  283622:	e8 b2 04 00 00       	call   283ad9 <cons_putchar>
					cmdline[cons.cur_x/8-2] = 0;
  283627:	8b 55 b8             	mov    -0x48(%ebp),%edx
  28362a:	8d 42 07             	lea    0x7(%edx),%eax
  28362d:	85 d2                	test   %edx,%edx
  28362f:	0f 49 c2             	cmovns %edx,%eax
  283632:	c1 f8 03             	sar    $0x3,%eax
  283635:	c6 44 05 c8 00       	movb   $0x0,-0x38(%ebp,%eax,1)
					cons_newline(&cons);
  28363a:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  28363d:	89 04 24             	mov    %eax,(%esp)
  283640:	e8 9b 03 00 00       	call   2839e0 <cons_newline>
					cons_runcmd(cmdline,&cons,fat,memtotal);
  283645:	ff 75 0c             	pushl  0xc(%ebp)
  283648:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
  28364e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  283651:	50                   	push   %eax
  283652:	8d 45 ca             	lea    -0x36(%ebp),%eax
  283655:	50                   	push   %eax
  283656:	e8 b0 0e 00 00       	call   28450b <cons_runcmd>
					if(sheet == 0)
  28365b:	83 c4 20             	add    $0x20,%esp
  28365e:	85 ff                	test   %edi,%edi
  283660:	75 15                	jne    283677 <console_task+0x2af>
						cmd_exit(&cons,fat);
  283662:	83 ec 08             	sub    $0x8,%esp
  283665:	ff b5 40 ff ff ff    	pushl  -0xc0(%ebp)
  28366b:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  28366e:	50                   	push   %eax
  28366f:	e8 ae 07 00 00       	call   283e22 <cmd_exit>
  283674:	83 c4 10             	add    $0x10,%esp
					cons_putchar(&cons,'>',1);
  283677:	83 ec 04             	sub    $0x4,%esp
  28367a:	6a 01                	push   $0x1
  28367c:	6a 3e                	push   $0x3e
  28367e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  283681:	50                   	push   %eax
  283682:	e8 52 04 00 00       	call   283ad9 <cons_putchar>
  283687:	83 c4 10             	add    $0x10,%esp
  28368a:	eb 31                	jmp    2836bd <console_task+0x2f5>
				}
				else
				{
					if(cons.cur_x<240)
  28368c:	8b 45 b8             	mov    -0x48(%ebp),%eax
  28368f:	3d ef 00 00 00       	cmp    $0xef,%eax
  283694:	7f 27                	jg     2836bd <console_task+0x2f5>
					{
						s[0] = i-256;
						s[1] = 0;
						cmdline[cons.cur_x/8-2] = i-256;
  283696:	8d 50 07             	lea    0x7(%eax),%edx
  283699:	85 c0                	test   %eax,%eax
  28369b:	0f 48 c2             	cmovs  %edx,%eax
  28369e:	c1 f8 03             	sar    $0x3,%eax
  2836a1:	88 5c 05 c8          	mov    %bl,-0x38(%ebp,%eax,1)
						cons_putchar(&cons,i-256,1);
  2836a5:	83 ec 04             	sub    $0x4,%esp
  2836a8:	6a 01                	push   $0x1
  2836aa:	81 eb 00 01 00 00    	sub    $0x100,%ebx
  2836b0:	53                   	push   %ebx
  2836b1:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2836b4:	50                   	push   %eax
  2836b5:	e8 1f 04 00 00       	call   283ad9 <cons_putchar>
  2836ba:	83 c4 10             	add    $0x10,%esp
					}
				}
			}
			if(sheet != 0)
  2836bd:	85 ff                	test   %edi,%edi
  2836bf:	0f 84 f7 fd ff ff    	je     2834bc <console_task+0xf4>
			{
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  2836c5:	8b 45 c0             	mov    -0x40(%ebp),%eax
  2836c8:	85 c0                	test   %eax,%eax
  2836ca:	78 24                	js     2836f0 <console_task+0x328>
  2836cc:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  2836cf:	8b 55 b8             	mov    -0x48(%ebp),%edx
  2836d2:	83 ec 04             	sub    $0x4,%esp
  2836d5:	8d 59 0f             	lea    0xf(%ecx),%ebx
  2836d8:	53                   	push   %ebx
  2836d9:	8d 5a 07             	lea    0x7(%edx),%ebx
  2836dc:	53                   	push   %ebx
  2836dd:	51                   	push   %ecx
  2836de:	52                   	push   %edx
  2836df:	0f b6 c0             	movzbl %al,%eax
  2836e2:	50                   	push   %eax
  2836e3:	ff 77 04             	pushl  0x4(%edi)
  2836e6:	ff 37                	pushl  (%edi)
  2836e8:	e8 c4 d5 ff ff       	call   280cb1 <boxfill8>
  2836ed:	83 c4 20             	add    $0x20,%esp
			sheet_refresh(sheet,cons.cur_x,cons.cur_y,cons.cur_x+8,cons.cur_y+16);
  2836f0:	8b 55 bc             	mov    -0x44(%ebp),%edx
  2836f3:	8b 45 b8             	mov    -0x48(%ebp),%eax
  2836f6:	83 ec 0c             	sub    $0xc,%esp
  2836f9:	8d 4a 10             	lea    0x10(%edx),%ecx
  2836fc:	51                   	push   %ecx
  2836fd:	8d 48 08             	lea    0x8(%eax),%ecx
  283700:	51                   	push   %ecx
  283701:	52                   	push   %edx
  283702:	50                   	push   %eax
  283703:	57                   	push   %edi
  283704:	e8 2d f3 ff ff       	call   282a36 <sheet_refresh>
  283709:	83 c4 20             	add    $0x20,%esp
  28370c:	e9 ab fd ff ff       	jmp    2834bc <console_task+0xf4>

00283711 <file_readfat>:
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
  283711:	55                   	push   %ebp
  283712:	89 e5                	mov    %esp,%ebp
  283714:	53                   	push   %ebx
  283715:	83 ec 10             	sub    $0x10,%esp
	int i,j=0;
  283718:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(i=0;i<2880;i+=2)
  28371f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  283726:	e9 87 00 00 00       	jmp    2837b2 <file_readfat+0xa1>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
  28372b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28372e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  283735:	8b 45 08             	mov    0x8(%ebp),%eax
  283738:	01 d0                	add    %edx,%eax
  28373a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28373d:	8b 55 0c             	mov    0xc(%ebp),%edx
  283740:	01 ca                	add    %ecx,%edx
  283742:	0f b6 12             	movzbl (%edx),%edx
  283745:	0f b6 d2             	movzbl %dl,%edx
  283748:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28374b:	8d 59 01             	lea    0x1(%ecx),%ebx
  28374e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  283751:	01 d9                	add    %ebx,%ecx
  283753:	0f b6 09             	movzbl (%ecx),%ecx
  283756:	0f b6 c9             	movzbl %cl,%ecx
  283759:	c1 e1 08             	shl    $0x8,%ecx
  28375c:	09 ca                	or     %ecx,%edx
  28375e:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  283764:	89 10                	mov    %edx,(%eax)
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
  283766:	8b 45 f8             	mov    -0x8(%ebp),%eax
  283769:	83 c0 01             	add    $0x1,%eax
  28376c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  283773:	8b 45 08             	mov    0x8(%ebp),%eax
  283776:	01 d0                	add    %edx,%eax
  283778:	8b 55 f4             	mov    -0xc(%ebp),%edx
  28377b:	8d 4a 01             	lea    0x1(%edx),%ecx
  28377e:	8b 55 0c             	mov    0xc(%ebp),%edx
  283781:	01 ca                	add    %ecx,%edx
  283783:	0f b6 12             	movzbl (%edx),%edx
  283786:	c0 ea 04             	shr    $0x4,%dl
  283789:	0f b6 d2             	movzbl %dl,%edx
  28378c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28378f:	8d 59 02             	lea    0x2(%ecx),%ebx
  283792:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  283795:	01 d9                	add    %ebx,%ecx
  283797:	0f b6 09             	movzbl (%ecx),%ecx
  28379a:	0f b6 c9             	movzbl %cl,%ecx
  28379d:	c1 e1 04             	shl    $0x4,%ecx
  2837a0:	09 ca                	or     %ecx,%edx
  2837a2:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  2837a8:	89 10                	mov    %edx,(%eax)
		j+=3;
  2837aa:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
	int i,j=0;
	for(i=0;i<2880;i+=2)
  2837ae:	83 45 f8 02          	addl   $0x2,-0x8(%ebp)
  2837b2:	81 7d f8 3f 0b 00 00 	cmpl   $0xb3f,-0x8(%ebp)
  2837b9:	0f 8e 6c ff ff ff    	jle    28372b <file_readfat+0x1a>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
		j+=3;
	}
	return;
  2837bf:	90                   	nop
}
  2837c0:	83 c4 10             	add    $0x10,%esp
  2837c3:	5b                   	pop    %ebx
  2837c4:	5d                   	pop    %ebp
  2837c5:	c3                   	ret    

002837c6 <file_loadfile>:

void file_loadfile(int clustno,int size,char *buf,int *fat,char *img)
{
  2837c6:	55                   	push   %ebp
  2837c7:	89 e5                	mov    %esp,%ebp
  2837c9:	83 ec 10             	sub    $0x10,%esp
	int i;
	for(;;)
	{
		if(size <= 512)
  2837cc:	81 7d 0c 00 02 00 00 	cmpl   $0x200,0xc(%ebp)
  2837d3:	7f 38                	jg     28380d <file_loadfile+0x47>
		{
			for(i=0;i<size;i++)
  2837d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  2837dc:	eb 25                	jmp    283803 <file_loadfile+0x3d>
			{
				buf[i] = img[clustno*512 + i];
  2837de:	8b 55 fc             	mov    -0x4(%ebp),%edx
  2837e1:	8b 45 10             	mov    0x10(%ebp),%eax
  2837e4:	01 c2                	add    %eax,%edx
  2837e6:	8b 45 08             	mov    0x8(%ebp),%eax
  2837e9:	c1 e0 09             	shl    $0x9,%eax
  2837ec:	89 c1                	mov    %eax,%ecx
  2837ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2837f1:	01 c8                	add    %ecx,%eax
  2837f3:	89 c1                	mov    %eax,%ecx
  2837f5:	8b 45 18             	mov    0x18(%ebp),%eax
  2837f8:	01 c8                	add    %ecx,%eax
  2837fa:	0f b6 00             	movzbl (%eax),%eax
  2837fd:	88 02                	mov    %al,(%edx)
	int i;
	for(;;)
	{
		if(size <= 512)
		{
			for(i=0;i<size;i++)
  2837ff:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  283803:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283806:	3b 45 0c             	cmp    0xc(%ebp),%eax
  283809:	7c d3                	jl     2837de <file_loadfile+0x18>
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
  28380b:	eb 5e                	jmp    28386b <file_loadfile+0xa5>
		}
		for(i=0;i<512;i++)
  28380d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  283814:	eb 25                	jmp    28383b <file_loadfile+0x75>
		{
			buf[i] = img[clustno*512 + i];
  283816:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283819:	8b 45 10             	mov    0x10(%ebp),%eax
  28381c:	01 c2                	add    %eax,%edx
  28381e:	8b 45 08             	mov    0x8(%ebp),%eax
  283821:	c1 e0 09             	shl    $0x9,%eax
  283824:	89 c1                	mov    %eax,%ecx
  283826:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283829:	01 c8                	add    %ecx,%eax
  28382b:	89 c1                	mov    %eax,%ecx
  28382d:	8b 45 18             	mov    0x18(%ebp),%eax
  283830:	01 c8                	add    %ecx,%eax
  283832:	0f b6 00             	movzbl (%eax),%eax
  283835:	88 02                	mov    %al,(%edx)
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
		}
		for(i=0;i<512;i++)
  283837:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  28383b:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%ebp)
  283842:	7e d2                	jle    283816 <file_loadfile+0x50>
		{
			buf[i] = img[clustno*512 + i];
		}
		size -= 512;
  283844:	81 6d 0c 00 02 00 00 	subl   $0x200,0xc(%ebp)
		buf += 512;
  28384b:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
		clustno = fat[clustno];
  283852:	8b 45 08             	mov    0x8(%ebp),%eax
  283855:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  28385c:	8b 45 14             	mov    0x14(%ebp),%eax
  28385f:	01 d0                	add    %edx,%eax
  283861:	8b 00                	mov    (%eax),%eax
  283863:	89 45 08             	mov    %eax,0x8(%ebp)
	}
  283866:	e9 61 ff ff ff       	jmp    2837cc <file_loadfile+0x6>
	return;
}
  28386b:	c9                   	leave  
  28386c:	c3                   	ret    

0028386d <file_search>:

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
  28386d:	55                   	push   %ebp
  28386e:	89 e5                	mov    %esp,%ebp
  283870:	83 ec 20             	sub    $0x20,%esp
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  283873:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  28387a:	eb 0f                	jmp    28388b <file_search+0x1e>
	{
		s[j] = ' ';
  28387c:	8d 55 ec             	lea    -0x14(%ebp),%edx
  28387f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  283882:	01 d0                	add    %edx,%eax
  283884:	c6 00 20             	movb   $0x20,(%eax)

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  283887:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  28388b:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  28388f:	7e eb                	jle    28387c <file_search+0xf>
	{
		s[j] = ' ';
	}
	j=0;
  283891:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;name[i]!=0;i++)
  283898:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  28389f:	e9 83 00 00 00       	jmp    283927 <file_search+0xba>
	{
		if(j>=11) return 0; //length of name is bigger than 11
  2838a4:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  2838a8:	7e 0a                	jle    2838b4 <file_search+0x47>
  2838aa:	b8 00 00 00 00       	mov    $0x0,%eax
  2838af:	e9 2a 01 00 00       	jmp    2839de <file_search+0x171>
		if(name[i] == '.' && j <= 8)
  2838b4:	8b 55 fc             	mov    -0x4(%ebp),%edx
  2838b7:	8b 45 08             	mov    0x8(%ebp),%eax
  2838ba:	01 d0                	add    %edx,%eax
  2838bc:	0f b6 00             	movzbl (%eax),%eax
  2838bf:	3c 2e                	cmp    $0x2e,%al
  2838c1:	75 0f                	jne    2838d2 <file_search+0x65>
  2838c3:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
  2838c7:	7f 09                	jg     2838d2 <file_search+0x65>
			j = 8;
  2838c9:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)
  2838d0:	eb 51                	jmp    283923 <file_search+0xb6>
		else
		{
			s[j] = name[i];
  2838d2:	8b 55 fc             	mov    -0x4(%ebp),%edx
  2838d5:	8b 45 08             	mov    0x8(%ebp),%eax
  2838d8:	01 d0                	add    %edx,%eax
  2838da:	0f b6 00             	movzbl (%eax),%eax
  2838dd:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  2838e0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2838e3:	01 ca                	add    %ecx,%edx
  2838e5:	88 02                	mov    %al,(%edx)
			if('a' <= s[j] && s[j] <= 'z')
  2838e7:	8d 55 ec             	lea    -0x14(%ebp),%edx
  2838ea:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2838ed:	01 d0                	add    %edx,%eax
  2838ef:	0f b6 00             	movzbl (%eax),%eax
  2838f2:	3c 60                	cmp    $0x60,%al
  2838f4:	7e 29                	jle    28391f <file_search+0xb2>
  2838f6:	8d 55 ec             	lea    -0x14(%ebp),%edx
  2838f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2838fc:	01 d0                	add    %edx,%eax
  2838fe:	0f b6 00             	movzbl (%eax),%eax
  283901:	3c 7a                	cmp    $0x7a,%al
  283903:	7f 1a                	jg     28391f <file_search+0xb2>
				s[j] -= 0x20;
  283905:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283908:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28390b:	01 d0                	add    %edx,%eax
  28390d:	0f b6 00             	movzbl (%eax),%eax
  283910:	83 e8 20             	sub    $0x20,%eax
  283913:	89 c1                	mov    %eax,%ecx
  283915:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283918:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28391b:	01 d0                	add    %edx,%eax
  28391d:	88 08                	mov    %cl,(%eax)
			j++;
  28391f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(j=0;j<11;j++)
	{
		s[j] = ' ';
	}
	j=0;
	for(i=0;name[i]!=0;i++)
  283923:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  283927:	8b 55 fc             	mov    -0x4(%ebp),%edx
  28392a:	8b 45 08             	mov    0x8(%ebp),%eax
  28392d:	01 d0                	add    %edx,%eax
  28392f:	0f b6 00             	movzbl (%eax),%eax
  283932:	84 c0                	test   %al,%al
  283934:	0f 85 6a ff ff ff    	jne    2838a4 <file_search+0x37>
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  28393a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  283941:	e9 84 00 00 00       	jmp    2839ca <file_search+0x15d>
	{
		if(finfo[i].name[0] == 0) break;
  283946:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283949:	c1 e0 06             	shl    $0x6,%eax
  28394c:	89 c2                	mov    %eax,%edx
  28394e:	8b 45 0c             	mov    0xc(%ebp),%eax
  283951:	01 d0                	add    %edx,%eax
  283953:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  283957:	84 c0                	test   %al,%al
  283959:	74 7d                	je     2839d8 <file_search+0x16b>
		if((finfo[i].type & 0x18) == 0)
  28395b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  28395e:	c1 e0 06             	shl    $0x6,%eax
  283961:	89 c2                	mov    %eax,%edx
  283963:	8b 45 0c             	mov    0xc(%ebp),%eax
  283966:	01 d0                	add    %edx,%eax
  283968:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  28396c:	0f b6 c0             	movzbl %al,%eax
  28396f:	83 e0 18             	and    $0x18,%eax
  283972:	85 c0                	test   %eax,%eax
  283974:	75 50                	jne    2839c6 <file_search+0x159>
		{
			for(j=0;j<11;j++)
  283976:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  28397d:	eb 31                	jmp    2839b0 <file_search+0x143>
			{
				if(finfo[i].name[j] != s[j])
  28397f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283982:	c1 e0 06             	shl    $0x6,%eax
  283985:	89 c2                	mov    %eax,%edx
  283987:	8b 45 0c             	mov    0xc(%ebp),%eax
  28398a:	01 c2                	add    %eax,%edx
  28398c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28398f:	01 d0                	add    %edx,%eax
  283991:	83 c0 20             	add    $0x20,%eax
  283994:	0f b6 00             	movzbl (%eax),%eax
  283997:	0f b6 d0             	movzbl %al,%edx
  28399a:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  28399d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2839a0:	01 c8                	add    %ecx,%eax
  2839a2:	0f b6 00             	movzbl (%eax),%eax
  2839a5:	0f be c0             	movsbl %al,%eax
  2839a8:	39 c2                	cmp    %eax,%edx
  2839aa:	75 19                	jne    2839c5 <file_search+0x158>
	for(i=0;i<max;)
	{
		if(finfo[i].name[0] == 0) break;
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
  2839ac:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  2839b0:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  2839b4:	7e c9                	jle    28397f <file_search+0x112>
			{
				if(finfo[i].name[j] != s[j])
					goto next;
			}
			return finfo+i;
  2839b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2839b9:	c1 e0 06             	shl    $0x6,%eax
  2839bc:	89 c2                	mov    %eax,%edx
  2839be:	8b 45 0c             	mov    0xc(%ebp),%eax
  2839c1:	01 d0                	add    %edx,%eax
  2839c3:	eb 19                	jmp    2839de <file_search+0x171>
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
			{
				if(finfo[i].name[j] != s[j])
					goto next;
  2839c5:	90                   	nop
			}
			return finfo+i;
		}
next:
		i++;
  2839c6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  2839ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2839cd:	3b 45 10             	cmp    0x10(%ebp),%eax
  2839d0:	0f 8c 70 ff ff ff    	jl     283946 <file_search+0xd9>
  2839d6:	eb 01                	jmp    2839d9 <file_search+0x16c>
	{
		if(finfo[i].name[0] == 0) break;
  2839d8:	90                   	nop
			return finfo+i;
		}
next:
		i++;
	}
	return 0;
  2839d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2839de:	c9                   	leave  
  2839df:	c3                   	ret    

002839e0 <cons_newline>:
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  2839e0:	55                   	push   %ebp
  2839e1:	89 e5                	mov    %esp,%ebp
  2839e3:	57                   	push   %edi
  2839e4:	56                   	push   %esi
  2839e5:	53                   	push   %ebx
  2839e6:	83 ec 1c             	sub    $0x1c,%esp
	int x,y;
	struct SHEET *sheet = cons->sht;
  2839e9:	8b 45 08             	mov    0x8(%ebp),%eax
  2839ec:	8b 18                	mov    (%eax),%ebx
	struct TASK *task = task_now();
  2839ee:	e8 ee f5 ff ff       	call   282fe1 <task_now>
  2839f3:	89 45 dc             	mov    %eax,-0x24(%ebp)
	if(cons->cur_y<28+112)
  2839f6:	8b 45 08             	mov    0x8(%ebp),%eax
  2839f9:	8b 40 08             	mov    0x8(%eax),%eax
  2839fc:	3d 8b 00 00 00       	cmp    $0x8b,%eax
  283a01:	7f 0e                	jg     283a11 <cons_newline+0x31>
	{
		cons->cur_y += 16;
  283a03:	83 c0 10             	add    $0x10,%eax
  283a06:	8b 7d 08             	mov    0x8(%ebp),%edi
  283a09:	89 47 08             	mov    %eax,0x8(%edi)
  283a0c:	e9 97 00 00 00       	jmp    283aa8 <cons_newline+0xc8>
  283a11:	bf 1c 00 00 00       	mov    $0x1c,%edi
	}
	else if(sheet != 0)
  283a16:	85 db                	test   %ebx,%ebx
  283a18:	75 3a                	jne    283a54 <cons_newline+0x74>
  283a1a:	e9 89 00 00 00       	jmp    283aa8 <cons_newline+0xc8>
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  283a1f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  283a22:	8b 43 04             	mov    0x4(%ebx),%eax
  283a25:	8b 75 e0             	mov    -0x20(%ebp),%esi
  283a28:	0f af f0             	imul   %eax,%esi
  283a2b:	89 d1                	mov    %edx,%ecx
  283a2d:	03 0b                	add    (%ebx),%ecx
  283a2f:	0f b6 34 31          	movzbl (%ecx,%esi,1),%esi
  283a33:	0f af c7             	imul   %edi,%eax
  283a36:	89 f3                	mov    %esi,%ebx
  283a38:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
		cons->cur_y += 16;
	}
	else if(sheet != 0)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
  283a3b:	83 c2 01             	add    $0x1,%edx
  283a3e:	81 fa f8 00 00 00    	cmp    $0xf8,%edx
  283a44:	75 d9                	jne    283a1f <cons_newline+0x3f>
  283a46:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	{
		cons->cur_y += 16;
	}
	else if(sheet != 0)
	{
		for(y=28;y<28+112;y++)
  283a49:	83 c7 01             	add    $0x1,%edi
  283a4c:	81 ff 8c 00 00 00    	cmp    $0x8c,%edi
  283a52:	74 33                	je     283a87 <cons_newline+0xa7>
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  283a54:	ba 08 00 00 00       	mov    $0x8,%edx
	}
	else if(sheet != 0)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  283a59:	8d 47 10             	lea    0x10(%edi),%eax
  283a5c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  283a5f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  283a62:	eb bb                	jmp    283a1f <cons_newline+0x3f>
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  283a64:	89 fa                	mov    %edi,%edx
  283a66:	0f af 53 04          	imul   0x4(%ebx),%edx
  283a6a:	89 c1                	mov    %eax,%ecx
  283a6c:	03 0b                	add    (%ebx),%ecx
  283a6e:	c6 04 11 00          	movb   $0x0,(%ecx,%edx,1)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
  283a72:	83 c0 01             	add    $0x1,%eax
  283a75:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283a7a:	75 e8                	jne    283a64 <cons_newline+0x84>
	else if(sheet != 0)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
  283a7c:	83 c7 01             	add    $0x1,%edi
  283a7f:	81 ff 9c 00 00 00    	cmp    $0x9c,%edi
  283a85:	74 07                	je     283a8e <cons_newline+0xae>
  283a87:	b8 08 00 00 00       	mov    $0x8,%eax
  283a8c:	eb d6                	jmp    283a64 <cons_newline+0x84>
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		sheet_refresh(sheet,8,28,8+240,28+128);
  283a8e:	83 ec 0c             	sub    $0xc,%esp
  283a91:	68 9c 00 00 00       	push   $0x9c
  283a96:	68 f8 00 00 00       	push   $0xf8
  283a9b:	6a 1c                	push   $0x1c
  283a9d:	6a 08                	push   $0x8
  283a9f:	53                   	push   %ebx
  283aa0:	e8 91 ef ff ff       	call   282a36 <sheet_refresh>
  283aa5:	83 c4 20             	add    $0x20,%esp
	}
	cons->cur_x = 8;
  283aa8:	8b 45 08             	mov    0x8(%ebp),%eax
  283aab:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
	if(task->langmode == 1 && task->langbyte1 != 0)
  283ab2:	8b 45 dc             	mov    -0x24(%ebp),%eax
  283ab5:	80 b8 bc 00 00 00 01 	cmpb   $0x1,0xbc(%eax)
  283abc:	75 13                	jne    283ad1 <cons_newline+0xf1>
  283abe:	80 b8 bd 00 00 00 00 	cmpb   $0x0,0xbd(%eax)
  283ac5:	74 0a                	je     283ad1 <cons_newline+0xf1>
		cons->cur_x += 8;
  283ac7:	8b 45 08             	mov    0x8(%ebp),%eax
  283aca:	c7 40 04 10 00 00 00 	movl   $0x10,0x4(%eax)
	return;
}
  283ad1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283ad4:	5b                   	pop    %ebx
  283ad5:	5e                   	pop    %esi
  283ad6:	5f                   	pop    %edi
  283ad7:	5d                   	pop    %ebp
  283ad8:	c3                   	ret    

00283ad9 <cons_putchar>:
#include "header.h"
void cons_putchar(struct CONSOLE *cons,int chr,char move)
{
  283ad9:	55                   	push   %ebp
  283ada:	89 e5                	mov    %esp,%ebp
  283adc:	56                   	push   %esi
  283add:	53                   	push   %ebx
  283ade:	83 ec 10             	sub    $0x10,%esp
  283ae1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  283ae4:	8b 45 0c             	mov    0xc(%ebp),%eax
  283ae7:	8b 75 10             	mov    0x10(%ebp),%esi
	char s[2];
	s[0] = chr;
  283aea:	88 45 f6             	mov    %al,-0xa(%ebp)
	s[1] = 0;
  283aed:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	if(s[0] == 0x09)
  283af1:	3c 09                	cmp    $0x9,%al
  283af3:	75 4b                	jne    283b40 <cons_putchar+0x67>
	{
		//tab
		for(;;)
		{
			if(cons->sht!=0)	putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000," ",1);
  283af5:	8b 03                	mov    (%ebx),%eax
  283af7:	85 c0                	test   %eax,%eax
  283af9:	74 1d                	je     283b18 <cons_putchar+0x3f>
  283afb:	83 ec 04             	sub    $0x4,%esp
  283afe:	6a 01                	push   $0x1
  283b00:	68 83 58 28 00       	push   $0x285883
  283b05:	6a 00                	push   $0x0
  283b07:	6a 07                	push   $0x7
  283b09:	ff 73 08             	pushl  0x8(%ebx)
  283b0c:	ff 73 04             	pushl  0x4(%ebx)
  283b0f:	50                   	push   %eax
  283b10:	e8 fb d5 ff ff       	call   281110 <putfonts8_asc_sht>
  283b15:	83 c4 20             	add    $0x20,%esp
			cons->cur_x += 8;
  283b18:	8b 43 04             	mov    0x4(%ebx),%eax
  283b1b:	83 c0 08             	add    $0x8,%eax
  283b1e:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240) {
  283b21:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283b26:	75 0c                	jne    283b34 <cons_putchar+0x5b>
				cons_newline(cons);
  283b28:	83 ec 0c             	sub    $0xc,%esp
  283b2b:	53                   	push   %ebx
  283b2c:	e8 af fe ff ff       	call   2839e0 <cons_newline>
  283b31:	83 c4 10             	add    $0x10,%esp
			}
			if(((cons->cur_x - 8) & 0x1f) == 0)
  283b34:	8b 43 04             	mov    0x4(%ebx),%eax
  283b37:	83 e8 08             	sub    $0x8,%eax
  283b3a:	a8 1f                	test   $0x1f,%al
  283b3c:	75 b7                	jne    283af5 <cons_putchar+0x1c>
  283b3e:	eb 5a                	jmp    283b9a <cons_putchar+0xc1>
				break;
		}
	}
	else if(s[0] == 0x0a) 
  283b40:	3c 0a                	cmp    $0xa,%al
  283b42:	75 0e                	jne    283b52 <cons_putchar+0x79>
		cons_newline(cons);
  283b44:	83 ec 0c             	sub    $0xc,%esp
  283b47:	53                   	push   %ebx
  283b48:	e8 93 fe ff ff       	call   2839e0 <cons_newline>
  283b4d:	83 c4 10             	add    $0x10,%esp
  283b50:	eb 48                	jmp    283b9a <cons_putchar+0xc1>
	else if(s[0] == 0x0d) 
  283b52:	3c 0d                	cmp    $0xd,%al
  283b54:	74 44                	je     283b9a <cons_putchar+0xc1>
		;//todo
	else
	{
		if(cons->sht!=0)	putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000,s,1);
  283b56:	8b 03                	mov    (%ebx),%eax
  283b58:	85 c0                	test   %eax,%eax
  283b5a:	74 1c                	je     283b78 <cons_putchar+0x9f>
  283b5c:	83 ec 04             	sub    $0x4,%esp
  283b5f:	6a 01                	push   $0x1
  283b61:	8d 55 f6             	lea    -0xa(%ebp),%edx
  283b64:	52                   	push   %edx
  283b65:	6a 00                	push   $0x0
  283b67:	6a 07                	push   $0x7
  283b69:	ff 73 08             	pushl  0x8(%ebx)
  283b6c:	ff 73 04             	pushl  0x4(%ebx)
  283b6f:	50                   	push   %eax
  283b70:	e8 9b d5 ff ff       	call   281110 <putfonts8_asc_sht>
  283b75:	83 c4 20             	add    $0x20,%esp
		if(move != 0)
  283b78:	89 f0                	mov    %esi,%eax
  283b7a:	84 c0                	test   %al,%al
  283b7c:	74 1c                	je     283b9a <cons_putchar+0xc1>
		{
			cons->cur_x += 8;
  283b7e:	8b 43 04             	mov    0x4(%ebx),%eax
  283b81:	83 c0 08             	add    $0x8,%eax
  283b84:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240)
  283b87:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283b8c:	75 0c                	jne    283b9a <cons_putchar+0xc1>
				cons_newline(cons);
  283b8e:	83 ec 0c             	sub    $0xc,%esp
  283b91:	53                   	push   %ebx
  283b92:	e8 49 fe ff ff       	call   2839e0 <cons_newline>
  283b97:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  283b9a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283b9d:	5b                   	pop    %ebx
  283b9e:	5e                   	pop    %esi
  283b9f:	5d                   	pop    %ebp
  283ba0:	c3                   	ret    

00283ba1 <cmd_mem>:
	}
	return;
}

void cmd_mem(struct CONSOLE *cons,unsigned int memtotal)
{
  283ba1:	55                   	push   %ebp
  283ba2:	89 e5                	mov    %esp,%ebp
  283ba4:	56                   	push   %esi
  283ba5:	53                   	push   %ebx
  283ba6:	83 ec 24             	sub    $0x24,%esp
  283ba9:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	char s[30];
	sprintf(s,"total %dMB",memtotal/(1024*1024));
  283bac:	8b 45 0c             	mov    0xc(%ebp),%eax
  283baf:	c1 e8 14             	shr    $0x14,%eax
  283bb2:	50                   	push   %eax
  283bb3:	68 00 58 28 00       	push   $0x285800
  283bb8:	8d 75 da             	lea    -0x26(%ebp),%esi
  283bbb:	56                   	push   %esi
  283bbc:	e8 5c df ff ff       	call   281b1d <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283bc1:	83 c4 0c             	add    $0xc,%esp
  283bc4:	6a 1e                	push   $0x1e
  283bc6:	56                   	push   %esi
  283bc7:	6a 00                	push   $0x0
  283bc9:	6a 07                	push   $0x7
  283bcb:	ff 73 08             	pushl  0x8(%ebx)
  283bce:	6a 08                	push   $0x8
  283bd0:	ff 33                	pushl  (%ebx)
  283bd2:	e8 39 d5 ff ff       	call   281110 <putfonts8_asc_sht>
	cons_newline(cons);
  283bd7:	83 c4 14             	add    $0x14,%esp
  283bda:	53                   	push   %ebx
  283bdb:	e8 00 fe ff ff       	call   2839e0 <cons_newline>
	sprintf(s,"free %dKB",memman_total(memman)/1024);
  283be0:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
  283be7:	e8 2c e5 ff ff       	call   282118 <memman_total>
  283bec:	83 c4 0c             	add    $0xc,%esp
  283bef:	c1 e8 0a             	shr    $0xa,%eax
  283bf2:	50                   	push   %eax
  283bf3:	68 0b 58 28 00       	push   $0x28580b
  283bf8:	56                   	push   %esi
  283bf9:	e8 1f df ff ff       	call   281b1d <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283bfe:	83 c4 0c             	add    $0xc,%esp
  283c01:	6a 1e                	push   $0x1e
  283c03:	56                   	push   %esi
  283c04:	6a 00                	push   $0x0
  283c06:	6a 07                	push   $0x7
  283c08:	ff 73 08             	pushl  0x8(%ebx)
  283c0b:	6a 08                	push   $0x8
  283c0d:	ff 33                	pushl  (%ebx)
  283c0f:	e8 fc d4 ff ff       	call   281110 <putfonts8_asc_sht>
	cons_newline(cons);
  283c14:	83 c4 14             	add    $0x14,%esp
  283c17:	53                   	push   %ebx
  283c18:	e8 c3 fd ff ff       	call   2839e0 <cons_newline>
	cons_newline(cons);
  283c1d:	89 1c 24             	mov    %ebx,(%esp)
  283c20:	e8 bb fd ff ff       	call   2839e0 <cons_newline>
	return;
  283c25:	83 c4 10             	add    $0x10,%esp
}
  283c28:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283c2b:	5b                   	pop    %ebx
  283c2c:	5e                   	pop    %esi
  283c2d:	5d                   	pop    %ebp
  283c2e:	c3                   	ret    

00283c2f <cmd_cls>:

void cmd_cls(struct CONSOLE *cons)
{
  283c2f:	55                   	push   %ebp
  283c30:	89 e5                	mov    %esp,%ebp
  283c32:	57                   	push   %edi
  283c33:	56                   	push   %esi
  283c34:	53                   	push   %ebx
  283c35:	83 ec 0c             	sub    $0xc,%esp
  283c38:	8b 7d 08             	mov    0x8(%ebp),%edi
	int x,y;
	struct SHEET *sheet = cons->sht;
  283c3b:	8b 17                	mov    (%edi),%edx
	for(y=28;y<28+128;y++)
  283c3d:	be 1c 00 00 00       	mov    $0x1c,%esi
  283c42:	eb 23                	jmp    283c67 <cmd_cls+0x38>
	{
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  283c44:	89 f1                	mov    %esi,%ecx
  283c46:	0f af 4a 04          	imul   0x4(%edx),%ecx
  283c4a:	89 c3                	mov    %eax,%ebx
  283c4c:	03 1a                	add    (%edx),%ebx
  283c4e:	c6 04 0b 00          	movb   $0x0,(%ebx,%ecx,1)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
	{
		for(x=8;x<8+240;x++)
  283c52:	83 c0 01             	add    $0x1,%eax
  283c55:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283c5a:	75 e8                	jne    283c44 <cmd_cls+0x15>

void cmd_cls(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
  283c5c:	83 c6 01             	add    $0x1,%esi
  283c5f:	81 fe 9c 00 00 00    	cmp    $0x9c,%esi
  283c65:	74 07                	je     283c6e <cmd_cls+0x3f>
	cons_newline(cons);
	return;
}

void cmd_cls(struct CONSOLE *cons)
{
  283c67:	b8 08 00 00 00       	mov    $0x8,%eax
  283c6c:	eb d6                	jmp    283c44 <cmd_cls+0x15>
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		}
	}
	sheet_refresh(sheet,8,28,8+240,28+128);
  283c6e:	83 ec 0c             	sub    $0xc,%esp
  283c71:	68 9c 00 00 00       	push   $0x9c
  283c76:	68 f8 00 00 00       	push   $0xf8
  283c7b:	6a 1c                	push   $0x1c
  283c7d:	6a 08                	push   $0x8
  283c7f:	52                   	push   %edx
  283c80:	e8 b1 ed ff ff       	call   282a36 <sheet_refresh>
	cons->cur_y = 28;
  283c85:	c7 47 08 1c 00 00 00 	movl   $0x1c,0x8(%edi)
	return;
  283c8c:	83 c4 20             	add    $0x20,%esp
}
  283c8f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283c92:	5b                   	pop    %ebx
  283c93:	5e                   	pop    %esi
  283c94:	5f                   	pop    %edi
  283c95:	5d                   	pop    %ebp
  283c96:	c3                   	ret    

00283c97 <cmd_dir>:

void cmd_dir(struct CONSOLE *cons)
{
  283c97:	55                   	push   %ebp
  283c98:	89 e5                	mov    %esp,%ebp
  283c9a:	57                   	push   %edi
  283c9b:	56                   	push   %esi
  283c9c:	53                   	push   %ebx
  283c9d:	83 ec 2c             	sub    $0x2c,%esp
  283ca0:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  283ca3:	0f b6 05 20 26 10 00 	movzbl 0x102620,%eax
  283caa:	84 c0                	test   %al,%al
  283cac:	0f 84 87 00 00 00    	je     283d39 <cmd_dir+0xa2>
  283cb2:	bb 00 26 10 00       	mov    $0x102600,%ebx
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  283cb7:	8d 75 ca             	lea    -0x36(%ebp),%esi
  283cba:	eb 0b                	jmp    283cc7 <cmd_dir+0x30>
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  283cbc:	83 c3 40             	add    $0x40,%ebx
  283cbf:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  283cc3:	84 c0                	test   %al,%al
  283cc5:	74 72                	je     283d39 <cmd_dir+0xa2>
		if(finfo[i].name[0] != 0xe5)
  283cc7:	3c e5                	cmp    $0xe5,%al
  283cc9:	74 66                	je     283d31 <cmd_dir+0x9a>
		{
			if((finfo[i].type & 0x18) == 0)
  283ccb:	f6 43 2b 18          	testb  $0x18,0x2b(%ebx)
  283ccf:	75 60                	jne    283d31 <cmd_dir+0x9a>
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  283cd1:	83 ec 04             	sub    $0x4,%esp
  283cd4:	ff 73 3c             	pushl  0x3c(%ebx)
  283cd7:	68 15 58 28 00       	push   $0x285815
  283cdc:	56                   	push   %esi
  283cdd:	e8 3b de ff ff       	call   281b1d <sprintf>
  283ce2:	83 c4 10             	add    $0x10,%esp
				for(j=0;j<8;j++)
  283ce5:	b8 00 00 00 00       	mov    $0x0,%eax
				{
					s[j] = finfo[i].name[j];
  283cea:	0f b6 54 03 20       	movzbl 0x20(%ebx,%eax,1),%edx
  283cef:	88 14 30             	mov    %dl,(%eax,%esi,1)
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
				for(j=0;j<8;j++)
  283cf2:	83 c0 01             	add    $0x1,%eax
  283cf5:	83 f8 08             	cmp    $0x8,%eax
  283cf8:	75 f0                	jne    283cea <cmd_dir+0x53>
				{
					s[j] = finfo[i].name[j];
				}
				s[9] = finfo[i].ext[0];
  283cfa:	0f b6 43 28          	movzbl 0x28(%ebx),%eax
  283cfe:	88 45 d3             	mov    %al,-0x2d(%ebp)
				s[10] = finfo[i].ext[1];
  283d01:	0f b6 43 29          	movzbl 0x29(%ebx),%eax
  283d05:	88 45 d4             	mov    %al,-0x2c(%ebp)
				s[11] = finfo[i].ext[2];
  283d08:	0f b6 43 2a          	movzbl 0x2a(%ebx),%eax
  283d0c:	88 45 d5             	mov    %al,-0x2b(%ebp)
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283d0f:	83 ec 04             	sub    $0x4,%esp
  283d12:	6a 1e                	push   $0x1e
  283d14:	56                   	push   %esi
  283d15:	6a 00                	push   $0x0
  283d17:	6a 07                	push   $0x7
  283d19:	ff 77 08             	pushl  0x8(%edi)
  283d1c:	6a 08                	push   $0x8
  283d1e:	ff 37                	pushl  (%edi)
  283d20:	e8 eb d3 ff ff       	call   281110 <putfonts8_asc_sht>
				cons_newline(cons);
  283d25:	83 c4 14             	add    $0x14,%esp
  283d28:	57                   	push   %edi
  283d29:	e8 b2 fc ff ff       	call   2839e0 <cons_newline>
  283d2e:	83 c4 10             	add    $0x10,%esp
void cmd_dir(struct CONSOLE *cons)
{
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
  283d31:	81 fb c0 5d 10 00    	cmp    $0x105dc0,%ebx
  283d37:	75 83                	jne    283cbc <cmd_dir+0x25>
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
				cons_newline(cons);
			}
		}
	}
	cons_newline(cons);
  283d39:	83 ec 0c             	sub    $0xc,%esp
  283d3c:	57                   	push   %edi
  283d3d:	e8 9e fc ff ff       	call   2839e0 <cons_newline>
	return;
  283d42:	83 c4 10             	add    $0x10,%esp
}
  283d45:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283d48:	5b                   	pop    %ebx
  283d49:	5e                   	pop    %esi
  283d4a:	5f                   	pop    %edi
  283d4b:	5d                   	pop    %ebp
  283d4c:	c3                   	ret    

00283d4d <cmd_type>:

void cmd_type(struct CONSOLE *cons,int *fat,char *cmdline)
{
  283d4d:	55                   	push   %ebp
  283d4e:	89 e5                	mov    %esp,%ebp
  283d50:	57                   	push   %edi
  283d51:	56                   	push   %esi
  283d52:	53                   	push   %ebx
  283d53:	83 ec 10             	sub    $0x10,%esp
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo = file_search(cmdline +5,(struct FILEINFO *)(ADR_DISKIMG + 0x002600),224);
  283d56:	68 e0 00 00 00       	push   $0xe0
  283d5b:	68 00 26 10 00       	push   $0x102600
  283d60:	8b 45 10             	mov    0x10(%ebp),%eax
  283d63:	83 c0 05             	add    $0x5,%eax
  283d66:	50                   	push   %eax
  283d67:	e8 01 fb ff ff       	call   28386d <file_search>
	char *p;
	int i;
	if(finfo != 0)
  283d6c:	83 c4 10             	add    $0x10,%esp
  283d6f:	85 c0                	test   %eax,%eax
  283d71:	74 6e                	je     283de1 <cmd_type+0x94>
  283d73:	89 c6                	mov    %eax,%esi
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  283d75:	83 ec 08             	sub    $0x8,%esp
  283d78:	ff 70 3c             	pushl  0x3c(%eax)
  283d7b:	68 00 00 3c 00       	push   $0x3c0000
  283d80:	e8 08 e7 ff ff       	call   28248d <memman_alloc_4k>
  283d85:	89 c7                	mov    %eax,%edi
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  283d87:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  283d8e:	ff 75 0c             	pushl  0xc(%ebp)
  283d91:	50                   	push   %eax
  283d92:	ff 76 3c             	pushl  0x3c(%esi)
  283d95:	0f b7 46 3a          	movzwl 0x3a(%esi),%eax
  283d99:	50                   	push   %eax
  283d9a:	e8 27 fa ff ff       	call   2837c6 <file_loadfile>
		for(i=0;i<finfo->size;i++)
  283d9f:	8b 46 3c             	mov    0x3c(%esi),%eax
  283da2:	83 c4 20             	add    $0x20,%esp
  283da5:	85 c0                	test   %eax,%eax
  283da7:	74 24                	je     283dcd <cmd_type+0x80>
  283da9:	bb 00 00 00 00       	mov    $0x0,%ebx
		{
			cons_putchar(cons,p[i],1);
  283dae:	83 ec 04             	sub    $0x4,%esp
  283db1:	6a 01                	push   $0x1
  283db3:	0f be 04 3b          	movsbl (%ebx,%edi,1),%eax
  283db7:	50                   	push   %eax
  283db8:	ff 75 08             	pushl  0x8(%ebp)
  283dbb:	e8 19 fd ff ff       	call   283ad9 <cons_putchar>
	int i;
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		for(i=0;i<finfo->size;i++)
  283dc0:	83 c3 01             	add    $0x1,%ebx
  283dc3:	8b 46 3c             	mov    0x3c(%esi),%eax
  283dc6:	83 c4 10             	add    $0x10,%esp
  283dc9:	39 d8                	cmp    %ebx,%eax
  283dcb:	77 e1                	ja     283dae <cmd_type+0x61>
		{
			cons_putchar(cons,p[i],1);
		}
		memman_free_4k(memman,(int)p,finfo->size);
  283dcd:	83 ec 04             	sub    $0x4,%esp
  283dd0:	50                   	push   %eax
  283dd1:	57                   	push   %edi
  283dd2:	68 00 00 3c 00       	push   $0x3c0000
  283dd7:	e8 dd e6 ff ff       	call   2824b9 <memman_free_4k>
  283ddc:	83 c4 10             	add    $0x10,%esp
  283ddf:	eb 2b                	jmp    283e0c <cmd_type+0xbf>
	}
	else
	{
		putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"File not found.",15);
  283de1:	83 ec 04             	sub    $0x4,%esp
  283de4:	6a 0f                	push   $0xf
  283de6:	68 25 58 28 00       	push   $0x285825
  283deb:	6a 00                	push   $0x0
  283ded:	6a 07                	push   $0x7
  283def:	8b 45 08             	mov    0x8(%ebp),%eax
  283df2:	ff 70 08             	pushl  0x8(%eax)
  283df5:	6a 08                	push   $0x8
  283df7:	ff 30                	pushl  (%eax)
  283df9:	e8 12 d3 ff ff       	call   281110 <putfonts8_asc_sht>
		cons_newline(cons);
  283dfe:	83 c4 14             	add    $0x14,%esp
  283e01:	ff 75 08             	pushl  0x8(%ebp)
  283e04:	e8 d7 fb ff ff       	call   2839e0 <cons_newline>
  283e09:	83 c4 10             	add    $0x10,%esp
	}
	cons_newline(cons);
  283e0c:	83 ec 0c             	sub    $0xc,%esp
  283e0f:	ff 75 08             	pushl  0x8(%ebp)
  283e12:	e8 c9 fb ff ff       	call   2839e0 <cons_newline>
	return;
  283e17:	83 c4 10             	add    $0x10,%esp
}
  283e1a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283e1d:	5b                   	pop    %ebx
  283e1e:	5e                   	pop    %esi
  283e1f:	5f                   	pop    %edi
  283e20:	5d                   	pop    %ebp
  283e21:	c3                   	ret    

00283e22 <cmd_exit>:
	}
	return 0;
}

void cmd_exit(struct CONSOLE *cons,int *fat)
{
  283e22:	55                   	push   %ebp
  283e23:	89 e5                	mov    %esp,%ebp
  283e25:	57                   	push   %edi
  283e26:	56                   	push   %esi
  283e27:	53                   	push   %ebx
  283e28:	83 ec 0c             	sub    $0xc,%esp
	extern struct TASKCTL *taskctl;
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct TASK *task = task_now();
  283e2b:	e8 b1 f1 ff ff       	call   282fe1 <task_now>
  283e30:	89 c3                	mov    %eax,%ebx
	struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
  283e32:	8b 3d e4 0f 00 00    	mov    0xfe4,%edi
	struct FIFO32 *fifo = (struct FIFO32 *) *((int *)0x0fec);
  283e38:	8b 35 ec 0f 00 00    	mov    0xfec,%esi
	timer_cancel(cons->timer);
  283e3e:	83 ec 0c             	sub    $0xc,%esp
  283e41:	8b 45 08             	mov    0x8(%ebp),%eax
  283e44:	ff 70 10             	pushl  0x10(%eax)
  283e47:	e8 9f ef ff ff       	call   282deb <timer_cancel>
	memman_free_4k(memman,(int)fat,4*2880);
  283e4c:	83 c4 0c             	add    $0xc,%esp
  283e4f:	68 00 2d 00 00       	push   $0x2d00
  283e54:	ff 75 0c             	pushl  0xc(%ebp)
  283e57:	68 00 00 3c 00       	push   $0x3c0000
  283e5c:	e8 58 e6 ff ff       	call   2824b9 <memman_free_4k>
	io_cli();
  283e61:	e8 5c cc ff ff       	call   280ac2 <io_cli>
	if(cons->sht != 0)
  283e66:	8b 45 08             	mov    0x8(%ebp),%eax
  283e69:	8b 00                	mov    (%eax),%eax
  283e6b:	83 c4 10             	add    $0x10,%esp
  283e6e:	85 c0                	test   %eax,%eax
  283e70:	74 25                	je     283e97 <cmd_exit+0x75>
		fifo32_put(fifo,cons->sht - shtctl->sheets0 + 768);
  283e72:	83 ec 08             	sub    $0x8,%esp
  283e75:	81 c7 14 04 00 00    	add    $0x414,%edi
  283e7b:	29 f8                	sub    %edi,%eax
  283e7d:	c1 f8 03             	sar    $0x3,%eax
  283e80:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
  283e86:	05 00 03 00 00       	add    $0x300,%eax
  283e8b:	50                   	push   %eax
  283e8c:	56                   	push   %esi
  283e8d:	e8 77 de ff ff       	call   281d09 <fifo32_put>
  283e92:	83 c4 10             	add    $0x10,%esp
  283e95:	eb 29                	jmp    283ec0 <cmd_exit+0x9e>
	else
		fifo32_put(fifo,task - taskctl->tasks0 + 1024 );
  283e97:	83 ec 08             	sub    $0x8,%esp
  283e9a:	89 d8                	mov    %ebx,%eax
  283e9c:	2b 05 bc a9 28 00    	sub    0x28a9bc,%eax
  283ea2:	8d 80 08 f0 ff ff    	lea    -0xff8(%eax),%eax
  283ea8:	c1 f8 06             	sar    $0x6,%eax
  283eab:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
  283eb1:	05 00 04 00 00       	add    $0x400,%eax
  283eb6:	50                   	push   %eax
  283eb7:	56                   	push   %esi
  283eb8:	e8 4c de ff ff       	call   281d09 <fifo32_put>
  283ebd:	83 c4 10             	add    $0x10,%esp
	io_sti();
  283ec0:	e8 ff cb ff ff       	call   280ac4 <io_sti>
	for(;;)
	{
		task_sleep(task);
  283ec5:	83 ec 0c             	sub    $0xc,%esp
  283ec8:	53                   	push   %ebx
  283ec9:	e8 b8 f4 ff ff       	call   283386 <task_sleep>
  283ece:	83 c4 10             	add    $0x10,%esp
  283ed1:	eb f2                	jmp    283ec5 <cmd_exit+0xa3>

00283ed3 <cons_putstr0>:
	}
}

void cons_putstr0(struct CONSOLE *cons,char *s)
{
  283ed3:	55                   	push   %ebp
  283ed4:	89 e5                	mov    %esp,%ebp
  283ed6:	56                   	push   %esi
  283ed7:	53                   	push   %ebx
  283ed8:	8b 75 08             	mov    0x8(%ebp),%esi
  283edb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	for(;*s!=0;s++)
  283ede:	0f b6 03             	movzbl (%ebx),%eax
  283ee1:	84 c0                	test   %al,%al
  283ee3:	74 1c                	je     283f01 <cons_putstr0+0x2e>
	{
		cons_putchar(cons,*s,1);
  283ee5:	83 ec 04             	sub    $0x4,%esp
  283ee8:	6a 01                	push   $0x1
  283eea:	0f be c0             	movsbl %al,%eax
  283eed:	50                   	push   %eax
  283eee:	56                   	push   %esi
  283eef:	e8 e5 fb ff ff       	call   283ad9 <cons_putchar>
	}
}

void cons_putstr0(struct CONSOLE *cons,char *s)
{
	for(;*s!=0;s++)
  283ef4:	83 c3 01             	add    $0x1,%ebx
  283ef7:	0f b6 03             	movzbl (%ebx),%eax
  283efa:	83 c4 10             	add    $0x10,%esp
  283efd:	84 c0                	test   %al,%al
  283eff:	75 e4                	jne    283ee5 <cons_putstr0+0x12>
	{
		cons_putchar(cons,*s,1);
	}
	return;
}
  283f01:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283f04:	5b                   	pop    %ebx
  283f05:	5e                   	pop    %esi
  283f06:	5d                   	pop    %ebp
  283f07:	c3                   	ret    

00283f08 <cmd_app>:
}



int cmd_app(struct CONSOLE *cons,int *fat,char *cmdline)
{
  283f08:	55                   	push   %ebp
  283f09:	89 e5                	mov    %esp,%ebp
  283f0b:	57                   	push   %edi
  283f0c:	56                   	push   %esi
  283f0d:	53                   	push   %ebx
  283f0e:	83 ec 4c             	sub    $0x4c,%esp
  283f11:	8b 75 10             	mov    0x10(%ebp),%esi
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
  283f14:	e8 c8 f0 ff ff       	call   282fe1 <task_now>
  283f19:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
  283f1c:	0f b6 06             	movzbl (%esi),%eax
  283f1f:	3c 20                	cmp    $0x20,%al
  283f21:	0f 8f 8e 02 00 00    	jg     2841b5 <cmd_app+0x2ad>
  283f27:	eb 16                	jmp    283f3f <cmd_app+0x37>
  283f29:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
  283f2d:	3c 20                	cmp    $0x20,%al
  283f2f:	7e 13                	jle    283f44 <cmd_app+0x3c>
			break;
		name[i] = cmdline[i];
  283f31:	88 44 1d d6          	mov    %al,-0x2a(%ebp,%ebx,1)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  283f35:	83 c3 01             	add    $0x1,%ebx
  283f38:	83 fb 0d             	cmp    $0xd,%ebx
  283f3b:	75 ec                	jne    283f29 <cmd_app+0x21>
  283f3d:	eb 05                	jmp    283f44 <cmd_app+0x3c>
  283f3f:	bb 00 00 00 00       	mov    $0x0,%ebx
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
	}
	name[i] = 0;
  283f44:	c6 44 1d d6 00       	movb   $0x0,-0x2a(%ebp,%ebx,1)

	finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  283f49:	83 ec 04             	sub    $0x4,%esp
  283f4c:	68 e0 00 00 00       	push   $0xe0
  283f51:	68 00 26 10 00       	push   $0x102600
  283f56:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  283f59:	50                   	push   %eax
  283f5a:	e8 0e f9 ff ff       	call   28386d <file_search>
  283f5f:	89 45 c0             	mov    %eax,-0x40(%ebp)
	if(finfo == 0 && name[i-1]!='.')
  283f62:	83 c4 10             	add    $0x10,%esp
  283f65:	85 c0                	test   %eax,%eax
  283f67:	75 48                	jne    283fb1 <cmd_app+0xa9>
  283f69:	80 7c 1d d5 2e       	cmpb   $0x2e,-0x2b(%ebp,%ebx,1)
  283f6e:	0f 84 4e 02 00 00    	je     2841c2 <cmd_app+0x2ba>
	{
		name[i  ] = '.';
  283f74:	c6 44 1d d6 2e       	movb   $0x2e,-0x2a(%ebp,%ebx,1)
		name[i+1] = 'B';
  283f79:	c6 44 1d d7 42       	movb   $0x42,-0x29(%ebp,%ebx,1)
		name[i+2] = 'I';
  283f7e:	c6 44 1d d8 49       	movb   $0x49,-0x28(%ebp,%ebx,1)
		name[i+3] = 'N';
  283f83:	c6 44 1d d9 4e       	movb   $0x4e,-0x27(%ebp,%ebx,1)
		name[i+4] = 0;
  283f88:	c6 44 1d da 00       	movb   $0x0,-0x26(%ebp,%ebx,1)
		finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  283f8d:	83 ec 04             	sub    $0x4,%esp
  283f90:	68 e0 00 00 00       	push   $0xe0
  283f95:	68 00 26 10 00       	push   $0x102600
  283f9a:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  283f9d:	50                   	push   %eax
  283f9e:	e8 ca f8 ff ff       	call   28386d <file_search>
  283fa3:	89 45 c0             	mov    %eax,-0x40(%ebp)
	}

	if(finfo != 0)
  283fa6:	83 c4 10             	add    $0x10,%esp
  283fa9:	85 c0                	test   %eax,%eax
  283fab:	0f 84 fd 01 00 00    	je     2841ae <cmd_app+0x2a6>
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  283fb1:	83 ec 08             	sub    $0x8,%esp
  283fb4:	8b 7d c0             	mov    -0x40(%ebp),%edi
  283fb7:	ff 77 3c             	pushl  0x3c(%edi)
  283fba:	68 00 00 3c 00       	push   $0x3c0000
  283fbf:	e8 c9 e4 ff ff       	call   28248d <memman_alloc_4k>
  283fc4:	89 c6                	mov    %eax,%esi
  283fc6:	89 45 bc             	mov    %eax,-0x44(%ebp)
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  283fc9:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  283fd0:	ff 75 0c             	pushl  0xc(%ebp)
  283fd3:	50                   	push   %eax
  283fd4:	ff 77 3c             	pushl  0x3c(%edi)
  283fd7:	0f b7 47 3a          	movzwl 0x3a(%edi),%eax
  283fdb:	50                   	push   %eax
  283fdc:	e8 e5 f7 ff ff       	call   2837c6 <file_loadfile>
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
  283fe1:	83 c4 20             	add    $0x20,%esp
  283fe4:	83 7f 3c 23          	cmpl   $0x23,0x3c(%edi)
  283fe8:	0f 86 82 01 00 00    	jbe    284170 <cmd_app+0x268>
  283fee:	83 ec 04             	sub    $0x4,%esp
  283ff1:	6a 04                	push   $0x4
  283ff3:	68 35 58 28 00       	push   $0x285835
  283ff8:	89 f0                	mov    %esi,%eax
  283ffa:	83 c0 04             	add    $0x4,%eax
  283ffd:	50                   	push   %eax
  283ffe:	e8 55 dc ff ff       	call   281c58 <strncmp>
  284003:	83 c4 10             	add    $0x10,%esp
  284006:	85 c0                	test   %eax,%eax
  284008:	0f 85 62 01 00 00    	jne    284170 <cmd_app+0x268>
  28400e:	80 3e 00             	cmpb   $0x0,(%esi)
  284011:	0f 85 59 01 00 00    	jne    284170 <cmd_app+0x268>
		{
			int segsiz	=	*((int *)(p+0x0000));
  284017:	8b 45 bc             	mov    -0x44(%ebp),%eax
  28401a:	8b 08                	mov    (%eax),%ecx
			int esp		=	*((int *)(p+0x000c));
  28401c:	8b 70 0c             	mov    0xc(%eax),%esi
			int datsiz	=	*((int *)(p+0x0010));
  28401f:	8b 58 10             	mov    0x10(%eax),%ebx
			int dathrb	=	*((int *)(p+0x0014));
  284022:	8b 78 14             	mov    0x14(%eax),%edi

			q = (char *)memman_alloc_4k(memman,segsiz);
  284025:	83 ec 08             	sub    $0x8,%esp
  284028:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  28402b:	51                   	push   %ecx
  28402c:	68 00 00 3c 00       	push   $0x3c0000
  284031:	e8 57 e4 ff ff       	call   28248d <memman_alloc_4k>
  284036:	89 c2                	mov    %eax,%edx
			//*((int *)0xfe8) = (int) q;
			task->ds_base = (int)q;
  284038:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  28403b:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  28403e:	89 91 a8 00 00 00    	mov    %edx,0xa8(%ecx)
			set_segmdesc(task->ldt+0,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
  284044:	68 fa 40 00 00       	push   $0x40fa
  284049:	ff 75 bc             	pushl  -0x44(%ebp)
  28404c:	8b 45 c0             	mov    -0x40(%ebp),%eax
  28404f:	8b 40 3c             	mov    0x3c(%eax),%eax
  284052:	83 e8 01             	sub    $0x1,%eax
  284055:	50                   	push   %eax
  284056:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  284059:	89 c8                	mov    %ecx,%eax
  28405b:	05 94 00 00 00       	add    $0x94,%eax
  284060:	50                   	push   %eax
  284061:	e8 48 d5 ff ff       	call   2815ae <set_segmdesc>
			set_segmdesc(task->ldt+1,segsiz - 1,     (int)q,AR_DATA32_RW + 0x60);
  284066:	83 c4 20             	add    $0x20,%esp
  284069:	68 f2 40 00 00       	push   $0x40f2
  28406e:	ff 75 b4             	pushl  -0x4c(%ebp)
  284071:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  284074:	8d 41 ff             	lea    -0x1(%ecx),%eax
  284077:	50                   	push   %eax
  284078:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  28407b:	05 9c 00 00 00       	add    $0x9c,%eax
  284080:	50                   	push   %eax
  284081:	e8 28 d5 ff ff       	call   2815ae <set_segmdesc>
			for(int i = 0;i<datsiz;i++)
  284086:	83 c4 10             	add    $0x10,%esp
  284089:	85 db                	test   %ebx,%ebx
  28408b:	7e 1b                	jle    2840a8 <cmd_app+0x1a0>
  28408d:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				q[esp + i] = p[dathrb + i];
  284092:	03 7d bc             	add    -0x44(%ebp),%edi
  284095:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  284098:	01 f2                	add    %esi,%edx
  28409a:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  28409e:	88 0c 02             	mov    %cl,(%edx,%eax,1)
			q = (char *)memman_alloc_4k(memman,segsiz);
			//*((int *)0xfe8) = (int) q;
			task->ds_base = (int)q;
			set_segmdesc(task->ldt+0,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
			set_segmdesc(task->ldt+1,segsiz - 1,     (int)q,AR_DATA32_RW + 0x60);
			for(int i = 0;i<datsiz;i++)
  2840a1:	83 c0 01             	add    $0x1,%eax
  2840a4:	39 c3                	cmp    %eax,%ebx
  2840a6:	75 f2                	jne    28409a <cmd_app+0x192>
			{
				q[esp + i] = p[dathrb + i];
			}
			start_app(0x1b,0*8+4,esp,1*8+4,&(task->tss.esp0));
  2840a8:	83 ec 0c             	sub    $0xc,%esp
  2840ab:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  2840ae:	83 c0 30             	add    $0x30,%eax
  2840b1:	50                   	push   %eax
  2840b2:	6a 0c                	push   $0xc
  2840b4:	56                   	push   %esi
  2840b5:	6a 04                	push   $0x4
  2840b7:	6a 1b                	push   $0x1b
  2840b9:	e8 d2 05 00 00       	call   284690 <start_app>
			struct SHEET *sht;
			struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
  2840be:	8b 3d e4 0f 00 00    	mov    0xfe4,%edi
  2840c4:	8d 9f 30 04 00 00    	lea    0x430(%edi),%ebx
  2840ca:	8d b7 14 04 00 00    	lea    0x414(%edi),%esi
  2840d0:	81 c7 14 2c 00 00    	add    $0x2c14,%edi
  2840d6:	83 c4 20             	add    $0x20,%esp
			for(int i=0;i<MAX_SHEETS;i++)
			{
				sht = &(shtctl->sheets0[i]);
				if((sht->flags&0x11) == 0x11 && sht->task == task)
  2840d9:	8b 03                	mov    (%ebx),%eax
  2840db:	83 e0 11             	and    $0x11,%eax
  2840de:	83 f8 11             	cmp    $0x11,%eax
  2840e1:	75 14                	jne    2840f7 <cmd_app+0x1ef>
  2840e3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  2840e6:	3b 43 08             	cmp    0x8(%ebx),%eax
  2840e9:	75 0c                	jne    2840f7 <cmd_app+0x1ef>
					sheet_free(sht);
  2840eb:	83 ec 0c             	sub    $0xc,%esp
  2840ee:	56                   	push   %esi
  2840ef:	e8 be ea ff ff       	call   282bb2 <sheet_free>
  2840f4:	83 c4 10             	add    $0x10,%esp
  2840f7:	83 c3 28             	add    $0x28,%ebx
  2840fa:	83 c6 28             	add    $0x28,%esi
				q[esp + i] = p[dathrb + i];
			}
			start_app(0x1b,0*8+4,esp,1*8+4,&(task->tss.esp0));
			struct SHEET *sht;
			struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
			for(int i=0;i<MAX_SHEETS;i++)
  2840fd:	39 fe                	cmp    %edi,%esi
  2840ff:	75 d8                	jne    2840d9 <cmd_app+0x1d1>
  284101:	bb 00 00 00 00       	mov    $0x0,%ebx
  284106:	8b 75 c4             	mov    -0x3c(%ebp),%esi
				if((sht->flags&0x11) == 0x11 && sht->task == task)
					sheet_free(sht);
			}
			for(int i=0;i<8;i++)
			{
				if(task->fhandle[i].buf != 0)
  284109:	89 da                	mov    %ebx,%edx
  28410b:	03 96 b0 00 00 00    	add    0xb0(%esi),%edx
  284111:	8b 02                	mov    (%edx),%eax
  284113:	85 c0                	test   %eax,%eax
  284115:	74 21                	je     284138 <cmd_app+0x230>
				{
					memman_free_4k(memman,(int)task->fhandle[i].buf,task->fhandle[i].size);
  284117:	83 ec 04             	sub    $0x4,%esp
  28411a:	ff 72 04             	pushl  0x4(%edx)
  28411d:	50                   	push   %eax
  28411e:	68 00 00 3c 00       	push   $0x3c0000
  284123:	e8 91 e3 ff ff       	call   2824b9 <memman_free_4k>
					task->fhandle[i].buf = 0;
  284128:	8b 86 b0 00 00 00    	mov    0xb0(%esi),%eax
  28412e:	c7 04 18 00 00 00 00 	movl   $0x0,(%eax,%ebx,1)
  284135:	83 c4 10             	add    $0x10,%esp
  284138:	83 c3 0c             	add    $0xc,%ebx
			{
				sht = &(shtctl->sheets0[i]);
				if((sht->flags&0x11) == 0x11 && sht->task == task)
					sheet_free(sht);
			}
			for(int i=0;i<8;i++)
  28413b:	83 fb 60             	cmp    $0x60,%ebx
  28413e:	75 c9                	jne    284109 <cmd_app+0x201>
				{
					memman_free_4k(memman,(int)task->fhandle[i].buf,task->fhandle[i].size);
					task->fhandle[i].buf = 0;
				}
			}
			timer_cancelall(&task->fifo);
  284140:	83 ec 0c             	sub    $0xc,%esp
  284143:	8b 7d c4             	mov    -0x3c(%ebp),%edi
  284146:	89 f8                	mov    %edi,%eax
  284148:	83 c0 10             	add    $0x10,%eax
  28414b:	50                   	push   %eax
  28414c:	e8 0a ed ff ff       	call   282e5b <timer_cancelall>
			memman_free_4k(memman,(int)q,segsiz);
  284151:	83 c4 0c             	add    $0xc,%esp
  284154:	ff 75 b8             	pushl  -0x48(%ebp)
  284157:	ff 75 b4             	pushl  -0x4c(%ebp)
  28415a:	68 00 00 3c 00       	push   $0x3c0000
  28415f:	e8 55 e3 ff ff       	call   2824b9 <memman_free_4k>
			task->langbyte1 = 0;
  284164:	c6 87 bd 00 00 00 00 	movb   $0x0,0xbd(%edi)
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
		{
  28416b:	83 c4 10             	add    $0x10,%esp
  28416e:	eb 13                	jmp    284183 <cmd_app+0x27b>
			memman_free_4k(memman,(int)q,segsiz);
			task->langbyte1 = 0;
		}
		else
		{
			cons_putstr0(cons,".bin file format error.\n");
  284170:	83 ec 08             	sub    $0x8,%esp
  284173:	68 3a 58 28 00       	push   $0x28583a
  284178:	ff 75 08             	pushl  0x8(%ebp)
  28417b:	e8 53 fd ff ff       	call   283ed3 <cons_putstr0>
  284180:	83 c4 10             	add    $0x10,%esp
		}
		memman_free_4k(memman,(int)p,finfo->size);
  284183:	83 ec 04             	sub    $0x4,%esp
  284186:	8b 45 c0             	mov    -0x40(%ebp),%eax
  284189:	ff 70 3c             	pushl  0x3c(%eax)
  28418c:	ff 75 bc             	pushl  -0x44(%ebp)
  28418f:	68 00 00 3c 00       	push   $0x3c0000
  284194:	e8 20 e3 ff ff       	call   2824b9 <memman_free_4k>
		cons_newline(cons);
  284199:	83 c4 04             	add    $0x4,%esp
  28419c:	ff 75 08             	pushl  0x8(%ebp)
  28419f:	e8 3c f8 ff ff       	call   2839e0 <cons_newline>
		return 1;
  2841a4:	83 c4 10             	add    $0x10,%esp
  2841a7:	b8 01 00 00 00       	mov    $0x1,%eax
  2841ac:	eb 14                	jmp    2841c2 <cmd_app+0x2ba>
	}
	return 0;
  2841ae:	b8 00 00 00 00       	mov    $0x0,%eax
  2841b3:	eb 0d                	jmp    2841c2 <cmd_app+0x2ba>

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
  2841b5:	88 45 d6             	mov    %al,-0x2a(%ebp)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  2841b8:	bb 01 00 00 00       	mov    $0x1,%ebx
  2841bd:	e9 67 fd ff ff       	jmp    283f29 <cmd_app+0x21>
		memman_free_4k(memman,(int)p,finfo->size);
		cons_newline(cons);
		return 1;
	}
	return 0;
}
  2841c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2841c5:	5b                   	pop    %ebx
  2841c6:	5e                   	pop    %esi
  2841c7:	5f                   	pop    %edi
  2841c8:	5d                   	pop    %ebp
  2841c9:	c3                   	ret    

002841ca <cons_putstr1>:
	}
	return;
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
  2841ca:	55                   	push   %ebp
  2841cb:	89 e5                	mov    %esp,%ebp
  2841cd:	57                   	push   %edi
  2841ce:	56                   	push   %esi
  2841cf:	53                   	push   %ebx
  2841d0:	83 ec 0c             	sub    $0xc,%esp
  2841d3:	8b 7d 08             	mov    0x8(%ebp),%edi
  2841d6:	8b 75 0c             	mov    0xc(%ebp),%esi
  2841d9:	8b 45 10             	mov    0x10(%ebp),%eax
	int i;
	for(i=0;i<l;i++)
  2841dc:	85 c0                	test   %eax,%eax
  2841de:	7e 1d                	jle    2841fd <cons_putstr1+0x33>
  2841e0:	89 f3                	mov    %esi,%ebx
  2841e2:	01 c6                	add    %eax,%esi
	{
		cons_putchar(cons,s[i],1);
  2841e4:	83 ec 04             	sub    $0x4,%esp
  2841e7:	6a 01                	push   $0x1
  2841e9:	0f be 03             	movsbl (%ebx),%eax
  2841ec:	50                   	push   %eax
  2841ed:	57                   	push   %edi
  2841ee:	e8 e6 f8 ff ff       	call   283ad9 <cons_putchar>
  2841f3:	83 c3 01             	add    $0x1,%ebx
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
	int i;
	for(i=0;i<l;i++)
  2841f6:	83 c4 10             	add    $0x10,%esp
  2841f9:	39 f3                	cmp    %esi,%ebx
  2841fb:	75 e7                	jne    2841e4 <cons_putstr1+0x1a>
	{
		cons_putchar(cons,s[i],1);
	}
	return;
}
  2841fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  284200:	5b                   	pop    %ebx
  284201:	5e                   	pop    %esi
  284202:	5f                   	pop    %edi
  284203:	5d                   	pop    %ebp
  284204:	c3                   	ret    

00284205 <open_constask>:

struct TASK *open_constask(struct SHEET *sht,unsigned int memtotal)
{
  284205:	55                   	push   %ebp
  284206:	89 e5                	mov    %esp,%ebp
  284208:	53                   	push   %ebx
  284209:	83 ec 04             	sub    $0x4,%esp
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct TASK *task = task_alloc();
  28420c:	e8 d7 ec ff ff       	call   282ee8 <task_alloc>
  284211:	89 c3                	mov    %eax,%ebx
	task->cons_stack = memman_alloc_4k(memman,64*1024);
  284213:	83 ec 08             	sub    $0x8,%esp
  284216:	68 00 00 01 00       	push   $0x10000
  28421b:	68 00 00 3c 00       	push   $0x3c0000
  284220:	e8 68 e2 ff ff       	call   28248d <memman_alloc_4k>
  284225:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
	task->tss.esp = task->cons_stack+64*1024-12;
  28422b:	8d 90 f4 ff 00 00    	lea    0xfff4(%eax),%edx
  284231:	89 53 64             	mov    %edx,0x64(%ebx)
	task->tss.eip = (int)&console_task - 0x280000;
  284234:	c7 43 4c c8 33 00 00 	movl   $0x33c8,0x4c(%ebx)
	task->tss.es = 1*8;
  28423b:	c7 43 74 08 00 00 00 	movl   $0x8,0x74(%ebx)
	task->tss.cs = 3*8;
  284242:	c7 43 78 18 00 00 00 	movl   $0x18,0x78(%ebx)
	task->tss.ss = 1*8;
  284249:	c7 43 7c 08 00 00 00 	movl   $0x8,0x7c(%ebx)
	task->tss.ds = 1*8;
  284250:	c7 83 80 00 00 00 08 	movl   $0x8,0x80(%ebx)
  284257:	00 00 00 
	task->tss.fs = 1*8;
  28425a:	c7 83 84 00 00 00 08 	movl   $0x8,0x84(%ebx)
  284261:	00 00 00 
	task->tss.gs = 1*8;
  284264:	c7 83 88 00 00 00 08 	movl   $0x8,0x88(%ebx)
  28426b:	00 00 00 
	*((int *)(task->tss.esp + 4)) = sht;
  28426e:	8b 55 08             	mov    0x8(%ebp),%edx
  284271:	89 90 f8 ff 00 00    	mov    %edx,0xfff8(%eax)
	*((int *)(task->tss.esp + 8)) = memtotal;
  284277:	8b 43 64             	mov    0x64(%ebx),%eax
  28427a:	8b 55 0c             	mov    0xc(%ebp),%edx
  28427d:	89 50 08             	mov    %edx,0x8(%eax)
	task_run(task,2,2);
  284280:	83 c4 0c             	add    $0xc,%esp
  284283:	6a 02                	push   $0x2
  284285:	6a 02                	push   $0x2
  284287:	53                   	push   %ebx
  284288:	e8 49 ee ff ff       	call   2830d6 <task_run>
	int *cons_fifo = memman_alloc_4k(memman,128*4);
  28428d:	83 c4 08             	add    $0x8,%esp
  284290:	68 00 02 00 00       	push   $0x200
  284295:	68 00 00 3c 00       	push   $0x3c0000
  28429a:	e8 ee e1 ff ff       	call   28248d <memman_alloc_4k>
	fifo32_init(&task->fifo,128,cons_fifo,task);
  28429f:	53                   	push   %ebx
  2842a0:	50                   	push   %eax
  2842a1:	68 80 00 00 00       	push   $0x80
  2842a6:	8d 43 10             	lea    0x10(%ebx),%eax
  2842a9:	50                   	push   %eax
  2842aa:	e8 29 da ff ff       	call   281cd8 <fifo32_init>
	return task;
}
  2842af:	89 d8                	mov    %ebx,%eax
  2842b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2842b4:	c9                   	leave  
  2842b5:	c3                   	ret    

002842b6 <open_console>:

struct SHEET *open_console(struct SHTCTL *shtctl,unsigned int memtotal)
{
  2842b6:	55                   	push   %ebp
  2842b7:	89 e5                	mov    %esp,%ebp
  2842b9:	56                   	push   %esi
  2842ba:	53                   	push   %ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct SHEET *sht = sheet_alloc(shtctl);
  2842bb:	83 ec 0c             	sub    $0xc,%esp
  2842be:	ff 75 08             	pushl  0x8(%ebp)
  2842c1:	e8 b6 e2 ff ff       	call   28257c <sheet_alloc>
  2842c6:	89 c3                	mov    %eax,%ebx
	unsigned char *buf = (unsigned char *)memman_alloc_4k(memman,256*165);
  2842c8:	83 c4 08             	add    $0x8,%esp
  2842cb:	68 00 a5 00 00       	push   $0xa500
  2842d0:	68 00 00 3c 00       	push   $0x3c0000
  2842d5:	e8 b3 e1 ff ff       	call   28248d <memman_alloc_4k>
  2842da:	89 c6                	mov    %eax,%esi
	sheet_setbuf(sht,buf,256,165,-1);
  2842dc:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  2842e3:	68 a5 00 00 00       	push   $0xa5
  2842e8:	68 00 01 00 00       	push   $0x100
  2842ed:	50                   	push   %eax
  2842ee:	53                   	push   %ebx
  2842ef:	e8 fb e2 ff ff       	call   2825ef <sheet_setbuf>
	make_window8(buf,256,165,"console",0);
  2842f4:	83 c4 14             	add    $0x14,%esp
  2842f7:	6a 00                	push   $0x0
  2842f9:	68 53 58 28 00       	push   $0x285853
  2842fe:	68 a5 00 00 00       	push   $0xa5
  284303:	68 00 01 00 00       	push   $0x100
  284308:	56                   	push   %esi
  284309:	e8 a4 cc ff ff       	call   280fb2 <make_window8>
	make_textbox8(sht,8,28,240,128,COL8_000000);
  28430e:	83 c4 18             	add    $0x18,%esp
  284311:	6a 00                	push   $0x0
  284313:	68 80 00 00 00       	push   $0x80
  284318:	68 f0 00 00 00       	push   $0xf0
  28431d:	6a 1c                	push   $0x1c
  28431f:	6a 08                	push   $0x8
  284321:	53                   	push   %ebx
  284322:	e8 4e ce ff ff       	call   281175 <make_textbox8>
	sht->task = open_constask(sht,memtotal);
  284327:	83 c4 18             	add    $0x18,%esp
  28432a:	ff 75 0c             	pushl  0xc(%ebp)
  28432d:	53                   	push   %ebx
  28432e:	e8 d2 fe ff ff       	call   284205 <open_constask>
  284333:	89 43 24             	mov    %eax,0x24(%ebx)
	sht->flags |= 0x20;
  284336:	83 4b 1c 20          	orl    $0x20,0x1c(%ebx)
	return sht;
}
  28433a:	89 d8                	mov    %ebx,%eax
  28433c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  28433f:	5b                   	pop    %ebx
  284340:	5e                   	pop    %esi
  284341:	5d                   	pop    %ebp
  284342:	c3                   	ret    

00284343 <close_constask>:

void close_constask(struct TASK *task)
{
  284343:	55                   	push   %ebp
  284344:	89 e5                	mov    %esp,%ebp
  284346:	53                   	push   %ebx
  284347:	83 ec 10             	sub    $0x10,%esp
  28434a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	task_sleep(task);
  28434d:	53                   	push   %ebx
  28434e:	e8 33 f0 ff ff       	call   283386 <task_sleep>
	memman_free_4k(memman,task->cons_stack,64 * 1024);
  284353:	83 c4 0c             	add    $0xc,%esp
  284356:	68 00 00 01 00       	push   $0x10000
  28435b:	ff b3 ac 00 00 00    	pushl  0xac(%ebx)
  284361:	68 00 00 3c 00       	push   $0x3c0000
  284366:	e8 4e e1 ff ff       	call   2824b9 <memman_free_4k>
	memman_free_4k(memman,(int)task->fifo.buf,128*4);
  28436b:	83 c4 0c             	add    $0xc,%esp
  28436e:	68 00 02 00 00       	push   $0x200
  284373:	ff 73 10             	pushl  0x10(%ebx)
  284376:	68 00 00 3c 00       	push   $0x3c0000
  28437b:	e8 39 e1 ff ff       	call   2824b9 <memman_free_4k>
	task->flags = 0;
  284380:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
	return;
  284387:	83 c4 10             	add    $0x10,%esp
}
  28438a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  28438d:	c9                   	leave  
  28438e:	c3                   	ret    

0028438f <close_console>:

void close_console(struct SHEET *sht)
{
  28438f:	55                   	push   %ebp
  284390:	89 e5                	mov    %esp,%ebp
  284392:	56                   	push   %esi
  284393:	53                   	push   %ebx
  284394:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct TASK *task = sht->task;
  284397:	8b 73 24             	mov    0x24(%ebx),%esi
	memman_free_4k(memman,(int)sht->buf,256*165);
  28439a:	83 ec 04             	sub    $0x4,%esp
  28439d:	68 00 a5 00 00       	push   $0xa500
  2843a2:	ff 33                	pushl  (%ebx)
  2843a4:	68 00 00 3c 00       	push   $0x3c0000
  2843a9:	e8 0b e1 ff ff       	call   2824b9 <memman_free_4k>
	sheet_free(sht);
  2843ae:	89 1c 24             	mov    %ebx,(%esp)
  2843b1:	e8 fc e7 ff ff       	call   282bb2 <sheet_free>
	close_constask(task);
  2843b6:	89 34 24             	mov    %esi,(%esp)
  2843b9:	e8 85 ff ff ff       	call   284343 <close_constask>
	return;
  2843be:	83 c4 10             	add    $0x10,%esp
}
  2843c1:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2843c4:	5b                   	pop    %ebx
  2843c5:	5e                   	pop    %esi
  2843c6:	5d                   	pop    %ebp
  2843c7:	c3                   	ret    

002843c8 <cmd_start>:

void cmd_start(struct CONSOLE *cons,char *cmdline,int memtotal)
{
  2843c8:	55                   	push   %ebp
  2843c9:	89 e5                	mov    %esp,%ebp
  2843cb:	57                   	push   %edi
  2843cc:	56                   	push   %esi
  2843cd:	53                   	push   %ebx
  2843ce:	83 ec 14             	sub    $0x14,%esp
	struct SHTCTL *shtctl = (struct SHTCTL *) *((int *) 0x0fe4);
  2843d1:	8b 3d e4 0f 00 00    	mov    0xfe4,%edi
	struct SHEET *sht = open_console(shtctl,memtotal);
  2843d7:	ff 75 10             	pushl  0x10(%ebp)
  2843da:	57                   	push   %edi
  2843db:	e8 d6 fe ff ff       	call   2842b6 <open_console>
  2843e0:	89 c6                	mov    %eax,%esi
	struct FIFO32 *fifo = &sht->task->fifo;
  2843e2:	8b 40 24             	mov    0x24(%eax),%eax
  2843e5:	8d 58 10             	lea    0x10(%eax),%ebx
	int i;
	sheet_slide(sht,32,4);
  2843e8:	83 c4 0c             	add    $0xc,%esp
  2843eb:	6a 04                	push   $0x4
  2843ed:	6a 20                	push   $0x20
  2843ef:	56                   	push   %esi
  2843f0:	e8 5e e7 ff ff       	call   282b53 <sheet_slide>
	sheet_updown(sht,shtctl->top);
  2843f5:	83 c4 08             	add    $0x8,%esp
  2843f8:	ff 77 10             	pushl  0x10(%edi)
  2843fb:	56                   	push   %esi
  2843fc:	e8 69 e6 ff ff       	call   282a6a <sheet_updown>
	for(i = 6;cmdline[i]!=0;i++)
  284401:	8b 45 0c             	mov    0xc(%ebp),%eax
  284404:	0f b6 40 06          	movzbl 0x6(%eax),%eax
  284408:	83 c4 10             	add    $0x10,%esp
  28440b:	84 c0                	test   %al,%al
  28440d:	74 26                	je     284435 <cmd_start+0x6d>
  28440f:	8b 55 0c             	mov    0xc(%ebp),%edx
  284412:	8d 72 07             	lea    0x7(%edx),%esi
	{
		fifo32_put(fifo,cmdline[i] + 256);
  284415:	83 ec 08             	sub    $0x8,%esp
  284418:	0f be c0             	movsbl %al,%eax
  28441b:	05 00 01 00 00       	add    $0x100,%eax
  284420:	50                   	push   %eax
  284421:	53                   	push   %ebx
  284422:	e8 e2 d8 ff ff       	call   281d09 <fifo32_put>
  284427:	83 c6 01             	add    $0x1,%esi
	struct SHEET *sht = open_console(shtctl,memtotal);
	struct FIFO32 *fifo = &sht->task->fifo;
	int i;
	sheet_slide(sht,32,4);
	sheet_updown(sht,shtctl->top);
	for(i = 6;cmdline[i]!=0;i++)
  28442a:	0f b6 46 ff          	movzbl -0x1(%esi),%eax
  28442e:	83 c4 10             	add    $0x10,%esp
  284431:	84 c0                	test   %al,%al
  284433:	75 e0                	jne    284415 <cmd_start+0x4d>
	{
		fifo32_put(fifo,cmdline[i] + 256);
	}
	fifo32_put(fifo,10+256);
  284435:	83 ec 08             	sub    $0x8,%esp
  284438:	68 0a 01 00 00       	push   $0x10a
  28443d:	53                   	push   %ebx
  28443e:	e8 c6 d8 ff ff       	call   281d09 <fifo32_put>
	cons_newline(cons);
  284443:	83 c4 04             	add    $0x4,%esp
  284446:	ff 75 08             	pushl  0x8(%ebp)
  284449:	e8 92 f5 ff ff       	call   2839e0 <cons_newline>
	return;
  28444e:	83 c4 10             	add    $0x10,%esp
}
  284451:	8d 65 f4             	lea    -0xc(%ebp),%esp
  284454:	5b                   	pop    %ebx
  284455:	5e                   	pop    %esi
  284456:	5f                   	pop    %edi
  284457:	5d                   	pop    %ebp
  284458:	c3                   	ret    

00284459 <cmd_ncst>:

void cmd_ncst(struct CONSOLE *cons,char *cmdline,int memtotal)
{
  284459:	55                   	push   %ebp
  28445a:	89 e5                	mov    %esp,%ebp
  28445c:	56                   	push   %esi
  28445d:	53                   	push   %ebx
  28445e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct TASK *task = open_constask(0,memtotal);
  284461:	83 ec 08             	sub    $0x8,%esp
  284464:	ff 75 10             	pushl  0x10(%ebp)
  284467:	6a 00                	push   $0x0
  284469:	e8 97 fd ff ff       	call   284205 <open_constask>
	struct FIFO32 *fifo = &task->fifo;
  28446e:	8d 70 10             	lea    0x10(%eax),%esi
	int i;
	for(i=5;cmdline[i]!=0;i++) {
  284471:	0f b6 53 05          	movzbl 0x5(%ebx),%edx
  284475:	83 c4 10             	add    $0x10,%esp
  284478:	84 d2                	test   %dl,%dl
  28447a:	74 24                	je     2844a0 <cmd_ncst+0x47>
  28447c:	83 c3 06             	add    $0x6,%ebx
		fifo32_put(fifo,cmdline[i] + 256);
  28447f:	83 ec 08             	sub    $0x8,%esp
  284482:	0f be d2             	movsbl %dl,%edx
  284485:	81 c2 00 01 00 00    	add    $0x100,%edx
  28448b:	52                   	push   %edx
  28448c:	56                   	push   %esi
  28448d:	e8 77 d8 ff ff       	call   281d09 <fifo32_put>
  284492:	83 c3 01             	add    $0x1,%ebx
void cmd_ncst(struct CONSOLE *cons,char *cmdline,int memtotal)
{
	struct TASK *task = open_constask(0,memtotal);
	struct FIFO32 *fifo = &task->fifo;
	int i;
	for(i=5;cmdline[i]!=0;i++) {
  284495:	0f b6 53 ff          	movzbl -0x1(%ebx),%edx
  284499:	83 c4 10             	add    $0x10,%esp
  28449c:	84 d2                	test   %dl,%dl
  28449e:	75 df                	jne    28447f <cmd_ncst+0x26>
		fifo32_put(fifo,cmdline[i] + 256);
	}
	fifo32_put(fifo,10+256);
  2844a0:	83 ec 08             	sub    $0x8,%esp
  2844a3:	68 0a 01 00 00       	push   $0x10a
  2844a8:	56                   	push   %esi
  2844a9:	e8 5b d8 ff ff       	call   281d09 <fifo32_put>
	cons_newline(cons);
  2844ae:	83 c4 04             	add    $0x4,%esp
  2844b1:	ff 75 08             	pushl  0x8(%ebp)
  2844b4:	e8 27 f5 ff ff       	call   2839e0 <cons_newline>
	return;
  2844b9:	83 c4 10             	add    $0x10,%esp
}
  2844bc:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2844bf:	5b                   	pop    %ebx
  2844c0:	5e                   	pop    %esi
  2844c1:	5d                   	pop    %ebp
  2844c2:	c3                   	ret    

002844c3 <cmd_langmode>:

void cmd_langmode(struct CONSOLE *cons,char *cmdline)
{
  2844c3:	55                   	push   %ebp
  2844c4:	89 e5                	mov    %esp,%ebp
  2844c6:	53                   	push   %ebx
  2844c7:	83 ec 04             	sub    $0x4,%esp
  2844ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASK *task = task_now();
  2844cd:	e8 0f eb ff ff       	call   282fe1 <task_now>
	unsigned char mode = cmdline[9] - '0';
  2844d2:	8b 55 0c             	mov    0xc(%ebp),%edx
  2844d5:	0f b6 52 09          	movzbl 0x9(%edx),%edx
  2844d9:	83 ea 30             	sub    $0x30,%edx
	if(mode <= 1)
  2844dc:	80 fa 01             	cmp    $0x1,%dl
  2844df:	77 08                	ja     2844e9 <cmd_langmode+0x26>
		task->langmode = mode;
  2844e1:	88 90 bc 00 00 00    	mov    %dl,0xbc(%eax)
  2844e7:	eb 11                	jmp    2844fa <cmd_langmode+0x37>
	else
		cons_putstr0(cons,"mode number error.\n");
  2844e9:	83 ec 08             	sub    $0x8,%esp
  2844ec:	68 5b 58 28 00       	push   $0x28585b
  2844f1:	53                   	push   %ebx
  2844f2:	e8 dc f9 ff ff       	call   283ed3 <cons_putstr0>
  2844f7:	83 c4 10             	add    $0x10,%esp
	cons_newline(cons);
  2844fa:	83 ec 0c             	sub    $0xc,%esp
  2844fd:	53                   	push   %ebx
  2844fe:	e8 dd f4 ff ff       	call   2839e0 <cons_newline>
	return;
  284503:	83 c4 10             	add    $0x10,%esp
}
  284506:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  284509:	c9                   	leave  
  28450a:	c3                   	ret    

0028450b <cons_runcmd>:
	return;
}

#include "string.h"
void cons_runcmd(char *cmdline,struct CONSOLE *cons,int *fat,unsigned int memtotal)
{
  28450b:	55                   	push   %ebp
  28450c:	89 e5                	mov    %esp,%ebp
  28450e:	53                   	push   %ebx
  28450f:	83 ec 0c             	sub    $0xc,%esp
  284512:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(strcmp(cmdline,"mem") == 0)
  284515:	68 6f 58 28 00       	push   $0x28586f
  28451a:	53                   	push   %ebx
  28451b:	e8 d2 d6 ff ff       	call   281bf2 <strcmp>
  284520:	83 c4 10             	add    $0x10,%esp
  284523:	85 c0                	test   %eax,%eax
  284525:	75 16                	jne    28453d <cons_runcmd+0x32>
		cmd_mem(cons,memtotal);
  284527:	83 ec 08             	sub    $0x8,%esp
  28452a:	ff 75 14             	pushl  0x14(%ebp)
  28452d:	ff 75 0c             	pushl  0xc(%ebp)
  284530:	e8 6c f6 ff ff       	call   283ba1 <cmd_mem>
  284535:	83 c4 10             	add    $0x10,%esp
  284538:	e9 45 01 00 00       	jmp    284682 <cons_runcmd+0x177>
	else if(strcmp(cmdline,"cls") == 0)
  28453d:	83 ec 08             	sub    $0x8,%esp
  284540:	68 73 58 28 00       	push   $0x285873
  284545:	53                   	push   %ebx
  284546:	e8 a7 d6 ff ff       	call   281bf2 <strcmp>
  28454b:	83 c4 10             	add    $0x10,%esp
  28454e:	85 c0                	test   %eax,%eax
  284550:	75 13                	jne    284565 <cons_runcmd+0x5a>
		cmd_cls(cons);
  284552:	83 ec 0c             	sub    $0xc,%esp
  284555:	ff 75 0c             	pushl  0xc(%ebp)
  284558:	e8 d2 f6 ff ff       	call   283c2f <cmd_cls>
  28455d:	83 c4 10             	add    $0x10,%esp
  284560:	e9 1d 01 00 00       	jmp    284682 <cons_runcmd+0x177>
	else if(strcmp(cmdline,"dir") == 0)
  284565:	83 ec 08             	sub    $0x8,%esp
  284568:	68 77 58 28 00       	push   $0x285877
  28456d:	53                   	push   %ebx
  28456e:	e8 7f d6 ff ff       	call   281bf2 <strcmp>
  284573:	83 c4 10             	add    $0x10,%esp
  284576:	85 c0                	test   %eax,%eax
  284578:	75 13                	jne    28458d <cons_runcmd+0x82>
		cmd_dir(cons);
  28457a:	83 ec 0c             	sub    $0xc,%esp
  28457d:	ff 75 0c             	pushl  0xc(%ebp)
  284580:	e8 12 f7 ff ff       	call   283c97 <cmd_dir>
  284585:	83 c4 10             	add    $0x10,%esp
  284588:	e9 f5 00 00 00       	jmp    284682 <cons_runcmd+0x177>
	else if(strncmp(cmdline,"langmode ",9) == 0)
  28458d:	83 ec 04             	sub    $0x4,%esp
  284590:	6a 09                	push   $0x9
  284592:	68 7b 58 28 00       	push   $0x28587b
  284597:	53                   	push   %ebx
  284598:	e8 bb d6 ff ff       	call   281c58 <strncmp>
  28459d:	83 c4 10             	add    $0x10,%esp
  2845a0:	85 c0                	test   %eax,%eax
  2845a2:	75 14                	jne    2845b8 <cons_runcmd+0xad>
		cmd_langmode(cons,cmdline);
  2845a4:	83 ec 08             	sub    $0x8,%esp
  2845a7:	53                   	push   %ebx
  2845a8:	ff 75 0c             	pushl  0xc(%ebp)
  2845ab:	e8 13 ff ff ff       	call   2844c3 <cmd_langmode>
  2845b0:	83 c4 10             	add    $0x10,%esp
  2845b3:	e9 ca 00 00 00       	jmp    284682 <cons_runcmd+0x177>
	else if(strcmp(cmdline,"exit") == 0)
  2845b8:	83 ec 08             	sub    $0x8,%esp
  2845bb:	68 85 58 28 00       	push   $0x285885
  2845c0:	53                   	push   %ebx
  2845c1:	e8 2c d6 ff ff       	call   281bf2 <strcmp>
  2845c6:	83 c4 10             	add    $0x10,%esp
  2845c9:	85 c0                	test   %eax,%eax
  2845cb:	75 0e                	jne    2845db <cons_runcmd+0xd0>
		cmd_exit(cons,fat);
  2845cd:	83 ec 08             	sub    $0x8,%esp
  2845d0:	ff 75 10             	pushl  0x10(%ebp)
  2845d3:	ff 75 0c             	pushl  0xc(%ebp)
  2845d6:	e8 47 f8 ff ff       	call   283e22 <cmd_exit>
	else if(strncmp(cmdline,"start ",6) == 0)
  2845db:	83 ec 04             	sub    $0x4,%esp
  2845de:	6a 06                	push   $0x6
  2845e0:	68 8a 58 28 00       	push   $0x28588a
  2845e5:	53                   	push   %ebx
  2845e6:	e8 6d d6 ff ff       	call   281c58 <strncmp>
  2845eb:	83 c4 10             	add    $0x10,%esp
  2845ee:	85 c0                	test   %eax,%eax
  2845f0:	75 14                	jne    284606 <cons_runcmd+0xfb>
		cmd_start(cons,cmdline,memtotal);
  2845f2:	83 ec 04             	sub    $0x4,%esp
  2845f5:	ff 75 14             	pushl  0x14(%ebp)
  2845f8:	53                   	push   %ebx
  2845f9:	ff 75 0c             	pushl  0xc(%ebp)
  2845fc:	e8 c7 fd ff ff       	call   2843c8 <cmd_start>
  284601:	83 c4 10             	add    $0x10,%esp
  284604:	eb 7c                	jmp    284682 <cons_runcmd+0x177>
	else if(strncmp(cmdline,"ncst ",5) == 0)
  284606:	83 ec 04             	sub    $0x4,%esp
  284609:	6a 05                	push   $0x5
  28460b:	68 91 58 28 00       	push   $0x285891
  284610:	53                   	push   %ebx
  284611:	e8 42 d6 ff ff       	call   281c58 <strncmp>
  284616:	83 c4 10             	add    $0x10,%esp
  284619:	85 c0                	test   %eax,%eax
  28461b:	75 14                	jne    284631 <cons_runcmd+0x126>
		cmd_ncst(cons,cmdline,memtotal);
  28461d:	83 ec 04             	sub    $0x4,%esp
  284620:	ff 75 14             	pushl  0x14(%ebp)
  284623:	53                   	push   %ebx
  284624:	ff 75 0c             	pushl  0xc(%ebp)
  284627:	e8 2d fe ff ff       	call   284459 <cmd_ncst>
  28462c:	83 c4 10             	add    $0x10,%esp
  28462f:	eb 51                	jmp    284682 <cons_runcmd+0x177>
	else if(cmdline[0] != 0)
  284631:	80 3b 00             	cmpb   $0x0,(%ebx)
  284634:	74 4c                	je     284682 <cons_runcmd+0x177>
	{
		if(cmd_app(cons,fat,cmdline) == 0)
  284636:	83 ec 04             	sub    $0x4,%esp
  284639:	53                   	push   %ebx
  28463a:	ff 75 10             	pushl  0x10(%ebp)
  28463d:	ff 75 0c             	pushl  0xc(%ebp)
  284640:	e8 c3 f8 ff ff       	call   283f08 <cmd_app>
  284645:	83 c4 10             	add    $0x10,%esp
  284648:	85 c0                	test   %eax,%eax
  28464a:	75 36                	jne    284682 <cons_runcmd+0x177>
		{
			putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"Bad command.",12);
  28464c:	83 ec 04             	sub    $0x4,%esp
  28464f:	6a 0c                	push   $0xc
  284651:	68 97 58 28 00       	push   $0x285897
  284656:	6a 00                	push   $0x0
  284658:	6a 07                	push   $0x7
  28465a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28465d:	ff 70 08             	pushl  0x8(%eax)
  284660:	6a 08                	push   $0x8
  284662:	ff 30                	pushl  (%eax)
  284664:	e8 a7 ca ff ff       	call   281110 <putfonts8_asc_sht>
			cons_newline(cons);
  284669:	83 c4 14             	add    $0x14,%esp
  28466c:	ff 75 0c             	pushl  0xc(%ebp)
  28466f:	e8 6c f3 ff ff       	call   2839e0 <cons_newline>
			cons_newline(cons);
  284674:	83 c4 04             	add    $0x4,%esp
  284677:	ff 75 0c             	pushl  0xc(%ebp)
  28467a:	e8 61 f3 ff ff       	call   2839e0 <cons_newline>
  28467f:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  284682:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  284685:	c9                   	leave  
  284686:	c3                   	ret    
  284687:	66 90                	xchg   %ax,%ax
  284689:	66 90                	xchg   %ax,%ax
  28468b:	66 90                	xchg   %ax,%ax
  28468d:	66 90                	xchg   %ax,%ax
  28468f:	90                   	nop

00284690 <start_app>:
  284690:	60                   	pusha  
  284691:	8b 44 24 24          	mov    0x24(%esp),%eax
  284695:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  284699:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  28469d:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  2846a1:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  2846a5:	89 65 00             	mov    %esp,0x0(%ebp)
  2846a8:	8c 55 04             	mov    %ss,0x4(%ebp)
  2846ab:	8e c3                	mov    %ebx,%es
  2846ad:	8e db                	mov    %ebx,%ds
  2846af:	8e e3                	mov    %ebx,%fs
  2846b1:	8e eb                	mov    %ebx,%gs
  2846b3:	83 c9 03             	or     $0x3,%ecx
  2846b6:	83 cb 03             	or     $0x3,%ebx
  2846b9:	53                   	push   %ebx
  2846ba:	52                   	push   %edx
  2846bb:	51                   	push   %ecx
  2846bc:	50                   	push   %eax
  2846bd:	cb                   	lret   

002846be <sys_api>:
#include "header.h"
int *sys_api(int edi,int esi,int ebp,int esp,int ebx,int edx,int ecx,int eax)
{
  2846be:	55                   	push   %ebp
  2846bf:	89 e5                	mov    %esp,%ebp
  2846c1:	53                   	push   %ebx
  2846c2:	83 ec 44             	sub    $0x44,%esp
	struct TASK *task = task_now();
  2846c5:	e8 17 e9 ff ff       	call   282fe1 <task_now>
  2846ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct CONSOLE *cons = task->cons;
  2846cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
  2846d0:	8b 80 a4 00 00 00    	mov    0xa4(%eax),%eax
  2846d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int ds_base = task->ds_base;
  2846d9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  2846dc:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
  2846e2:	89 45 e0             	mov    %eax,-0x20(%ebp)
	struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
  2846e5:	b8 e4 0f 00 00       	mov    $0xfe4,%eax
  2846ea:	8b 00                	mov    (%eax),%eax
  2846ec:	89 45 dc             	mov    %eax,-0x24(%ebp)
	struct SHEET *sht;
	int *reg = &eax + 1;
  2846ef:	8d 45 24             	lea    0x24(%ebp),%eax
  2846f2:	83 c0 04             	add    $0x4,%eax
  2846f5:	89 45 d8             	mov    %eax,-0x28(%ebp)
	   and the parameters:
	   edi = 2nd_edi; esi = 2nd_esi ... eax = 2nd_eax
	   */
	struct FILEINFO *finfo;
	struct FILEHANDLE *fh;
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
  2846f8:	c7 45 d4 00 00 3c 00 	movl   $0x3c0000,-0x2c(%ebp)
	
	
	if(edx == 1) cons_putchar(cons,eax & 0xff,1);
  2846ff:	83 7d 1c 01          	cmpl   $0x1,0x1c(%ebp)
  284703:	75 1c                	jne    284721 <sys_api+0x63>
  284705:	8b 45 24             	mov    0x24(%ebp),%eax
  284708:	0f b6 c0             	movzbl %al,%eax
  28470b:	83 ec 04             	sub    $0x4,%esp
  28470e:	6a 01                	push   $0x1
  284710:	50                   	push   %eax
  284711:	ff 75 e4             	pushl  -0x1c(%ebp)
  284714:	e8 c0 f3 ff ff       	call   283ad9 <cons_putchar>
  284719:	83 c4 10             	add    $0x10,%esp
  28471c:	e9 28 09 00 00       	jmp    285049 <sys_api+0x98b>
	else if(edx == 2) cons_putstr0(cons,(char *)ebx+ds_base);
  284721:	83 7d 1c 02          	cmpl   $0x2,0x1c(%ebp)
  284725:	75 1c                	jne    284743 <sys_api+0x85>
  284727:	8b 55 e0             	mov    -0x20(%ebp),%edx
  28472a:	8b 45 18             	mov    0x18(%ebp),%eax
  28472d:	01 d0                	add    %edx,%eax
  28472f:	83 ec 08             	sub    $0x8,%esp
  284732:	50                   	push   %eax
  284733:	ff 75 e4             	pushl  -0x1c(%ebp)
  284736:	e8 98 f7 ff ff       	call   283ed3 <cons_putstr0>
  28473b:	83 c4 10             	add    $0x10,%esp
  28473e:	e9 06 09 00 00       	jmp    285049 <sys_api+0x98b>
	else if(edx == 3) cons_putstr1(cons,(char *)ebx+ds_base,ecx);
  284743:	83 7d 1c 03          	cmpl   $0x3,0x1c(%ebp)
  284747:	75 1f                	jne    284768 <sys_api+0xaa>
  284749:	8b 55 e0             	mov    -0x20(%ebp),%edx
  28474c:	8b 45 18             	mov    0x18(%ebp),%eax
  28474f:	01 d0                	add    %edx,%eax
  284751:	83 ec 04             	sub    $0x4,%esp
  284754:	ff 75 20             	pushl  0x20(%ebp)
  284757:	50                   	push   %eax
  284758:	ff 75 e4             	pushl  -0x1c(%ebp)
  28475b:	e8 6a fa ff ff       	call   2841ca <cons_putstr1>
  284760:	83 c4 10             	add    $0x10,%esp
  284763:	e9 e1 08 00 00       	jmp    285049 <sys_api+0x98b>
	else if(edx == 4)
  284768:	83 7d 1c 04          	cmpl   $0x4,0x1c(%ebp)
  28476c:	75 0b                	jne    284779 <sys_api+0xbb>
	{
		//exit app
		return &(task->tss.esp0);
  28476e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284771:	83 c0 30             	add    $0x30,%eax
  284774:	e9 d5 08 00 00       	jmp    28504e <sys_api+0x990>
	}
	else if(edx == 5)
  284779:	83 7d 1c 05          	cmpl   $0x5,0x1c(%ebp)
  28477d:	0f 85 d1 00 00 00    	jne    284854 <sys_api+0x196>
	{
		sht = sheet_alloc(shtctl);
  284783:	83 ec 0c             	sub    $0xc,%esp
  284786:	ff 75 dc             	pushl  -0x24(%ebp)
  284789:	e8 ee dd ff ff       	call   28257c <sheet_alloc>
  28478e:	83 c4 10             	add    $0x10,%esp
  284791:	89 45 bc             	mov    %eax,-0x44(%ebp)
		sht->task = task;
  284794:	8b 45 bc             	mov    -0x44(%ebp),%eax
  284797:	8b 55 e8             	mov    -0x18(%ebp),%edx
  28479a:	89 50 24             	mov    %edx,0x24(%eax)
		sht->flags |= 0x11;
  28479d:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2847a0:	8b 40 1c             	mov    0x1c(%eax),%eax
  2847a3:	83 c8 11             	or     $0x11,%eax
  2847a6:	89 c2                	mov    %eax,%edx
  2847a8:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2847ab:	89 50 1c             	mov    %edx,0x1c(%eax)
		sheet_setbuf(sht,(char *)ebx+ds_base,esi,edi,eax);
  2847ae:	8b 45 24             	mov    0x24(%ebp),%eax
  2847b1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  2847b4:	8b 55 18             	mov    0x18(%ebp),%edx
  2847b7:	01 ca                	add    %ecx,%edx
  2847b9:	83 ec 0c             	sub    $0xc,%esp
  2847bc:	50                   	push   %eax
  2847bd:	ff 75 08             	pushl  0x8(%ebp)
  2847c0:	ff 75 0c             	pushl  0xc(%ebp)
  2847c3:	52                   	push   %edx
  2847c4:	ff 75 bc             	pushl  -0x44(%ebp)
  2847c7:	e8 23 de ff ff       	call   2825ef <sheet_setbuf>
  2847cc:	83 c4 20             	add    $0x20,%esp
		make_window8((char *)ebx+ds_base,esi,edi,(char *)ecx+ds_base,0);
  2847cf:	8b 55 e0             	mov    -0x20(%ebp),%edx
  2847d2:	8b 45 20             	mov    0x20(%ebp),%eax
  2847d5:	01 d0                	add    %edx,%eax
  2847d7:	89 c1                	mov    %eax,%ecx
  2847d9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  2847dc:	8b 45 18             	mov    0x18(%ebp),%eax
  2847df:	01 d0                	add    %edx,%eax
  2847e1:	83 ec 0c             	sub    $0xc,%esp
  2847e4:	6a 00                	push   $0x0
  2847e6:	51                   	push   %ecx
  2847e7:	ff 75 08             	pushl  0x8(%ebp)
  2847ea:	ff 75 0c             	pushl  0xc(%ebp)
  2847ed:	50                   	push   %eax
  2847ee:	e8 bf c7 ff ff       	call   280fb2 <make_window8>
  2847f3:	83 c4 20             	add    $0x20,%esp
		sheet_slide(sht,((shtctl->xsize - esi)/2)&~3,(shtctl->ysize - edi)/2);
  2847f6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  2847f9:	8b 40 0c             	mov    0xc(%eax),%eax
  2847fc:	2b 45 08             	sub    0x8(%ebp),%eax
  2847ff:	89 c2                	mov    %eax,%edx
  284801:	c1 ea 1f             	shr    $0x1f,%edx
  284804:	01 d0                	add    %edx,%eax
  284806:	d1 f8                	sar    %eax
  284808:	89 c1                	mov    %eax,%ecx
  28480a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  28480d:	8b 40 08             	mov    0x8(%eax),%eax
  284810:	2b 45 0c             	sub    0xc(%ebp),%eax
  284813:	89 c2                	mov    %eax,%edx
  284815:	c1 ea 1f             	shr    $0x1f,%edx
  284818:	01 d0                	add    %edx,%eax
  28481a:	d1 f8                	sar    %eax
  28481c:	83 e0 fc             	and    $0xfffffffc,%eax
  28481f:	83 ec 04             	sub    $0x4,%esp
  284822:	51                   	push   %ecx
  284823:	50                   	push   %eax
  284824:	ff 75 bc             	pushl  -0x44(%ebp)
  284827:	e8 27 e3 ff ff       	call   282b53 <sheet_slide>
  28482c:	83 c4 10             	add    $0x10,%esp
		sheet_updown(sht,shtctl->top);	//above task_a
  28482f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  284832:	8b 40 10             	mov    0x10(%eax),%eax
  284835:	83 ec 08             	sub    $0x8,%esp
  284838:	50                   	push   %eax
  284839:	ff 75 bc             	pushl  -0x44(%ebp)
  28483c:	e8 29 e2 ff ff       	call   282a6a <sheet_updown>
  284841:	83 c4 10             	add    $0x10,%esp
		reg[7] = (int)sht;		//after sys_api ret and popad the eax will be sht
  284844:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284847:	8d 50 1c             	lea    0x1c(%eax),%edx
  28484a:	8b 45 bc             	mov    -0x44(%ebp),%eax
  28484d:	89 02                	mov    %eax,(%edx)
  28484f:	e9 f5 07 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 6)
  284854:	83 7d 1c 06          	cmpl   $0x6,0x1c(%ebp)
  284858:	75 74                	jne    2848ce <sys_api+0x210>
	{
		sht = (struct SHEET *)ebx;
  28485a:	8b 45 18             	mov    0x18(%ebp),%eax
  28485d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		putfonts8_asc(sht->buf,sht->bxsize,esi,edi,eax,(char *)ebp + ds_base);
  284860:	8b 55 e0             	mov    -0x20(%ebp),%edx
  284863:	8b 45 10             	mov    0x10(%ebp),%eax
  284866:	01 d0                	add    %edx,%eax
  284868:	89 c3                	mov    %eax,%ebx
  28486a:	8b 45 24             	mov    0x24(%ebp),%eax
  28486d:	0f be c8             	movsbl %al,%ecx
  284870:	8b 45 bc             	mov    -0x44(%ebp),%eax
  284873:	8b 50 04             	mov    0x4(%eax),%edx
  284876:	8b 45 bc             	mov    -0x44(%ebp),%eax
  284879:	8b 00                	mov    (%eax),%eax
  28487b:	83 ec 08             	sub    $0x8,%esp
  28487e:	53                   	push   %ebx
  28487f:	51                   	push   %ecx
  284880:	ff 75 08             	pushl  0x8(%ebp)
  284883:	ff 75 0c             	pushl  0xc(%ebp)
  284886:	52                   	push   %edx
  284887:	50                   	push   %eax
  284888:	e8 f5 cb ff ff       	call   281482 <putfonts8_asc>
  28488d:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  284890:	8b 45 18             	mov    0x18(%ebp),%eax
  284893:	83 e0 01             	and    $0x1,%eax
  284896:	85 c0                	test   %eax,%eax
  284898:	0f 85 ab 07 00 00    	jne    285049 <sys_api+0x98b>
			sheet_refresh(sht,esi,edi,esi+ecx*8,edi+16);
  28489e:	8b 45 08             	mov    0x8(%ebp),%eax
  2848a1:	8d 50 10             	lea    0x10(%eax),%edx
  2848a4:	8b 45 20             	mov    0x20(%ebp),%eax
  2848a7:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  2848ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  2848b1:	01 c8                	add    %ecx,%eax
  2848b3:	83 ec 0c             	sub    $0xc,%esp
  2848b6:	52                   	push   %edx
  2848b7:	50                   	push   %eax
  2848b8:	ff 75 08             	pushl  0x8(%ebp)
  2848bb:	ff 75 0c             	pushl  0xc(%ebp)
  2848be:	ff 75 bc             	pushl  -0x44(%ebp)
  2848c1:	e8 70 e1 ff ff       	call   282a36 <sheet_refresh>
  2848c6:	83 c4 20             	add    $0x20,%esp
  2848c9:	e9 7b 07 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 7)
  2848ce:	83 7d 1c 07          	cmpl   $0x7,0x1c(%ebp)
  2848d2:	75 68                	jne    28493c <sys_api+0x27e>
	{
		sht = (struct SHEET *)ebx;
  2848d4:	8b 45 18             	mov    0x18(%ebp),%eax
  2848d7:	89 45 bc             	mov    %eax,-0x44(%ebp)
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
  2848da:	8b 5d 24             	mov    0x24(%ebp),%ebx
  2848dd:	8b 45 10             	mov    0x10(%ebp),%eax
  2848e0:	0f b6 c8             	movzbl %al,%ecx
  2848e3:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2848e6:	8b 50 04             	mov    0x4(%eax),%edx
  2848e9:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2848ec:	8b 00                	mov    (%eax),%eax
  2848ee:	83 ec 04             	sub    $0x4,%esp
  2848f1:	ff 75 08             	pushl  0x8(%ebp)
  2848f4:	ff 75 0c             	pushl  0xc(%ebp)
  2848f7:	ff 75 20             	pushl  0x20(%ebp)
  2848fa:	53                   	push   %ebx
  2848fb:	51                   	push   %ecx
  2848fc:	52                   	push   %edx
  2848fd:	50                   	push   %eax
  2848fe:	e8 ae c3 ff ff       	call   280cb1 <boxfill8>
  284903:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  284906:	8b 45 18             	mov    0x18(%ebp),%eax
  284909:	83 e0 01             	and    $0x1,%eax
  28490c:	85 c0                	test   %eax,%eax
  28490e:	0f 85 35 07 00 00    	jne    285049 <sys_api+0x98b>
			sheet_refresh(sht,eax,ecx,esi+1,edi+1);
  284914:	8b 45 08             	mov    0x8(%ebp),%eax
  284917:	8d 48 01             	lea    0x1(%eax),%ecx
  28491a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28491d:	8d 50 01             	lea    0x1(%eax),%edx
  284920:	8b 45 24             	mov    0x24(%ebp),%eax
  284923:	83 ec 0c             	sub    $0xc,%esp
  284926:	51                   	push   %ecx
  284927:	52                   	push   %edx
  284928:	ff 75 20             	pushl  0x20(%ebp)
  28492b:	50                   	push   %eax
  28492c:	ff 75 bc             	pushl  -0x44(%ebp)
  28492f:	e8 02 e1 ff ff       	call   282a36 <sheet_refresh>
  284934:	83 c4 20             	add    $0x20,%esp
  284937:	e9 0d 07 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 8)
  28493c:	83 7d 1c 08          	cmpl   $0x8,0x1c(%ebp)
  284940:	75 3b                	jne    28497d <sys_api+0x2bf>
	{
		memman_init((struct MEMMAN *)(ebx + ds_base));
  284942:	8b 55 18             	mov    0x18(%ebp),%edx
  284945:	8b 45 e0             	mov    -0x20(%ebp),%eax
  284948:	01 d0                	add    %edx,%eax
  28494a:	83 ec 0c             	sub    $0xc,%esp
  28494d:	50                   	push   %eax
  28494e:	e8 98 d7 ff ff       	call   2820eb <memman_init>
  284953:	83 c4 10             	add    $0x10,%esp
		ecx &= 0xfffffff0;
  284956:	83 65 20 f0          	andl   $0xfffffff0,0x20(%ebp)
		memman_free((struct MEMMAN *)(ebx + ds_base),eax,ecx);
  28495a:	8b 45 20             	mov    0x20(%ebp),%eax
  28495d:	8b 55 24             	mov    0x24(%ebp),%edx
  284960:	89 d3                	mov    %edx,%ebx
  284962:	8b 4d 18             	mov    0x18(%ebp),%ecx
  284965:	8b 55 e0             	mov    -0x20(%ebp),%edx
  284968:	01 ca                	add    %ecx,%edx
  28496a:	83 ec 04             	sub    $0x4,%esp
  28496d:	50                   	push   %eax
  28496e:	53                   	push   %ebx
  28496f:	52                   	push   %edx
  284970:	e8 c5 d8 ff ff       	call   28223a <memman_free>
  284975:	83 c4 10             	add    $0x10,%esp
  284978:	e9 cc 06 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 9)
  28497d:	83 7d 1c 09          	cmpl   $0x9,0x1c(%ebp)
  284981:	75 31                	jne    2849b4 <sys_api+0x2f6>
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;
  284983:	8b 45 20             	mov    0x20(%ebp),%eax
  284986:	83 c0 0f             	add    $0xf,%eax
  284989:	83 e0 f0             	and    $0xfffffff0,%eax
  28498c:	89 45 20             	mov    %eax,0x20(%ebp)
		reg[7] = memman_alloc((struct MEMMAN *) (ebx + ds_base), ecx);
  28498f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284992:	8d 58 1c             	lea    0x1c(%eax),%ebx
  284995:	8b 45 20             	mov    0x20(%ebp),%eax
  284998:	8b 4d 18             	mov    0x18(%ebp),%ecx
  28499b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  28499e:	01 ca                	add    %ecx,%edx
  2849a0:	83 ec 08             	sub    $0x8,%esp
  2849a3:	50                   	push   %eax
  2849a4:	52                   	push   %edx
  2849a5:	e8 a7 d7 ff ff       	call   282151 <memman_alloc>
  2849aa:	83 c4 10             	add    $0x10,%esp
  2849ad:	89 03                	mov    %eax,(%ebx)
  2849af:	e9 95 06 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 10)
  2849b4:	83 7d 1c 0a          	cmpl   $0xa,0x1c(%ebp)
  2849b8:	75 2f                	jne    2849e9 <sys_api+0x32b>
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;
  2849ba:	8b 45 20             	mov    0x20(%ebp),%eax
  2849bd:	83 c0 0f             	add    $0xf,%eax
  2849c0:	83 e0 f0             	and    $0xfffffff0,%eax
  2849c3:	89 45 20             	mov    %eax,0x20(%ebp)
		memman_free((struct MEMMAN *)(edx + ds_base),eax,ecx);
  2849c6:	8b 45 20             	mov    0x20(%ebp),%eax
  2849c9:	8b 55 24             	mov    0x24(%ebp),%edx
  2849cc:	89 d3                	mov    %edx,%ebx
  2849ce:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  2849d1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  2849d4:	01 ca                	add    %ecx,%edx
  2849d6:	83 ec 04             	sub    $0x4,%esp
  2849d9:	50                   	push   %eax
  2849da:	53                   	push   %ebx
  2849db:	52                   	push   %edx
  2849dc:	e8 59 d8 ff ff       	call   28223a <memman_free>
  2849e1:	83 c4 10             	add    $0x10,%esp
  2849e4:	e9 60 06 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 11)
  2849e9:	83 7d 1c 0b          	cmpl   $0xb,0x1c(%ebp)
  2849ed:	75 58                	jne    284a47 <sys_api+0x389>
	{
		sht = (struct SHEET *)ebx;
  2849ef:	8b 45 18             	mov    0x18(%ebp),%eax
  2849f2:	89 45 bc             	mov    %eax,-0x44(%ebp)
		sht->buf[sht->bxsize * edi + esi] = eax;
  2849f5:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2849f8:	8b 10                	mov    (%eax),%edx
  2849fa:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2849fd:	8b 40 04             	mov    0x4(%eax),%eax
  284a00:	0f af 45 08          	imul   0x8(%ebp),%eax
  284a04:	89 c1                	mov    %eax,%ecx
  284a06:	8b 45 0c             	mov    0xc(%ebp),%eax
  284a09:	01 c8                	add    %ecx,%eax
  284a0b:	01 d0                	add    %edx,%eax
  284a0d:	8b 55 24             	mov    0x24(%ebp),%edx
  284a10:	88 10                	mov    %dl,(%eax)
		if(!(ebx&1))
  284a12:	8b 45 18             	mov    0x18(%ebp),%eax
  284a15:	83 e0 01             	and    $0x1,%eax
  284a18:	85 c0                	test   %eax,%eax
  284a1a:	0f 85 29 06 00 00    	jne    285049 <sys_api+0x98b>
			sheet_refresh(sht,esi,edi,esi+1,edi+1);
  284a20:	8b 45 08             	mov    0x8(%ebp),%eax
  284a23:	8d 50 01             	lea    0x1(%eax),%edx
  284a26:	8b 45 0c             	mov    0xc(%ebp),%eax
  284a29:	83 c0 01             	add    $0x1,%eax
  284a2c:	83 ec 0c             	sub    $0xc,%esp
  284a2f:	52                   	push   %edx
  284a30:	50                   	push   %eax
  284a31:	ff 75 08             	pushl  0x8(%ebp)
  284a34:	ff 75 0c             	pushl  0xc(%ebp)
  284a37:	ff 75 bc             	pushl  -0x44(%ebp)
  284a3a:	e8 f7 df ff ff       	call   282a36 <sheet_refresh>
  284a3f:	83 c4 20             	add    $0x20,%esp
  284a42:	e9 02 06 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 12)
  284a47:	83 7d 1c 0c          	cmpl   $0xc,0x1c(%ebp)
  284a4b:	75 26                	jne    284a73 <sys_api+0x3b5>
	{
		sht = (struct SHEET *)ebx;
  284a4d:	8b 45 18             	mov    0x18(%ebp),%eax
  284a50:	89 45 bc             	mov    %eax,-0x44(%ebp)
		sheet_refresh(sht,eax,ecx,esi,edi);
  284a53:	8b 45 24             	mov    0x24(%ebp),%eax
  284a56:	83 ec 0c             	sub    $0xc,%esp
  284a59:	ff 75 08             	pushl  0x8(%ebp)
  284a5c:	ff 75 0c             	pushl  0xc(%ebp)
  284a5f:	ff 75 20             	pushl  0x20(%ebp)
  284a62:	50                   	push   %eax
  284a63:	ff 75 bc             	pushl  -0x44(%ebp)
  284a66:	e8 cb df ff ff       	call   282a36 <sheet_refresh>
  284a6b:	83 c4 20             	add    $0x20,%esp
  284a6e:	e9 d6 05 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 13)
  284a73:	83 7d 1c 0d          	cmpl   $0xd,0x1c(%ebp)
  284a77:	75 5d                	jne    284ad6 <sys_api+0x418>
	{
		sht = (struct SHEET *)(ebx & 0xfffffffe);
  284a79:	8b 45 18             	mov    0x18(%ebp),%eax
  284a7c:	83 e0 fe             	and    $0xfffffffe,%eax
  284a7f:	89 45 bc             	mov    %eax,-0x44(%ebp)
		drawline8_sht(sht,eax,ecx,esi,edi,ebp);
  284a82:	8b 45 24             	mov    0x24(%ebp),%eax
  284a85:	83 ec 08             	sub    $0x8,%esp
  284a88:	ff 75 10             	pushl  0x10(%ebp)
  284a8b:	ff 75 08             	pushl  0x8(%ebp)
  284a8e:	ff 75 0c             	pushl  0xc(%ebp)
  284a91:	ff 75 20             	pushl  0x20(%ebp)
  284a94:	50                   	push   %eax
  284a95:	ff 75 bc             	pushl  -0x44(%ebp)
  284a98:	e8 01 c8 ff ff       	call   28129e <drawline8_sht>
  284a9d:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  284aa0:	8b 45 18             	mov    0x18(%ebp),%eax
  284aa3:	83 e0 01             	and    $0x1,%eax
  284aa6:	85 c0                	test   %eax,%eax
  284aa8:	0f 85 9b 05 00 00    	jne    285049 <sys_api+0x98b>
			sheet_refresh(sht,eax,ecx,esi+1,edi+1);
  284aae:	8b 45 08             	mov    0x8(%ebp),%eax
  284ab1:	8d 48 01             	lea    0x1(%eax),%ecx
  284ab4:	8b 45 0c             	mov    0xc(%ebp),%eax
  284ab7:	8d 50 01             	lea    0x1(%eax),%edx
  284aba:	8b 45 24             	mov    0x24(%ebp),%eax
  284abd:	83 ec 0c             	sub    $0xc,%esp
  284ac0:	51                   	push   %ecx
  284ac1:	52                   	push   %edx
  284ac2:	ff 75 20             	pushl  0x20(%ebp)
  284ac5:	50                   	push   %eax
  284ac6:	ff 75 bc             	pushl  -0x44(%ebp)
  284ac9:	e8 68 df ff ff       	call   282a36 <sheet_refresh>
  284ace:	83 c4 20             	add    $0x20,%esp
  284ad1:	e9 73 05 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 14)
  284ad6:	83 7d 1c 0e          	cmpl   $0xe,0x1c(%ebp)
  284ada:	75 14                	jne    284af0 <sys_api+0x432>
	{
		sheet_free((struct SHEET *)ebx);
  284adc:	8b 45 18             	mov    0x18(%ebp),%eax
  284adf:	83 ec 0c             	sub    $0xc,%esp
  284ae2:	50                   	push   %eax
  284ae3:	e8 ca e0 ff ff       	call   282bb2 <sheet_free>
  284ae8:	83 c4 10             	add    $0x10,%esp
  284aeb:	e9 59 05 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 15)
  284af0:	83 7d 1c 0f          	cmpl   $0xf,0x1c(%ebp)
  284af4:	0f 85 f3 00 00 00    	jne    284bed <sys_api+0x52f>
	{
		for(;;)
		{
			io_cli();
  284afa:	e8 c3 bf ff ff       	call   280ac2 <io_cli>
			if(fifo32_status(&task->fifo) == 0)
  284aff:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284b02:	83 c0 10             	add    $0x10,%eax
  284b05:	83 ec 0c             	sub    $0xc,%esp
  284b08:	50                   	push   %eax
  284b09:	e8 a8 d2 ff ff       	call   281db6 <fifo32_status>
  284b0e:	83 c4 10             	add    $0x10,%esp
  284b11:	85 c0                	test   %eax,%eax
  284b13:	75 32                	jne    284b47 <sys_api+0x489>
			{
				if(eax != 0)
  284b15:	8b 45 24             	mov    0x24(%ebp),%eax
  284b18:	85 c0                	test   %eax,%eax
  284b1a:	74 10                	je     284b2c <sys_api+0x46e>
					task_sleep(task);
  284b1c:	83 ec 0c             	sub    $0xc,%esp
  284b1f:	ff 75 e8             	pushl  -0x18(%ebp)
  284b22:	e8 5f e8 ff ff       	call   283386 <task_sleep>
  284b27:	83 c4 10             	add    $0x10,%esp
  284b2a:	eb 1b                	jmp    284b47 <sys_api+0x489>
				else
				{
					io_sti();
  284b2c:	e8 93 bf ff ff       	call   280ac4 <io_sti>
					reg[7] = -1;
  284b31:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284b34:	83 c0 1c             	add    $0x1c,%eax
  284b37:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
					return 0;
  284b3d:	b8 00 00 00 00       	mov    $0x0,%eax
  284b42:	e9 07 05 00 00       	jmp    28504e <sys_api+0x990>
				}
			}
			int i = fifo32_get(&task->fifo);
  284b47:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284b4a:	83 c0 10             	add    $0x10,%eax
  284b4d:	83 ec 0c             	sub    $0xc,%esp
  284b50:	50                   	push   %eax
  284b51:	e8 25 d2 ff ff       	call   281d7b <fifo32_get>
  284b56:	83 c4 10             	add    $0x10,%esp
  284b59:	89 45 d0             	mov    %eax,-0x30(%ebp)
			io_sti();
  284b5c:	e8 63 bf ff ff       	call   280ac4 <io_sti>
			if(i <= 1)
  284b61:	83 7d d0 01          	cmpl   $0x1,-0x30(%ebp)
  284b65:	7f 34                	jg     284b9b <sys_api+0x4dd>
			{
				timer_init(cons->timer,&task->fifo,1);
  284b67:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284b6a:	8d 50 10             	lea    0x10(%eax),%edx
  284b6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  284b70:	8b 40 10             	mov    0x10(%eax),%eax
  284b73:	83 ec 04             	sub    $0x4,%esp
  284b76:	6a 01                	push   $0x1
  284b78:	52                   	push   %edx
  284b79:	50                   	push   %eax
  284b7a:	e8 25 e1 ff ff       	call   282ca4 <timer_init>
  284b7f:	83 c4 10             	add    $0x10,%esp
				timer_settime(cons->timer,50);
  284b82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  284b85:	8b 40 10             	mov    0x10(%eax),%eax
  284b88:	83 ec 08             	sub    $0x8,%esp
  284b8b:	6a 32                	push   $0x32
  284b8d:	50                   	push   %eax
  284b8e:	e8 25 e1 ff ff       	call   282cb8 <timer_settime>
  284b93:	83 c4 10             	add    $0x10,%esp
  284b96:	e9 5f ff ff ff       	jmp    284afa <sys_api+0x43c>
			}
			else if(i == 2)
  284b9b:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
  284b9f:	75 0f                	jne    284bb0 <sys_api+0x4f2>
			{
				cons->cur_c = COL8_FFFFFF;
  284ba1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  284ba4:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
  284bab:	e9 4a ff ff ff       	jmp    284afa <sys_api+0x43c>
			}
			else if(i == 3)
  284bb0:	83 7d d0 03          	cmpl   $0x3,-0x30(%ebp)
  284bb4:	75 0f                	jne    284bc5 <sys_api+0x507>
			{
				cons->cur_c = -1;
  284bb6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  284bb9:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
  284bc0:	e9 35 ff ff ff       	jmp    284afa <sys_api+0x43c>
			}
			else if(i>=256)
  284bc5:	81 7d d0 ff 00 00 00 	cmpl   $0xff,-0x30(%ebp)
  284bcc:	0f 8e 28 ff ff ff    	jle    284afa <sys_api+0x43c>
			{
				reg[7] = i-256;
  284bd2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284bd5:	83 c0 1c             	add    $0x1c,%eax
  284bd8:	8b 55 d0             	mov    -0x30(%ebp),%edx
  284bdb:	81 ea 00 01 00 00    	sub    $0x100,%edx
  284be1:	89 10                	mov    %edx,(%eax)
				return 0;
  284be3:	b8 00 00 00 00       	mov    $0x0,%eax
  284be8:	e9 61 04 00 00       	jmp    28504e <sys_api+0x990>
			}
		}
	}
	else if(edx == 16)
  284bed:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  284bf1:	75 1e                	jne    284c11 <sys_api+0x553>
	{
		reg[7] = (int)timer_alloc();
  284bf3:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284bf6:	8d 58 1c             	lea    0x1c(%eax),%ebx
  284bf9:	e8 d8 df ff ff       	call   282bd6 <timer_alloc>
  284bfe:	89 03                	mov    %eax,(%ebx)
		((struct TIMER *)reg[7])->flags2 = 1;
  284c00:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284c03:	83 c0 1c             	add    $0x1c,%eax
  284c06:	8b 00                	mov    (%eax),%eax
  284c08:	c6 40 09 01          	movb   $0x1,0x9(%eax)
  284c0c:	e9 38 04 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 17)
  284c11:	83 7d 1c 11          	cmpl   $0x11,0x1c(%ebp)
  284c15:	75 25                	jne    284c3c <sys_api+0x57e>
	{
		timer_init((struct TIMER *)ebx,&task->fifo,eax+256);
  284c17:	8b 45 24             	mov    0x24(%ebp),%eax
  284c1a:	8d 88 00 01 00 00    	lea    0x100(%eax),%ecx
  284c20:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284c23:	8d 50 10             	lea    0x10(%eax),%edx
  284c26:	8b 45 18             	mov    0x18(%ebp),%eax
  284c29:	83 ec 04             	sub    $0x4,%esp
  284c2c:	51                   	push   %ecx
  284c2d:	52                   	push   %edx
  284c2e:	50                   	push   %eax
  284c2f:	e8 70 e0 ff ff       	call   282ca4 <timer_init>
  284c34:	83 c4 10             	add    $0x10,%esp
  284c37:	e9 0d 04 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 18)
  284c3c:	83 7d 1c 12          	cmpl   $0x12,0x1c(%ebp)
  284c40:	75 1a                	jne    284c5c <sys_api+0x59e>
	{
		timer_settime((struct TIMER *)ebx,eax);
  284c42:	8b 45 24             	mov    0x24(%ebp),%eax
  284c45:	89 c2                	mov    %eax,%edx
  284c47:	8b 45 18             	mov    0x18(%ebp),%eax
  284c4a:	83 ec 08             	sub    $0x8,%esp
  284c4d:	52                   	push   %edx
  284c4e:	50                   	push   %eax
  284c4f:	e8 64 e0 ff ff       	call   282cb8 <timer_settime>
  284c54:	83 c4 10             	add    $0x10,%esp
  284c57:	e9 ed 03 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 19)
  284c5c:	83 7d 1c 13          	cmpl   $0x13,0x1c(%ebp)
  284c60:	75 14                	jne    284c76 <sys_api+0x5b8>
	{
		timer_free((struct TIMER *)ebx);
  284c62:	8b 45 18             	mov    0x18(%ebp),%eax
  284c65:	83 ec 0c             	sub    $0xc,%esp
  284c68:	50                   	push   %eax
  284c69:	e8 2a e0 ff ff       	call   282c98 <timer_free>
  284c6e:	83 c4 10             	add    $0x10,%esp
  284c71:	e9 d3 03 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 20)
  284c76:	83 7d 1c 14          	cmpl   $0x14,0x1c(%ebp)
  284c7a:	0f 85 a4 00 00 00    	jne    284d24 <sys_api+0x666>
	{
		if(eax == 0)
  284c80:	8b 45 24             	mov    0x24(%ebp),%eax
  284c83:	85 c0                	test   %eax,%eax
  284c85:	75 29                	jne    284cb0 <sys_api+0x5f2>
		{
			int i = io_in8(0x61);
  284c87:	83 ec 0c             	sub    $0xc,%esp
  284c8a:	6a 61                	push   $0x61
  284c8c:	e8 43 be ff ff       	call   280ad4 <io_in8>
  284c91:	83 c4 10             	add    $0x10,%esp
  284c94:	89 45 cc             	mov    %eax,-0x34(%ebp)
			io_out8(0x61,i&0x0d);
  284c97:	8b 45 cc             	mov    -0x34(%ebp),%eax
  284c9a:	83 e0 0d             	and    $0xd,%eax
  284c9d:	83 ec 08             	sub    $0x8,%esp
  284ca0:	50                   	push   %eax
  284ca1:	6a 61                	push   $0x61
  284ca3:	e8 4e be ff ff       	call   280af6 <io_out8>
  284ca8:	83 c4 10             	add    $0x10,%esp
  284cab:	e9 99 03 00 00       	jmp    285049 <sys_api+0x98b>
		}
		else
		{
			int i = 1193180000/eax;
  284cb0:	8b 5d 24             	mov    0x24(%ebp),%ebx
  284cb3:	b8 60 7b 1e 47       	mov    $0x471e7b60,%eax
  284cb8:	99                   	cltd   
  284cb9:	f7 fb                	idiv   %ebx
  284cbb:	89 45 c8             	mov    %eax,-0x38(%ebp)
			io_out8(0x43,0xb6);
  284cbe:	83 ec 08             	sub    $0x8,%esp
  284cc1:	68 b6 00 00 00       	push   $0xb6
  284cc6:	6a 43                	push   $0x43
  284cc8:	e8 29 be ff ff       	call   280af6 <io_out8>
  284ccd:	83 c4 10             	add    $0x10,%esp
			io_out8(0x42,i&0xff);
  284cd0:	8b 45 c8             	mov    -0x38(%ebp),%eax
  284cd3:	0f b6 c0             	movzbl %al,%eax
  284cd6:	83 ec 08             	sub    $0x8,%esp
  284cd9:	50                   	push   %eax
  284cda:	6a 42                	push   $0x42
  284cdc:	e8 15 be ff ff       	call   280af6 <io_out8>
  284ce1:	83 c4 10             	add    $0x10,%esp
			io_out8(0x42,i>>8);
  284ce4:	8b 45 c8             	mov    -0x38(%ebp),%eax
  284ce7:	c1 f8 08             	sar    $0x8,%eax
  284cea:	83 ec 08             	sub    $0x8,%esp
  284ced:	50                   	push   %eax
  284cee:	6a 42                	push   $0x42
  284cf0:	e8 01 be ff ff       	call   280af6 <io_out8>
  284cf5:	83 c4 10             	add    $0x10,%esp
			i=io_in8(0x61);
  284cf8:	83 ec 0c             	sub    $0xc,%esp
  284cfb:	6a 61                	push   $0x61
  284cfd:	e8 d2 bd ff ff       	call   280ad4 <io_in8>
  284d02:	83 c4 10             	add    $0x10,%esp
  284d05:	89 45 c8             	mov    %eax,-0x38(%ebp)
			io_out8(0x61,(i|0x03)&0x0f);
  284d08:	8b 45 c8             	mov    -0x38(%ebp),%eax
  284d0b:	83 e0 0c             	and    $0xc,%eax
  284d0e:	83 c8 03             	or     $0x3,%eax
  284d11:	83 ec 08             	sub    $0x8,%esp
  284d14:	50                   	push   %eax
  284d15:	6a 61                	push   $0x61
  284d17:	e8 da bd ff ff       	call   280af6 <io_out8>
  284d1c:	83 c4 10             	add    $0x10,%esp
  284d1f:	e9 25 03 00 00       	jmp    285049 <sys_api+0x98b>
		}
	}
	else if(edx == 21)
  284d24:	83 7d 1c 15          	cmpl   $0x15,0x1c(%ebp)
  284d28:	0f 85 06 01 00 00    	jne    284e34 <sys_api+0x776>
	{

		int i = 0;
  284d2e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for(;i<8;i++)
  284d35:	eb 21                	jmp    284d58 <sys_api+0x69a>
		{
			if(task->fhandle[i].buf == 0)
  284d37:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284d3a:	8b 88 b0 00 00 00    	mov    0xb0(%eax),%ecx
  284d40:	8b 55 f4             	mov    -0xc(%ebp),%edx
  284d43:	89 d0                	mov    %edx,%eax
  284d45:	01 c0                	add    %eax,%eax
  284d47:	01 d0                	add    %edx,%eax
  284d49:	c1 e0 02             	shl    $0x2,%eax
  284d4c:	01 c8                	add    %ecx,%eax
  284d4e:	8b 00                	mov    (%eax),%eax
  284d50:	85 c0                	test   %eax,%eax
  284d52:	74 0c                	je     284d60 <sys_api+0x6a2>
	}
	else if(edx == 21)
	{

		int i = 0;
		for(;i<8;i++)
  284d54:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
  284d58:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
  284d5c:	7e d9                	jle    284d37 <sys_api+0x679>
  284d5e:	eb 01                	jmp    284d61 <sys_api+0x6a3>
		{
			if(task->fhandle[i].buf == 0)
				break;
  284d60:	90                   	nop
		}
		fh = &task->fhandle[i];
  284d61:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284d64:	8b 88 b0 00 00 00    	mov    0xb0(%eax),%ecx
  284d6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  284d6d:	89 d0                	mov    %edx,%eax
  284d6f:	01 c0                	add    %eax,%eax
  284d71:	01 d0                	add    %edx,%eax
  284d73:	c1 e0 02             	shl    $0x2,%eax
  284d76:	01 c8                	add    %ecx,%eax
  284d78:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		reg[7] = 0;
  284d7b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284d7e:	83 c0 1c             	add    $0x1c,%eax
  284d81:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if(i<8) 
  284d87:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
  284d8b:	0f 8f b8 02 00 00    	jg     285049 <sys_api+0x98b>
		{
			finfo = file_search((char *)ebx + ds_base,(struct FILEINFO *)(ADR_DISKIMG+0x002600),224);
  284d91:	8b 55 e0             	mov    -0x20(%ebp),%edx
  284d94:	8b 45 18             	mov    0x18(%ebp),%eax
  284d97:	01 d0                	add    %edx,%eax
  284d99:	83 ec 04             	sub    $0x4,%esp
  284d9c:	68 e0 00 00 00       	push   $0xe0
  284da1:	68 00 26 10 00       	push   $0x102600
  284da6:	50                   	push   %eax
  284da7:	e8 c1 ea ff ff       	call   28386d <file_search>
  284dac:	83 c4 10             	add    $0x10,%esp
  284daf:	89 45 c0             	mov    %eax,-0x40(%ebp)
			if(finfo != 0 )
  284db2:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  284db6:	0f 84 8d 02 00 00    	je     285049 <sys_api+0x98b>
			{
				reg[7] = (int)fh;
  284dbc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284dbf:	8d 50 1c             	lea    0x1c(%eax),%edx
  284dc2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284dc5:	89 02                	mov    %eax,(%edx)
				fh->buf = (char *)memman_alloc_4k(memman,finfo->size);
  284dc7:	8b 45 c0             	mov    -0x40(%ebp),%eax
  284dca:	8b 40 3c             	mov    0x3c(%eax),%eax
  284dcd:	83 ec 08             	sub    $0x8,%esp
  284dd0:	50                   	push   %eax
  284dd1:	ff 75 d4             	pushl  -0x2c(%ebp)
  284dd4:	e8 b4 d6 ff ff       	call   28248d <memman_alloc_4k>
  284dd9:	83 c4 10             	add    $0x10,%esp
  284ddc:	89 c2                	mov    %eax,%edx
  284dde:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284de1:	89 10                	mov    %edx,(%eax)
				fh->size= finfo->size;
  284de3:	8b 45 c0             	mov    -0x40(%ebp),%eax
  284de6:	8b 40 3c             	mov    0x3c(%eax),%eax
  284de9:	89 c2                	mov    %eax,%edx
  284deb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284dee:	89 50 04             	mov    %edx,0x4(%eax)
				fh->pos = 0;
  284df1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284df4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
				file_loadfile(finfo->clustno,finfo->size,fh->buf,task->fat,(char *)(ADR_DISKIMG + 0x003e00));
  284dfb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284dfe:	8b 88 b4 00 00 00    	mov    0xb4(%eax),%ecx
  284e04:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284e07:	8b 10                	mov    (%eax),%edx
  284e09:	8b 45 c0             	mov    -0x40(%ebp),%eax
  284e0c:	8b 40 3c             	mov    0x3c(%eax),%eax
  284e0f:	89 c3                	mov    %eax,%ebx
  284e11:	8b 45 c0             	mov    -0x40(%ebp),%eax
  284e14:	0f b7 40 3a          	movzwl 0x3a(%eax),%eax
  284e18:	0f b7 c0             	movzwl %ax,%eax
  284e1b:	83 ec 0c             	sub    $0xc,%esp
  284e1e:	68 00 3e 10 00       	push   $0x103e00
  284e23:	51                   	push   %ecx
  284e24:	52                   	push   %edx
  284e25:	53                   	push   %ebx
  284e26:	50                   	push   %eax
  284e27:	e8 9a e9 ff ff       	call   2837c6 <file_loadfile>
  284e2c:	83 c4 20             	add    $0x20,%esp
  284e2f:	e9 15 02 00 00       	jmp    285049 <sys_api+0x98b>
			}
		}
	}
	else if(edx == 22)
  284e34:	83 7d 1c 16          	cmpl   $0x16,0x1c(%ebp)
  284e38:	75 31                	jne    284e6b <sys_api+0x7ad>
	{
		fh = (struct FILEHANDLE *)eax;
  284e3a:	8b 45 24             	mov    0x24(%ebp),%eax
  284e3d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		memman_free_4k(memman,(int)fh->buf,fh->size);
  284e40:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284e43:	8b 40 04             	mov    0x4(%eax),%eax
  284e46:	89 c2                	mov    %eax,%edx
  284e48:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284e4b:	8b 00                	mov    (%eax),%eax
  284e4d:	83 ec 04             	sub    $0x4,%esp
  284e50:	52                   	push   %edx
  284e51:	50                   	push   %eax
  284e52:	ff 75 d4             	pushl  -0x2c(%ebp)
  284e55:	e8 5f d6 ff ff       	call   2824b9 <memman_free_4k>
  284e5a:	83 c4 10             	add    $0x10,%esp
		fh->buf = 0;
  284e5d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284e60:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  284e66:	e9 de 01 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 23)
  284e6b:	83 7d 1c 17          	cmpl   $0x17,0x1c(%ebp)
  284e6f:	0f 85 80 00 00 00    	jne    284ef5 <sys_api+0x837>
	{
		fh = (struct FILEHANDLE *)eax;
  284e75:	8b 45 24             	mov    0x24(%ebp),%eax
  284e78:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if(ecx == 0)
  284e7b:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
  284e7f:	75 0b                	jne    284e8c <sys_api+0x7ce>
		{
			fh->pos = ebx;
  284e81:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284e84:	8b 55 18             	mov    0x18(%ebp),%edx
  284e87:	89 50 08             	mov    %edx,0x8(%eax)
  284e8a:	eb 30                	jmp    284ebc <sys_api+0x7fe>
		}
		else if(ecx == 1)
  284e8c:	83 7d 20 01          	cmpl   $0x1,0x20(%ebp)
  284e90:	75 13                	jne    284ea5 <sys_api+0x7e7>
		{
			fh->pos += ebx;
  284e92:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284e95:	8b 50 08             	mov    0x8(%eax),%edx
  284e98:	8b 45 18             	mov    0x18(%ebp),%eax
  284e9b:	01 c2                	add    %eax,%edx
  284e9d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284ea0:	89 50 08             	mov    %edx,0x8(%eax)
  284ea3:	eb 17                	jmp    284ebc <sys_api+0x7fe>
		}
		else if(ecx == 2)
  284ea5:	83 7d 20 02          	cmpl   $0x2,0x20(%ebp)
  284ea9:	75 11                	jne    284ebc <sys_api+0x7fe>
		{
			fh->pos = fh->size+ebx;
  284eab:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284eae:	8b 50 04             	mov    0x4(%eax),%edx
  284eb1:	8b 45 18             	mov    0x18(%ebp),%eax
  284eb4:	01 c2                	add    %eax,%edx
  284eb6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284eb9:	89 50 08             	mov    %edx,0x8(%eax)
		}

		if(fh->pos < 0)
  284ebc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284ebf:	8b 40 08             	mov    0x8(%eax),%eax
  284ec2:	85 c0                	test   %eax,%eax
  284ec4:	79 0a                	jns    284ed0 <sys_api+0x812>
			fh->pos = 0;
  284ec6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284ec9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		if(fh->pos > fh->size)
  284ed0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284ed3:	8b 50 08             	mov    0x8(%eax),%edx
  284ed6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284ed9:	8b 40 04             	mov    0x4(%eax),%eax
  284edc:	39 c2                	cmp    %eax,%edx
  284ede:	0f 8e 65 01 00 00    	jle    285049 <sys_api+0x98b>
			fh->pos = fh->size;
  284ee4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284ee7:	8b 50 04             	mov    0x4(%eax),%edx
  284eea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284eed:	89 50 08             	mov    %edx,0x8(%eax)
  284ef0:	e9 54 01 00 00       	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 24)
  284ef5:	83 7d 1c 18          	cmpl   $0x18,0x1c(%ebp)
  284ef9:	75 5f                	jne    284f5a <sys_api+0x89c>
	{
		fh = (struct FILEHANDLE *)eax;
  284efb:	8b 45 24             	mov    0x24(%ebp),%eax
  284efe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if(ecx == 0)
  284f01:	83 7d 20 00          	cmpl   $0x0,0x20(%ebp)
  284f05:	75 13                	jne    284f1a <sys_api+0x85c>
		{
			reg[7] = fh->size;
  284f07:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284f0a:	8d 50 1c             	lea    0x1c(%eax),%edx
  284f0d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f10:	8b 40 04             	mov    0x4(%eax),%eax
  284f13:	89 02                	mov    %eax,(%edx)
  284f15:	e9 2f 01 00 00       	jmp    285049 <sys_api+0x98b>
		}
		else if(ecx == 1)
  284f1a:	83 7d 20 01          	cmpl   $0x1,0x20(%ebp)
  284f1e:	75 13                	jne    284f33 <sys_api+0x875>
		{
			reg[7] = fh->pos;
  284f20:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284f23:	8d 50 1c             	lea    0x1c(%eax),%edx
  284f26:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f29:	8b 40 08             	mov    0x8(%eax),%eax
  284f2c:	89 02                	mov    %eax,(%edx)
  284f2e:	e9 16 01 00 00       	jmp    285049 <sys_api+0x98b>
		}
		else if(ecx == 2)
  284f33:	83 7d 20 02          	cmpl   $0x2,0x20(%ebp)
  284f37:	0f 85 0c 01 00 00    	jne    285049 <sys_api+0x98b>
		{
			reg[7] = fh->pos - fh->size;
  284f3d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284f40:	8d 50 1c             	lea    0x1c(%eax),%edx
  284f43:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f46:	8b 48 08             	mov    0x8(%eax),%ecx
  284f49:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f4c:	8b 40 04             	mov    0x4(%eax),%eax
  284f4f:	29 c1                	sub    %eax,%ecx
  284f51:	89 c8                	mov    %ecx,%eax
  284f53:	89 02                	mov    %eax,(%edx)
  284f55:	e9 ef 00 00 00       	jmp    285049 <sys_api+0x98b>
		}
	}
	else if(edx == 25)
  284f5a:	83 7d 1c 19          	cmpl   $0x19,0x1c(%ebp)
  284f5e:	75 6b                	jne    284fcb <sys_api+0x90d>
	{
		fh = (struct FILEHANDLE *)eax;
  284f60:	8b 45 24             	mov    0x24(%ebp),%eax
  284f63:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		int i=0;
  284f66:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(;i<ecx;i++)
  284f6d:	eb 44                	jmp    284fb3 <sys_api+0x8f5>
		{
			if(fh->pos == fh->size)
  284f6f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f72:	8b 50 08             	mov    0x8(%eax),%edx
  284f75:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f78:	8b 40 04             	mov    0x4(%eax),%eax
  284f7b:	39 c2                	cmp    %eax,%edx
  284f7d:	74 3e                	je     284fbd <sys_api+0x8ff>
			{
				break;
			}
			*((char *)ebx+ds_base+i) = fh->buf[fh->pos];
  284f7f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  284f82:	8b 45 18             	mov    0x18(%ebp),%eax
  284f85:	01 c2                	add    %eax,%edx
  284f87:	8b 45 f0             	mov    -0x10(%ebp),%eax
  284f8a:	01 d0                	add    %edx,%eax
  284f8c:	89 c1                	mov    %eax,%ecx
  284f8e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f91:	8b 10                	mov    (%eax),%edx
  284f93:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284f96:	8b 40 08             	mov    0x8(%eax),%eax
  284f99:	01 d0                	add    %edx,%eax
  284f9b:	0f b6 00             	movzbl (%eax),%eax
  284f9e:	88 01                	mov    %al,(%ecx)
			fh->pos++;
  284fa0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284fa3:	8b 40 08             	mov    0x8(%eax),%eax
  284fa6:	8d 50 01             	lea    0x1(%eax),%edx
  284fa9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  284fac:	89 50 08             	mov    %edx,0x8(%eax)
	}
	else if(edx == 25)
	{
		fh = (struct FILEHANDLE *)eax;
		int i=0;
		for(;i<ecx;i++)
  284faf:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  284fb3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  284fb6:	3b 45 20             	cmp    0x20(%ebp),%eax
  284fb9:	7c b4                	jl     284f6f <sys_api+0x8b1>
  284fbb:	eb 01                	jmp    284fbe <sys_api+0x900>
		{
			if(fh->pos == fh->size)
			{
				break;
  284fbd:	90                   	nop
			}
			*((char *)ebx+ds_base+i) = fh->buf[fh->pos];
			fh->pos++;
		}
		reg[7] = i;
  284fbe:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284fc1:	8d 50 1c             	lea    0x1c(%eax),%edx
  284fc4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  284fc7:	89 02                	mov    %eax,(%edx)
  284fc9:	eb 7e                	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 26)
  284fcb:	83 7d 1c 1a          	cmpl   $0x1a,0x1c(%ebp)
  284fcf:	75 5d                	jne    28502e <sys_api+0x970>
	{
		int i=0;
  284fd1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		for(;;)
		{
			*((char *)ebx + ds_base +i) = task->cmdline[i];
  284fd8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  284fdb:	8b 45 18             	mov    0x18(%ebp),%eax
  284fde:	01 c2                	add    %eax,%edx
  284fe0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  284fe3:	01 d0                	add    %edx,%eax
  284fe5:	89 c1                	mov    %eax,%ecx
  284fe7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284fea:	8b 90 b8 00 00 00    	mov    0xb8(%eax),%edx
  284ff0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  284ff3:	01 d0                	add    %edx,%eax
  284ff5:	0f b6 00             	movzbl (%eax),%eax
  284ff8:	88 01                	mov    %al,(%ecx)
			if(task->cmdline[i] == 0)
  284ffa:	8b 45 e8             	mov    -0x18(%ebp),%eax
  284ffd:	8b 90 b8 00 00 00    	mov    0xb8(%eax),%edx
  285003:	8b 45 ec             	mov    -0x14(%ebp),%eax
  285006:	01 d0                	add    %edx,%eax
  285008:	0f b6 00             	movzbl (%eax),%eax
  28500b:	84 c0                	test   %al,%al
  28500d:	74 0e                	je     28501d <sys_api+0x95f>
				break;
			if(i >= ecx)
  28500f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  285012:	3b 45 20             	cmp    0x20(%ebp),%eax
  285015:	7d 09                	jge    285020 <sys_api+0x962>
				break;
			i++;
  285017:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
		}
  28501b:	eb bb                	jmp    284fd8 <sys_api+0x91a>
		int i=0;
		for(;;)
		{
			*((char *)ebx + ds_base +i) = task->cmdline[i];
			if(task->cmdline[i] == 0)
				break;
  28501d:	90                   	nop
  28501e:	eb 01                	jmp    285021 <sys_api+0x963>
			if(i >= ecx)
				break;
  285020:	90                   	nop
			i++;
		}
		reg[7] = i;
  285021:	8b 45 d8             	mov    -0x28(%ebp),%eax
  285024:	8d 50 1c             	lea    0x1c(%eax),%edx
  285027:	8b 45 ec             	mov    -0x14(%ebp),%eax
  28502a:	89 02                	mov    %eax,(%edx)
  28502c:	eb 1b                	jmp    285049 <sys_api+0x98b>
	}
	else if(edx == 27)
  28502e:	83 7d 1c 1b          	cmpl   $0x1b,0x1c(%ebp)
  285032:	75 15                	jne    285049 <sys_api+0x98b>
	{
		reg[7] = task->langmode;
  285034:	8b 45 d8             	mov    -0x28(%ebp),%eax
  285037:	8d 50 1c             	lea    0x1c(%eax),%edx
  28503a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  28503d:	0f b6 80 bc 00 00 00 	movzbl 0xbc(%eax),%eax
  285044:	0f b6 c0             	movzbl %al,%eax
  285047:	89 02                	mov    %eax,(%edx)
	}
	return 0;
  285049:	b8 00 00 00 00       	mov    $0x0,%eax
}
  28504e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  285051:	c9                   	leave  
  285052:	c3                   	ret    
  285053:	66 90                	xchg   %ax,%ax
  285055:	66 90                	xchg   %ax,%ax
  285057:	66 90                	xchg   %ax,%ax
  285059:	66 90                	xchg   %ax,%ax
  28505b:	66 90                	xchg   %ax,%ax
  28505d:	66 90                	xchg   %ax,%ax
  28505f:	90                   	nop

00285060 <api_putchar>:
  285060:	ba 01 00 00 00       	mov    $0x1,%edx
  285065:	8a 44 24 04          	mov    0x4(%esp),%al
  285069:	cd 40                	int    $0x40
  28506b:	c3                   	ret    

0028506c <api_putstr>:
  28506c:	ba 02 00 00 00       	mov    $0x2,%edx
  285071:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  285075:	cd 40                	int    $0x40
  285077:	c3                   	ret    

00285078 <api_end>:
  285078:	ba 04 00 00 00       	mov    $0x4,%edx
  28507d:	cd 40                	int    $0x40

0028507f <api_test>:
  28507f:	05 80 00 00 00       	add    $0x80,%eax
  285084:	c3                   	ret    

00285085 <api_openwin>:
  285085:	57                   	push   %edi
  285086:	56                   	push   %esi
  285087:	53                   	push   %ebx
  285088:	ba 05 00 00 00       	mov    $0x5,%edx
  28508d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  285091:	8b 74 24 14          	mov    0x14(%esp),%esi
  285095:	8b 7c 24 18          	mov    0x18(%esp),%edi
  285099:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  28509d:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  2850a1:	cd 40                	int    $0x40
  2850a3:	5b                   	pop    %ebx
  2850a4:	5e                   	pop    %esi
  2850a5:	5f                   	pop    %edi
  2850a6:	c3                   	ret    

002850a7 <api_putstrwin>:
  2850a7:	57                   	push   %edi
  2850a8:	56                   	push   %esi
  2850a9:	55                   	push   %ebp
  2850aa:	53                   	push   %ebx
  2850ab:	ba 06 00 00 00       	mov    $0x6,%edx
  2850b0:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  2850b4:	8b 74 24 18          	mov    0x18(%esp),%esi
  2850b8:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  2850bc:	8b 44 24 20          	mov    0x20(%esp),%eax
  2850c0:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  2850c4:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  2850c8:	cd 40                	int    $0x40
  2850ca:	5b                   	pop    %ebx
  2850cb:	5d                   	pop    %ebp
  2850cc:	5e                   	pop    %esi
  2850cd:	5f                   	pop    %edi
  2850ce:	c3                   	ret    

002850cf <api_boxfilwin>:
  2850cf:	57                   	push   %edi
  2850d0:	56                   	push   %esi
  2850d1:	55                   	push   %ebp
  2850d2:	53                   	push   %ebx
  2850d3:	ba 07 00 00 00       	mov    $0x7,%edx
  2850d8:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  2850dc:	8b 44 24 18          	mov    0x18(%esp),%eax
  2850e0:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  2850e4:	8b 74 24 20          	mov    0x20(%esp),%esi
  2850e8:	8b 7c 24 24          	mov    0x24(%esp),%edi
  2850ec:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  2850f0:	cd 40                	int    $0x40
  2850f2:	5b                   	pop    %ebx
  2850f3:	5d                   	pop    %ebp
  2850f4:	5e                   	pop    %esi
  2850f5:	5f                   	pop    %edi
  2850f6:	c3                   	ret    

002850f7 <api_initmalloc>:
  2850f7:	53                   	push   %ebx
  2850f8:	ba 08 00 00 00       	mov    $0x8,%edx
  2850fd:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  285104:	89 d8                	mov    %ebx,%eax
  285106:	05 00 80 00 00       	add    $0x8000,%eax
  28510b:	2e 8b 0d 00 00 00 00 	mov    %cs:0x0,%ecx
  285112:	29 c1                	sub    %eax,%ecx
  285114:	cd 40                	int    $0x40
  285116:	5b                   	pop    %ebx
  285117:	c3                   	ret    

00285118 <api_malloc>:
  285118:	53                   	push   %ebx
  285119:	ba 09 00 00 00       	mov    $0x9,%edx
  28511e:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  285125:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  285129:	cd 40                	int    $0x40
  28512b:	5b                   	pop    %ebx
  28512c:	c3                   	ret    

0028512d <api_free>:
  28512d:	53                   	push   %ebx
  28512e:	ba 0a 00 00 00       	mov    $0xa,%edx
  285133:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  28513a:	8b 44 24 08          	mov    0x8(%esp),%eax
  28513e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  285142:	cd 40                	int    $0x40
  285144:	5b                   	pop    %ebx
  285145:	c3                   	ret    

00285146 <api_pointwin>:
  285146:	57                   	push   %edi
  285147:	56                   	push   %esi
  285148:	53                   	push   %ebx
  285149:	ba 0b 00 00 00       	mov    $0xb,%edx
  28514e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  285152:	8b 74 24 14          	mov    0x14(%esp),%esi
  285156:	8b 7c 24 18          	mov    0x18(%esp),%edi
  28515a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  28515e:	cd 40                	int    $0x40
  285160:	5b                   	pop    %ebx
  285161:	5e                   	pop    %esi
  285162:	5f                   	pop    %edi
  285163:	c3                   	ret    

00285164 <api_refreshwin>:
  285164:	57                   	push   %edi
  285165:	56                   	push   %esi
  285166:	53                   	push   %ebx
  285167:	ba 0c 00 00 00       	mov    $0xc,%edx
  28516c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  285170:	8b 44 24 14          	mov    0x14(%esp),%eax
  285174:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  285178:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  28517c:	8b 7c 24 20          	mov    0x20(%esp),%edi
  285180:	cd 40                	int    $0x40
  285182:	5b                   	pop    %ebx
  285183:	5e                   	pop    %esi
  285184:	5f                   	pop    %edi
  285185:	c3                   	ret    

00285186 <api_linewin>:
  285186:	57                   	push   %edi
  285187:	56                   	push   %esi
  285188:	55                   	push   %ebp
  285189:	53                   	push   %ebx
  28518a:	ba 0d 00 00 00       	mov    $0xd,%edx
  28518f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  285193:	8b 44 24 18          	mov    0x18(%esp),%eax
  285197:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  28519b:	8b 74 24 20          	mov    0x20(%esp),%esi
  28519f:	8b 7c 24 24          	mov    0x24(%esp),%edi
  2851a3:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  2851a7:	cd 40                	int    $0x40
  2851a9:	5b                   	pop    %ebx
  2851aa:	5d                   	pop    %ebp
  2851ab:	5e                   	pop    %esi
  2851ac:	5f                   	pop    %edi
  2851ad:	c3                   	ret    

002851ae <api_closewin>:
  2851ae:	53                   	push   %ebx
  2851af:	ba 0e 00 00 00       	mov    $0xe,%edx
  2851b4:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  2851b8:	cd 40                	int    $0x40
  2851ba:	5b                   	pop    %ebx
  2851bb:	c3                   	ret    

002851bc <api_getkey>:
  2851bc:	ba 0f 00 00 00       	mov    $0xf,%edx
  2851c1:	8b 44 24 04          	mov    0x4(%esp),%eax
  2851c5:	cd 40                	int    $0x40
  2851c7:	c3                   	ret    

002851c8 <api_alloctimer>:
  2851c8:	ba 10 00 00 00       	mov    $0x10,%edx
  2851cd:	cd 40                	int    $0x40
  2851cf:	c3                   	ret    

002851d0 <api_inittimer>:
  2851d0:	53                   	push   %ebx
  2851d1:	ba 11 00 00 00       	mov    $0x11,%edx
  2851d6:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  2851da:	8b 44 24 0c          	mov    0xc(%esp),%eax
  2851de:	cd 40                	int    $0x40
  2851e0:	5b                   	pop    %ebx
  2851e1:	c3                   	ret    

002851e2 <api_settimer>:
  2851e2:	53                   	push   %ebx
  2851e3:	ba 12 00 00 00       	mov    $0x12,%edx
  2851e8:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  2851ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
  2851f0:	cd 40                	int    $0x40
  2851f2:	5b                   	pop    %ebx
  2851f3:	c3                   	ret    

002851f4 <api_freetimer>:
  2851f4:	53                   	push   %ebx
  2851f5:	ba 13 00 00 00       	mov    $0x13,%edx
  2851fa:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  2851fe:	cd 40                	int    $0x40
  285200:	5b                   	pop    %ebx
  285201:	c3                   	ret    

00285202 <api_beep>:
  285202:	ba 14 00 00 00       	mov    $0x14,%edx
  285207:	8b 44 24 04          	mov    0x4(%esp),%eax
  28520b:	cd 40                	int    $0x40
  28520d:	c3                   	ret    

0028520e <api_fopen>:
  28520e:	53                   	push   %ebx
  28520f:	ba 15 00 00 00       	mov    $0x15,%edx
  285214:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  285218:	cd 40                	int    $0x40
  28521a:	5b                   	pop    %ebx
  28521b:	c3                   	ret    

0028521c <api_fclose>:
  28521c:	ba 16 00 00 00       	mov    $0x16,%edx
  285221:	8b 44 24 04          	mov    0x4(%esp),%eax
  285225:	cd 40                	int    $0x40
  285227:	c3                   	ret    

00285228 <api_seek>:
  285228:	53                   	push   %ebx
  285229:	ba 17 00 00 00       	mov    $0x17,%edx
  28522e:	8b 44 24 08          	mov    0x8(%esp),%eax
  285232:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  285236:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  28523a:	cd 40                	int    $0x40
  28523c:	5b                   	pop    %ebx
  28523d:	c3                   	ret    

0028523e <api_fsize>:
  28523e:	ba 18 00 00 00       	mov    $0x18,%edx
  285243:	8b 44 24 04          	mov    0x4(%esp),%eax
  285247:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  28524b:	cd 40                	int    $0x40
  28524d:	c3                   	ret    

0028524e <api_fread>:
  28524e:	53                   	push   %ebx
  28524f:	ba 19 00 00 00       	mov    $0x19,%edx
  285254:	8b 44 24 10          	mov    0x10(%esp),%eax
  285258:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  28525c:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  285260:	cd 40                	int    $0x40
  285262:	5b                   	pop    %ebx
  285263:	c3                   	ret    

00285264 <api_cmdline>:
  285264:	53                   	push   %ebx
  285265:	ba 1a 00 00 00       	mov    $0x1a,%edx
  28526a:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  28526e:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  285272:	cd 40                	int    $0x40
  285274:	5b                   	pop    %ebx
  285275:	c3                   	ret    

00285276 <api_getlang>:
  285276:	ba 1b 00 00 00       	mov    $0x1b,%edx
  28527b:	cd 40                	int    $0x40
  28527d:	c3                   	ret    

0028527e <change_wtitle8>:
	}
	return;
}

void change_wtitle8(struct SHEET *sht,char act)
{
  28527e:	55                   	push   %ebp
  28527f:	89 e5                	mov    %esp,%ebp
  285281:	57                   	push   %edi
  285282:	56                   	push   %esi
  285283:	53                   	push   %ebx
  285284:	83 ec 2c             	sub    $0x2c,%esp
  285287:	8b 45 0c             	mov    0xc(%ebp),%eax
	int x,y,xsize = sht->bxsize;
  28528a:	8b 7d 08             	mov    0x8(%ebp),%edi
  28528d:	8b 7f 04             	mov    0x4(%edi),%edi
  285290:	89 fe                	mov    %edi,%esi
  285292:	89 7d cc             	mov    %edi,-0x34(%ebp)
	else
	{
		tc_new = COL8_C6C6C6;
		tbc_new = COL8_848484;
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
  285295:	3c 01                	cmp    $0x1,%al
  285297:	19 ff                	sbb    %edi,%edi
  285299:	89 fb                	mov    %edi,%ebx
  28529b:	83 e3 fd             	and    $0xfffffffd,%ebx
  28529e:	83 c3 0f             	add    $0xf,%ebx
  2852a1:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  2852a4:	89 fb                	mov    %edi,%ebx
  2852a6:	83 c3 08             	add    $0x8,%ebx
  2852a9:	88 5d e7             	mov    %bl,-0x19(%ebp)
  2852ac:	83 e7 03             	and    $0x3,%edi
  2852af:	83 c7 0c             	add    $0xc,%edi
  2852b2:	3c 01                	cmp    $0x1,%al
  2852b4:	19 c0                	sbb    %eax,%eax
  2852b6:	f7 d0                	not    %eax
  2852b8:	83 c0 08             	add    $0x8,%eax
  2852bb:	88 45 e5             	mov    %al,-0x1b(%ebp)
  2852be:	89 f0                	mov    %esi,%eax
  2852c0:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  2852c3:	8d 0c 76             	lea    (%esi,%esi,2),%ecx
  2852c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2852c9:	03 0b                	add    (%ebx),%ecx
			{
				c = tc_new;
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
  2852cb:	c7 45 d8 12 00 00 00 	movl   $0x12,-0x28(%ebp)
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
  2852d2:	8d 5e fc             	lea    -0x4(%esi),%ebx
  2852d5:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  2852d8:	83 e8 03             	sub    $0x3,%eax
  2852db:	89 45 e0             	mov    %eax,-0x20(%ebp)
		{
			c = buf[y*xsize + x];
			if(c == tc_old && x<=xsize -22)
  2852de:	8d 46 ea             	lea    -0x16(%esi),%eax
  2852e1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  2852e4:	eb 32                	jmp    285318 <change_wtitle8+0x9a>
  2852e6:	89 ce                	mov    %ecx,%esi
  2852e8:	89 d3                	mov    %edx,%ebx
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
		{
			c = buf[y*xsize + x];
  2852ea:	0f b6 04 11          	movzbl (%ecx,%edx,1),%eax
			if(c == tc_old && x<=xsize -22)
  2852ee:	38 45 e7             	cmp    %al,-0x19(%ebp)
  2852f1:	75 05                	jne    2852f8 <change_wtitle8+0x7a>
  2852f3:	39 55 dc             	cmp    %edx,-0x24(%ebp)
  2852f6:	7d 08                	jge    285300 <change_wtitle8+0x82>
			{
				c = tc_new;
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
  2852f8:	38 45 e6             	cmp    %al,-0x1a(%ebp)
  2852fb:	0f 44 c7             	cmove  %edi,%eax
  2852fe:	eb 04                	jmp    285304 <change_wtitle8+0x86>
		for(x=3;x<=xsize-4;x++)
		{
			c = buf[y*xsize + x];
			if(c == tc_old && x<=xsize -22)
			{
				c = tc_new;
  285300:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
			}
			buf[y*xsize+x] = c;
  285304:	88 04 1e             	mov    %al,(%esi,%ebx,1)
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
  285307:	83 c2 01             	add    $0x1,%edx
  28530a:	3b 55 e0             	cmp    -0x20(%ebp),%edx
  28530d:	75 d7                	jne    2852e6 <change_wtitle8+0x68>
  28530f:	03 4d d4             	add    -0x2c(%ebp),%ecx
		tc_new = COL8_C6C6C6;
		tbc_new = COL8_848484;
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
  285312:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  285316:	74 0d                	je     285325 <change_wtitle8+0xa7>
	{
		for(x=3;x<=xsize-4;x++)
  285318:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
  28531c:	7e f1                	jle    28530f <change_wtitle8+0x91>
  28531e:	ba 03 00 00 00       	mov    $0x3,%edx
  285323:	eb c1                	jmp    2852e6 <change_wtitle8+0x68>
				c = tbc_new;
			}
			buf[y*xsize+x] = c;
		}
	}
	sheet_refresh(sht,3,3,xsize,21);
  285325:	83 ec 0c             	sub    $0xc,%esp
  285328:	6a 15                	push   $0x15
  28532a:	ff 75 cc             	pushl  -0x34(%ebp)
  28532d:	6a 03                	push   $0x3
  28532f:	6a 03                	push   $0x3
  285331:	ff 75 08             	pushl  0x8(%ebp)
  285334:	e8 fd d6 ff ff       	call   282a36 <sheet_refresh>
	return;
  285339:	83 c4 20             	add    $0x20,%esp
}
  28533c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28533f:	5b                   	pop    %ebx
  285340:	5e                   	pop    %esi
  285341:	5f                   	pop    %edi
  285342:	5d                   	pop    %ebp
  285343:	c3                   	ret    

00285344 <keywin_off>:
#include "common.h"
#include "graphics.h"
#include "memory.h"
#include "task_console.h"
void keywin_off(struct SHEET *key_win)
{
  285344:	55                   	push   %ebp
  285345:	89 e5                	mov    %esp,%ebp
  285347:	53                   	push   %ebx
  285348:	83 ec 0c             	sub    $0xc,%esp
  28534b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	change_wtitle8(key_win,0);
  28534e:	6a 00                	push   $0x0
  285350:	53                   	push   %ebx
  285351:	e8 28 ff ff ff       	call   28527e <change_wtitle8>
	if((key_win->flags & 0x20))
  285356:	83 c4 10             	add    $0x10,%esp
  285359:	f6 43 1c 20          	testb  $0x20,0x1c(%ebx)
  28535d:	74 14                	je     285373 <keywin_off+0x2f>
	{
		fifo32_put(&key_win->task->fifo,3);
  28535f:	83 ec 08             	sub    $0x8,%esp
  285362:	6a 03                	push   $0x3
  285364:	8b 43 24             	mov    0x24(%ebx),%eax
  285367:	83 c0 10             	add    $0x10,%eax
  28536a:	50                   	push   %eax
  28536b:	e8 99 c9 ff ff       	call   281d09 <fifo32_put>
  285370:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  285373:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  285376:	c9                   	leave  
  285377:	c3                   	ret    

00285378 <keywin_on>:

void keywin_on(struct SHEET *key_win)
{
  285378:	55                   	push   %ebp
  285379:	89 e5                	mov    %esp,%ebp
  28537b:	53                   	push   %ebx
  28537c:	83 ec 0c             	sub    $0xc,%esp
  28537f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	change_wtitle8(key_win,1);
  285382:	6a 01                	push   $0x1
  285384:	53                   	push   %ebx
  285385:	e8 f4 fe ff ff       	call   28527e <change_wtitle8>
	if((key_win->flags & 0x20))
  28538a:	83 c4 10             	add    $0x10,%esp
  28538d:	f6 43 1c 20          	testb  $0x20,0x1c(%ebx)
  285391:	74 14                	je     2853a7 <keywin_on+0x2f>
	{
		fifo32_put(&key_win->task->fifo,2);
  285393:	83 ec 08             	sub    $0x8,%esp
  285396:	6a 02                	push   $0x2
  285398:	8b 43 24             	mov    0x24(%ebx),%eax
  28539b:	83 c0 10             	add    $0x10,%eax
  28539e:	50                   	push   %eax
  28539f:	e8 65 c9 ff ff       	call   281d09 <fifo32_put>
  2853a4:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  2853a7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2853aa:	c9                   	leave  
  2853ab:	c3                   	ret    

002853ac <load_hanyu>:
#include "memory.h"
#include "const.h"
#include "file.h"
unsigned char *hanyu;
void load_hanyu()
{
  2853ac:	55                   	push   %ebp
  2853ad:	89 e5                	mov    %esp,%ebp
  2853af:	56                   	push   %esi
  2853b0:	53                   	push   %ebx
	int *fat;
	struct FILEINFO *finfo;
	extern char hankaku[4096];

	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	hanyu = (unsigned char *)memman_alloc_4k(memman,16*256+32*94*55);
  2853b1:	83 ec 08             	sub    $0x8,%esp
  2853b4:	68 40 96 02 00       	push   $0x29640
  2853b9:	68 00 00 3c 00       	push   $0x3c0000
  2853be:	e8 ca d0 ff ff       	call   28248d <memman_alloc_4k>
  2853c3:	a3 c4 a9 28 00       	mov    %eax,0x28a9c4
	fat = (int *)memman_alloc_4k(memman,4*2880);
  2853c8:	83 c4 08             	add    $0x8,%esp
  2853cb:	68 00 2d 00 00       	push   $0x2d00
  2853d0:	68 00 00 3c 00       	push   $0x3c0000
  2853d5:	e8 b3 d0 ff ff       	call   28248d <memman_alloc_4k>
  2853da:	89 c3                	mov    %eax,%ebx
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG + 0x000200));
  2853dc:	83 c4 08             	add    $0x8,%esp
  2853df:	68 00 02 10 00       	push   $0x100200
  2853e4:	50                   	push   %eax
  2853e5:	e8 27 e3 ff ff       	call   283711 <file_readfat>
	finfo = file_search("hz.fnt",(struct FILEINFO *)(ADR_DISKIMG + 0x002600),224);
  2853ea:	83 c4 0c             	add    $0xc,%esp
  2853ed:	68 e0 00 00 00       	push   $0xe0
  2853f2:	68 00 26 10 00       	push   $0x102600
  2853f7:	68 a4 58 28 00       	push   $0x2858a4
  2853fc:	e8 6c e4 ff ff       	call   28386d <file_search>
  285401:	89 c6                	mov    %eax,%esi
  285403:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<16*256;i++)
  285406:	ba 00 00 00 00       	mov    $0x0,%edx
		hanyu[i] = hankaku[i];
  28540b:	8b 0d c4 a9 28 00    	mov    0x28a9c4,%ecx
  285411:	0f b6 82 a0 68 28 00 	movzbl 0x2868a0(%edx),%eax
  285418:	88 04 11             	mov    %al,(%ecx,%edx,1)
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	hanyu = (unsigned char *)memman_alloc_4k(memman,16*256+32*94*55);
	fat = (int *)memman_alloc_4k(memman,4*2880);
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG + 0x000200));
	finfo = file_search("hz.fnt",(struct FILEINFO *)(ADR_DISKIMG + 0x002600),224);
	for(int i=0;i<16*256;i++)
  28541b:	83 c2 01             	add    $0x1,%edx
  28541e:	81 fa 00 10 00 00    	cmp    $0x1000,%edx
  285424:	75 e5                	jne    28540b <load_hanyu+0x5f>
		hanyu[i] = hankaku[i];
	if(finfo != 0)
  285426:	85 f6                	test   %esi,%esi
  285428:	74 27                	je     285451 <load_hanyu+0xa5>
		file_loadfile(finfo->clustno,finfo->size,hanyu+16*256,fat,(char *)(ADR_DISKIMG + 0x003e00));
  28542a:	83 ec 0c             	sub    $0xc,%esp
  28542d:	68 00 3e 10 00       	push   $0x103e00
  285432:	53                   	push   %ebx
  285433:	a1 c4 a9 28 00       	mov    0x28a9c4,%eax
  285438:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
  28543e:	52                   	push   %edx
  28543f:	ff 76 3c             	pushl  0x3c(%esi)
  285442:	0f b7 46 3a          	movzwl 0x3a(%esi),%eax
  285446:	50                   	push   %eax
  285447:	e8 7a e3 ff ff       	call   2837c6 <file_loadfile>
  28544c:	83 c4 20             	add    $0x20,%esp
  28544f:	eb 19                	jmp    28546a <load_hanyu+0xbe>
  285451:	b8 00 10 00 00       	mov    $0x1000,%eax
	else
	{
		for(int i=16*256;i<16*256+32*94*55;i++)
		{
			hanyu[i] = 0xff;
  285456:	8b 15 c4 a9 28 00    	mov    0x28a9c4,%edx
  28545c:	c6 04 02 ff          	movb   $0xff,(%edx,%eax,1)
		hanyu[i] = hankaku[i];
	if(finfo != 0)
		file_loadfile(finfo->clustno,finfo->size,hanyu+16*256,fat,(char *)(ADR_DISKIMG + 0x003e00));
	else
	{
		for(int i=16*256;i<16*256+32*94*55;i++)
  285460:	83 c0 01             	add    $0x1,%eax
  285463:	3d 40 96 02 00       	cmp    $0x29640,%eax
  285468:	75 ec                	jne    285456 <load_hanyu+0xaa>
		{
			hanyu[i] = 0xff;
		}
	}
	*((int *)0x0fe8) = (int) hanyu;
  28546a:	a1 c4 a9 28 00       	mov    0x28a9c4,%eax
  28546f:	a3 e8 0f 00 00       	mov    %eax,0xfe8
	memman_free_4k(memman,(int) fat,4*2880);
  285474:	83 ec 04             	sub    $0x4,%esp
  285477:	68 00 2d 00 00       	push   $0x2d00
  28547c:	53                   	push   %ebx
  28547d:	68 00 00 3c 00       	push   $0x3c0000
  285482:	e8 32 d0 ff ff       	call   2824b9 <memman_free_4k>
}
  285487:	83 c4 10             	add    $0x10,%esp
  28548a:	8d 65 f8             	lea    -0x8(%ebp),%esp
  28548d:	5b                   	pop    %ebx
  28548e:	5e                   	pop    %esi
  28548f:	5d                   	pop    %ebp
  285490:	c3                   	ret    

00285491 <test>:
#include "test.h"
int test(int screenx, int screeny)
{
  285491:	55                   	push   %ebp
  285492:	89 e5                	mov    %esp,%ebp
	return screenx*screeny;
  285494:	8b 45 0c             	mov    0xc(%ebp),%eax
  285497:	0f af 45 08          	imul   0x8(%ebp),%eax
}
  28549b:	5d                   	pop    %ebp
  28549c:	c3                   	ret    
