
main.out.o：     文件格式 elf32-i386


Disassembly of section .text:

00280000 <bootmain>:
#include "header.h"


int bootmain()
{
  280000:	55                   	push   %ebp
	//the buf for all strings.
	char s[50] = {0};
  280001:	31 c0                	xor    %eax,%eax
  280003:	b9 32 00 00 00       	mov    $0x32,%ecx
#include "header.h"


int bootmain()
{
  280008:	89 e5                	mov    %esp,%ebp
  28000a:	57                   	push   %edi
  28000b:	56                   	push   %esi
	//the buf for all strings.
	char s[50] = {0};
  28000c:	8d bd 36 fc ff ff    	lea    -0x3ca(%ebp),%edi
#include "header.h"


int bootmain()
{
  280012:	53                   	push   %ebx
	struct BOOTINFO *binfo = (struct BOOTINFO *)0xff0;

	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32],*cons_fifo[2];
	fifo32_init(&fifo,128,fifobuf,0);
  280013:	8d 9d fc fb ff ff    	lea    -0x404(%ebp),%ebx
	fifo32_init(&keycmd,32,keycmd_buf,0);
  280019:	8d b5 18 fc ff ff    	lea    -0x3e8(%ebp),%esi
#include "header.h"


int bootmain()
{
  28001f:	81 ec 5c 04 00 00    	sub    $0x45c,%esp
	//the buf for all strings.
	char s[50] = {0};
  280025:	f3 aa                	rep stos %al,%es:(%edi)
	struct BOOTINFO *binfo = (struct BOOTINFO *)0xff0;

	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32],*cons_fifo[2];
	fifo32_init(&fifo,128,fifobuf,0);
  280027:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
  28002d:	6a 00                	push   $0x0
  28002f:	50                   	push   %eax
  280030:	68 80 00 00 00       	push   $0x80
  280035:	53                   	push   %ebx
  280036:	e8 2d 1a 00 00       	call   281a68 <fifo32_init>
	fifo32_init(&keycmd,32,keycmd_buf,0);
  28003b:	8d 85 68 fc ff ff    	lea    -0x398(%ebp),%eax
  280041:	6a 00                	push   $0x0
  280043:	50                   	push   %eax
  280044:	6a 20                	push   $0x20
  280046:	56                   	push   %esi
  280047:	e8 1c 1a 00 00       	call   281a68 <fifo32_init>

	int key_leds = (binfo->leds>>4)&7;
  28004c:	a0 f1 0f 00 00       	mov    0xff1,%al

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280051:	83 c4 18             	add    $0x18,%esp
  280054:	68 ed 00 00 00       	push   $0xed
  280059:	56                   	push   %esi
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32],*cons_fifo[2];
	fifo32_init(&fifo,128,fifobuf,0);
	fifo32_init(&keycmd,32,keycmd_buf,0);

	int key_leds = (binfo->leds>>4)&7;
  28005a:	c0 f8 04             	sar    $0x4,%al
  28005d:	83 e0 07             	and    $0x7,%eax
  280060:	89 85 c8 fb ff ff    	mov    %eax,-0x438(%ebp)

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280066:	e8 2e 1a 00 00       	call   281a99 <fifo32_put>
	fifo32_put(&keycmd,key_leds);
  28006b:	58                   	pop    %eax
  28006c:	5a                   	pop    %edx
  28006d:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  280073:	56                   	push   %esi
  280074:	e8 20 1a 00 00       	call   281a99 <fifo32_put>

	//init gdt idt pic and enable cpu interrupt
	init_gdtidt();
  280079:	e8 47 13 00 00       	call   2813c5 <init_gdtidt>
	init_pic();
  28007e:	e8 06 15 00 00       	call   281589 <init_pic>
	io_sti();
  280083:	e8 1c 09 00 00       	call   2809a4 <io_sti>

	//init keyboard and mouse
	init_keyboard(&fifo,256);
  280088:	59                   	pop    %ecx
  280089:	5e                   	pop    %esi
  28008a:	68 00 01 00 00       	push   $0x100
  28008f:	53                   	push   %ebx
  280090:	e8 0d 1c 00 00       	call   281ca2 <init_keyboard>
	struct MOUSE_DEC mdec;
	enable_mouse(&fifo,512,&mdec);
  280095:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  28009b:	83 c4 0c             	add    $0xc,%esp
  28009e:	50                   	push   %eax
  28009f:	68 00 02 00 00       	push   $0x200
  2800a4:	53                   	push   %ebx
  2800a5:	e8 aa 1a 00 00       	call   281b54 <enable_mouse>

	//init timer
	init_pit();
  2800aa:	e8 c9 27 00 00       	call   282878 <init_pit>

	io_out8(PIC0_IMR,0xf8);
  2800af:	5f                   	pop    %edi
  2800b0:	58                   	pop    %eax
  2800b1:	68 f8 00 00 00       	push   $0xf8
  2800b6:	6a 21                	push   $0x21
  2800b8:	e8 19 09 00 00       	call   2809d6 <io_out8>
	io_out8(PIC1_IMR,0xef);
  2800bd:	58                   	pop    %eax
  2800be:	5a                   	pop    %edx
  2800bf:	68 ef 00 00 00       	push   $0xef
  2800c4:	68 a1 00 00 00       	push   $0xa1
  2800c9:	e8 08 09 00 00       	call   2809d6 <io_out8>

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800ce:	59                   	pop    %ecx
  2800cf:	5b                   	pop    %ebx
  2800d0:	68 ff ff ff bf       	push   $0xbfffffff
  2800d5:	68 00 00 40 00       	push   $0x400000
  2800da:	e8 5d 1c 00 00       	call   281d3c <memtest>
	memman_init(memman);
  2800df:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
	io_out8(PIC1_IMR,0xef);

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800e6:	89 85 c4 fb ff ff    	mov    %eax,-0x43c(%ebp)
	memman_init(memman);
  2800ec:	e8 8a 1d 00 00       	call   281e7b <memman_init>
	//init memman with two mem block:0x00001000-0x0009efff and 0x00400000-memtotal
	memman_free(memman,0x00001000,0x0009e000);
  2800f1:	83 c4 0c             	add    $0xc,%esp
  2800f4:	68 00 e0 09 00       	push   $0x9e000
  2800f9:	68 00 10 00 00       	push   $0x1000
  2800fe:	68 00 00 3c 00       	push   $0x3c0000
  280103:	e8 c2 1e 00 00       	call   281fca <memman_free>
	memman_free(memman,0x00400000,memtotal-0x00400000);
  280108:	8b 85 c4 fb ff ff    	mov    -0x43c(%ebp),%eax
  28010e:	83 c4 0c             	add    $0xc,%esp
  280111:	2d 00 00 40 00       	sub    $0x400000,%eax
  280116:	50                   	push   %eax
  280117:	68 00 00 40 00       	push   $0x400000
  28011c:	68 00 00 3c 00       	push   $0x3c0000
  280121:	e8 a4 1e 00 00       	call   281fca <memman_free>
	struct SHTCTL *shtctl;
	struct SHEET *sht_bg, *sht_mouse, *sht_console[2];
	unsigned char *buf_bg,buf_mouse[256],*buf_console[2];
	struct TASK *task_a, *task_console[2];

	init_palette();
  280126:	e8 e0 09 00 00       	call   280b0b <init_palette>
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  28012b:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  280132:	50                   	push   %eax
  280133:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  28013a:	50                   	push   %eax
  28013b:	ff 35 f8 0f 00 00    	pushl  0xff8
  280141:	68 00 00 3c 00       	push   $0x3c0000
  280146:	e8 2d 21 00 00       	call   282278 <shtctl_init>
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  28014b:	83 c4 14             	add    $0x14,%esp
	struct SHEET *sht_bg, *sht_mouse, *sht_console[2];
	unsigned char *buf_bg,buf_mouse[256],*buf_console[2];
	struct TASK *task_a, *task_console[2];

	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  28014e:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
	*((int *)0x0fe4) = (int)shtctl;
  280154:	a3 e4 0f 00 00       	mov    %eax,0xfe4
	task_a = task_init(memman); //main task
  280159:	68 00 00 3c 00       	push   $0x3c0000
  28015e:	e8 57 2c 00 00       	call   282dba <task_init>
	fifo.task = task_a;
	task_run(task_a,1,0);
  280163:	83 c4 0c             	add    $0xc,%esp
	struct TASK *task_a, *task_console[2];

	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  280166:	89 85 a8 fb ff ff    	mov    %eax,-0x458(%ebp)
	fifo.task = task_a;
  28016c:	89 85 14 fc ff ff    	mov    %eax,-0x3ec(%ebp)
	task_run(task_a,1,0);
  280172:	6a 00                	push   $0x0
  280174:	6a 01                	push   $0x1
  280176:	50                   	push   %eax
  280177:	e8 ab 2b 00 00       	call   282d27 <task_run>

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
  28017c:	5e                   	pop    %esi
  28017d:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280183:	e8 84 21 00 00       	call   28230c <sheet_alloc>
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  280188:	5f                   	pop    %edi
  280189:	0f bf 15 f4 0f 00 00 	movswl 0xff4,%edx
	task_a = task_init(memman); //main task
	fifo.task = task_a;
	task_run(task_a,1,0);

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
  280190:	89 85 b0 fb ff ff    	mov    %eax,-0x450(%ebp)
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  280196:	58                   	pop    %eax
  280197:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  28019e:	0f af c2             	imul   %edx,%eax
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1;

	//console sheet
	for(int i=0;i<2;i++)
  2801a1:	31 f6                	xor    %esi,%esi
	fifo.task = task_a;
	task_run(task_a,1,0);

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  2801a3:	50                   	push   %eax
  2801a4:	68 00 00 3c 00       	push   $0x3c0000
  2801a9:	e8 6f 20 00 00       	call   28221d <memman_alloc_4k>
  2801ae:	89 c3                	mov    %eax,%ebx
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
  2801b0:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801b7:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  2801be:	50                   	push   %eax
  2801bf:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801c6:	50                   	push   %eax
  2801c7:	53                   	push   %ebx
  2801c8:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  2801ce:	e8 ac 21 00 00       	call   28237f <sheet_setbuf>
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
  2801d3:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801da:	83 c4 1c             	add    $0x1c,%esp
  2801dd:	50                   	push   %eax
  2801de:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801e5:	50                   	push   %eax
  2801e6:	53                   	push   %ebx

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  2801e7:	8d 9d e8 fc ff ff    	lea    -0x318(%ebp),%ebx

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
  2801ed:	e8 0f 0a 00 00       	call   280c01 <init_screen8>

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  2801f2:	58                   	pop    %eax
  2801f3:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  2801f9:	e8 0e 21 00 00       	call   28230c <sheet_alloc>
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  2801fe:	c7 04 24 63 00 00 00 	movl   $0x63,(%esp)
  280205:	6a 10                	push   $0x10
  280207:	6a 10                	push   $0x10
  280209:	53                   	push   %ebx
  28020a:	50                   	push   %eax
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  28020b:	89 85 ac fb ff ff    	mov    %eax,-0x454(%ebp)
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  280211:	e8 69 21 00 00       	call   28237f <sheet_setbuf>
	init_mouse_cursor8(buf_mouse,99);
  280216:	83 c4 18             	add    $0x18,%esp
  280219:	6a 63                	push   $0x63
  28021b:	53                   	push   %ebx
  28021c:	e8 4f 0b 00 00       	call   280d70 <init_mouse_cursor8>
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  280221:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280228:	b9 02 00 00 00       	mov    $0x2,%ecx
	int my = (binfo->scrny-28-16)/2;
  28022d:	83 c4 10             	add    $0x10,%esp
	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  280230:	83 e8 10             	sub    $0x10,%eax
  280233:	99                   	cltd   
  280234:	f7 f9                	idiv   %ecx
  280236:	89 85 c0 fb ff ff    	mov    %eax,-0x440(%ebp)
  28023c:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
	int my = (binfo->scrny-28-16)/2;
  280242:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  280249:	83 e8 2c             	sub    $0x2c,%eax
  28024c:	99                   	cltd   
  28024d:	f7 f9                	idiv   %ecx
  28024f:	89 85 bc fb ff ff    	mov    %eax,-0x444(%ebp)
  280255:	89 85 cc fb ff ff    	mov    %eax,-0x434(%ebp)
	int x,y,mmx = -1,mmy = -1;

	//console sheet
	for(int i=0;i<2;i++)
	{
		sht_console[i] = sheet_alloc(shtctl);
  28025b:	83 ec 0c             	sub    $0xc,%esp
  28025e:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280264:	e8 a3 20 00 00       	call   28230c <sheet_alloc>
  280269:	89 c7                	mov    %eax,%edi
  28026b:	89 84 b5 e4 fb ff ff 	mov    %eax,-0x41c(%ebp,%esi,4)
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1;

	//console sheet
	for(int i=0;i<2;i++)
  280272:	46                   	inc    %esi
	{
		sht_console[i] = sheet_alloc(shtctl);
		buf_console[i] = (unsigned char *)memman_alloc_4k(memman,256*165);
  280273:	58                   	pop    %eax
  280274:	5a                   	pop    %edx
  280275:	68 00 a5 00 00       	push   $0xa500
  28027a:	68 00 00 3c 00       	push   $0x3c0000
  28027f:	e8 99 1f 00 00       	call   28221d <memman_alloc_4k>
		sheet_setbuf(sht_console[i],buf_console[i],256,165,-1);
  280284:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  28028b:	68 a5 00 00 00       	push   $0xa5

	//console sheet
	for(int i=0;i<2;i++)
	{
		sht_console[i] = sheet_alloc(shtctl);
		buf_console[i] = (unsigned char *)memman_alloc_4k(memman,256*165);
  280290:	89 c3                	mov    %eax,%ebx
		sheet_setbuf(sht_console[i],buf_console[i],256,165,-1);
  280292:	68 00 01 00 00       	push   $0x100
  280297:	50                   	push   %eax
  280298:	57                   	push   %edi
  280299:	e8 e1 20 00 00       	call   28237f <sheet_setbuf>
		make_window8(buf_console[i],256,165,"console",0);
  28029e:	83 c4 14             	add    $0x14,%esp
  2802a1:	6a 00                	push   $0x0
  2802a3:	68 e0 46 28 00       	push   $0x2846e0
  2802a8:	68 a5 00 00 00       	push   $0xa5
  2802ad:	68 00 01 00 00       	push   $0x100
  2802b2:	53                   	push   %ebx
  2802b3:	e8 da 0b 00 00       	call   280e92 <make_window8>
		make_textbox8(sht_console[i],8,28,240,128,COL8_000000);
  2802b8:	83 c4 18             	add    $0x18,%esp
  2802bb:	6a 00                	push   $0x0
  2802bd:	68 80 00 00 00       	push   $0x80
  2802c2:	68 f0 00 00 00       	push   $0xf0
  2802c7:	6a 1c                	push   $0x1c
  2802c9:	6a 08                	push   $0x8
  2802cb:	57                   	push   %edi
  2802cc:	e8 84 0d 00 00       	call   281055 <make_textbox8>
		task_console[i] = task_alloc();
  2802d1:	83 c4 20             	add    $0x20,%esp
  2802d4:	e8 5f 28 00 00       	call   282b38 <task_alloc>
		task_console[i]->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  2802d9:	51                   	push   %ecx
  2802da:	51                   	push   %ecx
		sht_console[i] = sheet_alloc(shtctl);
		buf_console[i] = (unsigned char *)memman_alloc_4k(memman,256*165);
		sheet_setbuf(sht_console[i],buf_console[i],256,165,-1);
		make_window8(buf_console[i],256,165,"console",0);
		make_textbox8(sht_console[i],8,28,240,128,COL8_000000);
		task_console[i] = task_alloc();
  2802db:	89 c3                	mov    %eax,%ebx
		task_console[i]->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  2802dd:	68 00 00 01 00       	push   $0x10000
  2802e2:	68 00 00 3c 00       	push   $0x3c0000
  2802e7:	e8 31 1f 00 00       	call   28221d <memman_alloc_4k>
  2802ec:	8d 90 f4 ff 00 00    	lea    0xfff4(%eax),%edx
		task_console[i]->tss.eip = (int)&console_task - 0x280000;
  2802f2:	c7 43 4c db 2f 00 00 	movl   $0x2fdb,0x4c(%ebx)
		task_console[i]->tss.es = 1*8;
  2802f9:	c7 43 74 08 00 00 00 	movl   $0x8,0x74(%ebx)
		task_console[i]->tss.cs = 3*8;
  280300:	c7 43 78 18 00 00 00 	movl   $0x18,0x78(%ebx)
		task_console[i]->tss.ss = 1*8;
  280307:	c7 43 7c 08 00 00 00 	movl   $0x8,0x7c(%ebx)
		task_console[i]->tss.ds = 1*8;
		task_console[i]->tss.fs = 1*8;
		task_console[i]->tss.gs = 1*8;
		*((int *)(task_console[i]->tss.esp + 4)) = sht_console[i];
		*((int *)(task_console[i]->tss.esp + 8)) = memtotal;
		task_run(task_console[i],2,2);
  28030e:	83 c4 0c             	add    $0xc,%esp
		buf_console[i] = (unsigned char *)memman_alloc_4k(memman,256*165);
		sheet_setbuf(sht_console[i],buf_console[i],256,165,-1);
		make_window8(buf_console[i],256,165,"console",0);
		make_textbox8(sht_console[i],8,28,240,128,COL8_000000);
		task_console[i] = task_alloc();
		task_console[i]->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  280311:	89 53 64             	mov    %edx,0x64(%ebx)
		task_console[i]->tss.eip = (int)&console_task - 0x280000;
		task_console[i]->tss.es = 1*8;
		task_console[i]->tss.cs = 3*8;
		task_console[i]->tss.ss = 1*8;
		task_console[i]->tss.ds = 1*8;
  280314:	c7 83 80 00 00 00 08 	movl   $0x8,0x80(%ebx)
  28031b:	00 00 00 
		task_console[i]->tss.fs = 1*8;
  28031e:	c7 83 84 00 00 00 08 	movl   $0x8,0x84(%ebx)
  280325:	00 00 00 
		task_console[i]->tss.gs = 1*8;
  280328:	c7 83 88 00 00 00 08 	movl   $0x8,0x88(%ebx)
  28032f:	00 00 00 
		*((int *)(task_console[i]->tss.esp + 4)) = sht_console[i];
		*((int *)(task_console[i]->tss.esp + 8)) = memtotal;
  280332:	8b 8d c4 fb ff ff    	mov    -0x43c(%ebp),%ecx
		task_console[i]->tss.cs = 3*8;
		task_console[i]->tss.ss = 1*8;
		task_console[i]->tss.ds = 1*8;
		task_console[i]->tss.fs = 1*8;
		task_console[i]->tss.gs = 1*8;
		*((int *)(task_console[i]->tss.esp + 4)) = sht_console[i];
  280338:	89 b8 f8 ff 00 00    	mov    %edi,0xfff8(%eax)
		*((int *)(task_console[i]->tss.esp + 8)) = memtotal;
  28033e:	8b 43 64             	mov    0x64(%ebx),%eax
  280341:	89 48 08             	mov    %ecx,0x8(%eax)
		task_run(task_console[i],2,2);
  280344:	6a 02                	push   $0x2
  280346:	6a 02                	push   $0x2
  280348:	53                   	push   %ebx
  280349:	e8 d9 29 00 00       	call   282d27 <task_run>
		sht_console[i]->task = task_console[i];
		sht_console[i]->flags |= 0x20;
  28034e:	83 4f 1c 20          	orl    $0x20,0x1c(%edi)
		task_console[i]->tss.fs = 1*8;
		task_console[i]->tss.gs = 1*8;
		*((int *)(task_console[i]->tss.esp + 4)) = sht_console[i];
		*((int *)(task_console[i]->tss.esp + 8)) = memtotal;
		task_run(task_console[i],2,2);
		sht_console[i]->task = task_console[i];
  280352:	89 5f 24             	mov    %ebx,0x24(%edi)
		sht_console[i]->flags |= 0x20;
		cons_fifo[i] = memman_alloc_4k(memman,128*4);
  280355:	5f                   	pop    %edi
  280356:	58                   	pop    %eax
  280357:	68 00 02 00 00       	push   $0x200
  28035c:	68 00 00 3c 00       	push   $0x3c0000
  280361:	e8 b7 1e 00 00       	call   28221d <memman_alloc_4k>
		fifo32_init(&task_console[i]->fifo,128,cons_fifo[i],task_console[i]);
  280366:	53                   	push   %ebx
  280367:	83 c3 10             	add    $0x10,%ebx
  28036a:	50                   	push   %eax
  28036b:	68 80 00 00 00       	push   $0x80
  280370:	53                   	push   %ebx
  280371:	e8 f2 16 00 00       	call   281a68 <fifo32_init>
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1;

	//console sheet
	for(int i=0;i<2;i++)
  280376:	83 c4 20             	add    $0x20,%esp
  280379:	83 fe 02             	cmp    $0x2,%esi
  28037c:	0f 85 d9 fe ff ff    	jne    28025b <bootmain+0x25b>
		sht_console[i]->flags |= 0x20;
		cons_fifo[i] = memman_alloc_4k(memman,128*4);
		fifo32_init(&task_console[i]->fifo,128,cons_fifo[i],task_console[i]);
	}

	sheet_slide(sht_bg,0,0);
  280382:	56                   	push   %esi
  280383:	6a 00                	push   $0x0
  280385:	6a 00                	push   $0x0
  280387:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  28038d:	e8 09 24 00 00       	call   28279b <sheet_slide>
	sheet_slide(sht_console[1],56,6);
  280392:	8b 9d e8 fb ff ff    	mov    -0x418(%ebp),%ebx
  280398:	83 c4 0c             	add    $0xc,%esp
  28039b:	6a 06                	push   $0x6
  28039d:	6a 38                	push   $0x38
  28039f:	53                   	push   %ebx
  2803a0:	e8 f6 23 00 00       	call   28279b <sheet_slide>
	sheet_slide(sht_console[0],8,2);
  2803a5:	8b b5 e4 fb ff ff    	mov    -0x41c(%ebp),%esi
  2803ab:	83 c4 0c             	add    $0xc,%esp
  2803ae:	6a 02                	push   $0x2
  2803b0:	6a 08                	push   $0x8
  2803b2:	56                   	push   %esi
  2803b3:	e8 e3 23 00 00       	call   28279b <sheet_slide>
	sheet_slide(sht_mouse,mx,my);
  2803b8:	83 c4 0c             	add    $0xc,%esp
  2803bb:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  2803c1:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2803c7:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  2803cd:	e8 c9 23 00 00       	call   28279b <sheet_slide>
	sheet_updown(sht_bg,		0);
  2803d2:	5f                   	pop    %edi
  2803d3:	58                   	pop    %eax
  2803d4:	6a 00                	push   $0x0
  2803d6:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  2803dc:	e8 d1 22 00 00       	call   2826b2 <sheet_updown>
	sheet_updown(sht_console[1],1);
  2803e1:	58                   	pop    %eax
  2803e2:	5a                   	pop    %edx
  2803e3:	6a 01                	push   $0x1
  2803e5:	53                   	push   %ebx
  2803e6:	e8 c7 22 00 00       	call   2826b2 <sheet_updown>
	sheet_updown(sht_console[0],2);
  2803eb:	59                   	pop    %ecx
  2803ec:	5b                   	pop    %ebx
  2803ed:	6a 02                	push   $0x2
  2803ef:	56                   	push   %esi
  2803f0:	e8 bd 22 00 00       	call   2826b2 <sheet_updown>
	sheet_updown(sht_mouse,		3);
  2803f5:	5f                   	pop    %edi
  2803f6:	58                   	pop    %eax
  2803f7:	6a 03                	push   $0x3
  2803f9:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)

	extern struct TIMERCTL timerctl;
	struct SHEET *key_win,*sht = 0;
  2803ff:	31 ff                	xor    %edi,%edi
	sheet_slide(sht_console[0],8,2);
	sheet_slide(sht_mouse,mx,my);
	sheet_updown(sht_bg,		0);
	sheet_updown(sht_console[1],1);
	sheet_updown(sht_console[0],2);
	sheet_updown(sht_mouse,		3);
  280401:	e8 ac 22 00 00       	call   2826b2 <sheet_updown>

	extern struct TIMERCTL timerctl;
	struct SHEET *key_win,*sht = 0;
	//init window focus
	key_win = sht_console[0];
	keywin_on(key_win);
  280406:	89 34 24             	mov    %esi,(%esp)
  280409:	e8 7a 42 00 00       	call   284688 <keywin_on>
  28040e:	83 c4 10             	add    $0x10,%esp

	int key_shift = 0,keycmd_wait = -1;
  280411:	c7 85 b8 fb ff ff ff 	movl   $0xffffffff,-0x448(%ebp)
  280418:	ff ff ff 
  28041b:	c7 85 c4 fb ff ff 00 	movl   $0x0,-0x43c(%ebp)
  280422:	00 00 00 
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1;
  280425:	c7 85 b4 fb ff ff ff 	movl   $0xffffffff,-0x44c(%ebp)
  28042c:	ff ff ff 
							mmy = my;
						}
					}
					else
					{
						mmx = -1;
  28042f:	c7 85 c0 fb ff ff ff 	movl   $0xffffffff,-0x440(%ebp)
  280436:	ff ff ff 

	int key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  280439:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  28043f:	83 ec 0c             	sub    $0xc,%esp
  280442:	50                   	push   %eax
  280443:	e8 fe 16 00 00       	call   281b46 <fifo32_status>
  280448:	8b 8d b8 fb ff ff    	mov    -0x448(%ebp),%ecx
  28044e:	83 c4 10             	add    $0x10,%esp
  280451:	c1 e9 1f             	shr    $0x1f,%ecx
  280454:	74 30                	je     280486 <bootmain+0x486>
  280456:	85 c0                	test   %eax,%eax
  280458:	7e 2c                	jle    280486 <bootmain+0x486>
		{
			keycmd_wait = fifo32_get(&keycmd);
  28045a:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  280460:	83 ec 0c             	sub    $0xc,%esp
  280463:	50                   	push   %eax
  280464:	e8 a2 16 00 00       	call   281b0b <fifo32_get>
  280469:	89 85 b8 fb ff ff    	mov    %eax,-0x448(%ebp)
			wait_KBC_sendready();
  28046f:	e8 15 18 00 00       	call   281c89 <wait_KBC_sendready>
			io_out8(PORT_KEYDAT,keycmd_wait);
  280474:	59                   	pop    %ecx
  280475:	5b                   	pop    %ebx
  280476:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  28047c:	6a 60                	push   $0x60
  28047e:	e8 53 05 00 00       	call   2809d6 <io_out8>
  280483:	83 c4 10             	add    $0x10,%esp
		}
		io_cli();
  280486:	e8 17 05 00 00       	call   2809a2 <io_cli>
		if(fifo32_status(&fifo) == 0)
  28048b:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  280491:	83 ec 0c             	sub    $0xc,%esp
  280494:	50                   	push   %eax
  280495:	e8 ac 16 00 00       	call   281b46 <fifo32_status>
  28049a:	83 c4 10             	add    $0x10,%esp
  28049d:	85 c0                	test   %eax,%eax
  28049f:	75 13                	jne    2804b4 <bootmain+0x4b4>
		{	
			task_sleep(task_a);
  2804a1:	83 ec 0c             	sub    $0xc,%esp
  2804a4:	ff b5 a8 fb ff ff    	pushl  -0x458(%ebp)
  2804aa:	e8 ea 2a 00 00       	call   282f99 <task_sleep>
  2804af:	e9 55 04 00 00       	jmp    280909 <bootmain+0x909>
			io_sti();
		}
		else
		{
			int i = fifo32_get(&fifo);
  2804b4:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  2804ba:	83 ec 0c             	sub    $0xc,%esp
  2804bd:	50                   	push   %eax
  2804be:	e8 48 16 00 00       	call   281b0b <fifo32_get>
  2804c3:	89 c3                	mov    %eax,%ebx
			io_sti();
  2804c5:	e8 da 04 00 00       	call   2809a4 <io_sti>
			if(key_win->flags == 0) //key_win already closed
  2804ca:	83 c4 10             	add    $0x10,%esp
  2804cd:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  2804d1:	75 1f                	jne    2804f2 <bootmain+0x4f2>
			{
				key_win = shtctl->sheets[shtctl->top - 1];
  2804d3:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  2804d9:	8b 8d d4 fb ff ff    	mov    -0x42c(%ebp),%ecx
				keywin_on(key_win);
  2804df:	83 ec 0c             	sub    $0xc,%esp
		{
			int i = fifo32_get(&fifo);
			io_sti();
			if(key_win->flags == 0) //key_win already closed
			{
				key_win = shtctl->sheets[shtctl->top - 1];
  2804e2:	8b 40 10             	mov    0x10(%eax),%eax
  2804e5:	8b 74 81 10          	mov    0x10(%ecx,%eax,4),%esi
				keywin_on(key_win);
  2804e9:	56                   	push   %esi
  2804ea:	e8 99 41 00 00       	call   284688 <keywin_on>
  2804ef:	83 c4 10             	add    $0x10,%esp
			}
			if(256<=i && i<=511)
  2804f2:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
  2804f8:	3d ff 00 00 00       	cmp    $0xff,%eax
  2804fd:	0f 87 3d 02 00 00    	ja     280740 <bootmain+0x740>
			{
				xtoa(i-256,s);
  280503:	52                   	push   %edx
  280504:	52                   	push   %edx
  280505:	8d 95 36 fc ff ff    	lea    -0x3ca(%ebp),%edx
  28050b:	89 85 bc fb ff ff    	mov    %eax,-0x444(%ebp)
  280511:	52                   	push   %edx
  280512:	50                   	push   %eax
  280513:	89 95 a4 fb ff ff    	mov    %edx,-0x45c(%ebp)
  280519:	e8 f8 12 00 00       	call   281816 <xtoa>
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);
  28051e:	8b 95 a4 fb ff ff    	mov    -0x45c(%ebp),%edx
  280524:	83 c4 0c             	add    $0xc,%esp
  280527:	6a 04                	push   $0x4
  280529:	52                   	push   %edx
  28052a:	6a 00                	push   $0x0
  28052c:	6a 07                	push   $0x7
  28052e:	6a 10                	push   $0x10
  280530:	6a 00                	push   $0x0
  280532:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  280538:	e8 b3 0a 00 00       	call   280ff0 <putfonts8_asc_sht>

				s[0] = key_char(i-256,key_shift);
  28053d:	8b 85 bc fb ff ff    	mov    -0x444(%ebp),%eax
  280543:	83 c4 18             	add    $0x18,%esp
  280546:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  28054c:	50                   	push   %eax
  28054d:	e8 c2 17 00 00       	call   281d14 <key_char>
				s[1] = 0;

				if('A' <= s[0] && s[0] <= 'Z')
  280552:	8d 50 bf             	lea    -0x41(%eax),%edx
  280555:	83 c4 10             	add    $0x10,%esp
			if(256<=i && i<=511)
			{
				xtoa(i-256,s);
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);

				s[0] = key_char(i-256,key_shift);
  280558:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				s[1] = 0;
  28055e:	c6 85 37 fc ff ff 00 	movb   $0x0,-0x3c9(%ebp)

				if('A' <= s[0] && s[0] <= 'Z')
  280565:	80 fa 19             	cmp    $0x19,%dl
  280568:	77 26                	ja     280590 <bootmain+0x590>
				{
					if((key_leds&4) == 0 && key_shift != 0 ||	//keyboard led off and shift on
  28056a:	f6 85 c8 fb ff ff 04 	testb  $0x4,-0x438(%ebp)
  280571:	75 0b                	jne    28057e <bootmain+0x57e>
  280573:	83 bd c4 fb ff ff 00 	cmpl   $0x0,-0x43c(%ebp)
  28057a:	75 0b                	jne    280587 <bootmain+0x587>
  28057c:	eb 12                	jmp    280590 <bootmain+0x590>
							(key_leds&4) != 0 && key_shift == 0)			//keyboard led on and shift off
  28057e:	83 bd c4 fb ff ff 00 	cmpl   $0x0,-0x43c(%ebp)
  280585:	75 09                	jne    280590 <bootmain+0x590>
						s[0] += 0x20;		//uppercase 2 lowercases					
  280587:	83 c0 20             	add    $0x20,%eax
  28058a:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				}
				if(s[0]!=0)//visible char,return key and back key
  280590:	0f be 85 36 fc ff ff 	movsbl -0x3ca(%ebp),%eax
  280597:	84 c0                	test   %al,%al
  280599:	74 17                	je     2805b2 <bootmain+0x5b2>
				{
					fifo32_put(&key_win->task->fifo,s[0]+256); //send key to console fifo
  28059b:	05 00 01 00 00       	add    $0x100,%eax
  2805a0:	51                   	push   %ecx
  2805a1:	51                   	push   %ecx
  2805a2:	50                   	push   %eax
  2805a3:	8b 46 24             	mov    0x24(%esi),%eax
  2805a6:	83 c0 10             	add    $0x10,%eax
  2805a9:	50                   	push   %eax
  2805aa:	e8 ea 14 00 00       	call   281a99 <fifo32_put>
  2805af:	83 c4 10             	add    $0x10,%esp
				}
				if(i == 256 + 0x0f) //tab key
  2805b2:	81 fb 0f 01 00 00    	cmp    $0x10f,%ebx
  2805b8:	75 3a                	jne    2805f4 <bootmain+0x5f4>
				{
					keywin_off(key_win);
  2805ba:	83 ec 0c             	sub    $0xc,%esp
  2805bd:	56                   	push   %esi
  2805be:	e8 91 40 00 00       	call   284654 <keywin_off>
					int j=key_win->height - 1;
  2805c3:	8b 46 18             	mov    0x18(%esi),%eax
					if(j==0)
  2805c6:	83 c4 10             	add    $0x10,%esp
  2805c9:	48                   	dec    %eax
  2805ca:	75 10                	jne    2805dc <bootmain+0x5dc>
					{
						j = shtctl->top-1;
  2805cc:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  2805d2:	8b 40 10             	mov    0x10(%eax),%eax
  2805d5:	89 85 bc fb ff ff    	mov    %eax,-0x444(%ebp)
  2805db:	48                   	dec    %eax
					}
					key_win = shtctl->sheets[j];
  2805dc:	8b b5 d4 fb ff ff    	mov    -0x42c(%ebp),%esi
					keywin_on(key_win);
  2805e2:	83 ec 0c             	sub    $0xc,%esp
					int j=key_win->height - 1;
					if(j==0)
					{
						j = shtctl->top-1;
					}
					key_win = shtctl->sheets[j];
  2805e5:	8b 74 86 14          	mov    0x14(%esi,%eax,4),%esi
					keywin_on(key_win);
  2805e9:	56                   	push   %esi
  2805ea:	e8 99 40 00 00       	call   284688 <keywin_on>
  2805ef:	e9 1a 03 00 00       	jmp    28090e <bootmain+0x90e>
				}
				else if(i == 256 + 0x2a)  //left shift on
  2805f4:	81 fb 2a 01 00 00    	cmp    $0x12a,%ebx
  2805fa:	75 0c                	jne    280608 <bootmain+0x608>
				{
					key_shift |= 1;
  2805fc:	83 8d c4 fb ff ff 01 	orl    $0x1,-0x43c(%ebp)
  280603:	e9 31 fe ff ff       	jmp    280439 <bootmain+0x439>
				} 
				else if(i == 256 + 0x36) //right shift on
  280608:	81 fb 36 01 00 00    	cmp    $0x136,%ebx
  28060e:	75 0c                	jne    28061c <bootmain+0x61c>
				{
					key_shift |= 2;
  280610:	83 8d c4 fb ff ff 02 	orl    $0x2,-0x43c(%ebp)
  280617:	e9 1d fe ff ff       	jmp    280439 <bootmain+0x439>
				}
				else if(i == 256 + 0xaa)  //left shift off
  28061c:	81 fb aa 01 00 00    	cmp    $0x1aa,%ebx
  280622:	75 0c                	jne    280630 <bootmain+0x630>
				{
					key_shift &= ~1;
  280624:	83 a5 c4 fb ff ff fe 	andl   $0xfffffffe,-0x43c(%ebp)
  28062b:	e9 09 fe ff ff       	jmp    280439 <bootmain+0x439>
				} 
				else if(i == 256 + 0xb6) //right shift off
  280630:	81 fb b6 01 00 00    	cmp    $0x1b6,%ebx
  280636:	75 0c                	jne    280644 <bootmain+0x644>
				{
					key_shift &= ~2;
  280638:	83 a5 c4 fb ff ff fd 	andl   $0xfffffffd,-0x43c(%ebp)
  28063f:	e9 f5 fd ff ff       	jmp    280439 <bootmain+0x439>
				}
				else if(i == 256 + 0x3a) //CapsLock
  280644:	81 fb 3a 01 00 00    	cmp    $0x13a,%ebx
  28064a:	75 09                	jne    280655 <bootmain+0x655>
				{
					key_leds ^= 4;
  28064c:	83 b5 c8 fb ff ff 04 	xorl   $0x4,-0x438(%ebp)
  280653:	eb 0f                	jmp    280664 <bootmain+0x664>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x45) //NumLock
  280655:	81 fb 45 01 00 00    	cmp    $0x145,%ebx
  28065b:	75 33                	jne    280690 <bootmain+0x690>
				{
					key_leds ^= 2;
  28065d:	83 b5 c8 fb ff ff 02 	xorl   $0x2,-0x438(%ebp)
					fifo32_put(&keycmd,KEYCMD_LED);
  280664:	50                   	push   %eax
  280665:	50                   	push   %eax
  280666:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  28066c:	68 ed 00 00 00       	push   $0xed
  280671:	50                   	push   %eax
  280672:	e8 22 14 00 00       	call   281a99 <fifo32_put>
					fifo32_put(&keycmd,key_leds);
  280677:	58                   	pop    %eax
  280678:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  28067e:	5a                   	pop    %edx
  28067f:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  280685:	50                   	push   %eax
  280686:	e8 0e 14 00 00       	call   281a99 <fifo32_put>
  28068b:	e9 7e 02 00 00       	jmp    28090e <bootmain+0x90e>
				}
				else if(i == 256 + 0x46) //ScrollLock
  280690:	81 fb 46 01 00 00    	cmp    $0x146,%ebx
  280696:	75 09                	jne    2806a1 <bootmain+0x6a1>
				{
					key_leds ^= 1;
  280698:	83 b5 c8 fb ff ff 01 	xorl   $0x1,-0x438(%ebp)
  28069f:	eb c3                	jmp    280664 <bootmain+0x664>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0xfa)
  2806a1:	81 fb fa 01 00 00    	cmp    $0x1fa,%ebx
  2806a7:	75 0f                	jne    2806b8 <bootmain+0x6b8>
				{
					keycmd_wait = -1;
  2806a9:	c7 85 b8 fb ff ff ff 	movl   $0xffffffff,-0x448(%ebp)
  2806b0:	ff ff ff 
  2806b3:	e9 81 fd ff ff       	jmp    280439 <bootmain+0x439>
				}
				else if(i == 256 + 0xfe)
  2806b8:	81 fb fe 01 00 00    	cmp    $0x1fe,%ebx
  2806be:	75 19                	jne    2806d9 <bootmain+0x6d9>
				{
					wait_KBC_sendready();
  2806c0:	e8 c4 15 00 00       	call   281c89 <wait_KBC_sendready>
					io_out8(PORT_KEYDAT,keycmd_wait);
  2806c5:	53                   	push   %ebx
  2806c6:	53                   	push   %ebx
  2806c7:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  2806cd:	6a 60                	push   $0x60
  2806cf:	e8 02 03 00 00       	call   2809d6 <io_out8>
  2806d4:	e9 35 02 00 00       	jmp    28090e <bootmain+0x90e>
				}
				else if(i == 256 + 0x3b && key_shift != 0)	//shift + F1
  2806d9:	81 fb 3b 01 00 00    	cmp    $0x13b,%ebx
  2806df:	75 2a                	jne    28070b <bootmain+0x70b>
  2806e1:	83 bd c4 fb ff ff 00 	cmpl   $0x0,-0x43c(%ebp)
  2806e8:	74 21                	je     28070b <bootmain+0x70b>
				{
					struct TASK *task = key_win->task;
  2806ea:	8b 5e 24             	mov    0x24(%esi),%ebx
					if(task!=0 && task->tss.ss0 != 0)
  2806ed:	85 db                	test   %ebx,%ebx
  2806ef:	0f 84 44 fd ff ff    	je     280439 <bootmain+0x439>
  2806f5:	83 7b 34 00          	cmpl   $0x0,0x34(%ebx)
  2806f9:	0f 84 3a fd ff ff    	je     280439 <bootmain+0x439>
					{
						extern void asm_end_app();
						cons_putstr0(task->cons,"\nBreak(key):\n");
  2806ff:	51                   	push   %ecx
  280700:	51                   	push   %ecx
  280701:	68 e8 46 28 00       	push   $0x2846e8
  280706:	e9 e1 01 00 00       	jmp    2808ec <bootmain+0x8ec>
						task->tss.eax = (int)&(task->tss.esp0);
						task->tss.eip = (int)asm_end_app - 0x280000;
						io_sti();
					}
				}
				else if(i == 256 + 0x57 && shtctl->top > 2)
  28070b:	81 fb 57 01 00 00    	cmp    $0x157,%ebx
  280711:	0f 85 22 fd ff ff    	jne    280439 <bootmain+0x439>
  280717:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  28071d:	8b 40 10             	mov    0x10(%eax),%eax
  280720:	83 f8 02             	cmp    $0x2,%eax
  280723:	0f 8e 10 fd ff ff    	jle    280439 <bootmain+0x439>
				{
					//F11 to pop the bottom window
					sheet_updown(shtctl->sheets[1],shtctl->top - 1);
  280729:	48                   	dec    %eax
  28072a:	52                   	push   %edx
  28072b:	52                   	push   %edx
  28072c:	50                   	push   %eax
  28072d:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  280733:	ff 70 18             	pushl  0x18(%eax)
  280736:	e8 77 1f 00 00       	call   2826b2 <sheet_updown>
  28073b:	e9 ce 01 00 00       	jmp    28090e <bootmain+0x90e>
				}

			}
			else if(512<=i && i<=767)
  280740:	8d 83 00 fe ff ff    	lea    -0x200(%ebx),%eax
  280746:	3d ff 00 00 00       	cmp    $0xff,%eax
  28074b:	0f 87 e8 fc ff ff    	ja     280439 <bootmain+0x439>
			{
				if(mouse_decode(&mdec,i-512)!=0)
  280751:	50                   	push   %eax
  280752:	50                   	push   %eax
  280753:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  280759:	0f b6 db             	movzbl %bl,%ebx
  28075c:	53                   	push   %ebx
  28075d:	50                   	push   %eax
  28075e:	e8 3b 14 00 00       	call   281b9e <mouse_decode>
  280763:	83 c4 10             	add    $0x10,%esp
  280766:	85 c0                	test   %eax,%eax
  280768:	0f 84 cb fc ff ff    	je     280439 <bootmain+0x439>
  28076e:	8b 95 d0 fb ff ff    	mov    -0x430(%ebp),%edx
  280774:	31 c0                	xor    %eax,%eax
  280776:	03 95 f0 fb ff ff    	add    -0x410(%ebp),%edx
  28077c:	0f 48 d0             	cmovs  %eax,%edx
  28077f:	89 95 d0 fb ff ff    	mov    %edx,-0x430(%ebp)
  280785:	8b 95 cc fb ff ff    	mov    -0x434(%ebp),%edx
  28078b:	03 95 f4 fb ff ff    	add    -0x40c(%ebp),%edx
  280791:	0f 49 c2             	cmovns %edx,%eax
  280794:	89 85 cc fb ff ff    	mov    %eax,-0x434(%ebp)
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  28079a:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2807a1:	3b 85 d0 fb ff ff    	cmp    -0x430(%ebp),%eax
  2807a7:	8d 50 ff             	lea    -0x1(%eax),%edx
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2807aa:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  2807b1:	0f 4f 95 d0 fb ff ff 	cmovg  -0x430(%ebp),%edx
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2807b8:	39 85 cc fb ff ff    	cmp    %eax,-0x434(%ebp)
					sheet_slide(sht_mouse,mx,my);
  2807be:	53                   	push   %ebx
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  2807bf:	89 95 d0 fb ff ff    	mov    %edx,-0x430(%ebp)
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2807c5:	8d 50 ff             	lea    -0x1(%eax),%edx
  2807c8:	0f 4c 95 cc fb ff ff 	cmovl  -0x434(%ebp),%edx
					sheet_slide(sht_mouse,mx,my);
  2807cf:	52                   	push   %edx
  2807d0:	ff b5 d0 fb ff ff    	pushl  -0x430(%ebp)
  2807d6:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2807dc:	89 95 cc fb ff ff    	mov    %edx,-0x434(%ebp)
					sheet_slide(sht_mouse,mx,my);
  2807e2:	e8 b4 1f 00 00       	call   28279b <sheet_slide>
					if(mdec.btn & 0x01)
  2807e7:	83 c4 10             	add    $0x10,%esp
  2807ea:	f6 85 f8 fb ff ff 01 	testb  $0x1,-0x408(%ebp)
  2807f1:	0f 84 38 fc ff ff    	je     28042f <bootmain+0x42f>
					{
						if(mmx < 0) 
  2807f7:	83 bd c0 fb ff ff 00 	cmpl   $0x0,-0x440(%ebp)
  2807fe:	0f 89 4e 01 00 00    	jns    280952 <bootmain+0x952>
						{
							for(int j=shtctl->top-1;j>0;j--)
  280804:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  28080a:	8b 40 10             	mov    0x10(%eax),%eax
  28080d:	89 85 bc fb ff ff    	mov    %eax,-0x444(%ebp)
  280813:	48                   	dec    %eax
  280814:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
  28081a:	eb 01                	jmp    28081d <bootmain+0x81d>
  28081c:	48                   	dec    %eax
  28081d:	85 c0                	test   %eax,%eax
  28081f:	0f 8e 14 fc ff ff    	jle    280439 <bootmain+0x439>
							{
								sht = shtctl->sheets[j];
  280825:	8b bd d4 fb ff ff    	mov    -0x42c(%ebp),%edi
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  28082b:	8b 8d d0 fb ff ff    	mov    -0x430(%ebp),%ecx
					{
						if(mmx < 0) 
						{
							for(int j=shtctl->top-1;j>0;j--)
							{
								sht = shtctl->sheets[j];
  280831:	8b 7c 87 14          	mov    0x14(%edi,%eax,4),%edi
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280835:	2b 4f 0c             	sub    0xc(%edi),%ecx
  280838:	89 8d bc fb ff ff    	mov    %ecx,-0x444(%ebp)
  28083e:	78 dc                	js     28081c <bootmain+0x81c>
  280840:	8b 9d cc fb ff ff    	mov    -0x434(%ebp),%ebx
  280846:	2b 5f 10             	sub    0x10(%edi),%ebx
  280849:	8b 4f 04             	mov    0x4(%edi),%ecx
  28084c:	78 ce                	js     28081c <bootmain+0x81c>
  28084e:	39 8d bc fb ff ff    	cmp    %ecx,-0x444(%ebp)
  280854:	7d c6                	jge    28081c <bootmain+0x81c>
  280856:	3b 5f 08             	cmp    0x8(%edi),%ebx
  280859:	7d c1                	jge    28081c <bootmain+0x81c>
								{
									if(sht->buf[y*sht->bxsize+x] != sht->col_inv )
  28085b:	8b 95 bc fb ff ff    	mov    -0x444(%ebp),%edx
  280861:	03 17                	add    (%edi),%edx
  280863:	0f af cb             	imul   %ebx,%ecx
  280866:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  28086a:	3b 4f 14             	cmp    0x14(%edi),%ecx
  28086d:	74 ad                	je     28081c <bootmain+0x81c>
									{
										sheet_updown(sht,shtctl->top-1);
  28086f:	51                   	push   %ecx
  280870:	51                   	push   %ecx
  280871:	ff b5 a4 fb ff ff    	pushl  -0x45c(%ebp)
  280877:	57                   	push   %edi
  280878:	e8 35 1e 00 00       	call   2826b2 <sheet_updown>
										if(sht!=key_win)
  28087d:	83 c4 10             	add    $0x10,%esp
  280880:	39 fe                	cmp    %edi,%esi
  280882:	74 14                	je     280898 <bootmain+0x898>
										{
											keywin_off(key_win);
  280884:	83 ec 0c             	sub    $0xc,%esp
  280887:	56                   	push   %esi
  280888:	e8 c7 3d 00 00       	call   284654 <keywin_off>
											key_win = sht;
											keywin_on(key_win);
  28088d:	89 3c 24             	mov    %edi,(%esp)
  280890:	e8 f3 3d 00 00       	call   284688 <keywin_on>
  280895:	83 c4 10             	add    $0x10,%esp
										}
										if(x>=3 && x<sht->bxsize-3 && y>=3 && y<21)
  280898:	83 bd bc fb ff ff 02 	cmpl   $0x2,-0x444(%ebp)
  28089f:	8b 47 04             	mov    0x4(%edi),%eax
  2808a2:	7f 72                	jg     280916 <bootmain+0x916>
										{
											mmx = mx;
											mmy = my;
										}
										if(sht->bxsize - 21 <= x && x<sht->bxsize - 5 && y>=5 && y<19) //click the close button
  2808a4:	8d 50 eb             	lea    -0x15(%eax),%edx
  2808a7:	39 95 bc fb ff ff    	cmp    %edx,-0x444(%ebp)
  2808ad:	89 fe                	mov    %edi,%esi
  2808af:	0f 8c 84 fb ff ff    	jl     280439 <bootmain+0x439>
  2808b5:	83 e8 05             	sub    $0x5,%eax
  2808b8:	39 85 bc fb ff ff    	cmp    %eax,-0x444(%ebp)
  2808be:	0f 8d 75 fb ff ff    	jge    280439 <bootmain+0x439>
  2808c4:	83 eb 05             	sub    $0x5,%ebx
  2808c7:	83 fb 0d             	cmp    $0xd,%ebx
  2808ca:	0f 87 69 fb ff ff    	ja     280439 <bootmain+0x439>
										{
											if(sht->flags & 0x10)
  2808d0:	f6 47 1c 10          	testb  $0x10,0x1c(%edi)
  2808d4:	0f 84 5f fb ff ff    	je     280439 <bootmain+0x439>
											{
												if(sht->task != 0)
  2808da:	8b 5f 24             	mov    0x24(%edi),%ebx
  2808dd:	85 db                	test   %ebx,%ebx
  2808df:	0f 84 54 fb ff ff    	je     280439 <bootmain+0x439>
												{
													struct TASK *task = sht->task;
													struct CONSOLE *cons = task->cons;
													cons_putstr0(cons,"\nBreak(mouse) :\n");
  2808e5:	52                   	push   %edx
  2808e6:	52                   	push   %edx
  2808e7:	68 f6 46 28 00       	push   $0x2846f6
  2808ec:	ff b3 94 00 00 00    	pushl  0x94(%ebx)
  2808f2:	e8 43 30 00 00       	call   28393a <cons_putstr0>
													io_cli();
  2808f7:	e8 a6 00 00 00       	call   2809a2 <io_cli>
													task->tss.eax = (int)&(task->tss.esp0);
  2808fc:	8d 43 30             	lea    0x30(%ebx),%eax
													extern void asm_end_app();
													task->tss.eip = (int)&asm_end_app - 0x280000;
  2808ff:	c7 43 4c 20 2b 00 00 	movl   $0x2b20,0x4c(%ebx)
												{
													struct TASK *task = sht->task;
													struct CONSOLE *cons = task->cons;
													cons_putstr0(cons,"\nBreak(mouse) :\n");
													io_cli();
													task->tss.eax = (int)&(task->tss.esp0);
  280906:	89 43 54             	mov    %eax,0x54(%ebx)
													extern void asm_end_app();
													task->tss.eip = (int)&asm_end_app - 0x280000;
													io_sti();
  280909:	e8 96 00 00 00       	call   2809a4 <io_sti>
  28090e:	83 c4 10             	add    $0x10,%esp
  280911:	e9 23 fb ff ff       	jmp    280439 <bootmain+0x439>
										{
											keywin_off(key_win);
											key_win = sht;
											keywin_on(key_win);
										}
										if(x>=3 && x<sht->bxsize-3 && y>=3 && y<21)
  280916:	8d 50 fd             	lea    -0x3(%eax),%edx
  280919:	39 95 bc fb ff ff    	cmp    %edx,-0x444(%ebp)
  28091f:	7d 83                	jge    2808a4 <bootmain+0x8a4>
  280921:	8d 53 fd             	lea    -0x3(%ebx),%edx
										{
											mmx = mx;
											mmy = my;
  280924:	8b 8d b4 fb ff ff    	mov    -0x44c(%ebp),%ecx
  28092a:	83 fa 11             	cmp    $0x11,%edx
  28092d:	0f 46 8d cc fb ff ff 	cmovbe -0x434(%ebp),%ecx
  280934:	89 8d b4 fb ff ff    	mov    %ecx,-0x44c(%ebp)
  28093a:	8b 8d c0 fb ff ff    	mov    -0x440(%ebp),%ecx
  280940:	0f 46 8d d0 fb ff ff 	cmovbe -0x430(%ebp),%ecx
  280947:	89 8d c0 fb ff ff    	mov    %ecx,-0x440(%ebp)
  28094d:	e9 52 ff ff ff       	jmp    2808a4 <bootmain+0x8a4>
						}
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							sheet_slide(sht,sht->vx0+x,sht->vy0+y);
  280952:	50                   	push   %eax
  280953:	8b 85 cc fb ff ff    	mov    -0x434(%ebp),%eax
  280959:	2b 85 b4 fb ff ff    	sub    -0x44c(%ebp),%eax
  28095f:	03 47 10             	add    0x10(%edi),%eax
  280962:	50                   	push   %eax
  280963:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  280969:	2b 85 c0 fb ff ff    	sub    -0x440(%ebp),%eax
  28096f:	03 47 0c             	add    0xc(%edi),%eax
  280972:	50                   	push   %eax
  280973:	57                   	push   %edi
  280974:	e8 22 1e 00 00       	call   28279b <sheet_slide>
							mmx = mx;
							mmy = my;
  280979:	8b 85 cc fb ff ff    	mov    -0x434(%ebp),%eax
						}
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							sheet_slide(sht,sht->vx0+x,sht->vy0+y);
  28097f:	83 c4 10             	add    $0x10,%esp
							mmx = mx;
							mmy = my;
  280982:	89 85 b4 fb ff ff    	mov    %eax,-0x44c(%ebp)
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							sheet_slide(sht,sht->vx0+x,sht->vy0+y);
							mmx = mx;
  280988:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  28098e:	89 85 c0 fb ff ff    	mov    %eax,-0x440(%ebp)
  280994:	e9 a0 fa ff ff       	jmp    280439 <bootmain+0x439>
  280999:	66 90                	xchg   %ax,%ax
  28099b:	66 90                	xchg   %ax,%ax
  28099d:	66 90                	xchg   %ax,%ax
  28099f:	90                   	nop

002809a0 <io_hlt>:
  2809a0:	f4                   	hlt    
  2809a1:	c3                   	ret    

002809a2 <io_cli>:
  2809a2:	fa                   	cli    
  2809a3:	c3                   	ret    

002809a4 <io_sti>:
  2809a4:	fb                   	sti    
  2809a5:	c3                   	ret    

002809a6 <io_stihlt>:
  2809a6:	fb                   	sti    
  2809a7:	f4                   	hlt    
  2809a8:	c3                   	ret    

002809a9 <write_mem8>:
  2809a9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  2809ad:	8a 44 24 08          	mov    0x8(%esp),%al
  2809b1:	88 01                	mov    %al,(%ecx)
  2809b3:	c3                   	ret    

002809b4 <io_in8>:
  2809b4:	8b 54 24 04          	mov    0x4(%esp),%edx
  2809b8:	b8 00 00 00 00       	mov    $0x0,%eax
  2809bd:	ec                   	in     (%dx),%al
  2809be:	c3                   	ret    

002809bf <io_in16>:
  2809bf:	8b 54 24 04          	mov    0x4(%esp),%edx
  2809c3:	b8 00 00 00 00       	mov    $0x0,%eax
  2809c8:	66 ed                	in     (%dx),%ax
  2809ca:	c3                   	ret    

002809cb <io_in32>:
  2809cb:	8b 54 24 04          	mov    0x4(%esp),%edx
  2809cf:	b8 00 00 00 00       	mov    $0x0,%eax
  2809d4:	ed                   	in     (%dx),%eax
  2809d5:	c3                   	ret    

002809d6 <io_out8>:
  2809d6:	8b 54 24 04          	mov    0x4(%esp),%edx
  2809da:	8b 44 24 08          	mov    0x8(%esp),%eax
  2809de:	ee                   	out    %al,(%dx)
  2809df:	c3                   	ret    

002809e0 <io_out16>:
  2809e0:	8b 54 24 04          	mov    0x4(%esp),%edx
  2809e4:	8b 44 24 08          	mov    0x8(%esp),%eax
  2809e8:	66 ef                	out    %ax,(%dx)
  2809ea:	c3                   	ret    

002809eb <io_out32>:
  2809eb:	8b 54 24 04          	mov    0x4(%esp),%edx
  2809ef:	8b 44 24 08          	mov    0x8(%esp),%eax
  2809f3:	ef                   	out    %eax,(%dx)
  2809f4:	c3                   	ret    

002809f5 <io_load_eflags>:
  2809f5:	9c                   	pushf  
  2809f6:	58                   	pop    %eax
  2809f7:	c3                   	ret    

002809f8 <io_store_eflags>:
  2809f8:	8b 44 24 04          	mov    0x4(%esp),%eax
  2809fc:	50                   	push   %eax
  2809fd:	9d                   	popf   
  2809fe:	c3                   	ret    

002809ff <load_gdtr>:
  2809ff:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280a04:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280a09:	0f 01 54 24 06       	lgdtl  0x6(%esp)
  280a0e:	c3                   	ret    

00280a0f <load_idtr>:
  280a0f:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280a14:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280a19:	0f 01 5c 24 06       	lidtl  0x6(%esp)
  280a1e:	c3                   	ret    

00280a1f <load_cr0>:
  280a1f:	0f 20 c0             	mov    %cr0,%eax
  280a22:	c3                   	ret    

00280a23 <store_cr0>:
  280a23:	8b 44 24 04          	mov    0x4(%esp),%eax
  280a27:	0f 22 c0             	mov    %eax,%cr0
  280a2a:	c3                   	ret    

00280a2b <_memtest_sub>:
  280a2b:	57                   	push   %edi
  280a2c:	56                   	push   %esi
  280a2d:	53                   	push   %ebx
  280a2e:	be 55 aa 55 aa       	mov    $0xaa55aa55,%esi
  280a33:	bf aa 55 aa 55       	mov    $0x55aa55aa,%edi
  280a38:	8b 44 24 10          	mov    0x10(%esp),%eax

00280a3c <mts_loop>:
  280a3c:	89 c3                	mov    %eax,%ebx
  280a3e:	81 c3 fc 0f 00 00    	add    $0xffc,%ebx
  280a44:	8b 13                	mov    (%ebx),%edx
  280a46:	89 33                	mov    %esi,(%ebx)
  280a48:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280a4b:	3b 3b                	cmp    (%ebx),%edi
  280a4d:	75 18                	jne    280a67 <mts_qit>
  280a4f:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280a52:	3b 33                	cmp    (%ebx),%esi
  280a54:	75 11                	jne    280a67 <mts_qit>
  280a56:	89 13                	mov    %edx,(%ebx)
  280a58:	05 00 10 00 00       	add    $0x1000,%eax
  280a5d:	3b 44 24 14          	cmp    0x14(%esp),%eax
  280a61:	76 d9                	jbe    280a3c <mts_loop>

00280a63 <mts_ret>:
  280a63:	5b                   	pop    %ebx
  280a64:	5e                   	pop    %esi
  280a65:	5f                   	pop    %edi
  280a66:	c3                   	ret    

00280a67 <mts_qit>:
  280a67:	89 13                	mov    %edx,(%ebx)
  280a69:	5b                   	pop    %ebx
  280a6a:	5e                   	pop    %esi
  280a6b:	5f                   	pop    %edi
  280a6c:	c3                   	ret    

00280a6d <set_palette>:
	set_palette(16,231,table2);
	return;	
}

void set_palette(int start, int end, unsigned char *rgb)
{
  280a6d:	55                   	push   %ebp
  280a6e:	89 e5                	mov    %esp,%ebp
  280a70:	57                   	push   %edi
  280a71:	56                   	push   %esi
  280a72:	53                   	push   %ebx
  280a73:	83 ec 1c             	sub    $0x1c,%esp
  280a76:	8b 75 08             	mov    0x8(%ebp),%esi
  280a79:	8b 7d 0c             	mov    0xc(%ebp),%edi
  280a7c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int i,eflags;
	eflags = io_load_eflags();
  280a7f:	e8 71 ff ff ff       	call   2809f5 <io_load_eflags>
  280a84:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	io_cli();
  280a87:	e8 16 ff ff ff       	call   2809a2 <io_cli>
	io_out8(0x03c8,start);
  280a8c:	83 ec 08             	sub    $0x8,%esp
  280a8f:	56                   	push   %esi
  280a90:	68 c8 03 00 00       	push   $0x3c8
  280a95:	e8 3c ff ff ff       	call   2809d6 <io_out8>
	for(i=start;i<=end;i++)
  280a9a:	83 c4 10             	add    $0x10,%esp
  280a9d:	39 fe                	cmp    %edi,%esi
  280a9f:	7f 54                	jg     280af5 <set_palette+0x88>
	{
		io_out8(0x03c9,rgb[0]/4);
  280aa1:	83 ec 08             	sub    $0x8,%esp
  280aa4:	0f b6 03             	movzbl (%ebx),%eax
  280aa7:	c0 e8 02             	shr    $0x2,%al
  280aaa:	0f b6 c0             	movzbl %al,%eax
  280aad:	50                   	push   %eax
  280aae:	68 c9 03 00 00       	push   $0x3c9
  280ab3:	e8 1e ff ff ff       	call   2809d6 <io_out8>
		io_out8(0x03c9,rgb[1]/4);
  280ab8:	83 c4 08             	add    $0x8,%esp
  280abb:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  280abf:	c0 e8 02             	shr    $0x2,%al
  280ac2:	0f b6 c0             	movzbl %al,%eax
  280ac5:	50                   	push   %eax
  280ac6:	68 c9 03 00 00       	push   $0x3c9
  280acb:	e8 06 ff ff ff       	call   2809d6 <io_out8>
		io_out8(0x03c9,rgb[2]/4);
  280ad0:	83 c4 08             	add    $0x8,%esp
  280ad3:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
  280ad7:	c0 e8 02             	shr    $0x2,%al
  280ada:	0f b6 c0             	movzbl %al,%eax
  280add:	50                   	push   %eax
  280ade:	68 c9 03 00 00       	push   $0x3c9
  280ae3:	e8 ee fe ff ff       	call   2809d6 <io_out8>
		rgb+=3;
  280ae8:	83 c3 03             	add    $0x3,%ebx
{
	int i,eflags;
	eflags = io_load_eflags();
	io_cli();
	io_out8(0x03c8,start);
	for(i=start;i<=end;i++)
  280aeb:	83 c6 01             	add    $0x1,%esi
  280aee:	83 c4 10             	add    $0x10,%esp
  280af1:	39 f7                	cmp    %esi,%edi
  280af3:	7d ac                	jge    280aa1 <set_palette+0x34>
		io_out8(0x03c9,rgb[0]/4);
		io_out8(0x03c9,rgb[1]/4);
		io_out8(0x03c9,rgb[2]/4);
		rgb+=3;
	}
	io_store_eflags(eflags);
  280af5:	83 ec 0c             	sub    $0xc,%esp
  280af8:	ff 75 e4             	pushl  -0x1c(%ebp)
  280afb:	e8 f8 fe ff ff       	call   2809f8 <io_store_eflags>
	return;
  280b00:	83 c4 10             	add    $0x10,%esp
}
  280b03:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280b06:	5b                   	pop    %ebx
  280b07:	5e                   	pop    %esi
  280b08:	5f                   	pop    %edi
  280b09:	5d                   	pop    %ebp
  280b0a:	c3                   	ret    

00280b0b <init_palette>:
#include "graphics.h"

void init_palette(void)
{
  280b0b:	55                   	push   %ebp
  280b0c:	89 e5                	mov    %esp,%ebp
  280b0e:	57                   	push   %edi
  280b0f:	56                   	push   %esi
  280b10:	53                   	push   %ebx
  280b11:	81 ec a0 02 00 00    	sub    $0x2a0,%esp
		0x00, 0x84, 0x84,	//dark light blue
		0x84, 0x84, 0x84,	//dark gray
	};
	unsigned char table2[216*3];
	int r,g,b;
	set_palette(0,15,table_rgb);
  280b17:	68 00 59 28 00       	push   $0x285900
  280b1c:	6a 0f                	push   $0xf
  280b1e:	6a 00                	push   $0x0
  280b20:	e8 48 ff ff ff       	call   280a6d <set_palette>
  280b25:	8d bd 60 fd ff ff    	lea    -0x2a0(%ebp),%edi
  280b2b:	83 c4 10             	add    $0x10,%esp
  280b2e:	bb 00 00 00 00       	mov    $0x0,%ebx
  280b33:	eb 32                	jmp    280b67 <init_palette+0x5c>
	{
		for(g=0;g<6;g++)
		{
			for(r=0;r<6;r++)
			{
				table2[(r+g*6+b*36)*3+0] = r*51;
  280b35:	88 10                	mov    %dl,(%eax)
				table2[(r+g*6+b*36)*3+1] = g*51;
  280b37:	88 48 01             	mov    %cl,0x1(%eax)
				table2[(r+g*6+b*36)*3+2] = b*51;
  280b3a:	88 58 02             	mov    %bl,0x2(%eax)
  280b3d:	83 c2 33             	add    $0x33,%edx
  280b40:	83 c0 03             	add    $0x3,%eax
	set_palette(0,15,table_rgb);
	for(b=0;b<6;b++)
	{
		for(g=0;g<6;g++)
		{
			for(r=0;r<6;r++)
  280b43:	80 fa 32             	cmp    $0x32,%dl
  280b46:	75 ed                	jne    280b35 <init_palette+0x2a>
  280b48:	83 c6 12             	add    $0x12,%esi
  280b4b:	83 c1 33             	add    $0x33,%ecx
	unsigned char table2[216*3];
	int r,g,b;
	set_palette(0,15,table_rgb);
	for(b=0;b<6;b++)
	{
		for(g=0;g<6;g++)
  280b4e:	80 f9 32             	cmp    $0x32,%cl
  280b51:	74 09                	je     280b5c <init_palette+0x51>
#include "graphics.h"

void init_palette(void)
{
  280b53:	89 f0                	mov    %esi,%eax
  280b55:	ba 00 00 00 00       	mov    $0x0,%edx
  280b5a:	eb d9                	jmp    280b35 <init_palette+0x2a>
  280b5c:	83 c3 33             	add    $0x33,%ebx
  280b5f:	83 c7 6c             	add    $0x6c,%edi
		0x84, 0x84, 0x84,	//dark gray
	};
	unsigned char table2[216*3];
	int r,g,b;
	set_palette(0,15,table_rgb);
	for(b=0;b<6;b++)
  280b62:	80 fb 32             	cmp    $0x32,%bl
  280b65:	74 09                	je     280b70 <init_palette+0x65>
#include "graphics.h"

void init_palette(void)
{
  280b67:	89 fe                	mov    %edi,%esi
  280b69:	b9 00 00 00 00       	mov    $0x0,%ecx
  280b6e:	eb e3                	jmp    280b53 <init_palette+0x48>
				table2[(r+g*6+b*36)*3+1] = g*51;
				table2[(r+g*6+b*36)*3+2] = b*51;
			}
		}
	}
	set_palette(16,231,table2);
  280b70:	83 ec 04             	sub    $0x4,%esp
  280b73:	8d 85 60 fd ff ff    	lea    -0x2a0(%ebp),%eax
  280b79:	50                   	push   %eax
  280b7a:	68 e7 00 00 00       	push   $0xe7
  280b7f:	6a 10                	push   $0x10
  280b81:	e8 e7 fe ff ff       	call   280a6d <set_palette>
	return;	
  280b86:	83 c4 10             	add    $0x10,%esp
}
  280b89:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280b8c:	5b                   	pop    %ebx
  280b8d:	5e                   	pop    %esi
  280b8e:	5f                   	pop    %edi
  280b8f:	5d                   	pop    %ebp
  280b90:	c3                   	ret    

00280b91 <boxfill8>:
	io_store_eflags(eflags);
	return;
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
  280b91:	55                   	push   %ebp
  280b92:	89 e5                	mov    %esp,%ebp
  280b94:	57                   	push   %edi
  280b95:	56                   	push   %esi
  280b96:	53                   	push   %ebx
  280b97:	83 ec 04             	sub    $0x4,%esp
  280b9a:	8b 55 0c             	mov    0xc(%ebp),%edx
  280b9d:	8b 7d 14             	mov    0x14(%ebp),%edi
  280ba0:	8b 75 18             	mov    0x18(%ebp),%esi
  280ba3:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  280ba6:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
	int x,y;
	for(y=y0;y<=y1;y++)
  280baa:	3b 75 20             	cmp    0x20(%ebp),%esi
  280bad:	7f 28                	jg     280bd7 <boxfill8+0x46>
  280baf:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280bb2:	0f af d6             	imul   %esi,%edx
  280bb5:	03 55 08             	add    0x8(%ebp),%edx
  280bb8:	eb 15                	jmp    280bcf <boxfill8+0x3e>
	{
		for(x=x0;x<=x1;x++)
			vram[y*xsize+x]=c;
  280bba:	88 1c 02             	mov    %bl,(%edx,%eax,1)
void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
	{
		for(x=x0;x<=x1;x++)
  280bbd:	83 c0 01             	add    $0x1,%eax
  280bc0:	39 c1                	cmp    %eax,%ecx
  280bc2:	7d f6                	jge    280bba <boxfill8+0x29>
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
  280bc4:	83 c6 01             	add    $0x1,%esi
  280bc7:	03 55 f0             	add    -0x10(%ebp),%edx
  280bca:	39 75 20             	cmp    %esi,0x20(%ebp)
  280bcd:	7c 08                	jl     280bd7 <boxfill8+0x46>
	{
		for(x=x0;x<=x1;x++)
  280bcf:	89 f8                	mov    %edi,%eax
  280bd1:	39 cf                	cmp    %ecx,%edi
  280bd3:	7e e5                	jle    280bba <boxfill8+0x29>
  280bd5:	eb ed                	jmp    280bc4 <boxfill8+0x33>
			vram[y*xsize+x]=c;
	}
		
	return;
}
  280bd7:	83 c4 04             	add    $0x4,%esp
  280bda:	5b                   	pop    %ebx
  280bdb:	5e                   	pop    %esi
  280bdc:	5f                   	pop    %edi
  280bdd:	5d                   	pop    %ebp
  280bde:	c3                   	ret    

00280bdf <boxfill8_test>:

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
  280bdf:	55                   	push   %ebp
  280be0:	89 e5                	mov    %esp,%ebp
  280be2:	53                   	push   %ebx
  280be3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  280be6:	8b 55 10             	mov    0x10(%ebp),%edx
  280be9:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	int i;
	for(i=0;i<size;i++)
  280bed:	85 d2                	test   %edx,%edx
  280bef:	7e 0d                	jle    280bfe <boxfill8_test+0x1f>
  280bf1:	89 d8                	mov    %ebx,%eax
  280bf3:	01 da                	add    %ebx,%edx
	{
		vram[i] = c;
  280bf5:	88 08                	mov    %cl,(%eax)
  280bf7:	83 c0 01             	add    $0x1,%eax
}

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
	int i;
	for(i=0;i<size;i++)
  280bfa:	39 d0                	cmp    %edx,%eax
  280bfc:	75 f7                	jne    280bf5 <boxfill8_test+0x16>
	{
		vram[i] = c;
	}
	//vram[TRY_BG_SIZE-1] = c;
}
  280bfe:	5b                   	pop    %ebx
  280bff:	5d                   	pop    %ebp
  280c00:	c3                   	ret    

00280c01 <init_screen8>:

void init_screen8(unsigned char *vram, int xsize, int ysize)
{
  280c01:	55                   	push   %ebp
  280c02:	89 e5                	mov    %esp,%ebp
  280c04:	57                   	push   %edi
  280c05:	56                   	push   %esi
  280c06:	53                   	push   %ebx
  280c07:	83 ec 14             	sub    $0x14,%esp
  280c0a:	8b 7d 08             	mov    0x8(%ebp),%edi
  280c0d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280c10:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(vram,310,COL8_008484,0,0,310,190);
  280c13:	68 be 00 00 00       	push   $0xbe
  280c18:	68 36 01 00 00       	push   $0x136
  280c1d:	6a 00                	push   $0x0
  280c1f:	6a 00                	push   $0x0
  280c21:	6a 0e                	push   $0xe
  280c23:	68 36 01 00 00       	push   $0x136
  280c28:	57                   	push   %edi
  280c29:	e8 63 ff ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_008484,0,      0,          xsize-1,    ysize-29);
  280c2e:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280c31:	89 c2                	mov    %eax,%edx
  280c33:	8d 46 e3             	lea    -0x1d(%esi),%eax
  280c36:	50                   	push   %eax
  280c37:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280c3a:	52                   	push   %edx
  280c3b:	6a 00                	push   $0x0
  280c3d:	6a 00                	push   $0x0
  280c3f:	6a 0e                	push   $0xe
  280c41:	53                   	push   %ebx
  280c42:	57                   	push   %edi
  280c43:	e8 49 ff ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-28,   xsize-1,    ysize-28);
  280c48:	8d 46 e4             	lea    -0x1c(%esi),%eax
  280c4b:	83 c4 38             	add    $0x38,%esp
  280c4e:	50                   	push   %eax
  280c4f:	ff 75 f0             	pushl  -0x10(%ebp)
  280c52:	50                   	push   %eax
  280c53:	6a 00                	push   $0x0
  280c55:	6a 08                	push   $0x8
  280c57:	53                   	push   %ebx
  280c58:	57                   	push   %edi
  280c59:	e8 33 ff ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,0,      ysize-27,   xsize-1,    ysize-27);
  280c5e:	8d 46 e5             	lea    -0x1b(%esi),%eax
  280c61:	50                   	push   %eax
  280c62:	ff 75 f0             	pushl  -0x10(%ebp)
  280c65:	50                   	push   %eax
  280c66:	6a 00                	push   $0x0
  280c68:	6a 07                	push   $0x7
  280c6a:	53                   	push   %ebx
  280c6b:	57                   	push   %edi
  280c6c:	e8 20 ff ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-26,   xsize-1,    ysize- 1);
  280c71:	83 c4 38             	add    $0x38,%esp
  280c74:	8d 46 ff             	lea    -0x1(%esi),%eax
  280c77:	50                   	push   %eax
  280c78:	ff 75 f0             	pushl  -0x10(%ebp)
  280c7b:	8d 46 e6             	lea    -0x1a(%esi),%eax
  280c7e:	50                   	push   %eax
  280c7f:	6a 00                	push   $0x0
  280c81:	6a 08                	push   $0x8
  280c83:	53                   	push   %ebx
  280c84:	57                   	push   %edi
  280c85:	e8 07 ff ff ff       	call   280b91 <boxfill8>
	
	
	boxfill8(vram,xsize,COL8_FFFFFF,3,      ysize-24,   59,         ysize-24);
  280c8a:	8d 46 e8             	lea    -0x18(%esi),%eax
  280c8d:	50                   	push   %eax
  280c8e:	6a 3b                	push   $0x3b
  280c90:	89 45 f0             	mov    %eax,-0x10(%ebp)
  280c93:	50                   	push   %eax
  280c94:	6a 03                	push   $0x3
  280c96:	6a 07                	push   $0x7
  280c98:	53                   	push   %ebx
  280c99:	57                   	push   %edi
  280c9a:	e8 f2 fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,2,      ysize-24,    2,         ysize- 4);
  280c9f:	8d 4e fc             	lea    -0x4(%esi),%ecx
  280ca2:	83 c4 38             	add    $0x38,%esp
  280ca5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  280ca8:	51                   	push   %ecx
  280ca9:	6a 02                	push   $0x2
  280cab:	ff 75 f0             	pushl  -0x10(%ebp)
  280cae:	6a 02                	push   $0x2
  280cb0:	6a 07                	push   $0x7
  280cb2:	53                   	push   %ebx
  280cb3:	57                   	push   %edi
  280cb4:	e8 d8 fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,3,      ysize- 4,   59,         ysize- 4);
  280cb9:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  280cbc:	51                   	push   %ecx
  280cbd:	6a 3b                	push   $0x3b
  280cbf:	51                   	push   %ecx
  280cc0:	6a 03                	push   $0x3
  280cc2:	6a 0f                	push   $0xf
  280cc4:	53                   	push   %ebx
  280cc5:	57                   	push   %edi
  280cc6:	e8 c6 fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,59,     ysize-23,   59,         ysize- 5);
  280ccb:	8d 56 e9             	lea    -0x17(%esi),%edx
  280cce:	83 c4 38             	add    $0x38,%esp
  280cd1:	8d 46 fb             	lea    -0x5(%esi),%eax
  280cd4:	50                   	push   %eax
  280cd5:	6a 3b                	push   $0x3b
  280cd7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  280cda:	52                   	push   %edx
  280cdb:	6a 3b                	push   $0x3b
  280cdd:	6a 0f                	push   $0xf
  280cdf:	53                   	push   %ebx
  280ce0:	57                   	push   %edi
  280ce1:	e8 ab fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,2,      ysize- 3,   59,         ysize- 3);
  280ce6:	83 ee 03             	sub    $0x3,%esi
  280ce9:	56                   	push   %esi
  280cea:	6a 3b                	push   $0x3b
  280cec:	56                   	push   %esi
  280ced:	6a 02                	push   $0x2
  280cef:	6a 00                	push   $0x0
  280cf1:	53                   	push   %ebx
  280cf2:	57                   	push   %edi
  280cf3:	e8 99 fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,60,     ysize-24,   60,         ysize- 3);
  280cf8:	83 c4 38             	add    $0x38,%esp
  280cfb:	56                   	push   %esi
  280cfc:	6a 3c                	push   $0x3c
  280cfe:	ff 75 f0             	pushl  -0x10(%ebp)
  280d01:	6a 3c                	push   $0x3c
  280d03:	6a 00                	push   $0x0
  280d05:	53                   	push   %ebx
  280d06:	57                   	push   %edi
  280d07:	e8 85 fe ff ff       	call   280b91 <boxfill8>
	
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-24,   xsize- 4,   ysize-24);
  280d0c:	8d 4b fc             	lea    -0x4(%ebx),%ecx
  280d0f:	8d 53 d1             	lea    -0x2f(%ebx),%edx
  280d12:	8b 45 f0             	mov    -0x10(%ebp),%eax
  280d15:	50                   	push   %eax
  280d16:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  280d19:	51                   	push   %ecx
  280d1a:	50                   	push   %eax
  280d1b:	89 55 e8             	mov    %edx,-0x18(%ebp)
  280d1e:	52                   	push   %edx
  280d1f:	6a 0f                	push   $0xf
  280d21:	53                   	push   %ebx
  280d22:	57                   	push   %edi
  280d23:	e8 69 fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-23,   xsize-47,   ysize- 4);
  280d28:	83 c4 38             	add    $0x38,%esp
  280d2b:	ff 75 ec             	pushl  -0x14(%ebp)
  280d2e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  280d31:	52                   	push   %edx
  280d32:	ff 75 e4             	pushl  -0x1c(%ebp)
  280d35:	52                   	push   %edx
  280d36:	6a 0f                	push   $0xf
  280d38:	53                   	push   %ebx
  280d39:	57                   	push   %edi
  280d3a:	e8 52 fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize-47,       ysize- 3,   xsize- 4,   ysize- 3);
  280d3f:	56                   	push   %esi
  280d40:	ff 75 e0             	pushl  -0x20(%ebp)
  280d43:	56                   	push   %esi
  280d44:	ff 75 e8             	pushl  -0x18(%ebp)
  280d47:	6a 07                	push   $0x7
  280d49:	53                   	push   %ebx
  280d4a:	57                   	push   %edi
  280d4b:	e8 41 fe ff ff       	call   280b91 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
  280d50:	8d 43 fd             	lea    -0x3(%ebx),%eax
  280d53:	83 c4 38             	add    $0x38,%esp
  280d56:	56                   	push   %esi
  280d57:	50                   	push   %eax
  280d58:	ff 75 f0             	pushl  -0x10(%ebp)
  280d5b:	50                   	push   %eax
  280d5c:	6a 07                	push   $0x7
  280d5e:	53                   	push   %ebx
  280d5f:	57                   	push   %edi
  280d60:	e8 2c fe ff ff       	call   280b91 <boxfill8>
}
  280d65:	83 c4 1c             	add    $0x1c,%esp
  280d68:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280d6b:	5b                   	pop    %ebx
  280d6c:	5e                   	pop    %esi
  280d6d:	5f                   	pop    %edi
  280d6e:	5d                   	pop    %ebp
  280d6f:	c3                   	ret    

00280d70 <init_mouse_cursor8>:


void init_mouse_cursor8(char *mouse, char bc)
{
  280d70:	55                   	push   %ebp
  280d71:	89 e5                	mov    %esp,%ebp
  280d73:	57                   	push   %edi
  280d74:	56                   	push   %esi
  280d75:	53                   	push   %ebx
  280d76:	83 ec 08             	sub    $0x8,%esp
  280d79:	8b 75 08             	mov    0x8(%ebp),%esi
  280d7c:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
  280d80:	89 75 f0             	mov    %esi,-0x10(%ebp)
  280d83:	8d 86 00 01 00 00    	lea    0x100(%esi),%eax
  280d89:	89 45 ec             	mov    %eax,-0x14(%ebp)
  280d8c:	eb 38                	jmp    280dc6 <init_mouse_cursor8+0x56>
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280d8e:	0f b6 94 03 00 48 28 	movzbl 0x284800(%ebx,%eax,1),%edx
  280d95:	00 
  280d96:	80 fa 2a             	cmp    $0x2a,%dl
  280d99:	75 06                	jne    280da1 <init_mouse_cursor8+0x31>
				mouse[y*16+x] = COL8_000000;
  280d9b:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
  280d9f:	eb 15                	jmp    280db6 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == 'O')
  280da1:	80 fa 4f             	cmp    $0x4f,%dl
  280da4:	75 06                	jne    280dac <init_mouse_cursor8+0x3c>
				mouse[y*16+x] = COL8_FFFFFF;
  280da6:	c6 04 06 07          	movb   $0x7,(%esi,%eax,1)
  280daa:	eb 0a                	jmp    280db6 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == '.')
  280dac:	80 fa 2e             	cmp    $0x2e,%dl
  280daf:	75 05                	jne    280db6 <init_mouse_cursor8+0x46>
				mouse[y*16+x] = bc;
  280db1:	89 fa                	mov    %edi,%edx
  280db3:	88 14 06             	mov    %dl,(%esi,%eax,1)
	};
	int x,y;
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
  280db6:	83 c0 01             	add    $0x1,%eax
  280db9:	83 f8 10             	cmp    $0x10,%eax
  280dbc:	75 d0                	jne    280d8e <init_mouse_cursor8+0x1e>
  280dbe:	83 c6 10             	add    $0x10,%esi
        "............*OO*",
        ".............***"
	};
	int x,y;
	
	for(y=0;y<16;y++)
  280dc1:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  280dc4:	74 0c                	je     280dd2 <init_mouse_cursor8+0x62>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
}


void init_mouse_cursor8(char *mouse, char bc)
{
  280dc6:	b8 00 00 00 00       	mov    $0x0,%eax
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280dcb:	89 f3                	mov    %esi,%ebx
  280dcd:	2b 5d f0             	sub    -0x10(%ebp),%ebx
  280dd0:	eb bc                	jmp    280d8e <init_mouse_cursor8+0x1e>
			else if(cursor[y][x] == '.')
				mouse[y*16+x] = bc;
		}
	}
	return;
}
  280dd2:	83 c4 08             	add    $0x8,%esp
  280dd5:	5b                   	pop    %ebx
  280dd6:	5e                   	pop    %esi
  280dd7:	5f                   	pop    %edi
  280dd8:	5d                   	pop    %ebp
  280dd9:	c3                   	ret    

00280dda <make_wtitle8>:
	make_wtitle8(buf,xsize,title,act);
	return;
}

void make_wtitle8(unsigned char *buf,int xsize,char *title,char act)
{
  280dda:	55                   	push   %ebp
  280ddb:	89 e5                	mov    %esp,%ebp
  280ddd:	57                   	push   %edi
  280dde:	56                   	push   %esi
  280ddf:	53                   	push   %ebx
  280de0:	83 ec 1c             	sub    $0x1c,%esp
  280de3:	8b 75 08             	mov    0x8(%ebp),%esi
  280de6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280de9:	8b 55 14             	mov    0x14(%ebp),%edx
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
		tbc= COL8_848484;
  280dec:	80 fa 01             	cmp    $0x1,%dl
  280def:	19 c0                	sbb    %eax,%eax
  280df1:	83 e0 03             	and    $0x3,%eax
  280df4:	83 c0 0c             	add    $0xc,%eax
  280df7:	80 fa 01             	cmp    $0x1,%dl
  280dfa:	19 ff                	sbb    %edi,%edi
  280dfc:	f7 d7                	not    %edi
  280dfe:	83 c7 08             	add    $0x8,%edi
	}
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
  280e01:	6a 14                	push   $0x14
  280e03:	8d 53 fc             	lea    -0x4(%ebx),%edx
  280e06:	52                   	push   %edx
  280e07:	6a 03                	push   $0x3
  280e09:	6a 03                	push   $0x3
  280e0b:	0f b6 c0             	movzbl %al,%eax
  280e0e:	50                   	push   %eax
  280e0f:	53                   	push   %ebx
  280e10:	56                   	push   %esi
  280e11:	e8 7b fd ff ff       	call   280b91 <boxfill8>
	putfonts8_asc(buf,xsize,24,4,tc,title);
  280e16:	83 c4 04             	add    $0x4,%esp
  280e19:	ff 75 10             	pushl  0x10(%ebp)
  280e1c:	89 f8                	mov    %edi,%eax
  280e1e:	0f be f8             	movsbl %al,%edi
  280e21:	57                   	push   %edi
  280e22:	6a 04                	push   $0x4
  280e24:	6a 18                	push   $0x18
  280e26:	53                   	push   %ebx
  280e27:	56                   	push   %esi
  280e28:	e8 c7 04 00 00       	call   2812f4 <putfonts8_asc>
  280e2d:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  280e30:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
  280e33:	01 fb                	add    %edi,%ebx
  280e35:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
  280e38:	83 c4 30             	add    $0x30,%esp
  280e3b:	be 00 00 00 00       	mov    $0x0,%esi
  280e40:	eb 41                	jmp    280e83 <make_wtitle8+0xa9>
  280e42:	89 c1                	mov    %eax,%ecx
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
		{
			c=closebtn[y][x];
  280e44:	0f b6 9c 06 20 47 28 	movzbl 0x284720(%esi,%eax,1),%ebx
  280e4b:	00 
			if(c == '@') c=COL8_000000;
  280e4c:	ba 00 00 00 00       	mov    $0x0,%edx
  280e51:	80 fb 40             	cmp    $0x40,%bl
  280e54:	74 13                	je     280e69 <make_wtitle8+0x8f>
			else if(c == '$') c=COL8_848484;
  280e56:	ba 0f 00 00 00       	mov    $0xf,%edx
  280e5b:	80 fb 24             	cmp    $0x24,%bl
  280e5e:	74 09                	je     280e69 <make_wtitle8+0x8f>
			else if(c == 'Q') c=COL8_C6C6C6;
			else c=COL8_FFFFFF;
  280e60:	80 fb 51             	cmp    $0x51,%bl
  280e63:	0f 94 c2             	sete   %dl
  280e66:	83 c2 07             	add    $0x7,%edx
			buf[(5+y)*xsize+(xsize-21+x)] = c;
  280e69:	88 54 0f eb          	mov    %dl,-0x15(%edi,%ecx,1)
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
  280e6d:	83 c0 01             	add    $0x1,%eax
  280e70:	83 f8 10             	cmp    $0x10,%eax
  280e73:	75 cd                	jne    280e42 <make_wtitle8+0x68>
  280e75:	03 7d e4             	add    -0x1c(%ebp),%edi
  280e78:	83 c6 10             	add    $0x10,%esi
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
  280e7b:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
  280e81:	74 07                	je     280e8a <make_wtitle8+0xb0>
		tc = COL8_FFFFFF;
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
  280e83:	b8 00 00 00 00       	mov    $0x0,%eax
  280e88:	eb b8                	jmp    280e42 <make_wtitle8+0x68>
			else c=COL8_FFFFFF;
			buf[(5+y)*xsize+(xsize-21+x)] = c;
		}
	}
	return;
}
  280e8a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280e8d:	5b                   	pop    %ebx
  280e8e:	5e                   	pop    %esi
  280e8f:	5f                   	pop    %edi
  280e90:	5d                   	pop    %ebp
  280e91:	c3                   	ret    

00280e92 <make_window8>:
	}
	return;
}

void make_window8(unsigned char *buf,int xsize,int ysize,char *title,char act)
{
  280e92:	55                   	push   %ebp
  280e93:	89 e5                	mov    %esp,%ebp
  280e95:	57                   	push   %edi
  280e96:	56                   	push   %esi
  280e97:	53                   	push   %ebx
  280e98:	83 ec 1c             	sub    $0x1c,%esp
  280e9b:	8b 75 08             	mov    0x8(%ebp),%esi
  280e9e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280ea1:	8b 45 18             	mov    0x18(%ebp),%eax
  280ea4:	89 45 d8             	mov    %eax,-0x28(%ebp)
	boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , xsize - 1, 0  );
  280ea7:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280eaa:	6a 00                	push   $0x0
  280eac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  280eaf:	50                   	push   %eax
  280eb0:	6a 00                	push   $0x0
  280eb2:	6a 00                	push   $0x0
  280eb4:	6a 08                	push   $0x8
  280eb6:	53                   	push   %ebx
  280eb7:	56                   	push   %esi
  280eb8:	e8 d4 fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , xsize - 2, 1  );
  280ebd:	8d 53 fe             	lea    -0x2(%ebx),%edx
  280ec0:	6a 01                	push   $0x1
  280ec2:	89 55 e0             	mov    %edx,-0x20(%ebp)
  280ec5:	52                   	push   %edx
  280ec6:	6a 01                	push   $0x1
  280ec8:	6a 01                	push   $0x1
  280eca:	6a 07                	push   $0x7
  280ecc:	53                   	push   %ebx
  280ecd:	56                   	push   %esi
  280ece:	e8 be fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , 0     , ysize-1);
  280ed3:	8b 7d 10             	mov    0x10(%ebp),%edi
  280ed6:	8d 4f ff             	lea    -0x1(%edi),%ecx
  280ed9:	83 c4 38             	add    $0x38,%esp
  280edc:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  280edf:	51                   	push   %ecx
  280ee0:	6a 00                	push   $0x0
  280ee2:	6a 00                	push   $0x0
  280ee4:	6a 00                	push   $0x0
  280ee6:	6a 08                	push   $0x8
  280ee8:	53                   	push   %ebx
  280ee9:	56                   	push   %esi
  280eea:	e8 a2 fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , 1     , ysize-2);
  280eef:	8b 7d 10             	mov    0x10(%ebp),%edi
  280ef2:	83 ef 02             	sub    $0x2,%edi
  280ef5:	57                   	push   %edi
  280ef6:	6a 01                	push   $0x1
  280ef8:	6a 01                	push   $0x1
  280efa:	6a 01                	push   $0x1
  280efc:	6a 07                	push   $0x7
  280efe:	53                   	push   %ebx
  280eff:	56                   	push   %esi
  280f00:	e8 8c fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, xsize-2,1     , xsize-2,ysize-2);
  280f05:	83 c4 38             	add    $0x38,%esp
  280f08:	57                   	push   %edi
  280f09:	8b 55 e0             	mov    -0x20(%ebp),%edx
  280f0c:	52                   	push   %edx
  280f0d:	6a 01                	push   $0x1
  280f0f:	52                   	push   %edx
  280f10:	6a 0f                	push   $0xf
  280f12:	53                   	push   %ebx
  280f13:	56                   	push   %esi
  280f14:	e8 78 fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, xsize-1,0     , xsize-1,ysize-1);
  280f19:	ff 75 dc             	pushl  -0x24(%ebp)
  280f1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  280f1f:	50                   	push   %eax
  280f20:	6a 00                	push   $0x0
  280f22:	50                   	push   %eax
  280f23:	6a 00                	push   $0x0
  280f25:	53                   	push   %ebx
  280f26:	56                   	push   %esi
  280f27:	e8 65 fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 2     , 2     , xsize-3,ysize-3);
  280f2c:	83 c4 38             	add    $0x38,%esp
  280f2f:	8b 55 10             	mov    0x10(%ebp),%edx
  280f32:	8d 42 fd             	lea    -0x3(%edx),%eax
  280f35:	50                   	push   %eax
  280f36:	8d 43 fd             	lea    -0x3(%ebx),%eax
  280f39:	50                   	push   %eax
  280f3a:	6a 02                	push   $0x2
  280f3c:	6a 02                	push   $0x2
  280f3e:	6a 08                	push   $0x8
  280f40:	53                   	push   %ebx
  280f41:	56                   	push   %esi
  280f42:	e8 4a fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, 1     , ysize-2,xsize-2,ysize-2);
  280f47:	57                   	push   %edi
  280f48:	ff 75 e0             	pushl  -0x20(%ebp)
  280f4b:	57                   	push   %edi
  280f4c:	6a 01                	push   $0x1
  280f4e:	6a 0f                	push   $0xf
  280f50:	53                   	push   %ebx
  280f51:	56                   	push   %esi
  280f52:	e8 3a fc ff ff       	call   280b91 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, 0     , ysize-1,xsize-1,ysize-1);
  280f57:	83 c4 38             	add    $0x38,%esp
  280f5a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  280f5d:	51                   	push   %ecx
  280f5e:	ff 75 e4             	pushl  -0x1c(%ebp)
  280f61:	51                   	push   %ecx
  280f62:	6a 00                	push   $0x0
  280f64:	6a 00                	push   $0x0
  280f66:	53                   	push   %ebx
  280f67:	56                   	push   %esi
  280f68:	e8 24 fc ff ff       	call   280b91 <boxfill8>
	make_wtitle8(buf,xsize,title,act);
  280f6d:	83 c4 1c             	add    $0x1c,%esp
  280f70:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  280f74:	50                   	push   %eax
  280f75:	ff 75 14             	pushl  0x14(%ebp)
  280f78:	53                   	push   %ebx
  280f79:	56                   	push   %esi
  280f7a:	e8 5b fe ff ff       	call   280dda <make_wtitle8>
	return;
  280f7f:	83 c4 10             	add    $0x10,%esp
}
  280f82:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280f85:	5b                   	pop    %ebx
  280f86:	5e                   	pop    %esi
  280f87:	5f                   	pop    %edi
  280f88:	5d                   	pop    %ebp
  280f89:	c3                   	ret    

00280f8a <putblock8_8>:
	}
	return;
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
  280f8a:	55                   	push   %ebp
  280f8b:	89 e5                	mov    %esp,%ebp
  280f8d:	57                   	push   %edi
  280f8e:	56                   	push   %esi
  280f8f:	53                   	push   %ebx
  280f90:	83 ec 04             	sub    $0x4,%esp
  280f93:	8b 45 0c             	mov    0xc(%ebp),%eax
  280f96:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int x,y;
	for(y=0;y<pysize;y++)
  280f99:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  280f9d:	7e 49                	jle    280fe8 <putblock8_8+0x5e>
  280f9f:	8b 7d 24             	mov    0x24(%ebp),%edi
  280fa2:	8b 4d 20             	mov    0x20(%ebp),%ecx
  280fa5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  280fa8:	0f af 45 1c          	imul   0x1c(%ebp),%eax
  280fac:	03 45 18             	add    0x18(%ebp),%eax
  280faf:	89 c2                	mov    %eax,%edx
  280fb1:	03 55 08             	add    0x8(%ebp),%edx
  280fb4:	be 00 00 00 00       	mov    $0x0,%esi
  280fb9:	eb 22                	jmp    280fdd <putblock8_8+0x53>
  280fbb:	89 5d 10             	mov    %ebx,0x10(%ebp)
		for(x=0;x<pxsize;x++)
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];
  280fbe:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
  280fc2:	88 1c 02             	mov    %bl,(%edx,%eax,1)

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
		for(x=0;x<pxsize;x++)
  280fc5:	83 c0 01             	add    $0x1,%eax
  280fc8:	39 45 10             	cmp    %eax,0x10(%ebp)
  280fcb:	75 f1                	jne    280fbe <putblock8_8+0x34>
  280fcd:	8b 5d 10             	mov    0x10(%ebp),%ebx
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
  280fd0:	83 c6 01             	add    $0x1,%esi
  280fd3:	01 f9                	add    %edi,%ecx
  280fd5:	03 55 f0             	add    -0x10(%ebp),%edx
  280fd8:	39 75 14             	cmp    %esi,0x14(%ebp)
  280fdb:	74 0b                	je     280fe8 <putblock8_8+0x5e>
		for(x=0;x<pxsize;x++)
  280fdd:	b8 00 00 00 00       	mov    $0x0,%eax
  280fe2:	85 db                	test   %ebx,%ebx
  280fe4:	7f d5                	jg     280fbb <putblock8_8+0x31>
  280fe6:	eb e8                	jmp    280fd0 <putblock8_8+0x46>
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];

	return;
}
  280fe8:	83 c4 04             	add    $0x4,%esp
  280feb:	5b                   	pop    %ebx
  280fec:	5e                   	pop    %esi
  280fed:	5f                   	pop    %edi
  280fee:	5d                   	pop    %ebp
  280fef:	c3                   	ret    

00280ff0 <putfonts8_asc_sht>:
//b background color
//c font color
void putfonts8_asc_sht(struct SHEET *sht,int x,int y,int c,int b,char *s,int l)
{
  280ff0:	55                   	push   %ebp
  280ff1:	89 e5                	mov    %esp,%ebp
  280ff3:	57                   	push   %edi
  280ff4:	56                   	push   %esi
  280ff5:	53                   	push   %ebx
  280ff6:	83 ec 0c             	sub    $0xc,%esp
  280ff9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  280ffc:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(sht->buf,sht->bxsize,b,x,y,x+l*8-1,y+15);
  280fff:	8b 45 20             	mov    0x20(%ebp),%eax
  281002:	8b 55 0c             	mov    0xc(%ebp),%edx
  281005:	8d 3c c2             	lea    (%edx,%eax,8),%edi
  281008:	8d 46 0f             	lea    0xf(%esi),%eax
  28100b:	50                   	push   %eax
  28100c:	8d 47 ff             	lea    -0x1(%edi),%eax
  28100f:	50                   	push   %eax
  281010:	56                   	push   %esi
  281011:	52                   	push   %edx
  281012:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  281016:	50                   	push   %eax
  281017:	ff 73 04             	pushl  0x4(%ebx)
  28101a:	ff 33                	pushl  (%ebx)
  28101c:	e8 70 fb ff ff       	call   280b91 <boxfill8>
	putfonts8_asc(sht->buf,sht->bxsize,x,y,c,s);
  281021:	83 c4 04             	add    $0x4,%esp
  281024:	ff 75 1c             	pushl  0x1c(%ebp)
  281027:	ff 75 14             	pushl  0x14(%ebp)
  28102a:	56                   	push   %esi
  28102b:	ff 75 0c             	pushl  0xc(%ebp)
  28102e:	ff 73 04             	pushl  0x4(%ebx)
  281031:	ff 33                	pushl  (%ebx)
  281033:	e8 bc 02 00 00       	call   2812f4 <putfonts8_asc>
	sheet_refresh(sht,x,y,x+l*8,y+16);
  281038:	83 c4 24             	add    $0x24,%esp
  28103b:	8d 46 10             	lea    0x10(%esi),%eax
  28103e:	50                   	push   %eax
  28103f:	57                   	push   %edi
  281040:	56                   	push   %esi
  281041:	ff 75 0c             	pushl  0xc(%ebp)
  281044:	53                   	push   %ebx
  281045:	e8 34 16 00 00       	call   28267e <sheet_refresh>
}
  28104a:	83 c4 20             	add    $0x20,%esp
  28104d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281050:	5b                   	pop    %ebx
  281051:	5e                   	pop    %esi
  281052:	5f                   	pop    %edi
  281053:	5d                   	pop    %ebp
  281054:	c3                   	ret    

00281055 <make_textbox8>:

void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c)
{
  281055:	55                   	push   %ebp
  281056:	89 e5                	mov    %esp,%ebp
  281058:	57                   	push   %edi
  281059:	56                   	push   %esi
  28105a:	53                   	push   %ebx
  28105b:	83 ec 18             	sub    $0x18,%esp
  28105e:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int x1 = x0 + sx, y1 = y0 + sy;
  281061:	8b 45 0c             	mov    0xc(%ebp),%eax
  281064:	03 45 14             	add    0x14(%ebp),%eax
  281067:	8b 55 10             	mov    0x10(%ebp),%edx
  28106a:	03 55 18             	add    0x18(%ebp),%edx
  28106d:	89 d7                	mov    %edx,%edi
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 2, y0 - 3, x1 + 1, y0 - 3);
  28106f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  281072:	8d 48 01             	lea    0x1(%eax),%ecx
  281075:	8b 75 10             	mov    0x10(%ebp),%esi
  281078:	83 ee 03             	sub    $0x3,%esi
  28107b:	8b 55 0c             	mov    0xc(%ebp),%edx
  28107e:	83 ea 02             	sub    $0x2,%edx
  281081:	56                   	push   %esi
  281082:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  281085:	51                   	push   %ecx
  281086:	56                   	push   %esi
  281087:	89 55 f0             	mov    %edx,-0x10(%ebp)
  28108a:	52                   	push   %edx
  28108b:	6a 0f                	push   $0xf
  28108d:	ff 73 04             	pushl  0x4(%ebx)
  281090:	ff 33                	pushl  (%ebx)
  281092:	e8 fa fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 3, y0 - 3, x0 - 3, y1 + 1);
  281097:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  28109a:	8d 7f 01             	lea    0x1(%edi),%edi
  28109d:	89 f9                	mov    %edi,%ecx
  28109f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  2810a2:	83 ef 03             	sub    $0x3,%edi
  2810a5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  2810a8:	51                   	push   %ecx
  2810a9:	57                   	push   %edi
  2810aa:	56                   	push   %esi
  2810ab:	57                   	push   %edi
  2810ac:	6a 0f                	push   $0xf
  2810ae:	ff 73 04             	pushl  0x4(%ebx)
  2810b1:	ff 33                	pushl  (%ebx)
  2810b3:	e8 d9 fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x0 - 3, y1 + 2, x1 + 1, y1 + 2);
  2810b8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  2810bb:	8d 4a 02             	lea    0x2(%edx),%ecx
  2810be:	83 c4 38             	add    $0x38,%esp
  2810c1:	51                   	push   %ecx
  2810c2:	ff 75 e0             	pushl  -0x20(%ebp)
  2810c5:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  2810c8:	51                   	push   %ecx
  2810c9:	57                   	push   %edi
  2810ca:	6a 07                	push   $0x7
  2810cc:	ff 73 04             	pushl  0x4(%ebx)
  2810cf:	ff 33                	pushl  (%ebx)
  2810d1:	e8 bb fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x1 + 2, y0 - 3, x1 + 2, y1 + 2);
  2810d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  2810d9:	83 c0 02             	add    $0x2,%eax
  2810dc:	ff 75 dc             	pushl  -0x24(%ebp)
  2810df:	50                   	push   %eax
  2810e0:	56                   	push   %esi
  2810e1:	50                   	push   %eax
  2810e2:	6a 07                	push   $0x7
  2810e4:	ff 73 04             	pushl  0x4(%ebx)
  2810e7:	ff 33                	pushl  (%ebx)
  2810e9:	e8 a3 fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 1, y0 - 2, x1 + 0, y0 - 2);
  2810ee:	8b 75 10             	mov    0x10(%ebp),%esi
  2810f1:	8d 7e fe             	lea    -0x2(%esi),%edi
  2810f4:	8b 75 0c             	mov    0xc(%ebp),%esi
  2810f7:	83 ee 01             	sub    $0x1,%esi
  2810fa:	83 c4 38             	add    $0x38,%esp
  2810fd:	57                   	push   %edi
  2810fe:	ff 75 e8             	pushl  -0x18(%ebp)
  281101:	57                   	push   %edi
  281102:	56                   	push   %esi
  281103:	6a 00                	push   $0x0
  281105:	ff 73 04             	pushl  0x4(%ebx)
  281108:	ff 33                	pushl  (%ebx)
  28110a:	e8 82 fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 2, y0 - 2, x0 - 2, y1 + 0);
  28110f:	ff 75 e4             	pushl  -0x1c(%ebp)
  281112:	8b 55 f0             	mov    -0x10(%ebp),%edx
  281115:	52                   	push   %edx
  281116:	57                   	push   %edi
  281117:	52                   	push   %edx
  281118:	6a 00                	push   $0x0
  28111a:	ff 73 04             	pushl  0x4(%ebx)
  28111d:	ff 33                	pushl  (%ebx)
  28111f:	e8 6d fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x0 - 2, y1 + 1, x1 + 0, y1 + 1);
  281124:	83 c4 38             	add    $0x38,%esp
  281127:	8b 45 ec             	mov    -0x14(%ebp),%eax
  28112a:	50                   	push   %eax
  28112b:	ff 75 e8             	pushl  -0x18(%ebp)
  28112e:	50                   	push   %eax
  28112f:	ff 75 f0             	pushl  -0x10(%ebp)
  281132:	6a 08                	push   $0x8
  281134:	ff 73 04             	pushl  0x4(%ebx)
  281137:	ff 33                	pushl  (%ebx)
  281139:	e8 53 fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x1 + 1, y0 - 2, x1 + 1, y1 + 1);
  28113e:	ff 75 ec             	pushl  -0x14(%ebp)
  281141:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  281144:	51                   	push   %ecx
  281145:	57                   	push   %edi
  281146:	51                   	push   %ecx
  281147:	6a 08                	push   $0x8
  281149:	ff 73 04             	pushl  0x4(%ebx)
  28114c:	ff 33                	pushl  (%ebx)
  28114e:	e8 3e fa ff ff       	call   280b91 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, c,           x0 - 1, y0 - 1, x1 + 0, y1 + 0);
  281153:	83 c4 38             	add    $0x38,%esp
  281156:	ff 75 e4             	pushl  -0x1c(%ebp)
  281159:	ff 75 e8             	pushl  -0x18(%ebp)
  28115c:	8b 45 10             	mov    0x10(%ebp),%eax
  28115f:	83 e8 01             	sub    $0x1,%eax
  281162:	50                   	push   %eax
  281163:	56                   	push   %esi
  281164:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  281168:	50                   	push   %eax
  281169:	ff 73 04             	pushl  0x4(%ebx)
  28116c:	ff 33                	pushl  (%ebx)
  28116e:	e8 1e fa ff ff       	call   280b91 <boxfill8>
    return;
  281173:	83 c4 1c             	add    $0x1c,%esp
}
  281176:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281179:	5b                   	pop    %ebx
  28117a:	5e                   	pop    %esi
  28117b:	5f                   	pop    %edi
  28117c:	5d                   	pop    %ebp
  28117d:	c3                   	ret    

0028117e <drawline8_sht>:

void drawline8_sht(struct SHEET *sht,int x0,int y0,int x1,int y1,int col)
{
  28117e:	55                   	push   %ebp
  28117f:	89 e5                	mov    %esp,%ebp
  281181:	57                   	push   %edi
  281182:	56                   	push   %esi
  281183:	53                   	push   %ebx
  281184:	83 ec 10             	sub    $0x10,%esp
  281187:	8b 75 08             	mov    0x8(%ebp),%esi
	int i,x,y,len,dx,dy;
	dx = x1-x0;
  28118a:	8b 7d 14             	mov    0x14(%ebp),%edi
  28118d:	2b 7d 0c             	sub    0xc(%ebp),%edi
	dy = y1-y0;
  281190:	8b 45 18             	mov    0x18(%ebp),%eax
  281193:	2b 45 10             	sub    0x10(%ebp),%eax
  281196:	89 45 f0             	mov    %eax,-0x10(%ebp)
	x = x0 << 10;
  281199:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  28119c:	c1 e1 0a             	shl    $0xa,%ecx
	y = y0 << 10;
  28119f:	8b 5d 10             	mov    0x10(%ebp),%ebx
  2811a2:	c1 e3 0a             	shl    $0xa,%ebx
  2811a5:	89 fa                	mov    %edi,%edx
  2811a7:	c1 fa 1f             	sar    $0x1f,%edx
  2811aa:	89 d0                	mov    %edx,%eax
  2811ac:	31 fa                	xor    %edi,%edx
  2811ae:	29 c2                	sub    %eax,%edx
  2811b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2811b3:	c1 f8 1f             	sar    $0x1f,%eax
  2811b6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  2811b9:	33 45 f0             	xor    -0x10(%ebp),%eax
  2811bc:	2b 45 ec             	sub    -0x14(%ebp),%eax
	}
	if (dy<0) 
	{
		dy = -dy;
	}
	if(dx >= dy)
  2811bf:	39 c2                	cmp    %eax,%edx
  2811c1:	7c 4a                	jl     28120d <drawline8_sht+0x8f>
	{
		len=dx+1;
  2811c3:	83 c2 01             	add    $0x1,%edx
  2811c6:	89 55 ec             	mov    %edx,-0x14(%ebp)
		if(x0 >x1)
			dx = -1024;
		else
			dx = 1024;
  2811c9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  2811cc:	39 7d 14             	cmp    %edi,0x14(%ebp)
  2811cf:	b8 00 04 00 00       	mov    $0x400,%eax
  2811d4:	ba 00 fc ff ff       	mov    $0xfffffc00,%edx
  2811d9:	89 c7                	mov    %eax,%edi
  2811db:	0f 4c fa             	cmovl  %edx,%edi
  2811de:	89 7d e8             	mov    %edi,-0x18(%ebp)
		if(y0<=y1)
  2811e1:	8b 7d 10             	mov    0x10(%ebp),%edi
  2811e4:	39 7d 18             	cmp    %edi,0x18(%ebp)
  2811e7:	7c 12                	jl     2811fb <drawline8_sht+0x7d>
			dy = ((y1 - y0 + 1)<<10)/len;
  2811e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2811ec:	83 c0 01             	add    $0x1,%eax
  2811ef:	c1 e0 0a             	shl    $0xa,%eax
  2811f2:	99                   	cltd   
  2811f3:	f7 7d ec             	idivl  -0x14(%ebp)
  2811f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  2811f9:	eb 52                	jmp    28124d <drawline8_sht+0xcf>
		else
			dy = ((y1 - y0 - 1)<<10)/len;
  2811fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2811fe:	83 e8 01             	sub    $0x1,%eax
  281201:	c1 e0 0a             	shl    $0xa,%eax
  281204:	99                   	cltd   
  281205:	f7 7d ec             	idivl  -0x14(%ebp)
  281208:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  28120b:	eb 40                	jmp    28124d <drawline8_sht+0xcf>
	}
	else
	{
		len=dy+1;
  28120d:	83 c0 01             	add    $0x1,%eax
  281210:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(y0>y1)
			dy = -1024;
		else
			dy = 1024;
  281213:	8b 55 10             	mov    0x10(%ebp),%edx
  281216:	39 55 18             	cmp    %edx,0x18(%ebp)
  281219:	b8 00 04 00 00       	mov    $0x400,%eax
  28121e:	ba 00 fc ff ff       	mov    $0xfffffc00,%edx
  281223:	0f 4c c2             	cmovl  %edx,%eax
  281226:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(x0<=x1)
  281229:	8b 55 0c             	mov    0xc(%ebp),%edx
  28122c:	39 55 14             	cmp    %edx,0x14(%ebp)
  28122f:	7c 0f                	jl     281240 <drawline8_sht+0xc2>
			dx = ((x1 - x0 + 1)<<10)/len;
  281231:	8d 47 01             	lea    0x1(%edi),%eax
  281234:	c1 e0 0a             	shl    $0xa,%eax
  281237:	99                   	cltd   
  281238:	f7 7d ec             	idivl  -0x14(%ebp)
  28123b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  28123e:	eb 0d                	jmp    28124d <drawline8_sht+0xcf>
		else
			dx = ((x1 - x0 - 1)<<10)/len;
  281240:	8d 47 ff             	lea    -0x1(%edi),%eax
  281243:	c1 e0 0a             	shl    $0xa,%eax
  281246:	99                   	cltd   
  281247:	f7 7d ec             	idivl  -0x14(%ebp)
  28124a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
	for(i=0;i<len;i++)
  28124d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  281251:	7e 31                	jle    281284 <drawline8_sht+0x106>
  281253:	ba 00 00 00 00       	mov    $0x0,%edx
  281258:	89 55 f0             	mov    %edx,-0x10(%ebp)
	{
		sht->buf[(y>>10)*sht->bxsize+(x>>10)] = col;
  28125b:	89 d8                	mov    %ebx,%eax
  28125d:	c1 f8 0a             	sar    $0xa,%eax
  281260:	0f af 46 04          	imul   0x4(%esi),%eax
  281264:	89 cf                	mov    %ecx,%edi
  281266:	c1 ff 0a             	sar    $0xa,%edi
  281269:	03 06                	add    (%esi),%eax
  28126b:	0f b6 55 1c          	movzbl 0x1c(%ebp),%edx
  28126f:	88 14 38             	mov    %dl,(%eax,%edi,1)
		x += dx;
  281272:	03 4d e8             	add    -0x18(%ebp),%ecx
		y += dy;
  281275:	03 5d e4             	add    -0x1c(%ebp),%ebx
		if(x0<=x1)
			dx = ((x1 - x0 + 1)<<10)/len;
		else
			dx = ((x1 - x0 - 1)<<10)/len;
	}
	for(i=0;i<len;i++)
  281278:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  28127c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28127f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  281282:	75 d7                	jne    28125b <drawline8_sht+0xdd>
		sht->buf[(y>>10)*sht->bxsize+(x>>10)] = col;
		x += dx;
		y += dy;
	}
	return;
}
  281284:	83 c4 10             	add    $0x10,%esp
  281287:	5b                   	pop    %ebx
  281288:	5e                   	pop    %esi
  281289:	5f                   	pop    %edi
  28128a:	5d                   	pop    %ebp
  28128b:	c3                   	ret    

0028128c <putfont8>:
#include "fontascii.h"
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
  28128c:	55                   	push   %ebp
  28128d:	89 e5                	mov    %esp,%ebp
  28128f:	57                   	push   %edi
  281290:	56                   	push   %esi
  281291:	53                   	push   %ebx
  281292:	83 ec 08             	sub    $0x8,%esp
  281295:	8b 45 0c             	mov    0xc(%ebp),%eax
  281298:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  28129b:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  28129f:	89 fb                	mov    %edi,%ebx
  2812a1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  2812a4:	0f af 45 14          	imul   0x14(%ebp),%eax
  2812a8:	03 45 10             	add    0x10(%ebp),%eax
  2812ab:	89 c1                	mov    %eax,%ecx
  2812ad:	03 4d 08             	add    0x8(%ebp),%ecx
  2812b0:	83 c7 10             	add    $0x10,%edi
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
  2812b3:	0f b6 13             	movzbl (%ebx),%edx
		int col = HKK_TABLE_COL-1;
  2812b6:	b8 07 00 00 00       	mov    $0x7,%eax
  2812bb:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  2812be:	89 f1                	mov    %esi,%ecx
  2812c0:	89 de                	mov    %ebx,%esi
  2812c2:	89 cb                	mov    %ecx,%ebx
		for(;col>=0;col--)
		{
			if(d&0x1) p[col] = c;
  2812c4:	f6 c2 01             	test   $0x1,%dl
  2812c7:	74 06                	je     2812cf <putfont8+0x43>
  2812c9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  2812cc:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
			d=d>>1;
  2812cf:	d0 ea                	shr    %dl
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
		int col = HKK_TABLE_COL-1;
		for(;col>=0;col--)
  2812d1:	83 e8 01             	sub    $0x1,%eax
  2812d4:	83 f8 ff             	cmp    $0xffffffff,%eax
  2812d7:	75 eb                	jne    2812c4 <putfont8+0x38>
  2812d9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  2812dc:	89 d8                	mov    %ebx,%eax
  2812de:	89 f3                	mov    %esi,%ebx
  2812e0:	89 c6                	mov    %eax,%esi
  2812e2:	83 c3 01             	add    $0x1,%ebx
  2812e5:	03 4d ec             	add    -0x14(%ebp),%ecx
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
	int i;
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
  2812e8:	39 fb                	cmp    %edi,%ebx
  2812ea:	75 c7                	jne    2812b3 <putfont8+0x27>
			if(d&0x1) p[col] = c;
			d=d>>1;
		}
	}

}
  2812ec:	83 c4 08             	add    $0x8,%esp
  2812ef:	5b                   	pop    %ebx
  2812f0:	5e                   	pop    %esi
  2812f1:	5f                   	pop    %edi
  2812f2:	5d                   	pop    %ebp
  2812f3:	c3                   	ret    

002812f4 <putfonts8_asc>:

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
  2812f4:	55                   	push   %ebp
  2812f5:	89 e5                	mov    %esp,%ebp
  2812f7:	57                   	push   %edi
  2812f8:	56                   	push   %esi
  2812f9:	53                   	push   %ebx
  2812fa:	8b 75 10             	mov    0x10(%ebp),%esi
  2812fd:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  281300:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
	extern char hankaku[];
	for(;*s !=0x00;s++)
  281304:	0f b6 03             	movzbl (%ebx),%eax
  281307:	84 c0                	test   %al,%al
  281309:	74 2f                	je     28133a <putfonts8_asc+0x46>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
  28130b:	0f be fa             	movsbl %dl,%edi
  28130e:	0f b6 c0             	movzbl %al,%eax
  281311:	c1 e0 04             	shl    $0x4,%eax
  281314:	05 40 59 28 00       	add    $0x285940,%eax
  281319:	50                   	push   %eax
  28131a:	57                   	push   %edi
  28131b:	ff 75 14             	pushl  0x14(%ebp)
  28131e:	56                   	push   %esi
  28131f:	ff 75 0c             	pushl  0xc(%ebp)
  281322:	ff 75 08             	pushl  0x8(%ebp)
  281325:	e8 62 ff ff ff       	call   28128c <putfont8>
		x+=HKK_TABLE_COL;
  28132a:	83 c6 08             	add    $0x8,%esi
}

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
	extern char hankaku[];
	for(;*s !=0x00;s++)
  28132d:	83 c3 01             	add    $0x1,%ebx
  281330:	0f b6 03             	movzbl (%ebx),%eax
  281333:	83 c4 18             	add    $0x18,%esp
  281336:	84 c0                	test   %al,%al
  281338:	75 d4                	jne    28130e <putfonts8_asc+0x1a>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
		x+=HKK_TABLE_COL;
	}
	return; 
}
  28133a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28133d:	5b                   	pop    %ebx
  28133e:	5e                   	pop    %esi
  28133f:	5f                   	pop    %edi
  281340:	5d                   	pop    %ebp
  281341:	c3                   	ret    

00281342 <set_segmdesc>:
#include "dsctbl.h"
#include "io.h"

void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit,int base,int ar)
{
  281342:	55                   	push   %ebp
  281343:	89 e5                	mov    %esp,%ebp
  281345:	57                   	push   %edi
  281346:	56                   	push   %esi
  281347:	53                   	push   %ebx
  281348:	8b 55 08             	mov    0x8(%ebp),%edx
  28134b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  28134e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281351:	8b 7d 14             	mov    0x14(%ebp),%edi
	if(limit>0xfffff)
  281354:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
  28135a:	76 09                	jbe    281365 <set_segmdesc+0x23>
	{
		ar |= 0x8000;
  28135c:	81 cf 00 80 00 00    	or     $0x8000,%edi
		limit /= 0x1000;
  281362:	c1 eb 0c             	shr    $0xc,%ebx
	}
	sd->limit_low = limit&0xffff;
  281365:	66 89 1a             	mov    %bx,(%edx)
	sd->base_low = base&0xffff;
  281368:	66 89 4a 02          	mov    %cx,0x2(%edx)
	sd->base_mid = (base>>16) & 0xff;
  28136c:	89 ce                	mov    %ecx,%esi
  28136e:	c1 fe 10             	sar    $0x10,%esi
  281371:	89 f0                	mov    %esi,%eax
  281373:	88 42 04             	mov    %al,0x4(%edx)
	sd->access_right = ar & 0xff;
  281376:	89 f8                	mov    %edi,%eax
  281378:	88 42 05             	mov    %al,0x5(%edx)
	sd->limit_high = ((limit>>16)&0x0f) | ((ar>>8)&0xf0);
  28137b:	c1 eb 10             	shr    $0x10,%ebx
  28137e:	83 e3 0f             	and    $0xf,%ebx
  281381:	89 f8                	mov    %edi,%eax
  281383:	c1 f8 08             	sar    $0x8,%eax
  281386:	83 e0 f0             	and    $0xfffffff0,%eax
  281389:	09 d8                	or     %ebx,%eax
  28138b:	88 42 06             	mov    %al,0x6(%edx)
	sd->base_high = (base>>24)&0xff;
  28138e:	c1 e9 18             	shr    $0x18,%ecx
  281391:	88 4a 07             	mov    %cl,0x7(%edx)
	return;
}
  281394:	5b                   	pop    %ebx
  281395:	5e                   	pop    %esi
  281396:	5f                   	pop    %edi
  281397:	5d                   	pop    %ebp
  281398:	c3                   	ret    

00281399 <set_gatedesc>:

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
  281399:	55                   	push   %ebp
  28139a:	89 e5                	mov    %esp,%ebp
  28139c:	53                   	push   %ebx
  28139d:	8b 45 08             	mov    0x8(%ebp),%eax
  2813a0:	8b 55 0c             	mov    0xc(%ebp),%edx
  2813a3:	8b 4d 14             	mov    0x14(%ebp),%ecx
	gd->offset_low = offset & 0xffff;
  2813a6:	66 89 10             	mov    %dx,(%eax)
	gd->selector = selector;
  2813a9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  2813ac:	66 89 58 02          	mov    %bx,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  2813b0:	89 cb                	mov    %ecx,%ebx
  2813b2:	c1 fb 08             	sar    $0x8,%ebx
  2813b5:	88 58 04             	mov    %bl,0x4(%eax)
	gd->access_right = ar&0xff;
  2813b8:	88 48 05             	mov    %cl,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  2813bb:	c1 ea 10             	shr    $0x10,%edx
  2813be:	66 89 50 06          	mov    %dx,0x6(%eax)
	return;
}
  2813c2:	5b                   	pop    %ebx
  2813c3:	5d                   	pop    %ebp
  2813c4:	c3                   	ret    

002813c5 <init_gdtidt>:

void init_gdtidt(void)
{
  2813c5:	55                   	push   %ebp
  2813c6:	89 e5                	mov    %esp,%ebp
  2813c8:	53                   	push   %ebx
  2813c9:	83 ec 04             	sub    $0x4,%esp
  2813cc:	bb 00 00 27 00       	mov    $0x270000,%ebx
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
	{
		set_segmdesc(gdt+i,0,0,0);
  2813d1:	6a 00                	push   $0x0
  2813d3:	6a 00                	push   $0x0
  2813d5:	6a 00                	push   $0x0
  2813d7:	53                   	push   %ebx
  2813d8:	e8 65 ff ff ff       	call   281342 <set_segmdesc>
  2813dd:	83 c3 08             	add    $0x8,%ebx
{
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
  2813e0:	83 c4 10             	add    $0x10,%esp
  2813e3:	81 fb 00 00 28 00    	cmp    $0x280000,%ebx
  2813e9:	75 e6                	jne    2813d1 <init_gdtidt+0xc>
	{
		set_segmdesc(gdt+i,0,0,0);
	}
	//must be similiar with bootstrap gdt.
	//otherwise the code will run with different segment descriptor.
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
  2813eb:	68 92 40 00 00       	push   $0x4092
  2813f0:	6a 00                	push   $0x0
  2813f2:	6a ff                	push   $0xffffffff
  2813f4:	68 08 00 27 00       	push   $0x270008
  2813f9:	e8 44 ff ff ff       	call   281342 <set_segmdesc>
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
  2813fe:	68 9a 40 00 00       	push   $0x409a
  281403:	6a 00                	push   $0x0
  281405:	68 ff ff 0f 00       	push   $0xfffff
  28140a:	68 10 00 27 00       	push   $0x270010
  28140f:	e8 2e ff ff ff       	call   281342 <set_segmdesc>
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
  281414:	83 c4 20             	add    $0x20,%esp
  281417:	68 9a 40 00 00       	push   $0x409a
  28141c:	68 00 00 28 00       	push   $0x280000
  281421:	68 ff ff 07 00       	push   $0x7ffff
  281426:	68 18 00 27 00       	push   $0x270018
  28142b:	e8 12 ff ff ff       	call   281342 <set_segmdesc>
	load_gdtr(LIMIT_GDT,ADR_GDT);
  281430:	83 c4 08             	add    $0x8,%esp
  281433:	68 00 00 27 00       	push   $0x270000
  281438:	68 ff ff 00 00       	push   $0xffff
  28143d:	e8 bd f5 ff ff       	call   2809ff <load_gdtr>
  281442:	83 c4 10             	add    $0x10,%esp
  281445:	b8 00 f8 26 00       	mov    $0x26f800,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28144a:	66 c7 00 00 00       	movw   $0x0,(%eax)
	gd->selector = selector;
  28144f:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  281455:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	gd->access_right = ar&0xff;
  281459:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  28145d:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
  281463:	83 c0 08             	add    $0x8,%eax
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
	load_gdtr(LIMIT_GDT,ADR_GDT);

	for(i=0;i<256;i++)
  281466:	3d 00 00 27 00       	cmp    $0x270000,%eax
  28146b:	75 dd                	jne    28144a <init_gdtidt+0x85>
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
  28146d:	b8 0e 17 00 00       	mov    $0x170e,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281472:	66 a3 00 f9 26 00    	mov    %ax,0x26f900
	gd->selector = selector;
  281478:	66 c7 05 02 f9 26 00 	movw   $0x18,0x26f902
  28147f:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281481:	c6 05 04 f9 26 00 00 	movb   $0x0,0x26f904
	gd->access_right = ar&0xff;
  281488:	c6 05 05 f9 26 00 8e 	movb   $0x8e,0x26f905
	gd->offset_high = (offset>>16)&0xffff;
  28148f:	c1 e8 10             	shr    $0x10,%eax
  281492:	66 a3 06 f9 26 00    	mov    %ax,0x26f906
	for(i=0;i<256;i++)
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
  281498:	b8 e0 16 00 00       	mov    $0x16e0,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28149d:	66 a3 08 f9 26 00    	mov    %ax,0x26f908
	gd->selector = selector;
  2814a3:	66 c7 05 0a f9 26 00 	movw   $0x18,0x26f90a
  2814aa:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2814ac:	c6 05 0c f9 26 00 00 	movb   $0x0,0x26f90c
	gd->access_right = ar&0xff;
  2814b3:	c6 05 0d f9 26 00 8e 	movb   $0x8e,0x26f90d
	gd->offset_high = (offset>>16)&0xffff;
  2814ba:	c1 e8 10             	shr    $0x10,%eax
  2814bd:	66 a3 0e f9 26 00    	mov    %ax,0x26f90e
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
  2814c3:	b8 f7 16 00 00       	mov    $0x16f7,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2814c8:	66 a3 60 f9 26 00    	mov    %ax,0x26f960
	gd->selector = selector;
  2814ce:	66 c7 05 62 f9 26 00 	movw   $0x18,0x26f962
  2814d5:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2814d7:	c6 05 64 f9 26 00 00 	movb   $0x0,0x26f964
	gd->access_right = ar&0xff;
  2814de:	c6 05 65 f9 26 00 8e 	movb   $0x8e,0x26f965
	gd->offset_high = (offset>>16)&0xffff;
  2814e5:	c1 e8 10             	shr    $0x10,%eax
  2814e8:	66 a3 66 f9 26 00    	mov    %ax,0x26f966
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
  2814ee:	b8 25 17 00 00       	mov    $0x1725,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2814f3:	66 a3 00 fa 26 00    	mov    %ax,0x26fa00
	gd->selector = selector;
  2814f9:	66 c7 05 02 fa 26 00 	movw   $0x18,0x26fa02
  281500:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281502:	c6 05 04 fa 26 00 00 	movb   $0x0,0x26fa04
	gd->access_right = ar&0xff;
  281509:	c6 05 05 fa 26 00 ee 	movb   $0xee,0x26fa05
	gd->offset_high = (offset>>16)&0xffff;
  281510:	c1 e8 10             	shr    $0x10,%eax
  281513:	66 a3 06 fa 26 00    	mov    %ax,0x26fa06
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
  281519:	b8 46 17 00 00       	mov    $0x1746,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28151e:	66 a3 68 f8 26 00    	mov    %ax,0x26f868
	gd->selector = selector;
  281524:	66 c7 05 6a f8 26 00 	movw   $0x18,0x26f86a
  28152b:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  28152d:	c6 05 6c f8 26 00 00 	movb   $0x0,0x26f86c
	gd->access_right = ar&0xff;
  281534:	c6 05 6d f8 26 00 8e 	movb   $0x8e,0x26f86d
	gd->offset_high = (offset>>16)&0xffff;
  28153b:	c1 e8 10             	shr    $0x10,%eax
  28153e:	66 a3 6e f8 26 00    	mov    %ax,0x26f86e
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
  281544:	b8 66 17 00 00       	mov    $0x1766,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281549:	66 a3 60 f8 26 00    	mov    %ax,0x26f860
	gd->selector = selector;
  28154f:	66 c7 05 62 f8 26 00 	movw   $0x18,0x26f862
  281556:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281558:	c6 05 64 f8 26 00 00 	movb   $0x0,0x26f864
	gd->access_right = ar&0xff;
  28155f:	c6 05 65 f8 26 00 8e 	movb   $0x8e,0x26f865
	gd->offset_high = (offset>>16)&0xffff;
  281566:	c1 e8 10             	shr    $0x10,%eax
  281569:	66 a3 66 f8 26 00    	mov    %ax,0x26f866
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
	load_idtr(LIMIT_IDT,ADR_IDT);
  28156f:	83 ec 08             	sub    $0x8,%esp
  281572:	68 00 f8 26 00       	push   $0x26f800
  281577:	68 ff 07 00 00       	push   $0x7ff
  28157c:	e8 8e f4 ff ff       	call   280a0f <load_idtr>

	return;
  281581:	83 c4 10             	add    $0x10,%esp
}
  281584:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  281587:	c9                   	leave  
  281588:	c3                   	ret    

00281589 <init_pic>:
#include "const.h"
#include "fifo.h"
#include "timer.h"
#include "string.h"
void init_pic(void)
{
  281589:	55                   	push   %ebp
  28158a:	89 e5                	mov    %esp,%ebp
  28158c:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIC0_IMR, 0xff);	//disable all pic0 int
  28158f:	68 ff 00 00 00       	push   $0xff
  281594:	6a 21                	push   $0x21
  281596:	e8 3b f4 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC1_IMR, 0xff);	//disable all pic1 int
  28159b:	83 c4 08             	add    $0x8,%esp
  28159e:	68 ff 00 00 00       	push   $0xff
  2815a3:	68 a1 00 00 00       	push   $0xa1
  2815a8:	e8 29 f4 ff ff       	call   2809d6 <io_out8>

	io_out8(PIC0_ICW1, 0x11);	
  2815ad:	83 c4 08             	add    $0x8,%esp
  2815b0:	6a 11                	push   $0x11
  2815b2:	6a 20                	push   $0x20
  2815b4:	e8 1d f4 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC0_ICW2, 0x20);
  2815b9:	83 c4 08             	add    $0x8,%esp
  2815bc:	6a 20                	push   $0x20
  2815be:	6a 21                	push   $0x21
  2815c0:	e8 11 f4 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC0_ICW3, 1 << 2);
  2815c5:	83 c4 08             	add    $0x8,%esp
  2815c8:	6a 04                	push   $0x4
  2815ca:	6a 21                	push   $0x21
  2815cc:	e8 05 f4 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC0_ICW4, 0x01);
  2815d1:	83 c4 08             	add    $0x8,%esp
  2815d4:	6a 01                	push   $0x1
  2815d6:	6a 21                	push   $0x21
  2815d8:	e8 f9 f3 ff ff       	call   2809d6 <io_out8>

	io_out8(PIC1_ICW1, 0x11);
  2815dd:	83 c4 08             	add    $0x8,%esp
  2815e0:	6a 11                	push   $0x11
  2815e2:	68 a0 00 00 00       	push   $0xa0
  2815e7:	e8 ea f3 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC1_ICW2, 0x28);
  2815ec:	83 c4 08             	add    $0x8,%esp
  2815ef:	6a 28                	push   $0x28
  2815f1:	68 a1 00 00 00       	push   $0xa1
  2815f6:	e8 db f3 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC1_ICW3, 2);
  2815fb:	83 c4 08             	add    $0x8,%esp
  2815fe:	6a 02                	push   $0x2
  281600:	68 a1 00 00 00       	push   $0xa1
  281605:	e8 cc f3 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC1_ICW4, 0x01);
  28160a:	83 c4 08             	add    $0x8,%esp
  28160d:	6a 01                	push   $0x1
  28160f:	68 a1 00 00 00       	push   $0xa1
  281614:	e8 bd f3 ff ff       	call   2809d6 <io_out8>

	io_out8(PIC0_IMR, 0xfb);
  281619:	83 c4 08             	add    $0x8,%esp
  28161c:	68 fb 00 00 00       	push   $0xfb
  281621:	6a 21                	push   $0x21
  281623:	e8 ae f3 ff ff       	call   2809d6 <io_out8>
	io_out8(PIC1_IMR, 0xff);
  281628:	83 c4 08             	add    $0x8,%esp
  28162b:	68 ff 00 00 00       	push   $0xff
  281630:	68 a1 00 00 00       	push   $0xa1
  281635:	e8 9c f3 ff ff       	call   2809d6 <io_out8>
}
  28163a:	83 c4 10             	add    $0x10,%esp
  28163d:	c9                   	leave  
  28163e:	c3                   	ret    

0028163f <inthandler0d>:

//when app code execute or access sys code or mem
int *inthandler0d(int *esp)
{
  28163f:	55                   	push   %ebp
  281640:	89 e5                	mov    %esp,%ebp
  281642:	57                   	push   %edi
  281643:	56                   	push   %esi
  281644:	53                   	push   %ebx
  281645:	83 ec 2c             	sub    $0x2c,%esp
	struct TASK *task = task_now();
  281648:	e8 e5 15 00 00       	call   282c32 <task_now>
  28164d:	89 c3                	mov    %eax,%ebx
	struct CONSOLE *cons = task->cons;
  28164f:	8b b0 94 00 00 00    	mov    0x94(%eax),%esi
	cons_putstr0(cons,"\nINT 0D:\n General Protected Exception.\n");
  281655:	83 ec 08             	sub    $0x8,%esp
  281658:	68 00 49 28 00       	push   $0x284900
  28165d:	56                   	push   %esi
  28165e:	e8 d7 22 00 00       	call   28393a <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  281663:	83 c4 0c             	add    $0xc,%esp
  281666:	8b 45 08             	mov    0x8(%ebp),%eax
  281669:	ff 70 2c             	pushl  0x2c(%eax)
  28166c:	68 28 49 28 00       	push   $0x284928
  281671:	8d 7d ca             	lea    -0x36(%ebp),%edi
  281674:	57                   	push   %edi
  281675:	e8 33 02 00 00       	call   2818ad <sprintf>
	cons_putstr0(cons,s);
  28167a:	83 c4 08             	add    $0x8,%esp
  28167d:	57                   	push   %edi
  28167e:	56                   	push   %esi
  28167f:	e8 b6 22 00 00       	call   28393a <cons_putstr0>
	return &(task->tss.esp0);
  281684:	8d 43 30             	lea    0x30(%ebx),%eax
}
  281687:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28168a:	5b                   	pop    %ebx
  28168b:	5e                   	pop    %esi
  28168c:	5f                   	pop    %edi
  28168d:	5d                   	pop    %ebp
  28168e:	c3                   	ret    

0028168f <inthandler0c>:


//when code write beyond stack too much
int *inthandler0c(int *esp)
{
  28168f:	55                   	push   %ebp
  281690:	89 e5                	mov    %esp,%ebp
  281692:	57                   	push   %edi
  281693:	56                   	push   %esi
  281694:	53                   	push   %ebx
  281695:	83 ec 2c             	sub    $0x2c,%esp
	struct TASK *task = task_now();
  281698:	e8 95 15 00 00       	call   282c32 <task_now>
  28169d:	89 c3                	mov    %eax,%ebx
	struct CONSOLE *cons = task->cons;
  28169f:	8b b0 94 00 00 00    	mov    0x94(%eax),%esi
	cons_putstr0(cons,"\nINT 0C:\n Stack Exception.\n");
  2816a5:	83 ec 08             	sub    $0x8,%esp
  2816a8:	68 30 49 28 00       	push   $0x284930
  2816ad:	56                   	push   %esi
  2816ae:	e8 87 22 00 00       	call   28393a <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  2816b3:	83 c4 0c             	add    $0xc,%esp
  2816b6:	8b 45 08             	mov    0x8(%ebp),%eax
  2816b9:	ff 70 2c             	pushl  0x2c(%eax)
  2816bc:	68 28 49 28 00       	push   $0x284928
  2816c1:	8d 7d ca             	lea    -0x36(%ebp),%edi
  2816c4:	57                   	push   %edi
  2816c5:	e8 e3 01 00 00       	call   2818ad <sprintf>
	cons_putstr0(cons,s);
  2816ca:	83 c4 08             	add    $0x8,%esp
  2816cd:	57                   	push   %edi
  2816ce:	56                   	push   %esi
  2816cf:	e8 66 22 00 00       	call   28393a <cons_putstr0>
	return &(task->tss.esp0);
  2816d4:	8d 43 30             	lea    0x30(%ebx),%eax
}
  2816d7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2816da:	5b                   	pop    %ebx
  2816db:	5e                   	pop    %esi
  2816dc:	5f                   	pop    %edi
  2816dd:	5d                   	pop    %ebp
  2816de:	c3                   	ret    
  2816df:	90                   	nop

002816e0 <asm_inthandler21>:
  2816e0:	06                   	push   %es
  2816e1:	1e                   	push   %ds
  2816e2:	60                   	pusha  
  2816e3:	89 e0                	mov    %esp,%eax
  2816e5:	50                   	push   %eax
  2816e6:	66 8c d0             	mov    %ss,%ax
  2816e9:	8e d8                	mov    %eax,%ds
  2816eb:	8e c0                	mov    %eax,%es
  2816ed:	e8 ed 05 00 00       	call   281cdf <inthandler21>
  2816f2:	58                   	pop    %eax
  2816f3:	61                   	popa   
  2816f4:	1f                   	pop    %ds
  2816f5:	07                   	pop    %es
  2816f6:	cf                   	iret   

002816f7 <asm_inthandler2c>:
  2816f7:	06                   	push   %es
  2816f8:	1e                   	push   %ds
  2816f9:	60                   	pusha  
  2816fa:	89 e0                	mov    %esp,%eax
  2816fc:	50                   	push   %eax
  2816fd:	66 8c d0             	mov    %ss,%ax
  281700:	8e d8                	mov    %eax,%ds
  281702:	8e c0                	mov    %eax,%es
  281704:	e8 3c 05 00 00       	call   281c45 <inthandler2c>
  281709:	58                   	pop    %eax
  28170a:	61                   	popa   
  28170b:	1f                   	pop    %ds
  28170c:	07                   	pop    %es
  28170d:	cf                   	iret   

0028170e <asm_inthandler20>:
  28170e:	06                   	push   %es
  28170f:	1e                   	push   %ds
  281710:	60                   	pusha  
  281711:	89 e0                	mov    %esp,%eax
  281713:	50                   	push   %eax
  281714:	66 8c d0             	mov    %ss,%ax
  281717:	8e d8                	mov    %eax,%ds
  281719:	8e c0                	mov    %eax,%es
  28171b:	e8 79 12 00 00       	call   282999 <inthandler20>
  281720:	58                   	pop    %eax
  281721:	61                   	popa   
  281722:	1f                   	pop    %ds
  281723:	07                   	pop    %es
  281724:	cf                   	iret   

00281725 <asm_sys_api>:
  281725:	fb                   	sti    
  281726:	1e                   	push   %ds
  281727:	06                   	push   %es
  281728:	60                   	pusha  
  281729:	60                   	pusha  
  28172a:	66 8c d0             	mov    %ss,%ax
  28172d:	8e d8                	mov    %eax,%ds
  28172f:	8e c0                	mov    %eax,%es
  281731:	e8 48 26 00 00       	call   283d7e <sys_api>
  281736:	83 f8 00             	cmp    $0x0,%eax
  281739:	75 07                	jne    281742 <end_app>
  28173b:	83 c4 20             	add    $0x20,%esp
  28173e:	61                   	popa   
  28173f:	07                   	pop    %es
  281740:	1f                   	pop    %ds
  281741:	cf                   	iret   

00281742 <end_app>:
  281742:	8b 20                	mov    (%eax),%esp
  281744:	61                   	popa   
  281745:	c3                   	ret    

00281746 <asm_inthandler0d>:
  281746:	fb                   	sti    
  281747:	06                   	push   %es
  281748:	1e                   	push   %ds
  281749:	60                   	pusha  
  28174a:	89 e0                	mov    %esp,%eax
  28174c:	50                   	push   %eax
  28174d:	66 8c d0             	mov    %ss,%ax
  281750:	8e d8                	mov    %eax,%ds
  281752:	8e c0                	mov    %eax,%es
  281754:	e8 e6 fe ff ff       	call   28163f <inthandler0d>
  281759:	83 f8 00             	cmp    $0x0,%eax
  28175c:	75 e4                	jne    281742 <end_app>
  28175e:	58                   	pop    %eax
  28175f:	61                   	popa   
  281760:	1f                   	pop    %ds
  281761:	07                   	pop    %es
  281762:	83 c4 04             	add    $0x4,%esp
  281765:	cf                   	iret   

00281766 <asm_inthandler0c>:
  281766:	fb                   	sti    
  281767:	06                   	push   %es
  281768:	1e                   	push   %ds
  281769:	60                   	pusha  
  28176a:	89 e0                	mov    %esp,%eax
  28176c:	50                   	push   %eax
  28176d:	66 8c d0             	mov    %ss,%ax
  281770:	8e d8                	mov    %eax,%ds
  281772:	8e c0                	mov    %eax,%es
  281774:	e8 16 ff ff ff       	call   28168f <inthandler0c>
  281779:	83 f8 00             	cmp    $0x0,%eax
  28177c:	75 c4                	jne    281742 <end_app>
  28177e:	58                   	pop    %eax
  28177f:	61                   	popa   
  281780:	1f                   	pop    %ds
  281781:	07                   	pop    %es
  281782:	83 c4 04             	add    $0x4,%esp
  281785:	cf                   	iret   

00281786 <itoa>:
#include"string.h"
void itoa(int value,char *buf){
  281786:	55                   	push   %ebp
  281787:	89 e5                	mov    %esp,%ebp
  281789:	57                   	push   %edi
  28178a:	56                   	push   %esi
  28178b:	53                   	push   %ebx
  28178c:	83 ec 10             	sub    $0x10,%esp
  28178f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281792:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char tmp_buf[10] = {0};
  281795:	c7 45 ea 00 00 00 00 	movl   $0x0,-0x16(%ebp)
  28179c:	c7 45 ee 00 00 00 00 	movl   $0x0,-0x12(%ebp)
  2817a3:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
  2817a9:	85 c9                	test   %ecx,%ecx
  2817ab:	79 08                	jns    2817b5 <itoa+0x2f>
		*buf++ = '-';
  2817ad:	c6 07 2d             	movb   $0x2d,(%edi)
		value = ~value + 1; 
  2817b0:	f7 d9                	neg    %ecx
#include"string.h"
void itoa(int value,char *buf){
	char tmp_buf[10] = {0};
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
		*buf++ = '-';
  2817b2:	8d 7f 01             	lea    0x1(%edi),%edi
  2817b5:	8d 5d ea             	lea    -0x16(%ebp),%ebx
		value = ~value + 1; 
	}

	do{
		*tbp++ = ('0' + (char)(value % 10));
  2817b8:	be 67 66 66 66       	mov    $0x66666667,%esi
  2817bd:	83 c3 01             	add    $0x1,%ebx
  2817c0:	89 c8                	mov    %ecx,%eax
  2817c2:	f7 ee                	imul   %esi
  2817c4:	c1 fa 02             	sar    $0x2,%edx
  2817c7:	89 c8                	mov    %ecx,%eax
  2817c9:	c1 f8 1f             	sar    $0x1f,%eax
  2817cc:	29 c2                	sub    %eax,%edx
  2817ce:	8d 04 92             	lea    (%edx,%edx,4),%eax
  2817d1:	01 c0                	add    %eax,%eax
  2817d3:	29 c1                	sub    %eax,%ecx
  2817d5:	83 c1 30             	add    $0x30,%ecx
  2817d8:	88 4b ff             	mov    %cl,-0x1(%ebx)
		value /= 10;
  2817db:	89 d1                	mov    %edx,%ecx
	}while(value);
  2817dd:	85 d2                	test   %edx,%edx
  2817df:	75 dc                	jne    2817bd <itoa+0x37>
	while(tmp_buf != tbp--)
  2817e1:	8d 73 ff             	lea    -0x1(%ebx),%esi
  2817e4:	8d 45 ea             	lea    -0x16(%ebp),%eax
  2817e7:	39 c3                	cmp    %eax,%ebx
  2817e9:	74 20                	je     28180b <itoa+0x85>
  2817eb:	89 f0                	mov    %esi,%eax
  2817ed:	89 fa                	mov    %edi,%edx
  2817ef:	8d 5d e9             	lea    -0x17(%ebp),%ebx
		*buf++ = *tbp;
  2817f2:	83 c2 01             	add    $0x1,%edx
  2817f5:	0f b6 08             	movzbl (%eax),%ecx
  2817f8:	88 4a ff             	mov    %cl,-0x1(%edx)

	do{
		*tbp++ = ('0' + (char)(value % 10));
		value /= 10;
	}while(value);
	while(tmp_buf != tbp--)
  2817fb:	83 e8 01             	sub    $0x1,%eax
  2817fe:	39 d8                	cmp    %ebx,%eax
  281800:	75 f0                	jne    2817f2 <itoa+0x6c>
  281802:	8d 45 f4             	lea    -0xc(%ebp),%eax
  281805:	29 c6                	sub    %eax,%esi
  281807:	8d 7c 37 0b          	lea    0xb(%edi,%esi,1),%edi
		*buf++ = *tbp;
	*buf='\0';
  28180b:	c6 07 00             	movb   $0x0,(%edi)
}
  28180e:	83 c4 10             	add    $0x10,%esp
  281811:	5b                   	pop    %ebx
  281812:	5e                   	pop    %esi
  281813:	5f                   	pop    %edi
  281814:	5d                   	pop    %ebp
  281815:	c3                   	ret    

00281816 <xtoa>:
    else
        value = value + 48;
    return value;
}

void xtoa(unsigned int value,char *buf){
  281816:	55                   	push   %ebp
  281817:	89 e5                	mov    %esp,%ebp
  281819:	57                   	push   %edi
  28181a:	56                   	push   %esi
  28181b:	53                   	push   %ebx
  28181c:	83 ec 20             	sub    $0x20,%esp
  28181f:	8b 45 08             	mov    0x8(%ebp),%eax
    char tmp_buf[30] = {0};
  281822:	bb 00 00 00 00       	mov    $0x0,%ebx
  281827:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
  28182e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  281835:	b9 1c 00 00 00       	mov    $0x1c,%ecx
  28183a:	ba 00 00 00 00       	mov    $0x0,%edx
  28183f:	89 5c 15 d8          	mov    %ebx,-0x28(%ebp,%edx,1)
  281843:	83 c2 04             	add    $0x4,%edx
  281846:	39 ca                	cmp    %ecx,%edx
  281848:	72 f5                	jb     28183f <xtoa+0x29>
    char *tbp = tmp_buf;

    *buf++='0';
  28184a:	8b 75 0c             	mov    0xc(%ebp),%esi
  28184d:	c6 06 30             	movb   $0x30,(%esi)
    *buf++='x';
  281850:	83 c6 02             	add    $0x2,%esi
  281853:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281856:	c6 43 01 78          	movb   $0x78,0x1(%ebx)
    return value;
}

void xtoa(unsigned int value,char *buf){
    char tmp_buf[30] = {0};
    char *tbp = tmp_buf;
  28185a:	8d 5d d6             	lea    -0x2a(%ebp),%ebx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  28185d:	83 c3 01             	add    $0x1,%ebx
  281860:	89 c1                	mov    %eax,%ecx
  281862:	83 e1 0f             	and    $0xf,%ecx
	*str='\0';
}

static  inline char fourbtoc(int value){
    if(value >= 10)
        value = value - 10 + 65;
  281865:	8d 79 37             	lea    0x37(%ecx),%edi
  281868:	8d 51 30             	lea    0x30(%ecx),%edx
  28186b:	83 f9 0a             	cmp    $0xa,%ecx
  28186e:	0f 4d d7             	cmovge %edi,%edx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  281871:	88 53 ff             	mov    %dl,-0x1(%ebx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
  281874:	c1 e8 04             	shr    $0x4,%eax
    }while(value);
  281877:	85 c0                	test   %eax,%eax
  281879:	75 e2                	jne    28185d <xtoa+0x47>
    
    while(tmp_buf != tbp){
  28187b:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  28187e:	39 c3                	cmp    %eax,%ebx
  281880:	74 20                	je     2818a2 <xtoa+0x8c>
  281882:	89 d8                	mov    %ebx,%eax
  281884:	89 f1                	mov    %esi,%ecx
  281886:	8d 7d d6             	lea    -0x2a(%ebp),%edi
      tbp--;
  281889:	83 e8 01             	sub    $0x1,%eax
      *buf++ = *tbp;
  28188c:	83 c1 01             	add    $0x1,%ecx
  28188f:	0f b6 10             	movzbl (%eax),%edx
  281892:	88 51 ff             	mov    %dl,-0x1(%ecx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
    }while(value);
    
    while(tmp_buf != tbp){
  281895:	39 f8                	cmp    %edi,%eax
  281897:	75 f0                	jne    281889 <xtoa+0x73>
  281899:	8d 45 f4             	lea    -0xc(%ebp),%eax
  28189c:	29 c3                	sub    %eax,%ebx
  28189e:	8d 74 1e 1e          	lea    0x1e(%esi,%ebx,1),%esi
      tbp--;
      *buf++ = *tbp;
    }
    *buf='\0';
  2818a2:	c6 06 00             	movb   $0x0,(%esi)
}
  2818a5:	83 c4 20             	add    $0x20,%esp
  2818a8:	5b                   	pop    %ebx
  2818a9:	5e                   	pop    %esi
  2818aa:	5f                   	pop    %edi
  2818ab:	5d                   	pop    %ebp
  2818ac:	c3                   	ret    

002818ad <sprintf>:
	while(tmp_buf != tbp--)
		*buf++ = *tbp;
	*buf='\0';
}

void sprintf(char *str,char *format ,...){
  2818ad:	55                   	push   %ebp
  2818ae:	89 e5                	mov    %esp,%ebp
  2818b0:	57                   	push   %edi
  2818b1:	56                   	push   %esi
  2818b2:	53                   	push   %ebx
  2818b3:	83 ec 10             	sub    $0x10,%esp
  2818b6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
  2818b9:	8d 7d 10             	lea    0x10(%ebp),%edi
	char buffer[10];
	char *buf=buffer;
	while(*format){
  2818bc:	e9 a8 00 00 00       	jmp    281969 <sprintf+0xbc>
		if(*format!='%'){
  2818c1:	3c 25                	cmp    $0x25,%al
  2818c3:	74 10                	je     2818d5 <sprintf+0x28>
			*str++=*format++;
  2818c5:	83 c6 01             	add    $0x1,%esi
  2818c8:	89 75 0c             	mov    %esi,0xc(%ebp)
  2818cb:	88 03                	mov    %al,(%ebx)
  2818cd:	8d 5b 01             	lea    0x1(%ebx),%ebx
			continue;
  2818d0:	e9 94 00 00 00       	jmp    281969 <sprintf+0xbc>
		}
		else{
			format++;
  2818d5:	8d 46 01             	lea    0x1(%esi),%eax
  2818d8:	89 45 0c             	mov    %eax,0xc(%ebp)
			switch (*format){
  2818db:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  2818df:	3c 73                	cmp    $0x73,%al
  2818e1:	74 5e                	je     281941 <sprintf+0x94>
  2818e3:	3c 78                	cmp    $0x78,%al
  2818e5:	74 2f                	je     281916 <sprintf+0x69>
  2818e7:	3c 64                	cmp    $0x64,%al
  2818e9:	75 75                	jne    281960 <sprintf+0xb3>
				case 'd':itoa(*var,buf);while(*buf){*str++=*buf++;};break;
  2818eb:	8d 45 ea             	lea    -0x16(%ebp),%eax
  2818ee:	50                   	push   %eax
  2818ef:	ff 37                	pushl  (%edi)
  2818f1:	e8 90 fe ff ff       	call   281786 <itoa>
  2818f6:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  2818fa:	83 c4 08             	add    $0x8,%esp
  2818fd:	84 c0                	test   %al,%al
  2818ff:	74 5f                	je     281960 <sprintf+0xb3>
  281901:	8d 55 ea             	lea    -0x16(%ebp),%edx
  281904:	83 c3 01             	add    $0x1,%ebx
  281907:	83 c2 01             	add    $0x1,%edx
  28190a:	88 43 ff             	mov    %al,-0x1(%ebx)
  28190d:	0f b6 02             	movzbl (%edx),%eax
  281910:	84 c0                	test   %al,%al
  281912:	75 f0                	jne    281904 <sprintf+0x57>
  281914:	eb 4a                	jmp    281960 <sprintf+0xb3>
				case 'x':xtoa(*var,buf);while(*buf){*str++=*buf++;};break;
  281916:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281919:	50                   	push   %eax
  28191a:	ff 37                	pushl  (%edi)
  28191c:	e8 f5 fe ff ff       	call   281816 <xtoa>
  281921:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281925:	83 c4 08             	add    $0x8,%esp
  281928:	84 c0                	test   %al,%al
  28192a:	74 34                	je     281960 <sprintf+0xb3>
  28192c:	8d 55 ea             	lea    -0x16(%ebp),%edx
  28192f:	83 c3 01             	add    $0x1,%ebx
  281932:	83 c2 01             	add    $0x1,%edx
  281935:	88 43 ff             	mov    %al,-0x1(%ebx)
  281938:	0f b6 02             	movzbl (%edx),%eax
  28193b:	84 c0                	test   %al,%al
  28193d:	75 f0                	jne    28192f <sprintf+0x82>
  28193f:	eb 1f                	jmp    281960 <sprintf+0xb3>
				case 's':buf=(char*)(*var);while(*buf){*str++=*buf++;};break;
  281941:	8b 0f                	mov    (%edi),%ecx
  281943:	0f b6 11             	movzbl (%ecx),%edx
  281946:	84 d2                	test   %dl,%dl
  281948:	74 16                	je     281960 <sprintf+0xb3>
  28194a:	89 d8                	mov    %ebx,%eax
  28194c:	83 c0 01             	add    $0x1,%eax
  28194f:	88 50 ff             	mov    %dl,-0x1(%eax)
  281952:	89 c2                	mov    %eax,%edx
  281954:	29 da                	sub    %ebx,%edx
  281956:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
  28195a:	84 d2                	test   %dl,%dl
  28195c:	75 ee                	jne    28194c <sprintf+0x9f>
  28195e:	89 c3                	mov    %eax,%ebx
			}
			buf=buffer;
			var++;
  281960:	83 c7 04             	add    $0x4,%edi
			format++;
  281963:	83 c6 02             	add    $0x2,%esi
  281966:	89 75 0c             	mov    %esi,0xc(%ebp)

void sprintf(char *str,char *format ,...){
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
	char buffer[10];
	char *buf=buffer;
	while(*format){
  281969:	8b 75 0c             	mov    0xc(%ebp),%esi
  28196c:	0f b6 06             	movzbl (%esi),%eax
  28196f:	84 c0                	test   %al,%al
  281971:	0f 85 4a ff ff ff    	jne    2818c1 <sprintf+0x14>
			buf=buffer;
			var++;
			format++;
		}
	}
	*str='\0';
  281977:	c6 03 00             	movb   $0x0,(%ebx)
}
  28197a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28197d:	5b                   	pop    %ebx
  28197e:	5e                   	pop    %esi
  28197f:	5f                   	pop    %edi
  281980:	5d                   	pop    %ebp
  281981:	c3                   	ret    

00281982 <strcmp>:
    }
    *buf='\0';
}

int strcmp(const char *str1,const char *str2)
{
  281982:	55                   	push   %ebp
  281983:	89 e5                	mov    %esp,%ebp
  281985:	57                   	push   %edi
  281986:	56                   	push   %esi
  281987:	53                   	push   %ebx
  281988:	8b 7d 08             	mov    0x8(%ebp),%edi
  28198b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  28198e:	0f b6 17             	movzbl (%edi),%edx
  281991:	be 00 00 00 00       	mov    $0x0,%esi
  281996:	84 d2                	test   %dl,%dl
  281998:	74 40                	je     2819da <strcmp+0x58>
  28199a:	eb 1d                	jmp    2819b9 <strcmp+0x37>
	{
		if(c1==c2) i++;
  28199c:	38 ca                	cmp    %cl,%dl
  28199e:	75 0f                	jne    2819af <strcmp+0x2d>
  2819a0:	83 c0 01             	add    $0x1,%eax

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  2819a3:	89 c6                	mov    %eax,%esi
  2819a5:	0f b6 14 07          	movzbl (%edi,%eax,1),%edx
  2819a9:	84 d2                	test   %dl,%dl
  2819ab:	75 1e                	jne    2819cb <strcmp+0x49>
  2819ad:	eb 2b                	jmp    2819da <strcmp+0x58>
	{
		if(c1==c2) i++;
		else return c1-c2;
  2819af:	0f be c2             	movsbl %dl,%eax
  2819b2:	0f be c9             	movsbl %cl,%ecx
  2819b5:	29 c8                	sub    %ecx,%eax
  2819b7:	eb 2a                	jmp    2819e3 <strcmp+0x61>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  2819b9:	0f b6 0b             	movzbl (%ebx),%ecx
  2819bc:	84 c9                	test   %cl,%cl
  2819be:	74 15                	je     2819d5 <strcmp+0x53>
	{
		if(c1==c2) i++;
  2819c0:	b8 00 00 00 00       	mov    $0x0,%eax
  2819c5:	38 ca                	cmp    %cl,%dl
  2819c7:	74 d7                	je     2819a0 <strcmp+0x1e>
  2819c9:	eb e4                	jmp    2819af <strcmp+0x2d>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  2819cb:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  2819cf:	84 c9                	test   %cl,%cl
  2819d1:	75 c9                	jne    28199c <strcmp+0x1a>
  2819d3:	eb 05                	jmp    2819da <strcmp+0x58>
  2819d5:	be 00 00 00 00       	mov    $0x0,%esi
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  2819da:	0f be c2             	movsbl %dl,%eax
  2819dd:	0f be 14 33          	movsbl (%ebx,%esi,1),%edx
  2819e1:	29 d0                	sub    %edx,%eax
}
  2819e3:	5b                   	pop    %ebx
  2819e4:	5e                   	pop    %esi
  2819e5:	5f                   	pop    %edi
  2819e6:	5d                   	pop    %ebp
  2819e7:	c3                   	ret    

002819e8 <strncmp>:

int strncmp(const char *str1,const char *str2,unsigned int n)
{
  2819e8:	55                   	push   %ebp
  2819e9:	89 e5                	mov    %esp,%ebp
  2819eb:	57                   	push   %edi
  2819ec:	56                   	push   %esi
  2819ed:	53                   	push   %ebx
  2819ee:	8b 75 08             	mov    0x8(%ebp),%esi
  2819f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  2819f4:	8b 7d 10             	mov    0x10(%ebp),%edi
	if(n == 0) return 0;
  2819f7:	b8 00 00 00 00       	mov    $0x0,%eax
  2819fc:	85 ff                	test   %edi,%edi
  2819fe:	74 63                	je     281a63 <strncmp+0x7b>
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a00:	83 ef 01             	sub    $0x1,%edi
  281a03:	89 fa                	mov    %edi,%edx
  281a05:	74 52                	je     281a59 <strncmp+0x71>
  281a07:	eb 19                	jmp    281a22 <strncmp+0x3a>
	{
		if(c1==c2) i++;
  281a09:	38 c8                	cmp    %cl,%al
  281a0b:	75 0b                	jne    281a18 <strncmp+0x30>
  281a0d:	83 c2 01             	add    $0x1,%edx
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a10:	39 fa                	cmp    %edi,%edx
  281a12:	75 27                	jne    281a3b <strncmp+0x53>
	{
		if(c1==c2) i++;
  281a14:	89 fa                	mov    %edi,%edx
  281a16:	eb 41                	jmp    281a59 <strncmp+0x71>
		else return c1-c2;
  281a18:	0f be c0             	movsbl %al,%eax
  281a1b:	0f be c9             	movsbl %cl,%ecx
  281a1e:	29 c8                	sub    %ecx,%eax
  281a20:	eb 41                	jmp    281a63 <strncmp+0x7b>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a22:	0f b6 06             	movzbl (%esi),%eax
  281a25:	84 c0                	test   %al,%al
  281a27:	74 24                	je     281a4d <strncmp+0x65>
  281a29:	0f b6 0b             	movzbl (%ebx),%ecx
  281a2c:	84 c9                	test   %cl,%cl
  281a2e:	74 24                	je     281a54 <strncmp+0x6c>
	{
		if(c1==c2) i++;
  281a30:	ba 00 00 00 00       	mov    $0x0,%edx
  281a35:	38 c8                	cmp    %cl,%al
  281a37:	74 d4                	je     281a0d <strncmp+0x25>
  281a39:	eb dd                	jmp    281a18 <strncmp+0x30>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a3b:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
  281a3f:	84 c0                	test   %al,%al
  281a41:	74 16                	je     281a59 <strncmp+0x71>
  281a43:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  281a47:	84 c9                	test   %cl,%cl
  281a49:	75 be                	jne    281a09 <strncmp+0x21>
  281a4b:	eb 0c                	jmp    281a59 <strncmp+0x71>
  281a4d:	ba 00 00 00 00       	mov    $0x0,%edx
  281a52:	eb 05                	jmp    281a59 <strncmp+0x71>
  281a54:	ba 00 00 00 00       	mov    $0x0,%edx
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281a59:	0f be 04 16          	movsbl (%esi,%edx,1),%eax
  281a5d:	0f be 14 13          	movsbl (%ebx,%edx,1),%edx
  281a61:	29 d0                	sub    %edx,%eax
}
  281a63:	5b                   	pop    %ebx
  281a64:	5e                   	pop    %esi
  281a65:	5f                   	pop    %edi
  281a66:	5d                   	pop    %ebp
  281a67:	c3                   	ret    

00281a68 <fifo32_init>:
#include "fifo.h"
#include "task.h"
void fifo32_init(struct FIFO32 *fifo,int size,int *buf,struct TASK *task)
{
  281a68:	55                   	push   %ebp
  281a69:	89 e5                	mov    %esp,%ebp
  281a6b:	8b 45 08             	mov    0x8(%ebp),%eax
  281a6e:	8b 55 0c             	mov    0xc(%ebp),%edx
	fifo->size=size;
  281a71:	89 50 0c             	mov    %edx,0xc(%eax)
	fifo->buf=buf;
  281a74:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281a77:	89 08                	mov    %ecx,(%eax)
	fifo->free = size;
  281a79:	89 50 10             	mov    %edx,0x10(%eax)
	fifo->flags = 0;
  281a7c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	fifo->p = 0;
  281a83:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->q = 0;
  281a8a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	fifo->task = task;
  281a91:	8b 55 14             	mov    0x14(%ebp),%edx
  281a94:	89 50 18             	mov    %edx,0x18(%eax)
	return;
}
  281a97:	5d                   	pop    %ebp
  281a98:	c3                   	ret    

00281a99 <fifo32_put>:
#define FLAGS_OVERRUN 0x0001
#include "timer.h"
extern struct TIMERCTL timerctl;

int fifo32_put(struct FIFO32 *fifo,int data)
{
  281a99:	55                   	push   %ebp
  281a9a:	89 e5                	mov    %esp,%ebp
  281a9c:	53                   	push   %ebx
  281a9d:	83 ec 04             	sub    $0x4,%esp
  281aa0:	8b 45 08             	mov    0x8(%ebp),%eax
	if(fifo->free == 0)
  281aa3:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  281aa7:	75 0b                	jne    281ab4 <fifo32_put+0x1b>
	{
		fifo->flags |= FLAGS_OVERRUN;
  281aa9:	83 48 14 01          	orl    $0x1,0x14(%eax)
		return -1;
  281aad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  281ab2:	eb 52                	jmp    281b06 <fifo32_put+0x6d>
	}
	fifo->buf[fifo->p] = data;
  281ab4:	8b 48 04             	mov    0x4(%eax),%ecx
  281ab7:	8b 10                	mov    (%eax),%edx
  281ab9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281abc:	89 1c 8a             	mov    %ebx,(%edx,%ecx,4)
	fifo->p++;
  281abf:	8b 48 04             	mov    0x4(%eax),%ecx
  281ac2:	8d 51 01             	lea    0x1(%ecx),%edx
  281ac5:	89 50 04             	mov    %edx,0x4(%eax)
	if(fifo->p == fifo->size)
  281ac8:	3b 50 0c             	cmp    0xc(%eax),%edx
  281acb:	75 07                	jne    281ad4 <fifo32_put+0x3b>
		fifo->p = 0;
  281acd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->free--;
  281ad4:	83 68 10 01          	subl   $0x1,0x10(%eax)

	//wake up task
	if(fifo->task!=0)
  281ad8:	8b 50 18             	mov    0x18(%eax),%edx
  281adb:	85 d2                	test   %edx,%edx
  281add:	74 22                	je     281b01 <fifo32_put+0x68>
		if(fifo->task->flags!=2)
		{
			task_run(fifo->task,-1,0);
		}
	}
	return 0;
  281adf:	b8 00 00 00 00       	mov    $0x0,%eax
	fifo->free--;

	//wake up task
	if(fifo->task!=0)
	{
		if(fifo->task->flags!=2)
  281ae4:	83 7a 04 02          	cmpl   $0x2,0x4(%edx)
  281ae8:	74 1c                	je     281b06 <fifo32_put+0x6d>
		{
			task_run(fifo->task,-1,0);
  281aea:	83 ec 04             	sub    $0x4,%esp
  281aed:	6a 00                	push   $0x0
  281aef:	6a ff                	push   $0xffffffff
  281af1:	52                   	push   %edx
  281af2:	e8 30 12 00 00       	call   282d27 <task_run>
  281af7:	83 c4 10             	add    $0x10,%esp
		}
	}
	return 0;
  281afa:	b8 00 00 00 00       	mov    $0x0,%eax
  281aff:	eb 05                	jmp    281b06 <fifo32_put+0x6d>
  281b01:	b8 00 00 00 00       	mov    $0x0,%eax
}
  281b06:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  281b09:	c9                   	leave  
  281b0a:	c3                   	ret    

00281b0b <fifo32_get>:

int fifo32_get(struct FIFO32 *fifo)
{
  281b0b:	55                   	push   %ebp
  281b0c:	89 e5                	mov    %esp,%ebp
  281b0e:	56                   	push   %esi
  281b0f:	53                   	push   %ebx
  281b10:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if(fifo->free == fifo->size)
  281b13:	8b 59 10             	mov    0x10(%ecx),%ebx
  281b16:	8b 71 0c             	mov    0xc(%ecx),%esi
  281b19:	39 f3                	cmp    %esi,%ebx
  281b1b:	74 20                	je     281b3d <fifo32_get+0x32>
		return -1;
	int data = fifo->buf[fifo->q];
  281b1d:	8b 51 08             	mov    0x8(%ecx),%edx
  281b20:	8b 01                	mov    (%ecx),%eax
  281b22:	8b 04 90             	mov    (%eax,%edx,4),%eax
	fifo->q++;
  281b25:	83 c2 01             	add    $0x1,%edx
	if(fifo->q == fifo->size)
  281b28:	39 d6                	cmp    %edx,%esi
int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
	int data = fifo->buf[fifo->q];
	fifo->q++;
  281b2a:	be 00 00 00 00       	mov    $0x0,%esi
  281b2f:	0f 44 d6             	cmove  %esi,%edx
  281b32:	89 51 08             	mov    %edx,0x8(%ecx)
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
  281b35:	83 c3 01             	add    $0x1,%ebx
  281b38:	89 59 10             	mov    %ebx,0x10(%ecx)
	return data;
  281b3b:	eb 05                	jmp    281b42 <fifo32_get+0x37>
}

int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
  281b3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	fifo->q++;
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
	return data;
}
  281b42:	5b                   	pop    %ebx
  281b43:	5e                   	pop    %esi
  281b44:	5d                   	pop    %ebp
  281b45:	c3                   	ret    

00281b46 <fifo32_status>:

int fifo32_status(struct FIFO32 *fifo)
{
  281b46:	55                   	push   %ebp
  281b47:	89 e5                	mov    %esp,%ebp
  281b49:	8b 55 08             	mov    0x8(%ebp),%edx
	return fifo->size - fifo->free;
  281b4c:	8b 42 0c             	mov    0xc(%edx),%eax
  281b4f:	2b 42 10             	sub    0x10(%edx),%eax
}
  281b52:	5d                   	pop    %ebp
  281b53:	c3                   	ret    

00281b54 <enable_mouse>:
#include "mouse.h"
struct FIFO32 *mousefifo;
int mousedata0;
void enable_mouse(struct FIFO32 *fifo,int data0,struct MOUSE_DEC *mdec)
{
  281b54:	55                   	push   %ebp
  281b55:	89 e5                	mov    %esp,%ebp
  281b57:	83 ec 08             	sub    $0x8,%esp
	mousefifo = fifo;
  281b5a:	8b 45 08             	mov    0x8(%ebp),%eax
  281b5d:	a3 24 73 28 00       	mov    %eax,0x287324
	mousedata0 = data0;
  281b62:	8b 45 0c             	mov    0xc(%ebp),%eax
  281b65:	a3 20 73 28 00       	mov    %eax,0x287320

	wait_KBC_sendready();
  281b6a:	e8 1a 01 00 00       	call   281c89 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_SENDTO_MOUSE);
  281b6f:	83 ec 08             	sub    $0x8,%esp
  281b72:	68 d4 00 00 00       	push   $0xd4
  281b77:	6a 64                	push   $0x64
  281b79:	e8 58 ee ff ff       	call   2809d6 <io_out8>
	wait_KBC_sendready();
  281b7e:	e8 06 01 00 00       	call   281c89 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,MOUSECMD_ENABLE);
  281b83:	83 c4 08             	add    $0x8,%esp
  281b86:	68 f4 00 00 00       	push   $0xf4
  281b8b:	6a 60                	push   $0x60
  281b8d:	e8 44 ee ff ff       	call   2809d6 <io_out8>
	mdec->phase = 0;
  281b92:	8b 45 10             	mov    0x10(%ebp),%eax
  281b95:	c6 40 03 00          	movb   $0x0,0x3(%eax)
	return;
  281b99:	83 c4 10             	add    $0x10,%esp
}
  281b9c:	c9                   	leave  
  281b9d:	c3                   	ret    

00281b9e <mouse_decode>:

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
  281b9e:	55                   	push   %ebp
  281b9f:	89 e5                	mov    %esp,%ebp
  281ba1:	56                   	push   %esi
  281ba2:	53                   	push   %ebx
  281ba3:	8b 55 08             	mov    0x8(%ebp),%edx
  281ba6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if(mdec->phase == 0)
  281ba9:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  281bad:	84 c0                	test   %al,%al
  281baf:	75 14                	jne    281bc5 <mouse_decode+0x27>
	{
		if(dat == 0xfa)
			mdec->phase = 1;
		return 0;
  281bb1:	b8 00 00 00 00       	mov    $0x0,%eax

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
	if(mdec->phase == 0)
	{
		if(dat == 0xfa)
  281bb6:	80 f9 fa             	cmp    $0xfa,%cl
  281bb9:	0f 85 82 00 00 00    	jne    281c41 <mouse_decode+0xa3>
			mdec->phase = 1;
  281bbf:	c6 42 03 01          	movb   $0x1,0x3(%edx)
  281bc3:	eb 7c                	jmp    281c41 <mouse_decode+0xa3>
		return 0;
	}
	if(mdec->phase == 1)
  281bc5:	3c 01                	cmp    $0x1,%al
  281bc7:	75 17                	jne    281be0 <mouse_decode+0x42>
	{
		if((dat&0xc8) == 0x08)
  281bc9:	89 cb                	mov    %ecx,%ebx
  281bcb:	83 e3 c8             	and    $0xffffffc8,%ebx
		{
			mdec->buf[0] = dat;
			mdec->phase = 2;
		}
		return 0;
  281bce:	b8 00 00 00 00       	mov    $0x0,%eax
			mdec->phase = 1;
		return 0;
	}
	if(mdec->phase == 1)
	{
		if((dat&0xc8) == 0x08)
  281bd3:	80 fb 08             	cmp    $0x8,%bl
  281bd6:	75 69                	jne    281c41 <mouse_decode+0xa3>
		{
			mdec->buf[0] = dat;
  281bd8:	88 0a                	mov    %cl,(%edx)
			mdec->phase = 2;
  281bda:	c6 42 03 02          	movb   $0x2,0x3(%edx)
  281bde:	eb 61                	jmp    281c41 <mouse_decode+0xa3>
		}
		return 0;
	}
	if(mdec->phase == 2)
  281be0:	3c 02                	cmp    $0x2,%al
  281be2:	75 0e                	jne    281bf2 <mouse_decode+0x54>
	{
		mdec->buf[1] = dat;
  281be4:	88 4a 01             	mov    %cl,0x1(%edx)
		mdec->phase = 3;
  281be7:	c6 42 03 03          	movb   $0x3,0x3(%edx)
		return 0;
  281beb:	b8 00 00 00 00       	mov    $0x0,%eax
  281bf0:	eb 4f                	jmp    281c41 <mouse_decode+0xa3>
	}
	if(mdec->phase == 3)
  281bf2:	3c 03                	cmp    $0x3,%al
  281bf4:	75 46                	jne    281c3c <mouse_decode+0x9e>
	{
		mdec->buf[2] = dat;
  281bf6:	88 4a 02             	mov    %cl,0x2(%edx)
		mdec->phase = 1;
  281bf9:	c6 42 03 01          	movb   $0x1,0x3(%edx)
		mdec->btn = mdec->buf[0] & 0x07;
  281bfd:	0f b6 02             	movzbl (%edx),%eax
  281c00:	89 c3                	mov    %eax,%ebx
  281c02:	83 e3 07             	and    $0x7,%ebx
  281c05:	89 5a 0c             	mov    %ebx,0xc(%edx)
		mdec->x = mdec->buf[1];
  281c08:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
  281c0c:	0f b6 f3             	movzbl %bl,%esi
  281c0f:	89 72 04             	mov    %esi,0x4(%edx)
		
		mdec->y = mdec->buf[2];
  281c12:	0f b6 f1             	movzbl %cl,%esi
  281c15:	89 72 08             	mov    %esi,0x8(%edx)
		if((mdec->buf[0] & 0x10)!=0)
  281c18:	a8 10                	test   $0x10,%al
  281c1a:	74 09                	je     281c25 <mouse_decode+0x87>
		{
			mdec->x |= 0xffffff00;
  281c1c:	81 cb 00 ff ff ff    	or     $0xffffff00,%ebx
  281c22:	89 5a 04             	mov    %ebx,0x4(%edx)
		}
		if((mdec->buf[0] & 0x20)!=0)
  281c25:	a8 20                	test   $0x20,%al
  281c27:	74 09                	je     281c32 <mouse_decode+0x94>
		{
			mdec->y |= 0xffffff00;
  281c29:	81 c9 00 ff ff ff    	or     $0xffffff00,%ecx
  281c2f:	89 4a 08             	mov    %ecx,0x8(%edx)
		}
		mdec->y = -mdec->y;
  281c32:	f7 5a 08             	negl   0x8(%edx)
		return 1;
  281c35:	b8 01 00 00 00       	mov    $0x1,%eax
  281c3a:	eb 05                	jmp    281c41 <mouse_decode+0xa3>
	}
	return -1;
  281c3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  281c41:	5b                   	pop    %ebx
  281c42:	5e                   	pop    %esi
  281c43:	5d                   	pop    %ebp
  281c44:	c3                   	ret    

00281c45 <inthandler2c>:
#include "fifo.h"


//hanlder for int 2c (mouse interrupts)
void inthandler2c(int *esp)
{
  281c45:	55                   	push   %ebp
  281c46:	89 e5                	mov    %esp,%ebp
  281c48:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic continue watch 2c int
	io_out8(PIC1_OCW2,0X64);
  281c4b:	6a 64                	push   $0x64
  281c4d:	68 a0 00 00 00       	push   $0xa0
  281c52:	e8 7f ed ff ff       	call   2809d6 <io_out8>
	io_out8(PIC0_OCW2,0x62);
  281c57:	83 c4 08             	add    $0x8,%esp
  281c5a:	6a 62                	push   $0x62
  281c5c:	6a 20                	push   $0x20
  281c5e:	e8 73 ed ff ff       	call   2809d6 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281c63:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281c6a:	e8 45 ed ff ff       	call   2809b4 <io_in8>
	fifo32_put(mousefifo,data+mousedata0);
  281c6f:	83 c4 08             	add    $0x8,%esp
  281c72:	03 05 20 73 28 00    	add    0x287320,%eax
  281c78:	50                   	push   %eax
  281c79:	ff 35 24 73 28 00    	pushl  0x287324
  281c7f:	e8 15 fe ff ff       	call   281a99 <fifo32_put>
	return;
  281c84:	83 c4 10             	add    $0x10,%esp
}
  281c87:	c9                   	leave  
  281c88:	c3                   	ret    

00281c89 <wait_KBC_sendready>:

struct FIFO32 *keyfifo;
int keydata0;

void wait_KBC_sendready(void)
{
  281c89:	55                   	push   %ebp
  281c8a:	89 e5                	mov    %esp,%ebp
  281c8c:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		if((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0)
  281c8f:	83 ec 0c             	sub    $0xc,%esp
  281c92:	6a 64                	push   $0x64
  281c94:	e8 1b ed ff ff       	call   2809b4 <io_in8>
  281c99:	83 c4 10             	add    $0x10,%esp
  281c9c:	a8 02                	test   $0x2,%al
  281c9e:	75 ef                	jne    281c8f <wait_KBC_sendready+0x6>
			break;
	}
	return;
}
  281ca0:	c9                   	leave  
  281ca1:	c3                   	ret    

00281ca2 <init_keyboard>:

void init_keyboard(struct FIFO32 *fifo,int data0)
{
  281ca2:	55                   	push   %ebp
  281ca3:	89 e5                	mov    %esp,%ebp
  281ca5:	83 ec 08             	sub    $0x8,%esp
	keyfifo = fifo;
  281ca8:	8b 45 08             	mov    0x8(%ebp),%eax
  281cab:	a3 28 73 28 00       	mov    %eax,0x287328
	keydata0 = data0;
  281cb0:	8b 45 0c             	mov    0xc(%ebp),%eax
  281cb3:	a3 2c 73 28 00       	mov    %eax,0x28732c
	wait_KBC_sendready();
  281cb8:	e8 cc ff ff ff       	call   281c89 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_WRITE_MODE);
  281cbd:	83 ec 08             	sub    $0x8,%esp
  281cc0:	6a 60                	push   $0x60
  281cc2:	6a 64                	push   $0x64
  281cc4:	e8 0d ed ff ff       	call   2809d6 <io_out8>
	wait_KBC_sendready();
  281cc9:	e8 bb ff ff ff       	call   281c89 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,KBC_MODE);
  281cce:	83 c4 08             	add    $0x8,%esp
  281cd1:	6a 47                	push   $0x47
  281cd3:	6a 60                	push   $0x60
  281cd5:	e8 fc ec ff ff       	call   2809d6 <io_out8>
	return;
  281cda:	83 c4 10             	add    $0x10,%esp
}
  281cdd:	c9                   	leave  
  281cde:	c3                   	ret    

00281cdf <inthandler21>:
#include "fifo.h"


//handler for int 21 (keyboard interrupts)
void inthandler21(int *esp)
{
  281cdf:	55                   	push   %ebp
  281ce0:	89 e5                	mov    %esp,%ebp
  281ce2:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic contine watch 21 int
	io_out8(PIC0_OCW2,0x61);
  281ce5:	6a 61                	push   $0x61
  281ce7:	6a 20                	push   $0x20
  281ce9:	e8 e8 ec ff ff       	call   2809d6 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281cee:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281cf5:	e8 ba ec ff ff       	call   2809b4 <io_in8>
	fifo32_put(keyfifo,data + keydata0);
  281cfa:	83 c4 08             	add    $0x8,%esp
  281cfd:	03 05 2c 73 28 00    	add    0x28732c,%eax
  281d03:	50                   	push   %eax
  281d04:	ff 35 28 73 28 00    	pushl  0x287328
  281d0a:	e8 8a fd ff ff       	call   281a99 <fifo32_put>
	return;
  281d0f:	83 c4 10             	add    $0x10,%esp
}
  281d12:	c9                   	leave  
  281d13:	c3                   	ret    

00281d14 <key_char>:
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
  281d14:	55                   	push   %ebp
  281d15:	89 e5                	mov    %esp,%ebp
  281d17:	8b 55 08             	mov    0x8(%ebp),%edx
	if(key>=0 && key<0x80)
	{
		if(key_shift==0) return keytable0[key];
		else return keytable1[key];
	}
	else return 0;
  281d1a:	b8 00 00 00 00       	mov    $0x0,%eax
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
	if(key>=0 && key<0x80)
  281d1f:	83 fa 7f             	cmp    $0x7f,%edx
  281d22:	77 16                	ja     281d3a <key_char+0x26>
	{
		if(key_shift==0) return keytable0[key];
  281d24:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  281d28:	75 09                	jne    281d33 <key_char+0x1f>
  281d2a:	0f b6 82 e0 49 28 00 	movzbl 0x2849e0(%edx),%eax
  281d31:	eb 07                	jmp    281d3a <key_char+0x26>
		else return keytable1[key];
  281d33:	0f b6 82 60 49 28 00 	movzbl 0x284960(%edx),%eax
	}
	else return 0;
}
  281d3a:	5d                   	pop    %ebp
  281d3b:	c3                   	ret    

00281d3c <memtest>:
#include "memory.h"
#include "io.h"

extern unsigned int _memtest_sub(unsigned int start,unsigned int end);
unsigned int memtest(unsigned int start,unsigned int end)
{
  281d3c:	55                   	push   %ebp
  281d3d:	89 e5                	mov    %esp,%ebp
  281d3f:	83 ec 18             	sub    $0x18,%esp
	char flg486 = 0;
  281d42:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	unsigned int eflg,cr0,i;
	
	//check cpu type
	eflg = io_load_eflags();
  281d46:	e8 aa ec ff ff       	call   2809f5 <io_load_eflags>
  281d4b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	eflg != EFLAGS_AC_BIT;
	io_store_eflags(eflg);
  281d4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281d51:	83 ec 0c             	sub    $0xc,%esp
  281d54:	50                   	push   %eax
  281d55:	e8 9e ec ff ff       	call   2809f8 <io_store_eflags>
  281d5a:	83 c4 10             	add    $0x10,%esp
	eflg = io_load_eflags();
  281d5d:	e8 93 ec ff ff       	call   2809f5 <io_load_eflags>
  281d62:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if((eflg & EFLAGS_AC_BIT) !=0)
  281d65:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281d68:	25 00 00 04 00       	and    $0x40000,%eax
  281d6d:	85 c0                	test   %eax,%eax
  281d6f:	74 04                	je     281d75 <memtest+0x39>
		flg486 = 1;
  281d71:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
	eflg &= ~EFLAGS_AC_BIT;
  281d75:	81 65 f0 ff ff fb ff 	andl   $0xfffbffff,-0x10(%ebp)
	io_store_eflags(eflg);
  281d7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281d7f:	83 ec 0c             	sub    $0xc,%esp
  281d82:	50                   	push   %eax
  281d83:	e8 70 ec ff ff       	call   2809f8 <io_store_eflags>
  281d88:	83 c4 10             	add    $0x10,%esp
	
	//disable cpu cache
	if(flg486)
  281d8b:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  281d8f:	74 1d                	je     281dae <memtest+0x72>
	{
		cr0 = load_cr0;
  281d91:	c7 45 ec 1f 0a 28 00 	movl   $0x280a1f,-0x14(%ebp)
		cr0 |= CR0_CACHE_DISABLE;
  281d98:	81 4d ec 00 00 00 60 	orl    $0x60000000,-0x14(%ebp)
		store_cr0(cr0);
  281d9f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  281da2:	83 ec 0c             	sub    $0xc,%esp
  281da5:	50                   	push   %eax
  281da6:	e8 78 ec ff ff       	call   280a23 <store_cr0>
  281dab:	83 c4 10             	add    $0x10,%esp
	}
	
	//i = memtest_sub(start,end);
	i = _memtest_sub(start,end);
  281dae:	83 ec 08             	sub    $0x8,%esp
  281db1:	ff 75 0c             	pushl  0xc(%ebp)
  281db4:	ff 75 08             	pushl  0x8(%ebp)
  281db7:	e8 6f ec ff ff       	call   280a2b <_memtest_sub>
  281dbc:	83 c4 10             	add    $0x10,%esp
  281dbf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	
	//enable cpu cache
	if(flg486)
  281dc2:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  281dc6:	74 1e                	je     281de6 <memtest+0xaa>
	{
		cr0 = load_cr0();
  281dc8:	e8 52 ec ff ff       	call   280a1f <load_cr0>
  281dcd:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cr0 &= ~CR0_CACHE_DISABLE;
  281dd0:	81 65 ec ff ff ff 9f 	andl   $0x9fffffff,-0x14(%ebp)
		store_cr0(cr0);
  281dd7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  281dda:	83 ec 0c             	sub    $0xc,%esp
  281ddd:	50                   	push   %eax
  281dde:	e8 40 ec ff ff       	call   280a23 <store_cr0>
  281de3:	83 c4 10             	add    $0x10,%esp
	}

	return i;
  281de6:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  281de9:	c9                   	leave  
  281dea:	c3                   	ret    

00281deb <memtest_sub>:

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
  281deb:	55                   	push   %ebp
  281dec:	89 e5                	mov    %esp,%ebp
  281dee:	83 ec 20             	sub    $0x20,%esp
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
  281df1:	c7 45 f8 55 aa 55 aa 	movl   $0xaa55aa55,-0x8(%ebp)
  281df8:	c7 45 f4 aa 55 aa 55 	movl   $0x55aa55aa,-0xc(%ebp)
	for(i=start;i<=end;i+=0x1000)
  281dff:	8b 45 08             	mov    0x8(%ebp),%eax
  281e02:	89 45 fc             	mov    %eax,-0x4(%ebp)
  281e05:	eb 67                	jmp    281e6e <memtest_sub+0x83>
	{
		p = (unsigned int *) (i+0xffc);
  281e07:	8b 45 fc             	mov    -0x4(%ebp),%eax
  281e0a:	05 fc 0f 00 00       	add    $0xffc,%eax
  281e0f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		old = *p;
  281e12:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e15:	8b 00                	mov    (%eax),%eax
  281e17:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*p = pat0;
  281e1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e1d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281e20:	89 10                	mov    %edx,(%eax)
		*p ^= 0xffffffff;
  281e22:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e25:	8b 00                	mov    (%eax),%eax
  281e27:	f7 d0                	not    %eax
  281e29:	89 c2                	mov    %eax,%edx
  281e2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e2e:	89 10                	mov    %edx,(%eax)
		if(*p != pat1)
  281e30:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e33:	8b 00                	mov    (%eax),%eax
  281e35:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  281e38:	74 0d                	je     281e47 <memtest_sub+0x5c>
  281e3a:	eb 01                	jmp    281e3d <memtest_sub+0x52>
			break;
		}
		*p ^= 0xffffffff;
		if(*p != pat0)
		{
			goto not_memory;
  281e3c:	90                   	nop
		*p = pat0;
		*p ^= 0xffffffff;
		if(*p != pat1)
		{
not_memory:
			*p = old;
  281e3d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e40:	8b 55 ec             	mov    -0x14(%ebp),%edx
  281e43:	89 10                	mov    %edx,(%eax)
			break;
  281e45:	eb 2f                	jmp    281e76 <memtest_sub+0x8b>
		}
		*p ^= 0xffffffff;
  281e47:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e4a:	8b 00                	mov    (%eax),%eax
  281e4c:	f7 d0                	not    %eax
  281e4e:	89 c2                	mov    %eax,%edx
  281e50:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e53:	89 10                	mov    %edx,(%eax)
		if(*p != pat0)
  281e55:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e58:	8b 00                	mov    (%eax),%eax
  281e5a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281e5d:	75 dd                	jne    281e3c <memtest_sub+0x51>
		{
			goto not_memory;
		}
		*p = old;
  281e5f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e62:	8b 55 ec             	mov    -0x14(%ebp),%edx
  281e65:	89 10                	mov    %edx,(%eax)

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
	for(i=start;i<=end;i+=0x1000)
  281e67:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%ebp)
  281e6e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  281e71:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281e74:	76 91                	jbe    281e07 <memtest_sub+0x1c>
		{
			goto not_memory;
		}
		*p = old;
	}
	return i;
  281e76:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  281e79:	c9                   	leave  
  281e7a:	c3                   	ret    

00281e7b <memman_init>:

void memman_init(struct MEMMAN *man)
{
  281e7b:	55                   	push   %ebp
  281e7c:	89 e5                	mov    %esp,%ebp
	man->frees = 0;
  281e7e:	8b 45 08             	mov    0x8(%ebp),%eax
  281e81:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	man->maxfrees = 0;
  281e87:	8b 45 08             	mov    0x8(%ebp),%eax
  281e8a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	man->lostsize = 0;
  281e91:	8b 45 08             	mov    0x8(%ebp),%eax
  281e94:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	man->losts = 0;
  281e9b:	8b 45 08             	mov    0x8(%ebp),%eax
  281e9e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return;
  281ea5:	90                   	nop
}
  281ea6:	5d                   	pop    %ebp
  281ea7:	c3                   	ret    

00281ea8 <memman_total>:

unsigned int memman_total(struct MEMMAN *man)
{
  281ea8:	55                   	push   %ebp
  281ea9:	89 e5                	mov    %esp,%ebp
  281eab:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,t = 0;
  281eae:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;i<man->frees;i++)
  281eb5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  281ebc:	eb 14                	jmp    281ed2 <memman_total+0x2a>
	{
		t+=man->free[i].size;
  281ebe:	8b 45 08             	mov    0x8(%ebp),%eax
  281ec1:	8b 55 fc             	mov    -0x4(%ebp),%edx
  281ec4:	83 c2 02             	add    $0x2,%edx
  281ec7:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281ecb:	01 45 f8             	add    %eax,-0x8(%ebp)
}

unsigned int memman_total(struct MEMMAN *man)
{
	unsigned int i,t = 0;
	for(i=0;i<man->frees;i++)
  281ece:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  281ed2:	8b 45 08             	mov    0x8(%ebp),%eax
  281ed5:	8b 00                	mov    (%eax),%eax
  281ed7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  281eda:	77 e2                	ja     281ebe <memman_total+0x16>
	{
		t+=man->free[i].size;
	}
	return t;
  281edc:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  281edf:	c9                   	leave  
  281ee0:	c3                   	ret    

00281ee1 <memman_alloc>:

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
  281ee1:	55                   	push   %ebp
  281ee2:	89 e5                	mov    %esp,%ebp
  281ee4:	53                   	push   %ebx
  281ee5:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  281ee8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  281eef:	e9 bd 00 00 00       	jmp    281fb1 <memman_alloc+0xd0>
	{
		if(man->free[i].size >= size)
  281ef4:	8b 45 08             	mov    0x8(%ebp),%eax
  281ef7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281efa:	83 c2 02             	add    $0x2,%edx
  281efd:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281f01:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281f04:	0f 82 a3 00 00 00    	jb     281fad <memman_alloc+0xcc>
		{
			a = man->free[i].addr;
  281f0a:	8b 45 08             	mov    0x8(%ebp),%eax
  281f0d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f10:	83 c2 02             	add    $0x2,%edx
  281f13:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  281f16:	89 45 f4             	mov    %eax,-0xc(%ebp)
			man->free[i].addr+=size;
  281f19:	8b 45 08             	mov    0x8(%ebp),%eax
  281f1c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f1f:	83 c2 02             	add    $0x2,%edx
  281f22:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  281f25:	8b 45 0c             	mov    0xc(%ebp),%eax
  281f28:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281f2b:	8b 45 08             	mov    0x8(%ebp),%eax
  281f2e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f31:	83 c2 02             	add    $0x2,%edx
  281f34:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
			man->free[i].size-=size;
  281f37:	8b 45 08             	mov    0x8(%ebp),%eax
  281f3a:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f3d:	83 c2 02             	add    $0x2,%edx
  281f40:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281f44:	2b 45 0c             	sub    0xc(%ebp),%eax
  281f47:	89 c2                	mov    %eax,%edx
  281f49:	8b 45 08             	mov    0x8(%ebp),%eax
  281f4c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  281f4f:	83 c1 02             	add    $0x2,%ecx
  281f52:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
			if(man->free[i].size == 0)
  281f56:	8b 45 08             	mov    0x8(%ebp),%eax
  281f59:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f5c:	83 c2 02             	add    $0x2,%edx
  281f5f:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281f63:	85 c0                	test   %eax,%eax
  281f65:	75 41                	jne    281fa8 <memman_alloc+0xc7>
			{
				man->frees--;
  281f67:	8b 45 08             	mov    0x8(%ebp),%eax
  281f6a:	8b 00                	mov    (%eax),%eax
  281f6c:	8d 50 ff             	lea    -0x1(%eax),%edx
  281f6f:	8b 45 08             	mov    0x8(%ebp),%eax
  281f72:	89 10                	mov    %edx,(%eax)
				for(;i<man->frees;i++)
  281f74:	eb 28                	jmp    281f9e <memman_alloc+0xbd>
				{
					man->free[i] = man->free[i+1];
  281f76:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281f79:	8d 50 01             	lea    0x1(%eax),%edx
  281f7c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281f7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281f82:	8d 58 02             	lea    0x2(%eax),%ebx
  281f85:	8b 45 08             	mov    0x8(%ebp),%eax
  281f88:	83 c2 02             	add    $0x2,%edx
  281f8b:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  281f8e:	8b 02                	mov    (%edx),%eax
  281f90:	8b 52 04             	mov    0x4(%edx),%edx
  281f93:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  281f96:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
			man->free[i].addr+=size;
			man->free[i].size-=size;
			if(man->free[i].size == 0)
			{
				man->frees--;
				for(;i<man->frees;i++)
  281f9a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281f9e:	8b 45 08             	mov    0x8(%ebp),%eax
  281fa1:	8b 00                	mov    (%eax),%eax
  281fa3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281fa6:	77 ce                	ja     281f76 <memman_alloc+0x95>
				{
					man->free[i] = man->free[i+1];
				}
			}
			return a;
  281fa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  281fab:	eb 17                	jmp    281fc4 <memman_alloc+0xe3>
}

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  281fad:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281fb1:	8b 45 08             	mov    0x8(%ebp),%eax
  281fb4:	8b 00                	mov    (%eax),%eax
  281fb6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281fb9:	0f 87 35 ff ff ff    	ja     281ef4 <memman_alloc+0x13>
				}
			}
			return a;
		}
	}
	return 0;
  281fbf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  281fc4:	83 c4 10             	add    $0x10,%esp
  281fc7:	5b                   	pop    %ebx
  281fc8:	5d                   	pop    %ebp
  281fc9:	c3                   	ret    

00281fca <memman_free>:

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  281fca:	55                   	push   %ebp
  281fcb:	89 e5                	mov    %esp,%ebp
  281fcd:	53                   	push   %ebx
  281fce:	83 ec 10             	sub    $0x10,%esp
	int i,j;
	
	for(i=0;i<man->frees;i++)
  281fd1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  281fd8:	eb 15                	jmp    281fef <memman_free+0x25>
	{
		if(man->free[i].addr>addr) break;
  281fda:	8b 45 08             	mov    0x8(%ebp),%eax
  281fdd:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281fe0:	83 c2 02             	add    $0x2,%edx
  281fe3:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  281fe6:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281fe9:	77 10                	ja     281ffb <memman_free+0x31>

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
	int i,j;
	
	for(i=0;i<man->frees;i++)
  281feb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281fef:	8b 45 08             	mov    0x8(%ebp),%eax
  281ff2:	8b 00                	mov    (%eax),%eax
  281ff4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281ff7:	7f e1                	jg     281fda <memman_free+0x10>
  281ff9:	eb 01                	jmp    281ffc <memman_free+0x32>
	{
		if(man->free[i].addr>addr) break;
  281ffb:	90                   	nop
	}

	//if prev combinable.
	if(i>0 && (man->free[i-1].addr+man->free[i-1].size == addr))
  281ffc:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  282000:	0f 8e f2 00 00 00    	jle    2820f8 <memman_free+0x12e>
  282006:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282009:	8d 50 ff             	lea    -0x1(%eax),%edx
  28200c:	8b 45 08             	mov    0x8(%ebp),%eax
  28200f:	83 c2 02             	add    $0x2,%edx
  282012:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  282015:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282018:	8d 48 ff             	lea    -0x1(%eax),%ecx
  28201b:	8b 45 08             	mov    0x8(%ebp),%eax
  28201e:	83 c1 02             	add    $0x2,%ecx
  282021:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  282025:	01 d0                	add    %edx,%eax
  282027:	3b 45 0c             	cmp    0xc(%ebp),%eax
  28202a:	0f 85 c8 00 00 00    	jne    2820f8 <memman_free+0x12e>
	{
		//combine with prev
		man->free[i-1].size += size;
  282030:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282033:	8d 58 ff             	lea    -0x1(%eax),%ebx
  282036:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282039:	8d 50 ff             	lea    -0x1(%eax),%edx
  28203c:	8b 45 08             	mov    0x8(%ebp),%eax
  28203f:	83 c2 02             	add    $0x2,%edx
  282042:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282046:	8b 45 10             	mov    0x10(%ebp),%eax
  282049:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28204c:	8b 45 08             	mov    0x8(%ebp),%eax
  28204f:	8d 53 02             	lea    0x2(%ebx),%edx
  282052:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)

		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
  282056:	8b 45 08             	mov    0x8(%ebp),%eax
  282059:	8b 00                	mov    (%eax),%eax
  28205b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28205e:	0f 8e 8a 00 00 00    	jle    2820ee <memman_free+0x124>
  282064:	8b 55 0c             	mov    0xc(%ebp),%edx
  282067:	8b 45 10             	mov    0x10(%ebp),%eax
  28206a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28206d:	8b 45 08             	mov    0x8(%ebp),%eax
  282070:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282073:	83 c2 02             	add    $0x2,%edx
  282076:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282079:	39 c1                	cmp    %eax,%ecx
  28207b:	75 71                	jne    2820ee <memman_free+0x124>
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
  28207d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282080:	8d 58 ff             	lea    -0x1(%eax),%ebx
  282083:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282086:	8d 50 ff             	lea    -0x1(%eax),%edx
  282089:	8b 45 08             	mov    0x8(%ebp),%eax
  28208c:	83 c2 02             	add    $0x2,%edx
  28208f:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282093:	8b 45 08             	mov    0x8(%ebp),%eax
  282096:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  282099:	83 c1 02             	add    $0x2,%ecx
  28209c:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  2820a0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2820a3:	8b 45 08             	mov    0x8(%ebp),%eax
  2820a6:	8d 53 02             	lea    0x2(%ebx),%edx
  2820a9:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
			for(;i<man->frees;i++)
  2820ad:	eb 28                	jmp    2820d7 <memman_free+0x10d>
				man->free[i] = man->free[i+1];
  2820af:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2820b2:	8d 50 01             	lea    0x1(%eax),%edx
  2820b5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2820b8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2820bb:	8d 58 02             	lea    0x2(%eax),%ebx
  2820be:	8b 45 08             	mov    0x8(%ebp),%eax
  2820c1:	83 c2 02             	add    $0x2,%edx
  2820c4:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  2820c7:	8b 02                	mov    (%edx),%eax
  2820c9:	8b 52 04             	mov    0x4(%edx),%edx
  2820cc:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  2820cf:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
			for(;i<man->frees;i++)
  2820d3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  2820d7:	8b 45 08             	mov    0x8(%ebp),%eax
  2820da:	8b 00                	mov    (%eax),%eax
  2820dc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  2820df:	7f ce                	jg     2820af <memman_free+0xe5>
				man->free[i] = man->free[i+1];
			man->frees--;
  2820e1:	8b 45 08             	mov    0x8(%ebp),%eax
  2820e4:	8b 00                	mov    (%eax),%eax
  2820e6:	8d 50 ff             	lea    -0x1(%eax),%edx
  2820e9:	8b 45 08             	mov    0x8(%ebp),%eax
  2820ec:	89 10                	mov    %edx,(%eax)
		}
		
		return 0;
  2820ee:	b8 00 00 00 00       	mov    $0x0,%eax
  2820f3:	e9 1f 01 00 00       	jmp    282217 <memman_free+0x24d>
	}

	//if next combinable
	if(i<man->frees && (addr + size == man->free[i].addr))
  2820f8:	8b 45 08             	mov    0x8(%ebp),%eax
  2820fb:	8b 00                	mov    (%eax),%eax
  2820fd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282100:	7e 52                	jle    282154 <memman_free+0x18a>
  282102:	8b 55 0c             	mov    0xc(%ebp),%edx
  282105:	8b 45 10             	mov    0x10(%ebp),%eax
  282108:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28210b:	8b 45 08             	mov    0x8(%ebp),%eax
  28210e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282111:	83 c2 02             	add    $0x2,%edx
  282114:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282117:	39 c1                	cmp    %eax,%ecx
  282119:	75 39                	jne    282154 <memman_free+0x18a>
	{
		man->free[i].addr = addr;
  28211b:	8b 45 08             	mov    0x8(%ebp),%eax
  28211e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282121:	8d 4a 02             	lea    0x2(%edx),%ecx
  282124:	8b 55 0c             	mov    0xc(%ebp),%edx
  282127:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size += size;
  28212a:	8b 45 08             	mov    0x8(%ebp),%eax
  28212d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282130:	83 c2 02             	add    $0x2,%edx
  282133:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282137:	8b 45 10             	mov    0x10(%ebp),%eax
  28213a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28213d:	8b 45 08             	mov    0x8(%ebp),%eax
  282140:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282143:	83 c2 02             	add    $0x2,%edx
  282146:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
		return 0;
  28214a:	b8 00 00 00 00       	mov    $0x0,%eax
  28214f:	e9 c3 00 00 00       	jmp    282217 <memman_free+0x24d>
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
  282154:	8b 45 08             	mov    0x8(%ebp),%eax
  282157:	8b 00                	mov    (%eax),%eax
  282159:	3d f9 0f 00 00       	cmp    $0xff9,%eax
  28215e:	0f 8f 8a 00 00 00    	jg     2821ee <memman_free+0x224>
	{
		for(j=man->frees-1;j>=i;j--)
  282164:	8b 45 08             	mov    0x8(%ebp),%eax
  282167:	8b 00                	mov    (%eax),%eax
  282169:	83 e8 01             	sub    $0x1,%eax
  28216c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  28216f:	eb 28                	jmp    282199 <memman_free+0x1cf>
			man->free[j+1] = man->free[j];
  282171:	8b 45 f4             	mov    -0xc(%ebp),%eax
  282174:	83 c0 01             	add    $0x1,%eax
  282177:	8b 4d 08             	mov    0x8(%ebp),%ecx
  28217a:	8d 58 02             	lea    0x2(%eax),%ebx
  28217d:	8b 45 08             	mov    0x8(%ebp),%eax
  282180:	8b 55 f4             	mov    -0xc(%ebp),%edx
  282183:	83 c2 02             	add    $0x2,%edx
  282186:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  282189:	8b 02                	mov    (%edx),%eax
  28218b:	8b 52 04             	mov    0x4(%edx),%edx
  28218e:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  282191:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
	{
		for(j=man->frees-1;j>=i;j--)
  282195:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  282199:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28219c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28219f:	7d d0                	jge    282171 <memman_free+0x1a7>
			man->free[j+1] = man->free[j];
		if(man->maxfrees < man->frees) man->maxfrees = man->frees;
  2821a1:	8b 45 08             	mov    0x8(%ebp),%eax
  2821a4:	8b 50 04             	mov    0x4(%eax),%edx
  2821a7:	8b 45 08             	mov    0x8(%ebp),%eax
  2821aa:	8b 00                	mov    (%eax),%eax
  2821ac:	39 c2                	cmp    %eax,%edx
  2821ae:	7d 0b                	jge    2821bb <memman_free+0x1f1>
  2821b0:	8b 45 08             	mov    0x8(%ebp),%eax
  2821b3:	8b 10                	mov    (%eax),%edx
  2821b5:	8b 45 08             	mov    0x8(%ebp),%eax
  2821b8:	89 50 04             	mov    %edx,0x4(%eax)
		man->free[i].addr = addr;
  2821bb:	8b 45 08             	mov    0x8(%ebp),%eax
  2821be:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821c1:	8d 4a 02             	lea    0x2(%edx),%ecx
  2821c4:	8b 55 0c             	mov    0xc(%ebp),%edx
  2821c7:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size = size;
  2821ca:	8b 45 08             	mov    0x8(%ebp),%eax
  2821cd:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821d0:	8d 4a 02             	lea    0x2(%edx),%ecx
  2821d3:	8b 55 10             	mov    0x10(%ebp),%edx
  2821d6:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
		man->frees++;
  2821da:	8b 45 08             	mov    0x8(%ebp),%eax
  2821dd:	8b 00                	mov    (%eax),%eax
  2821df:	8d 50 01             	lea    0x1(%eax),%edx
  2821e2:	8b 45 08             	mov    0x8(%ebp),%eax
  2821e5:	89 10                	mov    %edx,(%eax)
		return 0;
  2821e7:	b8 00 00 00 00       	mov    $0x0,%eax
  2821ec:	eb 29                	jmp    282217 <memman_free+0x24d>
	}

	//no room for new free
	man->losts++;
  2821ee:	8b 45 08             	mov    0x8(%ebp),%eax
  2821f1:	8b 40 0c             	mov    0xc(%eax),%eax
  2821f4:	8d 50 01             	lea    0x1(%eax),%edx
  2821f7:	8b 45 08             	mov    0x8(%ebp),%eax
  2821fa:	89 50 0c             	mov    %edx,0xc(%eax)
	man->lostsize += size;
  2821fd:	8b 45 08             	mov    0x8(%ebp),%eax
  282200:	8b 40 08             	mov    0x8(%eax),%eax
  282203:	89 c2                	mov    %eax,%edx
  282205:	8b 45 10             	mov    0x10(%ebp),%eax
  282208:	01 d0                	add    %edx,%eax
  28220a:	89 c2                	mov    %eax,%edx
  28220c:	8b 45 08             	mov    0x8(%ebp),%eax
  28220f:	89 50 08             	mov    %edx,0x8(%eax)
	return -1;
  282212:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  282217:	83 c4 10             	add    $0x10,%esp
  28221a:	5b                   	pop    %ebx
  28221b:	5d                   	pop    %ebp
  28221c:	c3                   	ret    

0028221d <memman_alloc_4k>:

unsigned int memman_alloc_4k(struct MEMMAN *man,unsigned int size)
{
  28221d:	55                   	push   %ebp
  28221e:	89 e5                	mov    %esp,%ebp
  282220:	83 ec 10             	sub    $0x10,%esp
	unsigned int a;
	size = (size+0xfff) & 0xfffff000;
  282223:	8b 45 0c             	mov    0xc(%ebp),%eax
  282226:	05 ff 0f 00 00       	add    $0xfff,%eax
  28222b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  282230:	89 45 0c             	mov    %eax,0xc(%ebp)
	a = memman_alloc(man,size);
  282233:	ff 75 0c             	pushl  0xc(%ebp)
  282236:	ff 75 08             	pushl  0x8(%ebp)
  282239:	e8 a3 fc ff ff       	call   281ee1 <memman_alloc>
  28223e:	83 c4 08             	add    $0x8,%esp
  282241:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return a;
  282244:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  282247:	c9                   	leave  
  282248:	c3                   	ret    

00282249 <memman_free_4k>:

int memman_free_4k(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  282249:	55                   	push   %ebp
  28224a:	89 e5                	mov    %esp,%ebp
  28224c:	83 ec 10             	sub    $0x10,%esp
	int i;
	size = (size+0xfff) & 0xfffff000;
  28224f:	8b 45 10             	mov    0x10(%ebp),%eax
  282252:	05 ff 0f 00 00       	add    $0xfff,%eax
  282257:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  28225c:	89 45 10             	mov    %eax,0x10(%ebp)
	i = memman_free(man,addr,size);
  28225f:	ff 75 10             	pushl  0x10(%ebp)
  282262:	ff 75 0c             	pushl  0xc(%ebp)
  282265:	ff 75 08             	pushl  0x8(%ebp)
  282268:	e8 5d fd ff ff       	call   281fca <memman_free>
  28226d:	83 c4 0c             	add    $0xc,%esp
  282270:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return i;
  282273:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  282276:	c9                   	leave  
  282277:	c3                   	ret    

00282278 <shtctl_init>:
#include "map_sheet.h"

struct SHTCTL* shtctl_init(struct MEMMAN *man,unsigned char *vram,int xsize,int ysize)
{
  282278:	55                   	push   %ebp
  282279:	89 e5                	mov    %esp,%ebp
  28227b:	57                   	push   %edi
  28227c:	56                   	push   %esi
  28227d:	53                   	push   %ebx
  28227e:	83 ec 14             	sub    $0x14,%esp
  282281:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct SHTCTL *ctl;
	int i;
	ctl = (struct SHTCTL *)memman_alloc_4k(man,sizeof(struct SHTCTL));
  282284:	68 14 2c 00 00       	push   $0x2c14
  282289:	57                   	push   %edi
  28228a:	e8 8e ff ff ff       	call   28221d <memman_alloc_4k>
  28228f:	89 c6                	mov    %eax,%esi
	if(ctl == 0)
  282291:	83 c4 10             	add    $0x10,%esp
  282294:	85 c0                	test   %eax,%eax
  282296:	74 6a                	je     282302 <shtctl_init+0x8a>
  282298:	89 c3                	mov    %eax,%ebx
		goto err;
	ctl->vram = vram;
  28229a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28229d:	89 06                	mov    %eax,(%esi)
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
  28229f:	83 ec 08             	sub    $0x8,%esp
  2822a2:	8b 45 10             	mov    0x10(%ebp),%eax
  2822a5:	0f af 45 14          	imul   0x14(%ebp),%eax
  2822a9:	50                   	push   %eax
  2822aa:	57                   	push   %edi
  2822ab:	e8 6d ff ff ff       	call   28221d <memman_alloc_4k>
  2822b0:	89 46 04             	mov    %eax,0x4(%esi)
	if(ctl->map == 0)
  2822b3:	83 c4 10             	add    $0x10,%esp
  2822b6:	85 c0                	test   %eax,%eax
  2822b8:	75 19                	jne    2822d3 <shtctl_init+0x5b>
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
  2822ba:	83 ec 04             	sub    $0x4,%esp
  2822bd:	68 14 2c 00 00       	push   $0x2c14
  2822c2:	56                   	push   %esi
  2822c3:	57                   	push   %edi
  2822c4:	e8 80 ff ff ff       	call   282249 <memman_free_4k>
		ctl = 0;
		goto err;
  2822c9:	83 c4 10             	add    $0x10,%esp
	ctl->vram = vram;
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
	if(ctl->map == 0)
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
		ctl = 0;
  2822cc:	be 00 00 00 00       	mov    $0x0,%esi
		goto err;
  2822d1:	eb 2f                	jmp    282302 <shtctl_init+0x8a>
	}
	ctl->xsize= xsize;
  2822d3:	8b 45 10             	mov    0x10(%ebp),%eax
  2822d6:	89 46 08             	mov    %eax,0x8(%esi)
	ctl->ysize= ysize;
  2822d9:	8b 45 14             	mov    0x14(%ebp),%eax
  2822dc:	89 46 0c             	mov    %eax,0xc(%esi)
	ctl->top = -1;
  2822df:	c7 46 10 ff ff ff ff 	movl   $0xffffffff,0x10(%esi)
  2822e6:	8d 86 30 04 00 00    	lea    0x430(%esi),%eax
  2822ec:	81 c3 30 2c 00 00    	add    $0x2c30,%ebx
	for(i=0;i<MAX_SHEETS;i++)
	{
		ctl->sheets0[i].flags = 0;
  2822f2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ctl->sheets0[i].ctl = ctl;
  2822f8:	89 70 04             	mov    %esi,0x4(%eax)
  2822fb:	83 c0 28             	add    $0x28,%eax
		goto err;
	}
	ctl->xsize= xsize;
	ctl->ysize= ysize;
	ctl->top = -1;
	for(i=0;i<MAX_SHEETS;i++)
  2822fe:	39 d8                	cmp    %ebx,%eax
  282300:	75 f0                	jne    2822f2 <shtctl_init+0x7a>
		ctl->sheets0[i].flags = 0;
		ctl->sheets0[i].ctl = ctl;
	}
	err:
		return ctl;
}
  282302:	89 f0                	mov    %esi,%eax
  282304:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282307:	5b                   	pop    %ebx
  282308:	5e                   	pop    %esi
  282309:	5f                   	pop    %edi
  28230a:	5d                   	pop    %ebp
  28230b:	c3                   	ret    

0028230c <sheet_alloc>:

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
  28230c:	55                   	push   %ebp
  28230d:	89 e5                	mov    %esp,%ebp
  28230f:	56                   	push   %esi
  282310:	53                   	push   %ebx
  282311:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
	{
		if(ctl->sheets0[i].flags == 0)
  282314:	83 b9 30 04 00 00 00 	cmpl   $0x0,0x430(%ecx)
  28231b:	74 12                	je     28232f <sheet_alloc+0x23>
  28231d:	8d 91 58 04 00 00    	lea    0x458(%ecx),%edx

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  282323:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(ctl->sheets0[i].flags == 0)
  282328:	83 3a 00             	cmpl   $0x0,(%edx)
  28232b:	75 3c                	jne    282369 <sheet_alloc+0x5d>
  28232d:	eb 05                	jmp    282334 <sheet_alloc+0x28>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  28232f:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(ctl->sheets0[i].flags == 0)
		{
			sht = &ctl->sheets0[i];
  282334:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  28233b:	8d 34 02             	lea    (%edx,%eax,1),%esi
			sht->flags = SHEET_USE;
  28233e:	8d 1c f1             	lea    (%ecx,%esi,8),%ebx
  282341:	c7 83 30 04 00 00 01 	movl   $0x1,0x430(%ebx)
  282348:	00 00 00 
			sht->height = -1;
  28234b:	c7 83 2c 04 00 00 ff 	movl   $0xffffffff,0x42c(%ebx)
  282352:	ff ff ff 
			sht->task = 0;
  282355:	c7 84 f1 38 04 00 00 	movl   $0x0,0x438(%ecx,%esi,8)
  28235c:	00 00 00 00 
			return sht;
  282360:	8d 84 f1 14 04 00 00 	lea    0x414(%ecx,%esi,8),%eax
  282367:	eb 12                	jmp    28237b <sheet_alloc+0x6f>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  282369:	83 c0 01             	add    $0x1,%eax
  28236c:	83 c2 28             	add    $0x28,%edx
  28236f:	3d 00 01 00 00       	cmp    $0x100,%eax
  282374:	75 b2                	jne    282328 <sheet_alloc+0x1c>
			sht->height = -1;
			sht->task = 0;
			return sht;
		}
	}
	return 0;
  282376:	b8 00 00 00 00       	mov    $0x0,%eax
}
  28237b:	5b                   	pop    %ebx
  28237c:	5e                   	pop    %esi
  28237d:	5d                   	pop    %ebp
  28237e:	c3                   	ret    

0028237f <sheet_setbuf>:

void sheet_setbuf(struct SHEET *sht,unsigned char *buf,int xsize,int ysize,int col_inv)
{
  28237f:	55                   	push   %ebp
  282380:	89 e5                	mov    %esp,%ebp
  282382:	8b 45 08             	mov    0x8(%ebp),%eax
	sht->buf = buf;
  282385:	8b 55 0c             	mov    0xc(%ebp),%edx
  282388:	89 10                	mov    %edx,(%eax)
	sht->bxsize = xsize;
  28238a:	8b 55 10             	mov    0x10(%ebp),%edx
  28238d:	89 50 04             	mov    %edx,0x4(%eax)
	sht->bysize = ysize;
  282390:	8b 55 14             	mov    0x14(%ebp),%edx
  282393:	89 50 08             	mov    %edx,0x8(%eax)
	sht->col_inv = col_inv;
  282396:	8b 55 18             	mov    0x18(%ebp),%edx
  282399:	89 50 14             	mov    %edx,0x14(%eax)
	return;
}
  28239c:	5d                   	pop    %ebp
  28239d:	c3                   	ret    

0028239e <sheet_refresh_ob>:
}

//not good refresh
//obsolete
void sheet_refresh_ob(struct SHTCTL *ctl)
{
  28239e:	55                   	push   %ebp
  28239f:	89 e5                	mov    %esp,%ebp
  2823a1:	57                   	push   %edi
  2823a2:	56                   	push   %esi
  2823a3:	53                   	push   %ebx
  2823a4:	83 ec 10             	sub    $0x10,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
  2823a7:	8b 45 08             	mov    0x8(%ebp),%eax
  2823aa:	8b 00                	mov    (%eax),%eax
  2823ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  2823af:	8b 45 08             	mov    0x8(%ebp),%eax
  2823b2:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  2823b6:	0f 88 80 00 00 00    	js     28243c <sheet_refresh_ob+0x9e>
  2823bc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	{
		sht = ctl->sheets[h];
  2823c3:	8b 45 08             	mov    0x8(%ebp),%eax
  2823c6:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  2823c9:	8b 54 b8 14          	mov    0x14(%eax,%edi,4),%edx
		buf = sht->buf;
  2823cd:	8b 02                	mov    (%edx),%eax
  2823cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
		for(by=0;by<sht->bysize;by++)
  2823d2:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  2823d6:	7e 55                	jle    28242d <sheet_refresh_ob+0x8f>
  2823d8:	bf 00 00 00 00       	mov    $0x0,%edi
		{
			vy = sht->vy0+by;
  2823dd:	89 f8                	mov    %edi,%eax
  2823df:	03 42 10             	add    0x10(%edx),%eax
  2823e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
			for(bx=0;bx<sht->bxsize;bx++)
  2823e5:	8b 4a 04             	mov    0x4(%edx),%ecx
  2823e8:	85 c9                	test   %ecx,%ecx
  2823ea:	7e 39                	jle    282425 <sheet_refresh_ob+0x87>
  2823ec:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				vx = sht->vx0+bx;
				c=buf[by*sht->bxsize+bx];
  2823f1:	0f af cf             	imul   %edi,%ecx
  2823f4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  2823f7:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  2823fa:	0f b6 1c 0b          	movzbl (%ebx,%ecx,1),%ebx
				if(c!=sht->col_inv)
  2823fe:	0f b6 cb             	movzbl %bl,%ecx
  282401:	3b 4a 14             	cmp    0x14(%edx),%ecx
  282404:	74 15                	je     28241b <sheet_refresh_ob+0x7d>
					vram[vy*ctl->xsize+vx] = c;
  282406:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282409:	8b 75 ec             	mov    -0x14(%ebp),%esi
  28240c:	0f af 71 08          	imul   0x8(%ecx),%esi
  282410:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  282413:	01 c1                	add    %eax,%ecx
  282415:	03 4a 0c             	add    0xc(%edx),%ecx
  282418:	88 1c 31             	mov    %bl,(%ecx,%esi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0+by;
			for(bx=0;bx<sht->bxsize;bx++)
  28241b:	83 c0 01             	add    $0x1,%eax
  28241e:	8b 4a 04             	mov    0x4(%edx),%ecx
  282421:	39 c1                	cmp    %eax,%ecx
  282423:	7f cc                	jg     2823f1 <sheet_refresh_ob+0x53>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  282425:	83 c7 01             	add    $0x1,%edi
  282428:	39 7a 08             	cmp    %edi,0x8(%edx)
  28242b:	7f b0                	jg     2823dd <sheet_refresh_ob+0x3f>
void sheet_refresh_ob(struct SHTCTL *ctl)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  28242d:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  282431:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  282434:	8b 7d 08             	mov    0x8(%ebp),%edi
  282437:	39 47 10             	cmp    %eax,0x10(%edi)
  28243a:	7d 87                	jge    2823c3 <sheet_refresh_ob+0x25>
					vram[vy*ctl->xsize+vx] = c;
			}
		}
	}
	return;
}
  28243c:	83 c4 10             	add    $0x10,%esp
  28243f:	5b                   	pop    %ebx
  282440:	5e                   	pop    %esi
  282441:	5f                   	pop    %edi
  282442:	5d                   	pop    %ebp
  282443:	c3                   	ret    

00282444 <sheet_refreshsub1>:



void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
  282444:	55                   	push   %ebp
  282445:	89 e5                	mov    %esp,%ebp
  282447:	57                   	push   %edi
  282448:	56                   	push   %esi
  282449:	53                   	push   %ebx
  28244a:	83 ec 14             	sub    $0x14,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
  28244d:	8b 45 08             	mov    0x8(%ebp),%eax
  282450:	8b 00                	mov    (%eax),%eax
  282452:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282455:	8b 45 08             	mov    0x8(%ebp),%eax
  282458:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  28245c:	0f 88 a7 00 00 00    	js     282509 <sheet_refreshsub1+0xc5>
  282462:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	{
		sht = ctl->sheets[h];
  282469:	8b 45 08             	mov    0x8(%ebp),%eax
  28246c:	8b 7d e0             	mov    -0x20(%ebp),%edi
  28246f:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  282473:	8b 01                	mov    (%ecx),%eax
  282475:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(by=0;by<sht->bysize;by++)
  282478:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  28247c:	7e 78                	jle    2824f6 <sheet_refreshsub1+0xb2>
  28247e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		{
			vy = sht->vy0 + by;
  282485:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  282488:	03 59 10             	add    0x10(%ecx),%ebx
			for(bx=0;bx<sht->bxsize;bx++)
  28248b:	8b 71 04             	mov    0x4(%ecx),%esi
  28248e:	85 f6                	test   %esi,%esi
  282490:	7e 58                	jle    2824ea <sheet_refreshsub1+0xa6>
  282492:	b8 00 00 00 00       	mov    $0x0,%eax
  282497:	89 5d f0             	mov    %ebx,-0x10(%ebp)
			{
				vx = sht->vx0 + bx;
  28249a:	89 c2                	mov    %eax,%edx
  28249c:	03 51 0c             	add    0xc(%ecx),%edx
				if(vx0<=vx && vx<vx1 && vy0<=vy && vy<vy1)
  28249f:	3b 55 0c             	cmp    0xc(%ebp),%edx
  2824a2:	7c 3c                	jl     2824e0 <sheet_refreshsub1+0x9c>
  2824a4:	3b 55 14             	cmp    0x14(%ebp),%edx
  2824a7:	7d 37                	jge    2824e0 <sheet_refreshsub1+0x9c>
  2824a9:	8b 7d f0             	mov    -0x10(%ebp),%edi
  2824ac:	3b 7d 10             	cmp    0x10(%ebp),%edi
  2824af:	7c 2f                	jl     2824e0 <sheet_refreshsub1+0x9c>
  2824b1:	3b 7d 18             	cmp    0x18(%ebp),%edi
  2824b4:	7d 2a                	jge    2824e0 <sheet_refreshsub1+0x9c>
				{
					c = buf[by*sht->bxsize+bx];
  2824b6:	0f af 75 ec          	imul   -0x14(%ebp),%esi
  2824ba:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  2824bd:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
  2824c0:	0f b6 34 37          	movzbl (%edi,%esi,1),%esi
					if(c!=sht->col_inv)
  2824c4:	89 f3                	mov    %esi,%ebx
  2824c6:	0f b6 fb             	movzbl %bl,%edi
  2824c9:	3b 79 14             	cmp    0x14(%ecx),%edi
  2824cc:	74 12                	je     2824e0 <sheet_refreshsub1+0x9c>
						vram[vy*ctl->xsize+vx] = c;
  2824ce:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2824d1:	8b 7d f0             	mov    -0x10(%ebp),%edi
  2824d4:	0f af 7b 08          	imul   0x8(%ebx),%edi
  2824d8:	03 55 e4             	add    -0x1c(%ebp),%edx
  2824db:	89 f3                	mov    %esi,%ebx
  2824dd:	88 1c 3a             	mov    %bl,(%edx,%edi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0 + by;
			for(bx=0;bx<sht->bxsize;bx++)
  2824e0:	83 c0 01             	add    $0x1,%eax
  2824e3:	8b 71 04             	mov    0x4(%ecx),%esi
  2824e6:	39 c6                	cmp    %eax,%esi
  2824e8:	7f b0                	jg     28249a <sheet_refreshsub1+0x56>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  2824ea:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  2824ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
  2824f1:	39 41 08             	cmp    %eax,0x8(%ecx)
  2824f4:	7f 8f                	jg     282485 <sheet_refreshsub1+0x41>
void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  2824f6:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  2824fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
  2824fd:	8b 7d 08             	mov    0x8(%ebp),%edi
  282500:	39 47 10             	cmp    %eax,0x10(%edi)
  282503:	0f 8d 60 ff ff ff    	jge    282469 <sheet_refreshsub1+0x25>
						vram[vy*ctl->xsize+vx] = c;
				}
			}
		}
	}
}
  282509:	83 c4 14             	add    $0x14,%esp
  28250c:	5b                   	pop    %ebx
  28250d:	5e                   	pop    %esi
  28250e:	5f                   	pop    %edi
  28250f:	5d                   	pop    %ebp
  282510:	c3                   	ret    

00282511 <sheet_refreshsub2>:

void sheet_refreshsub2(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1,int h0)
{
  282511:	55                   	push   %ebp
  282512:	89 e5                	mov    %esp,%ebp
  282514:	57                   	push   %edi
  282515:	56                   	push   %esi
  282516:	53                   	push   %ebx
  282517:	83 ec 30             	sub    $0x30,%esp
  28251a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  28251d:	8b 55 10             	mov    0x10(%ebp),%edx
  282520:	8b 75 14             	mov    0x14(%ebp),%esi
  282523:	8b 7d 18             	mov    0x18(%ebp),%edi
  282526:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	int h,bx,by,vx,vy,bx0,by0,bx1,by1;
	unsigned char *buf,c,*vram = ctl->vram,*map = ctl->map;
  282529:	8b 45 08             	mov    0x8(%ebp),%eax
  28252c:	8b 00                	mov    (%eax),%eax
  28252e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  282531:	8b 45 08             	mov    0x8(%ebp),%eax
  282534:	8b 40 04             	mov    0x4(%eax),%eax
  282537:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  28253a:	b8 00 00 00 00       	mov    $0x0,%eax
  28253f:	85 c9                	test   %ecx,%ecx
  282541:	0f 48 c8             	cmovs  %eax,%ecx
  282544:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  282547:	85 d2                	test   %edx,%edx
  282549:	0f 48 d0             	cmovs  %eax,%edx
  28254c:	89 55 d0             	mov    %edx,-0x30(%ebp)
	struct SHEET *sht;
	
	//limit the refresh rect in the visible rect.
	if(vx0<0) vx0 = 0;
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
  28254f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282552:	8b 51 08             	mov    0x8(%ecx),%edx
  282555:	39 f2                	cmp    %esi,%edx
  282557:	0f 4e f2             	cmovle %edx,%esi
  28255a:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
  28255d:	8b 51 0c             	mov    0xc(%ecx),%edx
  282560:	39 fa                	cmp    %edi,%edx
  282562:	0f 4e fa             	cmovle %edx,%edi
  282565:	89 7d cc             	mov    %edi,-0x34(%ebp)
  282568:	85 db                	test   %ebx,%ebx
  28256a:	0f 49 c3             	cmovns %ebx,%eax
  28256d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  282570:	39 41 10             	cmp    %eax,0x10(%ecx)
  282573:	0f 8c b3 00 00 00    	jl     28262c <sheet_refreshsub2+0x11b>
	{
		//calculate the need-refresh rect of each sheet.
		sht = ctl->sheets[h];
  282579:	8b 45 08             	mov    0x8(%ebp),%eax
  28257c:	8b 7d d8             	mov    -0x28(%ebp),%edi
  28257f:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  282583:	8b 01                	mov    (%ecx),%eax
  282585:	89 45 ec             	mov    %eax,-0x14(%ebp)
		bx0 = vx0 - sht->vx0;
  282588:	8b 41 0c             	mov    0xc(%ecx),%eax
		by0 = vy0 - sht->vy0;
  28258b:	8b 71 10             	mov    0x10(%ecx),%esi
		bx1 = vx1 - sht->vx0;
  28258e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  282591:	29 c2                	sub    %eax,%edx
		by1 = vy1 - sht->vy0;
  282593:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  282596:	29 f3                	sub    %esi,%ebx
  282598:	8b 7d c8             	mov    -0x38(%ebp),%edi
  28259b:	29 c7                	sub    %eax,%edi
  28259d:	89 f8                	mov    %edi,%eax
  28259f:	bf 00 00 00 00       	mov    $0x0,%edi
  2825a4:	0f 48 c7             	cmovs  %edi,%eax
  2825a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  2825aa:	8b 45 d0             	mov    -0x30(%ebp),%eax
  2825ad:	29 f0                	sub    %esi,%eax
  2825af:	0f 49 f8             	cmovns %eax,%edi

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
  2825b2:	8b 41 04             	mov    0x4(%ecx),%eax
  2825b5:	39 c2                	cmp    %eax,%edx
  2825b7:	0f 4e c2             	cmovle %edx,%eax
  2825ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(by1>sht->bysize) by1=sht->bysize;
  2825bd:	8b 41 08             	mov    0x8(%ecx),%eax
  2825c0:	39 c3                	cmp    %eax,%ebx
  2825c2:	0f 4e c3             	cmovle %ebx,%eax
  2825c5:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for(by=by0;by<by1;by++)
  2825c8:	39 f8                	cmp    %edi,%eax
  2825ca:	7e 4d                	jle    282619 <sheet_refreshsub2+0x108>
		{
			vy = sht->vy0+by;
  2825cc:	89 f8                	mov    %edi,%eax
  2825ce:	03 41 10             	add    0x10(%ecx),%eax
  2825d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
			for(bx=bx0;bx<bx1;bx++)
  2825d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  2825d7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  2825da:	7e 35                	jle    282611 <sheet_refreshsub2+0x100>
			{
				vx = sht->vx0+bx;
				c  = buf[by*sht->bxsize+bx];
  2825dc:	89 fa                	mov    %edi,%edx
  2825de:	0f af 51 04          	imul   0x4(%ecx),%edx
  2825e2:	8b 75 ec             	mov    -0x14(%ebp),%esi
  2825e5:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  2825e8:	0f b6 1c 13          	movzbl (%ebx,%edx,1),%ebx
				if(c!=sht->col_inv)
  2825ec:	0f b6 d3             	movzbl %bl,%edx
  2825ef:	3b 51 14             	cmp    0x14(%ecx),%edx
  2825f2:	74 15                	je     282609 <sheet_refreshsub2+0xf8>
					map[vy*ctl->xsize+vx] = c;
  2825f4:	8b 55 08             	mov    0x8(%ebp),%edx
  2825f7:	8b 75 e8             	mov    -0x18(%ebp),%esi
  2825fa:	0f af 72 08          	imul   0x8(%edx),%esi
  2825fe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  282601:	01 c2                	add    %eax,%edx
  282603:	03 51 0c             	add    0xc(%ecx),%edx
  282606:	88 1c 32             	mov    %bl,(%edx,%esi,1)
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
		{
			vy = sht->vy0+by;
			for(bx=bx0;bx<bx1;bx++)
  282609:	83 c0 01             	add    $0x1,%eax
  28260c:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  28260f:	75 cb                	jne    2825dc <sheet_refreshsub2+0xcb>

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
  282611:	83 c7 01             	add    $0x1,%edi
  282614:	39 7d e0             	cmp    %edi,-0x20(%ebp)
  282617:	75 b3                	jne    2825cc <sheet_refreshsub2+0xbb>
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  282619:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  28261d:	8b 45 d8             	mov    -0x28(%ebp),%eax
  282620:	8b 7d 08             	mov    0x8(%ebp),%edi
  282623:	39 47 10             	cmp    %eax,0x10(%edi)
  282626:	0f 8d 4d ff ff ff    	jge    282579 <sheet_refreshsub2+0x68>
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  28262c:	8b 7d d0             	mov    -0x30(%ebp),%edi
  28262f:	39 7d cc             	cmp    %edi,-0x34(%ebp)
  282632:	7f 2a                	jg     28265e <sheet_refreshsub2+0x14d>
  282634:	eb 40                	jmp    282676 <sheet_refreshsub2+0x165>
  282636:	89 4d f0             	mov    %ecx,-0x10(%ebp)
		for(vx=vx0;vx<vx1;vx++)
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
  282639:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28263c:	0f af 47 08          	imul   0x8(%edi),%eax
  282640:	01 d0                	add    %edx,%eax
  282642:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  282646:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
		for(vx=vx0;vx<vx1;vx++)
  282649:	83 c2 01             	add    $0x1,%edx
  28264c:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
  28264f:	75 e8                	jne    282639 <sheet_refreshsub2+0x128>
  282651:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  282654:	83 c1 01             	add    $0x1,%ecx
  282657:	3b 4d cc             	cmp    -0x34(%ebp),%ecx
  28265a:	74 1a                	je     282676 <sheet_refreshsub2+0x165>
  28265c:	eb 0c                	jmp    28266a <sheet_refreshsub2+0x159>
  28265e:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  282661:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  282664:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  282667:	8b 7d 08             	mov    0x8(%ebp),%edi
		for(vx=vx0;vx<vx1;vx++)
  28266a:	8b 45 c8             	mov    -0x38(%ebp),%eax
  28266d:	89 c2                	mov    %eax,%edx
  28266f:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  282672:	7f c2                	jg     282636 <sheet_refreshsub2+0x125>
  282674:	eb de                	jmp    282654 <sheet_refreshsub2+0x143>
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
}
  282676:	83 c4 30             	add    $0x30,%esp
  282679:	5b                   	pop    %ebx
  28267a:	5e                   	pop    %esi
  28267b:	5f                   	pop    %edi
  28267c:	5d                   	pop    %ebp
  28267d:	c3                   	ret    

0028267e <sheet_refresh>:

void sheet_refresh(struct SHEET *sht,int bx0,int by0,int bx1,int by1)
{
  28267e:	55                   	push   %ebp
  28267f:	89 e5                	mov    %esp,%ebp
  282681:	53                   	push   %ebx
  282682:	8b 45 08             	mov    0x8(%ebp),%eax
	//if(sht->height >= 0)
	//{
		struct SHTCTL *ctl = sht->ctl;
		sheet_refreshsub2(ctl,sht->vx0+bx0,sht->vy0+by0,sht->vx0+bx1,sht->vy0+by1,sht->height);
  282685:	8b 48 10             	mov    0x10(%eax),%ecx
  282688:	8b 50 0c             	mov    0xc(%eax),%edx
  28268b:	ff 70 18             	pushl  0x18(%eax)
  28268e:	89 cb                	mov    %ecx,%ebx
  282690:	03 5d 18             	add    0x18(%ebp),%ebx
  282693:	53                   	push   %ebx
  282694:	89 d3                	mov    %edx,%ebx
  282696:	03 5d 14             	add    0x14(%ebp),%ebx
  282699:	53                   	push   %ebx
  28269a:	03 4d 10             	add    0x10(%ebp),%ecx
  28269d:	51                   	push   %ecx
  28269e:	03 55 0c             	add    0xc(%ebp),%edx
  2826a1:	52                   	push   %edx
  2826a2:	ff 70 20             	pushl  0x20(%eax)
  2826a5:	e8 67 fe ff ff       	call   282511 <sheet_refreshsub2>
	//}
	return;
  2826aa:	83 c4 18             	add    $0x18,%esp
}
  2826ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2826b0:	c9                   	leave  
  2826b1:	c3                   	ret    

002826b2 <sheet_updown>:
	return;
}

//update the sheet with new height
void sheet_updown(struct SHEET *sht,int height)
{
  2826b2:	55                   	push   %ebp
  2826b3:	89 e5                	mov    %esp,%ebp
  2826b5:	57                   	push   %edi
  2826b6:	56                   	push   %esi
  2826b7:	53                   	push   %ebx
  2826b8:	8b 75 08             	mov    0x8(%ebp),%esi
  2826bb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct SHTCTL *ctl = sht->ctl;
  2826be:	8b 4e 20             	mov    0x20(%esi),%ecx
	int h,old = sht->height;
  2826c1:	8b 46 18             	mov    0x18(%esi),%eax
	if(height>ctl->top+1) height = ctl->top + 1;
  2826c4:	8b 79 10             	mov    0x10(%ecx),%edi
  2826c7:	8d 57 01             	lea    0x1(%edi),%edx
  2826ca:	39 da                	cmp    %ebx,%edx
  2826cc:	0f 4f d3             	cmovg  %ebx,%edx
  2826cf:	85 d2                	test   %edx,%edx
  2826d1:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  2826d6:	0f 49 da             	cmovns %edx,%ebx
	if(height<-1) height = -1;
	sht->height = height;
  2826d9:	89 5e 18             	mov    %ebx,0x18(%esi)

	//push down the sheet
	if(old>height)
  2826dc:	39 d8                	cmp    %ebx,%eax
  2826de:	7e 59                	jle    282739 <sheet_updown+0x87>
	{
		//if the sheet still shows
		if(height >=0 )
  2826e0:	85 db                	test   %ebx,%ebx
  2826e2:	79 09                	jns    2826ed <sheet_updown+0x3b>
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  2826e4:	8b 59 10             	mov    0x10(%ecx),%ebx
  2826e7:	39 d8                	cmp    %ebx,%eax
  2826e9:	7c 1c                	jl     282707 <sheet_updown+0x55>
  2826eb:	eb 31                	jmp    28271e <sheet_updown+0x6c>
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  2826ed:	8d 50 ff             	lea    -0x1(%eax),%edx
  2826f0:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  2826f4:	89 7c 91 18          	mov    %edi,0x18(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  2826f8:	89 47 18             	mov    %eax,0x18(%edi)
	if(old>height)
	{
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
  2826fb:	89 d0                	mov    %edx,%eax
  2826fd:	39 d3                	cmp    %edx,%ebx
  2826ff:	75 ec                	jne    2826ed <sheet_updown+0x3b>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;	
  282701:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  282705:	eb 1d                	jmp    282724 <sheet_updown+0x72>
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  282707:	8d 50 01             	lea    0x1(%eax),%edx
  28270a:	8b 5c 91 14          	mov    0x14(%ecx,%edx,4),%ebx
  28270e:	89 5c 91 10          	mov    %ebx,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282712:	89 43 18             	mov    %eax,0x18(%ebx)
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  282715:	8b 59 10             	mov    0x10(%ecx),%ebx
  282718:	89 d0                	mov    %edx,%eax
  28271a:	39 d3                	cmp    %edx,%ebx
  28271c:	7f e9                	jg     282707 <sheet_updown+0x55>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->top--;
  28271e:	83 eb 01             	sub    $0x1,%ebx
  282721:	89 59 10             	mov    %ebx,0x10(%ecx)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  282724:	ff 76 08             	pushl  0x8(%esi)
  282727:	ff 76 04             	pushl  0x4(%esi)
  28272a:	6a 00                	push   $0x0
  28272c:	6a 00                	push   $0x0
  28272e:	56                   	push   %esi
  28272f:	e8 4a ff ff ff       	call   28267e <sheet_refresh>
  282734:	83 c4 14             	add    $0x14,%esp
  282737:	eb 5a                	jmp    282793 <sheet_updown+0xe1>
	}
	else if(old<height) //pop up the sheet
  282739:	39 d8                	cmp    %ebx,%eax
  28273b:	7d 56                	jge    282793 <sheet_updown+0xe1>
	{
		if(old >= 0) //the sheet still shows.
  28273d:	85 c0                	test   %eax,%eax
  28273f:	78 1a                	js     28275b <sheet_updown+0xa9>
		{
			for(h=old;h<height;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  282741:	8d 50 01             	lea    0x1(%eax),%edx
  282744:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  282748:	89 7c 91 10          	mov    %edi,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  28274c:	89 47 18             	mov    %eax,0x18(%edi)
	}
	else if(old<height) //pop up the sheet
	{
		if(old >= 0) //the sheet still shows.
		{
			for(h=old;h<height;h++)
  28274f:	89 d0                	mov    %edx,%eax
  282751:	39 d3                	cmp    %edx,%ebx
  282753:	75 ec                	jne    282741 <sheet_updown+0x8f>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  282755:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  282759:	eb 25                	jmp    282780 <sheet_updown+0xce>
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
  28275b:	8b 41 10             	mov    0x10(%ecx),%eax
  28275e:	8d 50 01             	lea    0x1(%eax),%edx
  282761:	89 51 10             	mov    %edx,0x10(%ecx)
			for(h=ctl->top;h>height;h--)
  282764:	39 d3                	cmp    %edx,%ebx
  282766:	7d 14                	jge    28277c <sheet_updown+0xca>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  282768:	8d 42 ff             	lea    -0x1(%edx),%eax
  28276b:	8b 7c 81 14          	mov    0x14(%ecx,%eax,4),%edi
  28276f:	89 7c 81 18          	mov    %edi,0x18(%ecx,%eax,4)
				ctl->sheets[h]->height = h;
  282773:	89 57 18             	mov    %edx,0x18(%edi)
			ctl->sheets[height] = sht;
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
			for(h=ctl->top;h>height;h--)
  282776:	89 c2                	mov    %eax,%edx
  282778:	39 c3                	cmp    %eax,%ebx
  28277a:	75 ec                	jne    282768 <sheet_updown+0xb6>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  28277c:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  282780:	ff 76 08             	pushl  0x8(%esi)
  282783:	ff 76 04             	pushl  0x4(%esi)
  282786:	6a 00                	push   $0x0
  282788:	6a 00                	push   $0x0
  28278a:	56                   	push   %esi
  28278b:	e8 ee fe ff ff       	call   28267e <sheet_refresh>
  282790:	83 c4 14             	add    $0x14,%esp
	}
	//else height not change.
	return;
}
  282793:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282796:	5b                   	pop    %ebx
  282797:	5e                   	pop    %esi
  282798:	5f                   	pop    %edi
  282799:	5d                   	pop    %ebp
  28279a:	c3                   	ret    

0028279b <sheet_slide>:
	//}
	return;
}

void sheet_slide(struct SHEET *sht,int vx0,int vy0)
{
  28279b:	55                   	push   %ebp
  28279c:	89 e5                	mov    %esp,%ebp
  28279e:	57                   	push   %edi
  28279f:	56                   	push   %esi
  2827a0:	53                   	push   %ebx
  2827a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2827a4:	8b 75 10             	mov    0x10(%ebp),%esi
	//(vx0,vy0): the sheet buf in the vram pos.
	int old_vx0 = sht->vx0,old_vy0 = sht->vy0;
  2827a7:	8b 43 0c             	mov    0xc(%ebx),%eax
  2827aa:	8b 53 10             	mov    0x10(%ebx),%edx
	sht->vx0 = vx0;
  2827ad:	8b 7d 0c             	mov    0xc(%ebp),%edi
  2827b0:	89 7b 0c             	mov    %edi,0xc(%ebx)
	sht->vy0 = vy0;
  2827b3:	89 73 10             	mov    %esi,0x10(%ebx)
	if(sht->height >= 0)
  2827b6:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  2827ba:	78 36                	js     2827f2 <sheet_slide+0x57>
	{
		struct SHTCTL *ctl = sht->ctl;
  2827bc:	8b 7b 20             	mov    0x20(%ebx),%edi
		sheet_refreshsub2(ctl,old_vx0,old_vy0,old_vx0+sht->bxsize,old_vy0+sht->bysize, 0);
  2827bf:	6a 00                	push   $0x0
  2827c1:	89 d1                	mov    %edx,%ecx
  2827c3:	03 4b 08             	add    0x8(%ebx),%ecx
  2827c6:	51                   	push   %ecx
  2827c7:	89 c1                	mov    %eax,%ecx
  2827c9:	03 4b 04             	add    0x4(%ebx),%ecx
  2827cc:	51                   	push   %ecx
  2827cd:	52                   	push   %edx
  2827ce:	50                   	push   %eax
  2827cf:	57                   	push   %edi
  2827d0:	e8 3c fd ff ff       	call   282511 <sheet_refreshsub2>
		sheet_refreshsub2(ctl,vx0,vy0,vx0+sht->bxsize,vy0+sht->bysize,sht->height);
  2827d5:	ff 73 18             	pushl  0x18(%ebx)
  2827d8:	89 f0                	mov    %esi,%eax
  2827da:	03 43 08             	add    0x8(%ebx),%eax
  2827dd:	50                   	push   %eax
  2827de:	8b 45 0c             	mov    0xc(%ebp),%eax
  2827e1:	03 43 04             	add    0x4(%ebx),%eax
  2827e4:	50                   	push   %eax
  2827e5:	56                   	push   %esi
  2827e6:	ff 75 0c             	pushl  0xc(%ebp)
  2827e9:	57                   	push   %edi
  2827ea:	e8 22 fd ff ff       	call   282511 <sheet_refreshsub2>
  2827ef:	83 c4 30             	add    $0x30,%esp
	}
	return;
}
  2827f2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2827f5:	5b                   	pop    %ebx
  2827f6:	5e                   	pop    %esi
  2827f7:	5f                   	pop    %edi
  2827f8:	5d                   	pop    %ebp
  2827f9:	c3                   	ret    

002827fa <sheet_free>:

void sheet_free(struct SHEET *sht)
{
  2827fa:	55                   	push   %ebp
  2827fb:	89 e5                	mov    %esp,%ebp
  2827fd:	53                   	push   %ebx
  2827fe:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(sht->height >= 0)
  282801:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  282805:	78 0b                	js     282812 <sheet_free+0x18>
	{
		sheet_updown(sht,-1); //hide the sheet
  282807:	6a ff                	push   $0xffffffff
  282809:	53                   	push   %ebx
  28280a:	e8 a3 fe ff ff       	call   2826b2 <sheet_updown>
  28280f:	83 c4 08             	add    $0x8,%esp
	}
	sht->flags = 0; //set sheet unused.
  282812:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	return;
}
  282819:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  28281c:	c9                   	leave  
  28281d:	c3                   	ret    

0028281e <timer_alloc>:
	timerctl.next = 0xffffffff;
	return;
}

struct TIMER *timer_alloc(void)
{
  28281e:	55                   	push   %ebp
  28281f:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TIMER;i++)
	{
		if(timerctl.timers0[i].flags == 0)
  282821:	80 3d 50 73 28 00 00 	cmpb   $0x0,0x287350
  282828:	74 11                	je     28283b <timer_alloc+0x1d>
  28282a:	ba 64 73 28 00       	mov    $0x287364,%edx
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  28282f:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(timerctl.timers0[i].flags == 0)
  282834:	80 3a 00             	cmpb   $0x0,(%edx)
  282837:	75 2b                	jne    282864 <timer_alloc+0x46>
  282839:	eb 05                	jmp    282840 <timer_alloc+0x22>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  28283b:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(timerctl.timers0[i].flags == 0)
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
  282840:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  282847:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28284a:	8d 0c 8d 40 73 28 00 	lea    0x287340(,%ecx,4),%ecx
  282851:	c6 41 10 01          	movb   $0x1,0x10(%ecx)
			timerctl.timers0[i].flags2= 0;
  282855:	c6 41 11 00          	movb   $0x0,0x11(%ecx)
			return &timerctl.timers0[i];
  282859:	01 d0                	add    %edx,%eax
  28285b:	8d 04 85 48 73 28 00 	lea    0x287348(,%eax,4),%eax
  282862:	eb 12                	jmp    282876 <timer_alloc+0x58>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282864:	83 c0 01             	add    $0x1,%eax
  282867:	83 c2 14             	add    $0x14,%edx
  28286a:	3d f4 01 00 00       	cmp    $0x1f4,%eax
  28286f:	75 c3                	jne    282834 <timer_alloc+0x16>
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
			timerctl.timers0[i].flags2= 0;
			return &timerctl.timers0[i];
		}
	}
	return 0;
  282871:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282876:	5d                   	pop    %ebp
  282877:	c3                   	ret    

00282878 <init_pit>:
#include "task.h"

struct TIMERCTL timerctl;

void init_pit(void)
{
  282878:	55                   	push   %ebp
  282879:	89 e5                	mov    %esp,%ebp
  28287b:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIT_CTRL,0X34);
  28287e:	6a 34                	push   $0x34
  282880:	6a 43                	push   $0x43
  282882:	e8 4f e1 ff ff       	call   2809d6 <io_out8>
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
  282887:	83 c4 08             	add    $0x8,%esp
  28288a:	68 9c 00 00 00       	push   $0x9c
  28288f:	6a 40                	push   $0x40
  282891:	e8 40 e1 ff ff       	call   2809d6 <io_out8>
	io_out8(PIT_CNT0,0x2e);
  282896:	83 c4 08             	add    $0x8,%esp
  282899:	6a 2e                	push   $0x2e
  28289b:	6a 40                	push   $0x40
  28289d:	e8 34 e1 ff ff       	call   2809d6 <io_out8>
  2828a2:	b8 50 73 28 00       	mov    $0x287350,%eax
  2828a7:	ba 60 9a 28 00       	mov    $0x289a60,%edx
  2828ac:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<MAX_TIMER;i++)
		timerctl.timers0[i].flags = 0;
  2828af:	c6 00 00             	movb   $0x0,(%eax)
  2828b2:	83 c0 14             	add    $0x14,%eax
{
	io_out8(PIT_CTRL,0X34);
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
	io_out8(PIT_CNT0,0x2e);
	for(int i=0;i<MAX_TIMER;i++)
  2828b5:	39 d0                	cmp    %edx,%eax
  2828b7:	75 f6                	jne    2828af <init_pit+0x37>
		timerctl.timers0[i].flags = 0;
	struct TIMER *t = timer_alloc();
  2828b9:	e8 60 ff ff ff       	call   28281e <timer_alloc>
	t->next = 0;
  2828be:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	t->timeout = 0xffffffff;
  2828c4:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
	t->flags = TIMER_FLAGS_USING;
  2828cb:	c6 40 08 02          	movb   $0x2,0x8(%eax)
	timerctl.t0 = t;
  2828cf:	a3 58 9a 28 00       	mov    %eax,0x289a58
	timerctl.next = 0xffffffff;
  2828d4:	c7 05 44 73 28 00 ff 	movl   $0xffffffff,0x287344
  2828db:	ff ff ff 
	return;
}
  2828de:	c9                   	leave  
  2828df:	c3                   	ret    

002828e0 <timer_free>:
	}
	return 0;
}

void timer_free(struct TIMER *timer)
{
  2828e0:	55                   	push   %ebp
  2828e1:	89 e5                	mov    %esp,%ebp
	timer->flags = 0;
  2828e3:	8b 45 08             	mov    0x8(%ebp),%eax
  2828e6:	c6 40 08 00          	movb   $0x0,0x8(%eax)
	return;
}
  2828ea:	5d                   	pop    %ebp
  2828eb:	c3                   	ret    

002828ec <timer_init>:

void timer_init(struct TIMER *timer,struct FIFO32 *fifo,int data)
{
  2828ec:	55                   	push   %ebp
  2828ed:	89 e5                	mov    %esp,%ebp
  2828ef:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->fifo = fifo;
  2828f2:	8b 55 0c             	mov    0xc(%ebp),%edx
  2828f5:	89 50 0c             	mov    %edx,0xc(%eax)
	timer->data = data;
  2828f8:	8b 55 10             	mov    0x10(%ebp),%edx
  2828fb:	89 50 10             	mov    %edx,0x10(%eax)
	return ;
}
  2828fe:	5d                   	pop    %ebp
  2828ff:	c3                   	ret    

00282900 <timer_settime>:

void timer_settime(struct TIMER *timer,unsigned int timeout)
{
  282900:	55                   	push   %ebp
  282901:	89 e5                	mov    %esp,%ebp
  282903:	57                   	push   %edi
  282904:	56                   	push   %esi
  282905:	53                   	push   %ebx
  282906:	83 ec 0c             	sub    $0xc,%esp
  282909:	8b 5d 08             	mov    0x8(%ebp),%ebx
	timer->timeout = timeout + timerctl.count;
  28290c:	a1 40 73 28 00       	mov    0x287340,%eax
  282911:	03 45 0c             	add    0xc(%ebp),%eax
  282914:	89 43 04             	mov    %eax,0x4(%ebx)
	timer->flags = TIMER_FLAGS_USING;
  282917:	c6 43 08 02          	movb   $0x2,0x8(%ebx)
	int e = io_load_eflags();
  28291b:	e8 d5 e0 ff ff       	call   2809f5 <io_load_eflags>
  282920:	89 c6                	mov    %eax,%esi
	io_cli();
  282922:	e8 7b e0 ff ff       	call   2809a2 <io_cli>
	struct TIMER *t, *s;
	if(timer->timeout<=timerctl.t0->timeout)
  282927:	8b 4b 04             	mov    0x4(%ebx),%ecx
  28292a:	8b 3d 58 9a 28 00    	mov    0x289a58,%edi
  282930:	3b 4f 04             	cmp    0x4(%edi),%ecx
  282933:	77 1e                	ja     282953 <timer_settime+0x53>
	{
		timer->next = timerctl.t0;
  282935:	89 3b                	mov    %edi,(%ebx)
		timerctl.t0 = timer;
  282937:	89 1d 58 9a 28 00    	mov    %ebx,0x289a58
		timerctl.next = timer->timeout;
  28293d:	8b 43 04             	mov    0x4(%ebx),%eax
  282940:	a3 44 73 28 00       	mov    %eax,0x287344
		io_store_eflags(e);
  282945:	83 ec 0c             	sub    $0xc,%esp
  282948:	56                   	push   %esi
  282949:	e8 aa e0 ff ff       	call   2809f8 <io_store_eflags>
		return;
  28294e:	83 c4 10             	add    $0x10,%esp
  282951:	eb 3e                	jmp    282991 <timer_settime+0x91>
	}
	t = timerctl.t0->next;
  282953:	8b 17                	mov    (%edi),%edx
	s = timerctl.t0;
	while(t)
  282955:	85 d2                	test   %edx,%edx
  282957:	74 2c                	je     282985 <timer_settime+0x85>
	{
		if(timer->timeout<=t->timeout)
  282959:	3b 4a 04             	cmp    0x4(%edx),%ecx
  28295c:	77 21                	ja     28297f <timer_settime+0x7f>
  28295e:	eb 07                	jmp    282967 <timer_settime+0x67>
  282960:	3b 48 04             	cmp    0x4(%eax),%ecx
  282963:	77 18                	ja     28297d <timer_settime+0x7d>
  282965:	eb 04                	jmp    28296b <timer_settime+0x6b>
		timerctl.t0 = timer;
		timerctl.next = timer->timeout;
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
  282967:	89 d0                	mov    %edx,%eax
	s = timerctl.t0;
  282969:	89 fa                	mov    %edi,%edx
	while(t)
	{
		if(timer->timeout<=t->timeout)
		{
			timer->next = t;
  28296b:	89 03                	mov    %eax,(%ebx)
			s->next = timer;
  28296d:	89 1a                	mov    %ebx,(%edx)
			io_store_eflags(e);
  28296f:	83 ec 0c             	sub    $0xc,%esp
  282972:	56                   	push   %esi
  282973:	e8 80 e0 ff ff       	call   2809f8 <io_store_eflags>
			return;
  282978:	83 c4 10             	add    $0x10,%esp
  28297b:	eb 14                	jmp    282991 <timer_settime+0x91>
		}
		s = t;
		t = t->next;
  28297d:	89 c2                	mov    %eax,%edx
  28297f:	8b 02                	mov    (%edx),%eax
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
	s = timerctl.t0;
	while(t)
  282981:	85 c0                	test   %eax,%eax
  282983:	75 db                	jne    282960 <timer_settime+0x60>
			return;
		}
		s = t;
		t = t->next;
	}
	io_store_eflags(e);
  282985:	83 ec 0c             	sub    $0xc,%esp
  282988:	56                   	push   %esi
  282989:	e8 6a e0 ff ff       	call   2809f8 <io_store_eflags>
	return;
  28298e:	83 c4 10             	add    $0x10,%esp
}
  282991:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282994:	5b                   	pop    %ebx
  282995:	5e                   	pop    %esi
  282996:	5f                   	pop    %edi
  282997:	5d                   	pop    %ebp
  282998:	c3                   	ret    

00282999 <inthandler20>:

extern struct TIMER *task_timer;

//handler for int 20 (timer interrupts)
void inthandler20(int *esp)
{
  282999:	55                   	push   %ebp
  28299a:	89 e5                	mov    %esp,%ebp
  28299c:	56                   	push   %esi
  28299d:	53                   	push   %ebx
	char ts = 0;

	io_out8(PIC0_OCW2,0x60); //tell pic continue watch 20 int
  28299e:	83 ec 08             	sub    $0x8,%esp
  2829a1:	6a 60                	push   $0x60
  2829a3:	6a 20                	push   $0x20
  2829a5:	e8 2c e0 ff ff       	call   2809d6 <io_out8>
	timerctl.count ++;
  2829aa:	a1 40 73 28 00       	mov    0x287340,%eax
  2829af:	8d 50 01             	lea    0x1(%eax),%edx
  2829b2:	89 15 40 73 28 00    	mov    %edx,0x287340
	
	if(timerctl.count >= timerctl.next)
  2829b8:	83 c4 10             	add    $0x10,%esp
  2829bb:	3b 15 44 73 28 00    	cmp    0x287344,%edx
  2829c1:	72 69                	jb     282a2c <inthandler20+0x93>
	{
		struct TIMER *t = timerctl.t0;
  2829c3:	8b 1d 58 9a 28 00    	mov    0x289a58,%ebx
		while(t)
  2829c9:	85 db                	test   %ebx,%ebx
  2829cb:	75 46                	jne    282a13 <inthandler20+0x7a>
  2829cd:	eb 5d                	jmp    282a2c <inthandler20+0x93>
		{
			if(t->timeout <= timerctl.count)
  2829cf:	8b 43 04             	mov    0x4(%ebx),%eax
  2829d2:	3b 05 40 73 28 00    	cmp    0x287340,%eax
  2829d8:	77 2c                	ja     282a06 <inthandler20+0x6d>
			{
				t->flags = TIMER_FLAGS_ALLOC;
  2829da:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
				if(t!=task_timer) fifo32_put(t->fifo,t->data);
  2829de:	39 1d 60 9a 28 00    	cmp    %ebx,0x289a60
  2829e4:	74 13                	je     2829f9 <inthandler20+0x60>
  2829e6:	83 ec 08             	sub    $0x8,%esp
  2829e9:	ff 73 10             	pushl  0x10(%ebx)
  2829ec:	ff 73 0c             	pushl  0xc(%ebx)
  2829ef:	e8 a5 f0 ff ff       	call   281a99 <fifo32_put>
  2829f4:	83 c4 10             	add    $0x10,%esp
  2829f7:	eb 05                	jmp    2829fe <inthandler20+0x65>
				else ts=1;
  2829f9:	be 01 00 00 00       	mov    $0x1,%esi
				t = t->next;
  2829fe:	8b 1b                	mov    (%ebx),%ebx
	timerctl.count ++;
	
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
  282a00:	85 db                	test   %ebx,%ebx
  282a02:	75 cb                	jne    2829cf <inthandler20+0x36>
  282a04:	eb 1b                	jmp    282a21 <inthandler20+0x88>
				else ts=1;
				t = t->next;
			}
			else
			{
				timerctl.next = t->timeout;
  282a06:	a3 44 73 28 00       	mov    %eax,0x287344
				timerctl.t0 = t;
  282a0b:	89 1d 58 9a 28 00    	mov    %ebx,0x289a58
				break;
  282a11:	eb 0e                	jmp    282a21 <inthandler20+0x88>
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
		{
			if(t->timeout <= timerctl.count)
  282a13:	8b 43 04             	mov    0x4(%ebx),%eax
  282a16:	be 00 00 00 00       	mov    $0x0,%esi
  282a1b:	39 c2                	cmp    %eax,%edx
  282a1d:	73 bb                	jae    2829da <inthandler20+0x41>
  282a1f:	eb e5                	jmp    282a06 <inthandler20+0x6d>
				break;
			}
		}
	}

	if(ts!=0)task_switch();
  282a21:	89 f0                	mov    %esi,%eax
  282a23:	84 c0                	test   %al,%al
  282a25:	74 05                	je     282a2c <inthandler20+0x93>
  282a27:	e8 df 04 00 00       	call   282f0b <task_switch>
	return;
}
  282a2c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282a2f:	5b                   	pop    %ebx
  282a30:	5e                   	pop    %esi
  282a31:	5d                   	pop    %ebp
  282a32:	c3                   	ret    

00282a33 <timer_cancel>:

int timer_cancel(struct TIMER *timer)
{
  282a33:	55                   	push   %ebp
  282a34:	89 e5                	mov    %esp,%ebp
  282a36:	56                   	push   %esi
  282a37:	53                   	push   %ebx
  282a38:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int e;
	struct TIMER *t;
	e = io_load_eflags();
  282a3b:	e8 b5 df ff ff       	call   2809f5 <io_load_eflags>
  282a40:	89 c6                	mov    %eax,%esi
	io_cli();
  282a42:	e8 5b df ff ff       	call   2809a2 <io_cli>
	if(timer->flags == TIMER_FLAGS_USING)
  282a47:	80 7b 08 02          	cmpb   $0x2,0x8(%ebx)
  282a4b:	75 3e                	jne    282a8b <timer_cancel+0x58>
	{
		if(timer == timerctl.t0)
  282a4d:	8b 15 58 9a 28 00    	mov    0x289a58,%edx
  282a53:	39 d3                	cmp    %edx,%ebx
  282a55:	75 13                	jne    282a6a <timer_cancel+0x37>
		{
			t = timer->next;
  282a57:	8b 03                	mov    (%ebx),%eax
			timerctl.t0 = t;
  282a59:	a3 58 9a 28 00       	mov    %eax,0x289a58
			timerctl.next = t->timeout;
  282a5e:	8b 40 04             	mov    0x4(%eax),%eax
  282a61:	a3 44 73 28 00       	mov    %eax,0x287344
  282a66:	eb 0c                	jmp    282a74 <timer_cancel+0x41>
			{
				if(t->next == timer)
				{
					break;
				}
				t = t->next;
  282a68:	89 c2                	mov    %eax,%edx
		else
		{
			t = timerctl.t0;
			for(;;)
			{
				if(t->next == timer)
  282a6a:	8b 02                	mov    (%edx),%eax
  282a6c:	39 c3                	cmp    %eax,%ebx
  282a6e:	75 f8                	jne    282a68 <timer_cancel+0x35>
				{
					break;
				}
				t = t->next;
			}
			t->next = timer->next;
  282a70:	8b 03                	mov    (%ebx),%eax
  282a72:	89 02                	mov    %eax,(%edx)
		}
		timer->flags = TIMER_FLAGS_ALLOC;
  282a74:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
		io_store_eflags(e);
  282a78:	83 ec 0c             	sub    $0xc,%esp
  282a7b:	56                   	push   %esi
  282a7c:	e8 77 df ff ff       	call   2809f8 <io_store_eflags>
		return 1;
  282a81:	83 c4 10             	add    $0x10,%esp
  282a84:	b8 01 00 00 00       	mov    $0x1,%eax
  282a89:	eb 11                	jmp    282a9c <timer_cancel+0x69>
	}
	io_store_eflags(e);
  282a8b:	83 ec 0c             	sub    $0xc,%esp
  282a8e:	56                   	push   %esi
  282a8f:	e8 64 df ff ff       	call   2809f8 <io_store_eflags>
	return 0;
  282a94:	83 c4 10             	add    $0x10,%esp
  282a97:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282a9c:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282a9f:	5b                   	pop    %ebx
  282aa0:	5e                   	pop    %esi
  282aa1:	5d                   	pop    %ebp
  282aa2:	c3                   	ret    

00282aa3 <timer_cancelall>:

void timer_cancelall(struct FIFO32 *fifo)
{
  282aa3:	55                   	push   %ebp
  282aa4:	89 e5                	mov    %esp,%ebp
  282aa6:	57                   	push   %edi
  282aa7:	56                   	push   %esi
  282aa8:	53                   	push   %ebx
  282aa9:	83 ec 1c             	sub    $0x1c,%esp
	int e,i;
	struct TIMER *t;
	e = io_load_eflags();
  282aac:	e8 44 df ff ff       	call   2809f5 <io_load_eflags>
  282ab1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	io_cli();
  282ab4:	e8 e9 de ff ff       	call   2809a2 <io_cli>
  282ab9:	bb 48 73 28 00       	mov    $0x287348,%ebx
  282abe:	bf 58 9a 28 00       	mov    $0x289a58,%edi
	for(i=0;i<MAX_TIMER;i++)
	{
		t = &timerctl.timers0[i];
		if(t->flags != 0 && t->flags2 != 0 && t->fifo == fifo)
  282ac3:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  282ac7:	74 1e                	je     282ae7 <timer_cancelall+0x44>
  282ac9:	80 7b 09 00          	cmpb   $0x0,0x9(%ebx)
  282acd:	74 18                	je     282ae7 <timer_cancelall+0x44>
  282acf:	8b 45 08             	mov    0x8(%ebp),%eax
  282ad2:	39 43 0c             	cmp    %eax,0xc(%ebx)
  282ad5:	75 10                	jne    282ae7 <timer_cancelall+0x44>
		{
			timer_cancel(t);
  282ad7:	83 ec 0c             	sub    $0xc,%esp
  282ada:	53                   	push   %ebx
  282adb:	e8 53 ff ff ff       	call   282a33 <timer_cancel>
	return 0;
}

void timer_free(struct TIMER *timer)
{
	timer->flags = 0;
  282ae0:	c6 43 08 00          	movb   $0x0,0x8(%ebx)
  282ae4:	83 c4 10             	add    $0x10,%esp
  282ae7:	83 c3 14             	add    $0x14,%ebx
{
	int e,i;
	struct TIMER *t;
	e = io_load_eflags();
	io_cli();
	for(i=0;i<MAX_TIMER;i++)
  282aea:	39 fb                	cmp    %edi,%ebx
  282aec:	75 d5                	jne    282ac3 <timer_cancelall+0x20>
		{
			timer_cancel(t);
			timer_free(t);
		}
	}
	io_store_eflags(e);
  282aee:	83 ec 0c             	sub    $0xc,%esp
  282af1:	ff 75 e4             	pushl  -0x1c(%ebp)
  282af4:	e8 ff de ff ff       	call   2809f8 <io_store_eflags>
	return;
  282af9:	83 c4 10             	add    $0x10,%esp
}
  282afc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282aff:	5b                   	pop    %ebx
  282b00:	5e                   	pop    %esi
  282b01:	5f                   	pop    %edi
  282b02:	5d                   	pop    %ebp
  282b03:	c3                   	ret    
  282b04:	66 90                	xchg   %ax,%ax
  282b06:	66 90                	xchg   %ax,%ax
  282b08:	66 90                	xchg   %ax,%ax
  282b0a:	66 90                	xchg   %ax,%ax
  282b0c:	66 90                	xchg   %ax,%ax
  282b0e:	66 90                	xchg   %ax,%ax

00282b10 <load_tr>:
  282b10:	0f 00 5c 24 04       	ltr    0x4(%esp)
  282b15:	c3                   	ret    

00282b16 <farjmp>:
  282b16:	ff 6c 24 04          	ljmp   *0x4(%esp)
  282b1a:	c3                   	ret    

00282b1b <farcall>:
  282b1b:	ff 5c 24 04          	lcall  *0x4(%esp)
  282b1f:	c3                   	ret    

00282b20 <asm_end_app>:
  282b20:	8b 20                	mov    (%eax),%esp
  282b22:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  282b29:	61                   	popa   
  282b2a:	c3                   	ret    

00282b2b <task_idle>:

struct TASKCTL *taskctl;
struct TIMER *task_timer;

void task_idle(void)
{
  282b2b:	55                   	push   %ebp
  282b2c:	89 e5                	mov    %esp,%ebp
  282b2e:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		io_hlt();
  282b31:	e8 6a de ff ff       	call   2809a0 <io_hlt>
  282b36:	eb f9                	jmp    282b31 <task_idle+0x6>

00282b38 <task_alloc>:
	task_run(idle,MAX_TASKLEVELS-1,1);
	return task;
}

struct TASK *task_alloc(void)
{
  282b38:	55                   	push   %ebp
  282b39:	89 e5                	mov    %esp,%ebp
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
	{
		if(taskctl->tasks0[i].flags == 0)
  282b3b:	8b 0d 5c 9a 28 00    	mov    0x289a5c,%ecx
  282b41:	83 b9 fc 0f 00 00 00 	cmpl   $0x0,0xffc(%ecx)
  282b48:	74 16                	je     282b60 <task_alloc+0x28>
  282b4a:	8d 91 98 10 00 00    	lea    0x1098(%ecx),%edx

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282b50:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
  282b55:	83 3a 00             	cmpl   $0x0,(%edx)
  282b58:	0f 85 b9 00 00 00    	jne    282c17 <task_alloc+0xdf>
  282b5e:	eb 05                	jmp    282b65 <task_alloc+0x2d>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282b60:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
		{
			task = &taskctl->tasks0[i];
  282b65:	69 c0 9c 00 00 00    	imul   $0x9c,%eax,%eax
			task->flags = 1;
  282b6b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  282b6e:	c7 82 fc 0f 00 00 01 	movl   $0x1,0xffc(%edx)
  282b75:	00 00 00 
			task->tss.eflags = 0x202;
  282b78:	c7 82 48 10 00 00 02 	movl   $0x202,0x1048(%edx)
  282b7f:	02 00 00 
			task->tss.eax = 0;
  282b82:	c7 82 4c 10 00 00 00 	movl   $0x0,0x104c(%edx)
  282b89:	00 00 00 
			task->tss.ecx = 0;
  282b8c:	c7 82 50 10 00 00 00 	movl   $0x0,0x1050(%edx)
  282b93:	00 00 00 
			task->tss.edx = 0;
  282b96:	c7 82 54 10 00 00 00 	movl   $0x0,0x1054(%edx)
  282b9d:	00 00 00 
			task->tss.ebx = 0;
  282ba0:	c7 82 58 10 00 00 00 	movl   $0x0,0x1058(%edx)
  282ba7:	00 00 00 
			task->tss.ebp = 0;
  282baa:	c7 82 60 10 00 00 00 	movl   $0x0,0x1060(%edx)
  282bb1:	00 00 00 
			task->tss.esi = 0;
  282bb4:	c7 82 64 10 00 00 00 	movl   $0x0,0x1064(%edx)
  282bbb:	00 00 00 
			task->tss.edi = 0;
  282bbe:	c7 82 68 10 00 00 00 	movl   $0x0,0x1068(%edx)
  282bc5:	00 00 00 
			task->tss.es  = 0;
  282bc8:	c7 82 6c 10 00 00 00 	movl   $0x0,0x106c(%edx)
  282bcf:	00 00 00 
			task->tss.ds  = 0;
  282bd2:	c7 82 78 10 00 00 00 	movl   $0x0,0x1078(%edx)
  282bd9:	00 00 00 
			task->tss.fs  = 0;
  282bdc:	c7 82 7c 10 00 00 00 	movl   $0x0,0x107c(%edx)
  282be3:	00 00 00 
			task->tss.gs  = 0;
  282be6:	c7 82 80 10 00 00 00 	movl   $0x0,0x1080(%edx)
  282bed:	00 00 00 
			task->tss.ldtr= 0;
  282bf0:	c7 82 84 10 00 00 00 	movl   $0x0,0x1084(%edx)
  282bf7:	00 00 00 
			task->tss.iomap = 0x40000000;
  282bfa:	c7 82 88 10 00 00 00 	movl   $0x40000000,0x1088(%edx)
  282c01:	00 00 40 
			task->tss.ss0 = 0;
  282c04:	c7 82 2c 10 00 00 00 	movl   $0x0,0x102c(%edx)
  282c0b:	00 00 00 
			return task;
  282c0e:	8d 84 01 f8 0f 00 00 	lea    0xff8(%ecx,%eax,1),%eax
  282c15:	eb 19                	jmp    282c30 <task_alloc+0xf8>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282c17:	83 c0 01             	add    $0x1,%eax
  282c1a:	81 c2 9c 00 00 00    	add    $0x9c,%edx
  282c20:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  282c25:	0f 85 2a ff ff ff    	jne    282b55 <task_alloc+0x1d>
			task->tss.iomap = 0x40000000;
			task->tss.ss0 = 0;
			return task;
		}
	}
	return 0;
  282c2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282c30:	5d                   	pop    %ebp
  282c31:	c3                   	ret    

00282c32 <task_now>:
	}
	return;
}

struct TASK *task_now(void)
{
  282c32:	55                   	push   %ebp
  282c33:	89 e5                	mov    %esp,%ebp
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282c35:	8b 15 5c 9a 28 00    	mov    0x289a5c,%edx
  282c3b:	8b 02                	mov    (%edx),%eax
	return tl->tasks[tl->now];
  282c3d:	69 c8 98 01 00 00    	imul   $0x198,%eax,%ecx
  282c43:	6b c0 66             	imul   $0x66,%eax,%eax
  282c46:	03 44 0a 0c          	add    0xc(%edx,%ecx,1),%eax
  282c4a:	8b 44 82 10          	mov    0x10(%edx,%eax,4),%eax
}
  282c4e:	5d                   	pop    %ebp
  282c4f:	c3                   	ret    

00282c50 <task_add>:

void task_add(struct TASK *task)
{
  282c50:	55                   	push   %ebp
  282c51:	89 e5                	mov    %esp,%ebp
  282c53:	56                   	push   %esi
  282c54:	53                   	push   %ebx
  282c55:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  282c58:	8b 35 5c 9a 28 00    	mov    0x289a5c,%esi
  282c5e:	8b 4b 08             	mov    0x8(%ebx),%ecx
  282c61:	69 c1 98 01 00 00    	imul   $0x198,%ecx,%eax
  282c67:	01 f0                	add    %esi,%eax
	if(tl->running == MAX_TASKS_LV) return;
  282c69:	8b 50 08             	mov    0x8(%eax),%edx
  282c6c:	83 fa 64             	cmp    $0x64,%edx
  282c6f:	74 14                	je     282c85 <task_add+0x35>
	tl->tasks[tl->running] = task;
  282c71:	6b c9 66             	imul   $0x66,%ecx,%ecx
  282c74:	01 ca                	add    %ecx,%edx
  282c76:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
	tl->running++;
  282c7a:	83 40 08 01          	addl   $0x1,0x8(%eax)
	task->flags = 2;	//alive
  282c7e:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	return;
}
  282c85:	5b                   	pop    %ebx
  282c86:	5e                   	pop    %esi
  282c87:	5d                   	pop    %ebp
  282c88:	c3                   	ret    

00282c89 <task_remove>:

void task_remove(struct TASK *task)
{
  282c89:	55                   	push   %ebp
  282c8a:	89 e5                	mov    %esp,%ebp
  282c8c:	57                   	push   %edi
  282c8d:	56                   	push   %esi
  282c8e:	53                   	push   %ebx
  282c8f:	83 ec 04             	sub    $0x4,%esp
  282c92:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  282c95:	8b 3d 5c 9a 28 00    	mov    0x289a5c,%edi
  282c9b:	8b 43 08             	mov    0x8(%ebx),%eax
  282c9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  282ca1:	69 d0 98 01 00 00    	imul   $0x198,%eax,%edx
  282ca7:	01 fa                	add    %edi,%edx
	int i;
	for(i=0;i<tl->running;i++)
  282ca9:	8b 4a 08             	mov    0x8(%edx),%ecx
  282cac:	85 c9                	test   %ecx,%ecx
  282cae:	7e 1d                	jle    282ccd <task_remove+0x44>
	{
		if(tl->tasks[i] == task)
  282cb0:	3b 5a 10             	cmp    0x10(%edx),%ebx
  282cb3:	74 1f                	je     282cd4 <task_remove+0x4b>
  282cb5:	b8 00 00 00 00       	mov    $0x0,%eax
  282cba:	eb 06                	jmp    282cc2 <task_remove+0x39>
  282cbc:	3b 5c 82 10          	cmp    0x10(%edx,%eax,4),%ebx
  282cc0:	74 17                	je     282cd9 <task_remove+0x50>

void task_remove(struct TASK *task)
{
	struct TASKLEVEL *tl = &taskctl->level[task->level];
	int i;
	for(i=0;i<tl->running;i++)
  282cc2:	83 c0 01             	add    $0x1,%eax
  282cc5:	39 c8                	cmp    %ecx,%eax
  282cc7:	75 f3                	jne    282cbc <task_remove+0x33>
  282cc9:	89 c8                	mov    %ecx,%eax
  282ccb:	eb 0c                	jmp    282cd9 <task_remove+0x50>
  282ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  282cd2:	eb 05                	jmp    282cd9 <task_remove+0x50>
  282cd4:	b8 00 00 00 00       	mov    $0x0,%eax
		if(tl->tasks[i] == task)
		{
			break;
		}
	}
	tl->running--;
  282cd9:	83 e9 01             	sub    $0x1,%ecx
  282cdc:	89 4a 08             	mov    %ecx,0x8(%edx)
	if(i<tl->now)
  282cdf:	8b 72 0c             	mov    0xc(%edx),%esi
  282ce2:	39 c6                	cmp    %eax,%esi
  282ce4:	7e 06                	jle    282cec <task_remove+0x63>
	{
		tl->now--;
  282ce6:	83 ee 01             	sub    $0x1,%esi
  282ce9:	89 72 0c             	mov    %esi,0xc(%edx)
	}
	if(tl->now >= tl->running)
  282cec:	3b 4a 0c             	cmp    0xc(%edx),%ecx
  282cef:	7f 07                	jg     282cf8 <task_remove+0x6f>
	{
		tl->now = 0;
  282cf1:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	}
	task->flags = 1; //sleep;
  282cf8:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	
	for(;i<tl->running;i++)
  282cff:	39 42 08             	cmp    %eax,0x8(%edx)
  282d02:	7e 1b                	jle    282d1f <task_remove+0x96>
  282d04:	6b 4d f0 66          	imul   $0x66,-0x10(%ebp),%ecx
  282d08:	8d 4c 08 05          	lea    0x5(%eax,%ecx,1),%ecx
  282d0c:	8d 0c 8f             	lea    (%edi,%ecx,4),%ecx
	{
		tl->tasks[i] = tl->tasks[i+1];
  282d0f:	83 c0 01             	add    $0x1,%eax
  282d12:	8b 19                	mov    (%ecx),%ebx
  282d14:	89 59 fc             	mov    %ebx,-0x4(%ecx)
  282d17:	83 c1 04             	add    $0x4,%ecx
	{
		tl->now = 0;
	}
	task->flags = 1; //sleep;
	
	for(;i<tl->running;i++)
  282d1a:	39 42 08             	cmp    %eax,0x8(%edx)
  282d1d:	7f f0                	jg     282d0f <task_remove+0x86>
	{
		tl->tasks[i] = tl->tasks[i+1];
	}
	return;
}
  282d1f:	83 c4 04             	add    $0x4,%esp
  282d22:	5b                   	pop    %ebx
  282d23:	5e                   	pop    %esi
  282d24:	5f                   	pop    %edi
  282d25:	5d                   	pop    %ebp
  282d26:	c3                   	ret    

00282d27 <task_run>:
	}
	return 0;
}

void task_run(struct TASK *task,int level,int priority)
{
  282d27:	55                   	push   %ebp
  282d28:	89 e5                	mov    %esp,%ebp
  282d2a:	56                   	push   %esi
  282d2b:	53                   	push   %ebx
  282d2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282d2f:	8b 75 0c             	mov    0xc(%ebp),%esi
  282d32:	8b 45 10             	mov    0x10(%ebp),%eax
	if(level < 0) level = task->level;
  282d35:	85 f6                	test   %esi,%esi
  282d37:	79 03                	jns    282d3c <task_run+0x15>
  282d39:	8b 73 08             	mov    0x8(%ebx),%esi
	if(priority > 0) task->priority = priority;
  282d3c:	85 c0                	test   %eax,%eax
  282d3e:	7e 03                	jle    282d43 <task_run+0x1c>
  282d40:	89 43 0c             	mov    %eax,0xc(%ebx)
	if(task->flags == 2 && task->level != level)
  282d43:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282d47:	75 14                	jne    282d5d <task_run+0x36>
  282d49:	3b 73 08             	cmp    0x8(%ebx),%esi
  282d4c:	74 1b                	je     282d69 <task_run+0x42>
	{
		task_remove(task); //then task->flags = 1;
  282d4e:	53                   	push   %ebx
  282d4f:	e8 35 ff ff ff       	call   282c89 <task_remove>
	}
	if(task->flags != 2)
  282d54:	83 c4 04             	add    $0x4,%esp
  282d57:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282d5b:	74 0c                	je     282d69 <task_run+0x42>
	{
		task->level = level;
  282d5d:	89 73 08             	mov    %esi,0x8(%ebx)
		task_add(task);
  282d60:	53                   	push   %ebx
  282d61:	e8 ea fe ff ff       	call   282c50 <task_add>
  282d66:	83 c4 04             	add    $0x4,%esp
	}
	taskctl->lv_change = 1;
  282d69:	a1 5c 9a 28 00       	mov    0x289a5c,%eax
  282d6e:	c6 40 04 01          	movb   $0x1,0x4(%eax)
	return;
}
  282d72:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282d75:	5b                   	pop    %ebx
  282d76:	5e                   	pop    %esi
  282d77:	5d                   	pop    %ebp
  282d78:	c3                   	ret    

00282d79 <task_switchsub>:
	}
	return;
}

void task_switchsub(void)
{
  282d79:	55                   	push   %ebp
  282d7a:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		if(taskctl->level[i].running>0) break;
  282d7c:	8b 0d 5c 9a 28 00    	mov    0x289a5c,%ecx
  282d82:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  282d86:	7f 20                	jg     282da8 <task_switchsub+0x2f>
  282d88:	8d 91 a0 01 00 00    	lea    0x1a0(%ecx),%edx
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282d8e:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->level[i].running>0) break;
  282d93:	83 3a 00             	cmpl   $0x0,(%edx)
  282d96:	7f 15                	jg     282dad <task_switchsub+0x34>
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282d98:	83 c0 01             	add    $0x1,%eax
  282d9b:	81 c2 98 01 00 00    	add    $0x198,%edx
  282da1:	83 f8 0a             	cmp    $0xa,%eax
  282da4:	75 ed                	jne    282d93 <task_switchsub+0x1a>
  282da6:	eb 05                	jmp    282dad <task_switchsub+0x34>
  282da8:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->level[i].running>0) break;
	}
	taskctl->now_lv = i;
  282dad:	89 01                	mov    %eax,(%ecx)
	taskctl->lv_change = 0;
  282daf:	a1 5c 9a 28 00       	mov    0x289a5c,%eax
  282db4:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	return;
}
  282db8:	5d                   	pop    %ebp
  282db9:	c3                   	ret    

00282dba <task_init>:
		io_hlt();
	}
}

struct TASK *task_init(struct MEMMAN *memman)
{
  282dba:	55                   	push   %ebp
  282dbb:	89 e5                	mov    %esp,%ebp
  282dbd:	57                   	push   %edi
  282dbe:	56                   	push   %esi
  282dbf:	53                   	push   %ebx
  282dc0:	83 ec 14             	sub    $0x14,%esp
  282dc3:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
  282dc6:	68 58 71 02 00       	push   $0x27158
  282dcb:	57                   	push   %edi
  282dcc:	e8 4c f4 ff ff       	call   28221d <memman_alloc_4k>
  282dd1:	a3 5c 9a 28 00       	mov    %eax,0x289a5c
  282dd6:	83 c4 10             	add    $0x10,%esp
  282dd9:	be 20 00 00 00       	mov    $0x20,%esi
	for(i=0;i<MAX_TASKS;i++)
  282dde:	bb 00 00 00 00       	mov    $0x0,%ebx
	{
		taskctl->tasks0[i].flags = 0;
  282de3:	8b 15 5c 9a 28 00    	mov    0x289a5c,%edx
  282de9:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  282def:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282df2:	c7 81 fc 0f 00 00 00 	movl   $0x0,0xffc(%ecx)
  282df9:	00 00 00 
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
  282dfc:	89 b1 f8 0f 00 00    	mov    %esi,0xff8(%ecx)
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
  282e02:	68 89 00 00 00       	push   $0x89
  282e07:	8d 84 02 24 10 00 00 	lea    0x1024(%edx,%eax,1),%eax
  282e0e:	50                   	push   %eax
  282e0f:	6a 67                	push   $0x67
  282e11:	8d 86 00 00 27 00    	lea    0x270000(%esi),%eax
  282e17:	50                   	push   %eax
  282e18:	e8 25 e5 ff ff       	call   281342 <set_segmdesc>
{
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
	for(i=0;i<MAX_TASKS;i++)
  282e1d:	83 c3 01             	add    $0x1,%ebx
  282e20:	83 c6 08             	add    $0x8,%esi
  282e23:	83 c4 10             	add    $0x10,%esp
  282e26:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
  282e2c:	75 b5                	jne    282de3 <task_init+0x29>
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		taskctl->level[i].running = 0;
  282e2e:	8b 15 5c 9a 28 00    	mov    0x289a5c,%edx
  282e34:	8d 42 08             	lea    0x8(%edx),%eax
  282e37:	81 c2 f8 0f 00 00    	add    $0xff8,%edx
  282e3d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		taskctl->level[i].now = 0;
  282e43:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  282e4a:	05 98 01 00 00       	add    $0x198,%eax
		taskctl->tasks0[i].flags = 0;
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
  282e4f:	39 d0                	cmp    %edx,%eax
  282e51:	75 ea                	jne    282e3d <task_init+0x83>
	{
		taskctl->level[i].running = 0;
		taskctl->level[i].now = 0;
	}
	task = task_alloc();
  282e53:	e8 e0 fc ff ff       	call   282b38 <task_alloc>
  282e58:	89 c6                	mov    %eax,%esi
	task->flags = 2;
  282e5a:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
	task->priority = 2;
  282e61:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	task->level = 0;
  282e68:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	task_add(task);
  282e6f:	83 ec 0c             	sub    $0xc,%esp
  282e72:	50                   	push   %eax
  282e73:	e8 d8 fd ff ff       	call   282c50 <task_add>
	
	task_switchsub();
  282e78:	e8 fc fe ff ff       	call   282d79 <task_switchsub>
	load_tr(task->sel);
  282e7d:	83 c4 04             	add    $0x4,%esp
  282e80:	ff 36                	pushl  (%esi)
  282e82:	e8 89 fc ff ff       	call   282b10 <load_tr>
	task_timer = timer_alloc();
  282e87:	e8 92 f9 ff ff       	call   28281e <timer_alloc>
  282e8c:	a3 60 9a 28 00       	mov    %eax,0x289a60
	timer_settime(task_timer,task->priority);
  282e91:	83 c4 08             	add    $0x8,%esp
  282e94:	ff 76 0c             	pushl  0xc(%esi)
  282e97:	50                   	push   %eax
  282e98:	e8 63 fa ff ff       	call   282900 <timer_settime>

	struct TASK *idle = task_alloc();
  282e9d:	e8 96 fc ff ff       	call   282b38 <task_alloc>
  282ea2:	89 c3                	mov    %eax,%ebx
	idle->tss.esp = memman_alloc(memman,64*1024)+64*1024;
  282ea4:	83 c4 08             	add    $0x8,%esp
  282ea7:	68 00 00 01 00       	push   $0x10000
  282eac:	57                   	push   %edi
  282ead:	e8 2f f0 ff ff       	call   281ee1 <memman_alloc>
  282eb2:	05 00 00 01 00       	add    $0x10000,%eax
  282eb7:	89 43 64             	mov    %eax,0x64(%ebx)
	idle->tss.eip = (int)&task_idle-0x280000;
  282eba:	c7 43 4c 2b 2b 00 00 	movl   $0x2b2b,0x4c(%ebx)
	idle->tss.es = 1*8;
  282ec1:	c7 43 74 08 00 00 00 	movl   $0x8,0x74(%ebx)
	idle->tss.cs = 3*8;
  282ec8:	c7 43 78 18 00 00 00 	movl   $0x18,0x78(%ebx)
	idle->tss.ss = 1*8;
  282ecf:	c7 43 7c 08 00 00 00 	movl   $0x8,0x7c(%ebx)
	idle->tss.ds = 1*8;
  282ed6:	c7 83 80 00 00 00 08 	movl   $0x8,0x80(%ebx)
  282edd:	00 00 00 
	idle->tss.fs = 1*8;
  282ee0:	c7 83 84 00 00 00 08 	movl   $0x8,0x84(%ebx)
  282ee7:	00 00 00 
	idle->tss.gs = 1*8;
  282eea:	c7 83 88 00 00 00 08 	movl   $0x8,0x88(%ebx)
  282ef1:	00 00 00 
	task_run(idle,MAX_TASKLEVELS-1,1);
  282ef4:	83 c4 0c             	add    $0xc,%esp
  282ef7:	6a 01                	push   $0x1
  282ef9:	6a 09                	push   $0x9
  282efb:	53                   	push   %ebx
  282efc:	e8 26 fe ff ff       	call   282d27 <task_run>
	return task;
}
  282f01:	89 f0                	mov    %esi,%eax
  282f03:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282f06:	5b                   	pop    %ebx
  282f07:	5e                   	pop    %esi
  282f08:	5f                   	pop    %edi
  282f09:	5d                   	pop    %ebp
  282f0a:	c3                   	ret    

00282f0b <task_switch>:
	taskctl->lv_change = 1;
	return;
}

void task_switch(void)
{
  282f0b:	55                   	push   %ebp
  282f0c:	89 e5                	mov    %esp,%ebp
  282f0e:	56                   	push   %esi
  282f0f:	53                   	push   %ebx
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282f10:	8b 0d 5c 9a 28 00    	mov    0x289a5c,%ecx
  282f16:	8b 31                	mov    (%ecx),%esi
  282f18:	69 c6 98 01 00 00    	imul   $0x198,%esi,%eax
  282f1e:	01 c8                	add    %ecx,%eax
	struct TASK *new_task,*now_task = tl->tasks[tl->now];
  282f20:	8b 50 0c             	mov    0xc(%eax),%edx
  282f23:	6b de 66             	imul   $0x66,%esi,%ebx
  282f26:	01 d3                	add    %edx,%ebx
  282f28:	8b 5c 99 10          	mov    0x10(%ecx,%ebx,4),%ebx
	tl->now++;
  282f2c:	83 c2 01             	add    $0x1,%edx
  282f2f:	89 50 0c             	mov    %edx,0xc(%eax)
	if(tl->now == tl->running)
  282f32:	3b 50 08             	cmp    0x8(%eax),%edx
  282f35:	75 07                	jne    282f3e <task_switch+0x33>
	{
		tl->now = 0;
  282f37:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
	if(taskctl->lv_change!=0)
  282f3e:	80 79 04 00          	cmpb   $0x0,0x4(%ecx)
  282f42:	75 0c                	jne    282f50 <task_switch+0x45>
	return;
}

void task_switch(void)
{
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282f44:	69 f6 98 01 00 00    	imul   $0x198,%esi,%esi
  282f4a:	8d 44 31 08          	lea    0x8(%ecx,%esi,1),%eax
  282f4e:	eb 14                	jmp    282f64 <task_switch+0x59>
	{
		tl->now = 0;
	}
	if(taskctl->lv_change!=0)
	{
		task_switchsub();
  282f50:	e8 24 fe ff ff       	call   282d79 <task_switchsub>
		tl = &taskctl->level[taskctl->now_lv];
  282f55:	a1 5c 9a 28 00       	mov    0x289a5c,%eax
  282f5a:	69 10 98 01 00 00    	imul   $0x198,(%eax),%edx
  282f60:	8d 44 10 08          	lea    0x8(%eax,%edx,1),%eax
	}
	new_task = tl->tasks[tl->now];
  282f64:	8b 50 04             	mov    0x4(%eax),%edx
  282f67:	8b 74 90 08          	mov    0x8(%eax,%edx,4),%esi
	timer_settime(task_timer,new_task->priority);
  282f6b:	83 ec 08             	sub    $0x8,%esp
  282f6e:	ff 76 0c             	pushl  0xc(%esi)
  282f71:	ff 35 60 9a 28 00    	pushl  0x289a60
  282f77:	e8 84 f9 ff ff       	call   282900 <timer_settime>
	if(new_task != now_task)
  282f7c:	83 c4 10             	add    $0x10,%esp
  282f7f:	39 f3                	cmp    %esi,%ebx
  282f81:	74 0f                	je     282f92 <task_switch+0x87>
	{
		farjmp(0,new_task->sel);
  282f83:	83 ec 08             	sub    $0x8,%esp
  282f86:	ff 36                	pushl  (%esi)
  282f88:	6a 00                	push   $0x0
  282f8a:	e8 87 fb ff ff       	call   282b16 <farjmp>
  282f8f:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  282f92:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282f95:	5b                   	pop    %ebx
  282f96:	5e                   	pop    %esi
  282f97:	5d                   	pop    %ebp
  282f98:	c3                   	ret    

00282f99 <task_sleep>:

void task_sleep(struct TASK *task)
{
  282f99:	55                   	push   %ebp
  282f9a:	89 e5                	mov    %esp,%ebp
  282f9c:	56                   	push   %esi
  282f9d:	53                   	push   %ebx
  282f9e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASK *now_task;
	if(task->flags == 2)
  282fa1:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282fa5:	75 2d                	jne    282fd4 <task_sleep+0x3b>
	{
		now_task = task_now();
  282fa7:	e8 86 fc ff ff       	call   282c32 <task_now>
  282fac:	89 c6                	mov    %eax,%esi
		task_remove(task);
  282fae:	53                   	push   %ebx
  282faf:	e8 d5 fc ff ff       	call   282c89 <task_remove>
		if(task == now_task)
  282fb4:	83 c4 04             	add    $0x4,%esp
  282fb7:	39 f3                	cmp    %esi,%ebx
  282fb9:	75 19                	jne    282fd4 <task_sleep+0x3b>
		{
			task_switchsub();
  282fbb:	e8 b9 fd ff ff       	call   282d79 <task_switchsub>
			now_task = task_now();
  282fc0:	e8 6d fc ff ff       	call   282c32 <task_now>
			farjmp(0,now_task->sel);
  282fc5:	83 ec 08             	sub    $0x8,%esp
  282fc8:	ff 30                	pushl  (%eax)
  282fca:	6a 00                	push   $0x0
  282fcc:	e8 45 fb ff ff       	call   282b16 <farjmp>
  282fd1:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  282fd4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282fd7:	5b                   	pop    %ebx
  282fd8:	5e                   	pop    %esi
  282fd9:	5d                   	pop    %ebp
  282fda:	c3                   	ret    

00282fdb <console_task>:
#include "header.h"
void console_task(struct SHEET *sheet,unsigned int memtotal)
{
  282fdb:	55                   	push   %ebp
  282fdc:	89 e5                	mov    %esp,%ebp
  282fde:	57                   	push   %edi
  282fdf:	56                   	push   %esi
  282fe0:	53                   	push   %ebx
  282fe1:	83 ec 5c             	sub    $0x5c,%esp
  282fe4:	8b 7d 08             	mov    0x8(%ebp),%edi
	char s[50],cmdline[30];
	struct TASK *task = task_now();
  282fe7:	e8 46 fc ff ff       	call   282c32 <task_now>
  282fec:	89 c6                	mov    %eax,%esi
  282fee:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct CONSOLE cons;
	cons.sht = sheet;
  282ff1:	89 7d b4             	mov    %edi,-0x4c(%ebp)
	cons.cur_x = 8;
  282ff4:	c7 45 b8 08 00 00 00 	movl   $0x8,-0x48(%ebp)
	cons.cur_y = 28;
  282ffb:	c7 45 bc 1c 00 00 00 	movl   $0x1c,-0x44(%ebp)
	cons.cur_c = -1;
  283002:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
	//*((int *)0x0fec) = (int)&cons; //for api
	task->cons = &cons;
  283009:	8d 5d b4             	lea    -0x4c(%ebp),%ebx
  28300c:	89 98 94 00 00 00    	mov    %ebx,0x94(%eax)

	int i;
	cons.timer = timer_alloc();
  283012:	e8 07 f8 ff ff       	call   28281e <timer_alloc>
  283017:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	timer_init(cons.timer,&task->fifo,1);
  28301a:	83 c6 10             	add    $0x10,%esi
  28301d:	83 ec 04             	sub    $0x4,%esp
  283020:	6a 01                	push   $0x1
  283022:	56                   	push   %esi
  283023:	50                   	push   %eax
  283024:	e8 c3 f8 ff ff       	call   2828ec <timer_init>
	timer_settime(cons.timer,50);
  283029:	83 c4 08             	add    $0x8,%esp
  28302c:	6a 32                	push   $0x32
  28302e:	ff 75 c4             	pushl  -0x3c(%ebp)
  283031:	e8 ca f8 ff ff       	call   282900 <timer_settime>
	
	int *fat = (int *)memman_alloc_4k(memman, 4*2880);
  283036:	83 c4 08             	add    $0x8,%esp
  283039:	68 00 2d 00 00       	push   $0x2d00
  28303e:	68 00 00 3c 00       	push   $0x3c0000
  283043:	e8 d5 f1 ff ff       	call   28221d <memman_alloc_4k>
  283048:	89 45 a0             	mov    %eax,-0x60(%ebp)
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG+0x000200));
  28304b:	83 c4 08             	add    $0x8,%esp
  28304e:	68 00 02 10 00       	push   $0x100200
  283053:	50                   	push   %eax
  283054:	e8 08 02 00 00       	call   283261 <file_readfat>

	//draw prompt char
	cons_putchar(&cons,'>',1);
  283059:	83 c4 0c             	add    $0xc,%esp
  28305c:	6a 01                	push   $0x1
  28305e:	6a 3e                	push   $0x3e
  283060:	53                   	push   %ebx
  283061:	e8 95 05 00 00       	call   2835fb <cons_putchar>
  283066:	83 c4 10             	add    $0x10,%esp
	for(;;)
	{
		io_cli();
  283069:	e8 34 d9 ff ff       	call   2809a2 <io_cli>
		if(fifo32_status(&task->fifo)==0)
  28306e:	83 ec 0c             	sub    $0xc,%esp
  283071:	56                   	push   %esi
  283072:	e8 cf ea ff ff       	call   281b46 <fifo32_status>
  283077:	83 c4 10             	add    $0x10,%esp
  28307a:	85 c0                	test   %eax,%eax
  28307c:	75 15                	jne    283093 <console_task+0xb8>
		{
			task_sleep(task);
  28307e:	83 ec 0c             	sub    $0xc,%esp
  283081:	ff 75 a4             	pushl  -0x5c(%ebp)
  283084:	e8 10 ff ff ff       	call   282f99 <task_sleep>
			io_sti();
  283089:	e8 16 d9 ff ff       	call   2809a4 <io_sti>
  28308e:	83 c4 10             	add    $0x10,%esp
  283091:	eb d6                	jmp    283069 <console_task+0x8e>
		}
		else
		{
			i=fifo32_get(&task->fifo);
  283093:	83 ec 0c             	sub    $0xc,%esp
  283096:	56                   	push   %esi
  283097:	e8 6f ea ff ff       	call   281b0b <fifo32_get>
  28309c:	89 c3                	mov    %eax,%ebx
			io_sti();
  28309e:	e8 01 d9 ff ff       	call   2809a4 <io_sti>
			if(i<=1) //for cursor
  2830a3:	83 c4 10             	add    $0x10,%esp
  2830a6:	83 fb 01             	cmp    $0x1,%ebx
  2830a9:	7f 57                	jg     283102 <console_task+0x127>
			{
				if(i!=0)
  2830ab:	85 db                	test   %ebx,%ebx
  2830ad:	74 20                	je     2830cf <console_task+0xf4>
				{
					timer_init(cons.timer,&task->fifo,0);
  2830af:	83 ec 04             	sub    $0x4,%esp
  2830b2:	6a 00                	push   $0x0
  2830b4:	56                   	push   %esi
  2830b5:	ff 75 c4             	pushl  -0x3c(%ebp)
  2830b8:	e8 2f f8 ff ff       	call   2828ec <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_FFFFFF;
  2830bd:	83 c4 10             	add    $0x10,%esp
  2830c0:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  2830c4:	78 27                	js     2830ed <console_task+0x112>
  2830c6:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
  2830cd:	eb 1e                	jmp    2830ed <console_task+0x112>
				}
				else
				{
					timer_init(cons.timer,&task->fifo,1);
  2830cf:	83 ec 04             	sub    $0x4,%esp
  2830d2:	6a 01                	push   $0x1
  2830d4:	56                   	push   %esi
  2830d5:	ff 75 c4             	pushl  -0x3c(%ebp)
  2830d8:	e8 0f f8 ff ff       	call   2828ec <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_000000;
  2830dd:	83 c4 10             	add    $0x10,%esp
  2830e0:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  2830e4:	78 07                	js     2830ed <console_task+0x112>
  2830e6:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
				}
				timer_settime(cons.timer,50);
  2830ed:	83 ec 08             	sub    $0x8,%esp
  2830f0:	6a 32                	push   $0x32
  2830f2:	ff 75 c4             	pushl  -0x3c(%ebp)
  2830f5:	e8 06 f8 ff ff       	call   282900 <timer_settime>
  2830fa:	83 c4 10             	add    $0x10,%esp
  2830fd:	e9 13 01 00 00       	jmp    283215 <console_task+0x23a>
							
			}
			else if(i == 2) //get show cursor msg
  283102:	83 fb 02             	cmp    $0x2,%ebx
  283105:	75 11                	jne    283118 <console_task+0x13d>
			{
				cons.cur_c = COL8_FFFFFF;
  283107:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
						cmdline[cons.cur_x/8-2] = i-256;
						cons_putchar(&cons,i-256,1);
					}
				}
			}
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  28310e:	b8 07 00 00 00       	mov    $0x7,%eax
  283113:	e9 04 01 00 00       	jmp    28321c <console_task+0x241>
			}
			else if(i == 2) //get show cursor msg
			{
				cons.cur_c = COL8_FFFFFF;
			}
			else if(i == 3) //get hide cursor msg
  283118:	83 fb 03             	cmp    $0x3,%ebx
  28311b:	75 2a                	jne    283147 <console_task+0x16c>
			{
				cons.cur_c = -1;
  28311d:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
				boxfill8(sheet->buf,sheet->bxsize,COL8_000000,cons.cur_x,28,cons.cur_x+7,43);
  283124:	8b 45 b8             	mov    -0x48(%ebp),%eax
  283127:	83 ec 04             	sub    $0x4,%esp
  28312a:	6a 2b                	push   $0x2b
  28312c:	8d 50 07             	lea    0x7(%eax),%edx
  28312f:	52                   	push   %edx
  283130:	6a 1c                	push   $0x1c
  283132:	50                   	push   %eax
  283133:	6a 00                	push   $0x0
  283135:	ff 77 04             	pushl  0x4(%edi)
  283138:	ff 37                	pushl  (%edi)
  28313a:	e8 52 da ff ff       	call   280b91 <boxfill8>
  28313f:	83 c4 20             	add    $0x20,%esp
  283142:	e9 ce 00 00 00       	jmp    283215 <console_task+0x23a>
			}
			else if(256<=i && i<=511)
  283147:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
  28314d:	3d ff 00 00 00       	cmp    $0xff,%eax
  283152:	0f 87 bd 00 00 00    	ja     283215 <console_task+0x23a>
			{
				if(i == 8+256) //back key
  283158:	81 fb 08 01 00 00    	cmp    $0x108,%ebx
  28315e:	75 26                	jne    283186 <console_task+0x1ab>
				{
					if(cons.cur_x > 16)
  283160:	83 7d b8 10          	cmpl   $0x10,-0x48(%ebp)
  283164:	0f 8e ab 00 00 00    	jle    283215 <console_task+0x23a>
					{
						cons_putchar(&cons,' ',0);
  28316a:	83 ec 04             	sub    $0x4,%esp
  28316d:	6a 00                	push   $0x0
  28316f:	6a 20                	push   $0x20
  283171:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  283174:	50                   	push   %eax
  283175:	e8 81 04 00 00       	call   2835fb <cons_putchar>
						cons.cur_x -= 8;
  28317a:	83 6d b8 08          	subl   $0x8,-0x48(%ebp)
  28317e:	83 c4 10             	add    $0x10,%esp
  283181:	e9 8f 00 00 00       	jmp    283215 <console_task+0x23a>
					}
				}
				else if(i == 10+256) //return key
  283186:	81 fb 0a 01 00 00    	cmp    $0x10a,%ebx
  28318c:	75 56                	jne    2831e4 <console_task+0x209>
				{
					cons_putchar(&cons,' ',0);
  28318e:	83 ec 04             	sub    $0x4,%esp
  283191:	6a 00                	push   $0x0
  283193:	6a 20                	push   $0x20
  283195:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  283198:	50                   	push   %eax
  283199:	e8 5d 04 00 00       	call   2835fb <cons_putchar>
					cmdline[cons.cur_x/8-2] = 0;
  28319e:	8b 55 b8             	mov    -0x48(%ebp),%edx
  2831a1:	8d 42 07             	lea    0x7(%edx),%eax
  2831a4:	85 d2                	test   %edx,%edx
  2831a6:	0f 49 c2             	cmovns %edx,%eax
  2831a9:	c1 f8 03             	sar    $0x3,%eax
  2831ac:	c6 44 05 c8 00       	movb   $0x0,-0x38(%ebp,%eax,1)
					cons_newline(&cons);
  2831b1:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2831b4:	89 04 24             	mov    %eax,(%esp)
  2831b7:	e8 74 03 00 00       	call   283530 <cons_newline>
					cons_runcmd(cmdline,&cons,fat,memtotal);
  2831bc:	ff 75 0c             	pushl  0xc(%ebp)
  2831bf:	ff 75 a0             	pushl  -0x60(%ebp)
  2831c2:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2831c5:	50                   	push   %eax
  2831c6:	8d 45 ca             	lea    -0x36(%ebp),%eax
  2831c9:	50                   	push   %eax
  2831ca:	e8 41 0a 00 00       	call   283c10 <cons_runcmd>
					cons_putchar(&cons,'>',1);
  2831cf:	83 c4 1c             	add    $0x1c,%esp
  2831d2:	6a 01                	push   $0x1
  2831d4:	6a 3e                	push   $0x3e
  2831d6:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2831d9:	50                   	push   %eax
  2831da:	e8 1c 04 00 00       	call   2835fb <cons_putchar>
  2831df:	83 c4 10             	add    $0x10,%esp
  2831e2:	eb 31                	jmp    283215 <console_task+0x23a>
				}
				else
				{
					if(cons.cur_x<240)
  2831e4:	8b 45 b8             	mov    -0x48(%ebp),%eax
  2831e7:	3d ef 00 00 00       	cmp    $0xef,%eax
  2831ec:	7f 27                	jg     283215 <console_task+0x23a>
					{
						s[0] = i-256;
						s[1] = 0;
						cmdline[cons.cur_x/8-2] = i-256;
  2831ee:	8d 50 07             	lea    0x7(%eax),%edx
  2831f1:	85 c0                	test   %eax,%eax
  2831f3:	0f 48 c2             	cmovs  %edx,%eax
  2831f6:	c1 f8 03             	sar    $0x3,%eax
  2831f9:	88 5c 05 c8          	mov    %bl,-0x38(%ebp,%eax,1)
						cons_putchar(&cons,i-256,1);
  2831fd:	83 ec 04             	sub    $0x4,%esp
  283200:	6a 01                	push   $0x1
  283202:	81 eb 00 01 00 00    	sub    $0x100,%ebx
  283208:	53                   	push   %ebx
  283209:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  28320c:	50                   	push   %eax
  28320d:	e8 e9 03 00 00       	call   2835fb <cons_putchar>
  283212:	83 c4 10             	add    $0x10,%esp
					}
				}
			}
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  283215:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283218:	85 c0                	test   %eax,%eax
  28321a:	78 24                	js     283240 <console_task+0x265>
  28321c:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  28321f:	8b 55 b8             	mov    -0x48(%ebp),%edx
  283222:	83 ec 04             	sub    $0x4,%esp
  283225:	8d 59 0f             	lea    0xf(%ecx),%ebx
  283228:	53                   	push   %ebx
  283229:	8d 5a 07             	lea    0x7(%edx),%ebx
  28322c:	53                   	push   %ebx
  28322d:	51                   	push   %ecx
  28322e:	52                   	push   %edx
  28322f:	0f b6 c0             	movzbl %al,%eax
  283232:	50                   	push   %eax
  283233:	ff 77 04             	pushl  0x4(%edi)
  283236:	ff 37                	pushl  (%edi)
  283238:	e8 54 d9 ff ff       	call   280b91 <boxfill8>
  28323d:	83 c4 20             	add    $0x20,%esp
			sheet_refresh(sheet,cons.cur_x,cons.cur_y,cons.cur_x+8,cons.cur_y+16);
  283240:	8b 55 bc             	mov    -0x44(%ebp),%edx
  283243:	8b 45 b8             	mov    -0x48(%ebp),%eax
  283246:	83 ec 0c             	sub    $0xc,%esp
  283249:	8d 4a 10             	lea    0x10(%edx),%ecx
  28324c:	51                   	push   %ecx
  28324d:	8d 48 08             	lea    0x8(%eax),%ecx
  283250:	51                   	push   %ecx
  283251:	52                   	push   %edx
  283252:	50                   	push   %eax
  283253:	57                   	push   %edi
  283254:	e8 25 f4 ff ff       	call   28267e <sheet_refresh>
  283259:	83 c4 20             	add    $0x20,%esp
  28325c:	e9 08 fe ff ff       	jmp    283069 <console_task+0x8e>

00283261 <file_readfat>:
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
  283261:	55                   	push   %ebp
  283262:	89 e5                	mov    %esp,%ebp
  283264:	53                   	push   %ebx
  283265:	83 ec 10             	sub    $0x10,%esp
	int i,j=0;
  283268:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(i=0;i<2880;i+=2)
  28326f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  283276:	e9 87 00 00 00       	jmp    283302 <file_readfat+0xa1>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
  28327b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28327e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  283285:	8b 45 08             	mov    0x8(%ebp),%eax
  283288:	01 d0                	add    %edx,%eax
  28328a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28328d:	8b 55 0c             	mov    0xc(%ebp),%edx
  283290:	01 ca                	add    %ecx,%edx
  283292:	0f b6 12             	movzbl (%edx),%edx
  283295:	0f b6 d2             	movzbl %dl,%edx
  283298:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28329b:	8d 59 01             	lea    0x1(%ecx),%ebx
  28329e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  2832a1:	01 d9                	add    %ebx,%ecx
  2832a3:	0f b6 09             	movzbl (%ecx),%ecx
  2832a6:	0f b6 c9             	movzbl %cl,%ecx
  2832a9:	c1 e1 08             	shl    $0x8,%ecx
  2832ac:	09 ca                	or     %ecx,%edx
  2832ae:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  2832b4:	89 10                	mov    %edx,(%eax)
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
  2832b6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2832b9:	83 c0 01             	add    $0x1,%eax
  2832bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  2832c3:	8b 45 08             	mov    0x8(%ebp),%eax
  2832c6:	01 d0                	add    %edx,%eax
  2832c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  2832cb:	8d 4a 01             	lea    0x1(%edx),%ecx
  2832ce:	8b 55 0c             	mov    0xc(%ebp),%edx
  2832d1:	01 ca                	add    %ecx,%edx
  2832d3:	0f b6 12             	movzbl (%edx),%edx
  2832d6:	c0 ea 04             	shr    $0x4,%dl
  2832d9:	0f b6 d2             	movzbl %dl,%edx
  2832dc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  2832df:	8d 59 02             	lea    0x2(%ecx),%ebx
  2832e2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  2832e5:	01 d9                	add    %ebx,%ecx
  2832e7:	0f b6 09             	movzbl (%ecx),%ecx
  2832ea:	0f b6 c9             	movzbl %cl,%ecx
  2832ed:	c1 e1 04             	shl    $0x4,%ecx
  2832f0:	09 ca                	or     %ecx,%edx
  2832f2:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  2832f8:	89 10                	mov    %edx,(%eax)
		j+=3;
  2832fa:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
	int i,j=0;
	for(i=0;i<2880;i+=2)
  2832fe:	83 45 f8 02          	addl   $0x2,-0x8(%ebp)
  283302:	81 7d f8 3f 0b 00 00 	cmpl   $0xb3f,-0x8(%ebp)
  283309:	0f 8e 6c ff ff ff    	jle    28327b <file_readfat+0x1a>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
		j+=3;
	}
	return;
  28330f:	90                   	nop
}
  283310:	83 c4 10             	add    $0x10,%esp
  283313:	5b                   	pop    %ebx
  283314:	5d                   	pop    %ebp
  283315:	c3                   	ret    

00283316 <file_loadfile>:

void file_loadfile(int clustno,int size,char *buf,int *fat,char *img)
{
  283316:	55                   	push   %ebp
  283317:	89 e5                	mov    %esp,%ebp
  283319:	83 ec 10             	sub    $0x10,%esp
	int i;
	for(;;)
	{
		if(size <= 512)
  28331c:	81 7d 0c 00 02 00 00 	cmpl   $0x200,0xc(%ebp)
  283323:	7f 38                	jg     28335d <file_loadfile+0x47>
		{
			for(i=0;i<size;i++)
  283325:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  28332c:	eb 25                	jmp    283353 <file_loadfile+0x3d>
			{
				buf[i] = img[clustno*512 + i];
  28332e:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283331:	8b 45 10             	mov    0x10(%ebp),%eax
  283334:	01 c2                	add    %eax,%edx
  283336:	8b 45 08             	mov    0x8(%ebp),%eax
  283339:	c1 e0 09             	shl    $0x9,%eax
  28333c:	89 c1                	mov    %eax,%ecx
  28333e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283341:	01 c8                	add    %ecx,%eax
  283343:	89 c1                	mov    %eax,%ecx
  283345:	8b 45 18             	mov    0x18(%ebp),%eax
  283348:	01 c8                	add    %ecx,%eax
  28334a:	0f b6 00             	movzbl (%eax),%eax
  28334d:	88 02                	mov    %al,(%edx)
	int i;
	for(;;)
	{
		if(size <= 512)
		{
			for(i=0;i<size;i++)
  28334f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  283353:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283356:	3b 45 0c             	cmp    0xc(%ebp),%eax
  283359:	7c d3                	jl     28332e <file_loadfile+0x18>
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
  28335b:	eb 5e                	jmp    2833bb <file_loadfile+0xa5>
		}
		for(i=0;i<512;i++)
  28335d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  283364:	eb 25                	jmp    28338b <file_loadfile+0x75>
		{
			buf[i] = img[clustno*512 + i];
  283366:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283369:	8b 45 10             	mov    0x10(%ebp),%eax
  28336c:	01 c2                	add    %eax,%edx
  28336e:	8b 45 08             	mov    0x8(%ebp),%eax
  283371:	c1 e0 09             	shl    $0x9,%eax
  283374:	89 c1                	mov    %eax,%ecx
  283376:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283379:	01 c8                	add    %ecx,%eax
  28337b:	89 c1                	mov    %eax,%ecx
  28337d:	8b 45 18             	mov    0x18(%ebp),%eax
  283380:	01 c8                	add    %ecx,%eax
  283382:	0f b6 00             	movzbl (%eax),%eax
  283385:	88 02                	mov    %al,(%edx)
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
		}
		for(i=0;i<512;i++)
  283387:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  28338b:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%ebp)
  283392:	7e d2                	jle    283366 <file_loadfile+0x50>
		{
			buf[i] = img[clustno*512 + i];
		}
		size -= 512;
  283394:	81 6d 0c 00 02 00 00 	subl   $0x200,0xc(%ebp)
		buf += 512;
  28339b:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
		clustno = fat[clustno];
  2833a2:	8b 45 08             	mov    0x8(%ebp),%eax
  2833a5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  2833ac:	8b 45 14             	mov    0x14(%ebp),%eax
  2833af:	01 d0                	add    %edx,%eax
  2833b1:	8b 00                	mov    (%eax),%eax
  2833b3:	89 45 08             	mov    %eax,0x8(%ebp)
	}
  2833b6:	e9 61 ff ff ff       	jmp    28331c <file_loadfile+0x6>
	return;
}
  2833bb:	c9                   	leave  
  2833bc:	c3                   	ret    

002833bd <file_search>:

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
  2833bd:	55                   	push   %ebp
  2833be:	89 e5                	mov    %esp,%ebp
  2833c0:	83 ec 20             	sub    $0x20,%esp
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  2833c3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  2833ca:	eb 0f                	jmp    2833db <file_search+0x1e>
	{
		s[j] = ' ';
  2833cc:	8d 55 ec             	lea    -0x14(%ebp),%edx
  2833cf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2833d2:	01 d0                	add    %edx,%eax
  2833d4:	c6 00 20             	movb   $0x20,(%eax)

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  2833d7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  2833db:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  2833df:	7e eb                	jle    2833cc <file_search+0xf>
	{
		s[j] = ' ';
	}
	j=0;
  2833e1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;name[i]!=0;i++)
  2833e8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  2833ef:	e9 83 00 00 00       	jmp    283477 <file_search+0xba>
	{
		if(j>=11) return 0; //length of name is bigger than 11
  2833f4:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  2833f8:	7e 0a                	jle    283404 <file_search+0x47>
  2833fa:	b8 00 00 00 00       	mov    $0x0,%eax
  2833ff:	e9 2a 01 00 00       	jmp    28352e <file_search+0x171>
		if(name[i] == '.' && j <= 8)
  283404:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283407:	8b 45 08             	mov    0x8(%ebp),%eax
  28340a:	01 d0                	add    %edx,%eax
  28340c:	0f b6 00             	movzbl (%eax),%eax
  28340f:	3c 2e                	cmp    $0x2e,%al
  283411:	75 0f                	jne    283422 <file_search+0x65>
  283413:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
  283417:	7f 09                	jg     283422 <file_search+0x65>
			j = 8;
  283419:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)
  283420:	eb 51                	jmp    283473 <file_search+0xb6>
		else
		{
			s[j] = name[i];
  283422:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283425:	8b 45 08             	mov    0x8(%ebp),%eax
  283428:	01 d0                	add    %edx,%eax
  28342a:	0f b6 00             	movzbl (%eax),%eax
  28342d:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  283430:	8b 55 f8             	mov    -0x8(%ebp),%edx
  283433:	01 ca                	add    %ecx,%edx
  283435:	88 02                	mov    %al,(%edx)
			if('a' <= s[j] && s[j] <= 'z')
  283437:	8d 55 ec             	lea    -0x14(%ebp),%edx
  28343a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28343d:	01 d0                	add    %edx,%eax
  28343f:	0f b6 00             	movzbl (%eax),%eax
  283442:	3c 60                	cmp    $0x60,%al
  283444:	7e 29                	jle    28346f <file_search+0xb2>
  283446:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283449:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28344c:	01 d0                	add    %edx,%eax
  28344e:	0f b6 00             	movzbl (%eax),%eax
  283451:	3c 7a                	cmp    $0x7a,%al
  283453:	7f 1a                	jg     28346f <file_search+0xb2>
				s[j] -= 0x20;
  283455:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283458:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28345b:	01 d0                	add    %edx,%eax
  28345d:	0f b6 00             	movzbl (%eax),%eax
  283460:	83 e8 20             	sub    $0x20,%eax
  283463:	89 c1                	mov    %eax,%ecx
  283465:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283468:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28346b:	01 d0                	add    %edx,%eax
  28346d:	88 08                	mov    %cl,(%eax)
			j++;
  28346f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(j=0;j<11;j++)
	{
		s[j] = ' ';
	}
	j=0;
	for(i=0;name[i]!=0;i++)
  283473:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  283477:	8b 55 fc             	mov    -0x4(%ebp),%edx
  28347a:	8b 45 08             	mov    0x8(%ebp),%eax
  28347d:	01 d0                	add    %edx,%eax
  28347f:	0f b6 00             	movzbl (%eax),%eax
  283482:	84 c0                	test   %al,%al
  283484:	0f 85 6a ff ff ff    	jne    2833f4 <file_search+0x37>
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  28348a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  283491:	e9 84 00 00 00       	jmp    28351a <file_search+0x15d>
	{
		if(finfo[i].name[0] == 0) break;
  283496:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283499:	c1 e0 06             	shl    $0x6,%eax
  28349c:	89 c2                	mov    %eax,%edx
  28349e:	8b 45 0c             	mov    0xc(%ebp),%eax
  2834a1:	01 d0                	add    %edx,%eax
  2834a3:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  2834a7:	84 c0                	test   %al,%al
  2834a9:	74 7d                	je     283528 <file_search+0x16b>
		if((finfo[i].type & 0x18) == 0)
  2834ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2834ae:	c1 e0 06             	shl    $0x6,%eax
  2834b1:	89 c2                	mov    %eax,%edx
  2834b3:	8b 45 0c             	mov    0xc(%ebp),%eax
  2834b6:	01 d0                	add    %edx,%eax
  2834b8:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  2834bc:	0f b6 c0             	movzbl %al,%eax
  2834bf:	83 e0 18             	and    $0x18,%eax
  2834c2:	85 c0                	test   %eax,%eax
  2834c4:	75 50                	jne    283516 <file_search+0x159>
		{
			for(j=0;j<11;j++)
  2834c6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  2834cd:	eb 31                	jmp    283500 <file_search+0x143>
			{
				if(finfo[i].name[j] != s[j])
  2834cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2834d2:	c1 e0 06             	shl    $0x6,%eax
  2834d5:	89 c2                	mov    %eax,%edx
  2834d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  2834da:	01 c2                	add    %eax,%edx
  2834dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2834df:	01 d0                	add    %edx,%eax
  2834e1:	83 c0 20             	add    $0x20,%eax
  2834e4:	0f b6 00             	movzbl (%eax),%eax
  2834e7:	0f b6 d0             	movzbl %al,%edx
  2834ea:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  2834ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2834f0:	01 c8                	add    %ecx,%eax
  2834f2:	0f b6 00             	movzbl (%eax),%eax
  2834f5:	0f be c0             	movsbl %al,%eax
  2834f8:	39 c2                	cmp    %eax,%edx
  2834fa:	75 19                	jne    283515 <file_search+0x158>
	for(i=0;i<max;)
	{
		if(finfo[i].name[0] == 0) break;
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
  2834fc:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  283500:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  283504:	7e c9                	jle    2834cf <file_search+0x112>
			{
				if(finfo[i].name[j] != s[j])
					goto next;
			}
			return finfo+i;
  283506:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283509:	c1 e0 06             	shl    $0x6,%eax
  28350c:	89 c2                	mov    %eax,%edx
  28350e:	8b 45 0c             	mov    0xc(%ebp),%eax
  283511:	01 d0                	add    %edx,%eax
  283513:	eb 19                	jmp    28352e <file_search+0x171>
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
			{
				if(finfo[i].name[j] != s[j])
					goto next;
  283515:	90                   	nop
			}
			return finfo+i;
		}
next:
		i++;
  283516:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  28351a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  28351d:	3b 45 10             	cmp    0x10(%ebp),%eax
  283520:	0f 8c 70 ff ff ff    	jl     283496 <file_search+0xd9>
  283526:	eb 01                	jmp    283529 <file_search+0x16c>
	{
		if(finfo[i].name[0] == 0) break;
  283528:	90                   	nop
			return finfo+i;
		}
next:
		i++;
	}
	return 0;
  283529:	b8 00 00 00 00       	mov    $0x0,%eax
}
  28352e:	c9                   	leave  
  28352f:	c3                   	ret    

00283530 <cons_newline>:
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  283530:	55                   	push   %ebp
  283531:	89 e5                	mov    %esp,%ebp
  283533:	57                   	push   %edi
  283534:	56                   	push   %esi
  283535:	53                   	push   %ebx
  283536:	83 ec 1c             	sub    $0x1c,%esp
	int x,y;
	struct SHEET *sheet = cons->sht;
	if(cons->cur_y<28+112)
  283539:	8b 45 08             	mov    0x8(%ebp),%eax
  28353c:	8b 40 08             	mov    0x8(%eax),%eax
  28353f:	3d 8b 00 00 00       	cmp    $0x8b,%eax
  283544:	7e 0c                	jle    283552 <cons_newline+0x22>
}

void cons_newline(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
  283546:	8b 45 08             	mov    0x8(%ebp),%eax
  283549:	8b 18                	mov    (%eax),%ebx
  28354b:	bf 1c 00 00 00       	mov    $0x1c,%edi
  283550:	eb 43                	jmp    283595 <cons_newline+0x65>
	if(cons->cur_y<28+112)
	{
		cons->cur_y += 16;
  283552:	83 c0 10             	add    $0x10,%eax
  283555:	8b 7d 08             	mov    0x8(%ebp),%edi
  283558:	89 47 08             	mov    %eax,0x8(%edi)
  28355b:	e9 89 00 00 00       	jmp    2835e9 <cons_newline+0xb9>
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  283560:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  283563:	8b 43 04             	mov    0x4(%ebx),%eax
  283566:	8b 75 e0             	mov    -0x20(%ebp),%esi
  283569:	0f af f0             	imul   %eax,%esi
  28356c:	89 d1                	mov    %edx,%ecx
  28356e:	03 0b                	add    (%ebx),%ecx
  283570:	0f b6 34 31          	movzbl (%ecx,%esi,1),%esi
  283574:	0f af c7             	imul   %edi,%eax
  283577:	89 f3                	mov    %esi,%ebx
  283579:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
		cons->cur_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
  28357c:	83 c2 01             	add    $0x1,%edx
  28357f:	81 fa f8 00 00 00    	cmp    $0xf8,%edx
  283585:	75 d9                	jne    283560 <cons_newline+0x30>
  283587:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	{
		cons->cur_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
  28358a:	83 c7 01             	add    $0x1,%edi
  28358d:	81 ff 8c 00 00 00    	cmp    $0x8c,%edi
  283593:	74 33                	je     2835c8 <cons_newline+0x98>
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  283595:	ba 08 00 00 00       	mov    $0x8,%edx
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  28359a:	8d 47 10             	lea    0x10(%edi),%eax
  28359d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  2835a0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  2835a3:	eb bb                	jmp    283560 <cons_newline+0x30>
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  2835a5:	89 fa                	mov    %edi,%edx
  2835a7:	0f af 53 04          	imul   0x4(%ebx),%edx
  2835ab:	89 c1                	mov    %eax,%ecx
  2835ad:	03 0b                	add    (%ebx),%ecx
  2835af:	c6 04 11 00          	movb   $0x0,(%ecx,%edx,1)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
  2835b3:	83 c0 01             	add    $0x1,%eax
  2835b6:	3d f8 00 00 00       	cmp    $0xf8,%eax
  2835bb:	75 e8                	jne    2835a5 <cons_newline+0x75>
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
  2835bd:	83 c7 01             	add    $0x1,%edi
  2835c0:	81 ff 9c 00 00 00    	cmp    $0x9c,%edi
  2835c6:	74 07                	je     2835cf <cons_newline+0x9f>
}

void cons_newline(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
  2835c8:	b8 08 00 00 00       	mov    $0x8,%eax
  2835cd:	eb d6                	jmp    2835a5 <cons_newline+0x75>
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		sheet_refresh(sheet,8,28,8+240,28+128);
  2835cf:	83 ec 0c             	sub    $0xc,%esp
  2835d2:	68 9c 00 00 00       	push   $0x9c
  2835d7:	68 f8 00 00 00       	push   $0xf8
  2835dc:	6a 1c                	push   $0x1c
  2835de:	6a 08                	push   $0x8
  2835e0:	53                   	push   %ebx
  2835e1:	e8 98 f0 ff ff       	call   28267e <sheet_refresh>
  2835e6:	83 c4 20             	add    $0x20,%esp
	}
	cons->cur_x = 8;
  2835e9:	8b 45 08             	mov    0x8(%ebp),%eax
  2835ec:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
}
  2835f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2835f6:	5b                   	pop    %ebx
  2835f7:	5e                   	pop    %esi
  2835f8:	5f                   	pop    %edi
  2835f9:	5d                   	pop    %ebp
  2835fa:	c3                   	ret    

002835fb <cons_putchar>:
#include "header.h"
void cons_putchar(struct CONSOLE *cons,int chr,char move)
{
  2835fb:	55                   	push   %ebp
  2835fc:	89 e5                	mov    %esp,%ebp
  2835fe:	56                   	push   %esi
  2835ff:	53                   	push   %ebx
  283600:	83 ec 10             	sub    $0x10,%esp
  283603:	8b 5d 08             	mov    0x8(%ebp),%ebx
  283606:	8b 45 0c             	mov    0xc(%ebp),%eax
  283609:	8b 75 10             	mov    0x10(%ebp),%esi
	char s[2];
	s[0] = chr;
  28360c:	88 45 f6             	mov    %al,-0xa(%ebp)
	s[1] = 0;
  28360f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	if(s[0] == 0x09)
  283613:	3c 09                	cmp    $0x9,%al
  283615:	75 46                	jne    28365d <cons_putchar+0x62>
	{
		//tab
		for(;;)
		{
			putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000," ",1);
  283617:	83 ec 04             	sub    $0x4,%esp
  28361a:	6a 01                	push   $0x1
  28361c:	68 c3 4a 28 00       	push   $0x284ac3
  283621:	6a 00                	push   $0x0
  283623:	6a 07                	push   $0x7
  283625:	ff 73 08             	pushl  0x8(%ebx)
  283628:	ff 73 04             	pushl  0x4(%ebx)
  28362b:	ff 33                	pushl  (%ebx)
  28362d:	e8 be d9 ff ff       	call   280ff0 <putfonts8_asc_sht>
			cons->cur_x += 8;
  283632:	8b 43 04             	mov    0x4(%ebx),%eax
  283635:	83 c0 08             	add    $0x8,%eax
  283638:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240) {
  28363b:	83 c4 20             	add    $0x20,%esp
  28363e:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283643:	75 0c                	jne    283651 <cons_putchar+0x56>
				cons_newline(cons);
  283645:	83 ec 0c             	sub    $0xc,%esp
  283648:	53                   	push   %ebx
  283649:	e8 e2 fe ff ff       	call   283530 <cons_newline>
  28364e:	83 c4 10             	add    $0x10,%esp
			}
			if(((cons->cur_x - 8) & 0x1f) == 0)
  283651:	8b 43 04             	mov    0x4(%ebx),%eax
  283654:	83 e8 08             	sub    $0x8,%eax
  283657:	a8 1f                	test   $0x1f,%al
  283659:	75 bc                	jne    283617 <cons_putchar+0x1c>
  28365b:	eb 55                	jmp    2836b2 <cons_putchar+0xb7>
				break;
		}
	}
	else if(s[0] == 0x0a) 
  28365d:	3c 0a                	cmp    $0xa,%al
  28365f:	75 0e                	jne    28366f <cons_putchar+0x74>
		cons_newline(cons);
  283661:	83 ec 0c             	sub    $0xc,%esp
  283664:	53                   	push   %ebx
  283665:	e8 c6 fe ff ff       	call   283530 <cons_newline>
  28366a:	83 c4 10             	add    $0x10,%esp
  28366d:	eb 43                	jmp    2836b2 <cons_putchar+0xb7>
	else if(s[0] == 0x0d) 
  28366f:	3c 0d                	cmp    $0xd,%al
  283671:	74 3f                	je     2836b2 <cons_putchar+0xb7>
		;//todo
	else
	{
		putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000,s,1);
  283673:	83 ec 04             	sub    $0x4,%esp
  283676:	6a 01                	push   $0x1
  283678:	8d 45 f6             	lea    -0xa(%ebp),%eax
  28367b:	50                   	push   %eax
  28367c:	6a 00                	push   $0x0
  28367e:	6a 07                	push   $0x7
  283680:	ff 73 08             	pushl  0x8(%ebx)
  283683:	ff 73 04             	pushl  0x4(%ebx)
  283686:	ff 33                	pushl  (%ebx)
  283688:	e8 63 d9 ff ff       	call   280ff0 <putfonts8_asc_sht>
		if(move != 0)
  28368d:	83 c4 20             	add    $0x20,%esp
  283690:	89 f0                	mov    %esi,%eax
  283692:	84 c0                	test   %al,%al
  283694:	74 1c                	je     2836b2 <cons_putchar+0xb7>
		{
			cons->cur_x += 8;
  283696:	8b 43 04             	mov    0x4(%ebx),%eax
  283699:	83 c0 08             	add    $0x8,%eax
  28369c:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240)
  28369f:	3d f8 00 00 00       	cmp    $0xf8,%eax
  2836a4:	75 0c                	jne    2836b2 <cons_putchar+0xb7>
				cons_newline(cons);
  2836a6:	83 ec 0c             	sub    $0xc,%esp
  2836a9:	53                   	push   %ebx
  2836aa:	e8 81 fe ff ff       	call   283530 <cons_newline>
  2836af:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  2836b2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2836b5:	5b                   	pop    %ebx
  2836b6:	5e                   	pop    %esi
  2836b7:	5d                   	pop    %ebp
  2836b8:	c3                   	ret    

002836b9 <cmd_mem>:
	}
	return;
}

void cmd_mem(struct CONSOLE *cons,unsigned int memtotal)
{
  2836b9:	55                   	push   %ebp
  2836ba:	89 e5                	mov    %esp,%ebp
  2836bc:	56                   	push   %esi
  2836bd:	53                   	push   %ebx
  2836be:	83 ec 24             	sub    $0x24,%esp
  2836c1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	char s[30];
	sprintf(s,"total %dMB",memtotal/(1024*1024));
  2836c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  2836c7:	c1 e8 14             	shr    $0x14,%eax
  2836ca:	50                   	push   %eax
  2836cb:	68 60 4a 28 00       	push   $0x284a60
  2836d0:	8d 75 da             	lea    -0x26(%ebp),%esi
  2836d3:	56                   	push   %esi
  2836d4:	e8 d4 e1 ff ff       	call   2818ad <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  2836d9:	83 c4 0c             	add    $0xc,%esp
  2836dc:	6a 1e                	push   $0x1e
  2836de:	56                   	push   %esi
  2836df:	6a 00                	push   $0x0
  2836e1:	6a 07                	push   $0x7
  2836e3:	ff 73 08             	pushl  0x8(%ebx)
  2836e6:	6a 08                	push   $0x8
  2836e8:	ff 33                	pushl  (%ebx)
  2836ea:	e8 01 d9 ff ff       	call   280ff0 <putfonts8_asc_sht>
	cons_newline(cons);
  2836ef:	83 c4 14             	add    $0x14,%esp
  2836f2:	53                   	push   %ebx
  2836f3:	e8 38 fe ff ff       	call   283530 <cons_newline>
	sprintf(s,"free %dKB",memman_total(memman)/1024);
  2836f8:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
  2836ff:	e8 a4 e7 ff ff       	call   281ea8 <memman_total>
  283704:	83 c4 0c             	add    $0xc,%esp
  283707:	c1 e8 0a             	shr    $0xa,%eax
  28370a:	50                   	push   %eax
  28370b:	68 6b 4a 28 00       	push   $0x284a6b
  283710:	56                   	push   %esi
  283711:	e8 97 e1 ff ff       	call   2818ad <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283716:	83 c4 0c             	add    $0xc,%esp
  283719:	6a 1e                	push   $0x1e
  28371b:	56                   	push   %esi
  28371c:	6a 00                	push   $0x0
  28371e:	6a 07                	push   $0x7
  283720:	ff 73 08             	pushl  0x8(%ebx)
  283723:	6a 08                	push   $0x8
  283725:	ff 33                	pushl  (%ebx)
  283727:	e8 c4 d8 ff ff       	call   280ff0 <putfonts8_asc_sht>
	cons_newline(cons);
  28372c:	83 c4 14             	add    $0x14,%esp
  28372f:	53                   	push   %ebx
  283730:	e8 fb fd ff ff       	call   283530 <cons_newline>
	cons_newline(cons);
  283735:	89 1c 24             	mov    %ebx,(%esp)
  283738:	e8 f3 fd ff ff       	call   283530 <cons_newline>
	return;
  28373d:	83 c4 10             	add    $0x10,%esp
}
  283740:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283743:	5b                   	pop    %ebx
  283744:	5e                   	pop    %esi
  283745:	5d                   	pop    %ebp
  283746:	c3                   	ret    

00283747 <cmd_cls>:

void cmd_cls(struct CONSOLE *cons)
{
  283747:	55                   	push   %ebp
  283748:	89 e5                	mov    %esp,%ebp
  28374a:	57                   	push   %edi
  28374b:	56                   	push   %esi
  28374c:	53                   	push   %ebx
  28374d:	83 ec 0c             	sub    $0xc,%esp
  283750:	8b 7d 08             	mov    0x8(%ebp),%edi
	int x,y;
	struct SHEET *sheet = cons->sht;
  283753:	8b 17                	mov    (%edi),%edx
	for(y=28;y<28+128;y++)
  283755:	be 1c 00 00 00       	mov    $0x1c,%esi
  28375a:	eb 23                	jmp    28377f <cmd_cls+0x38>
	{
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  28375c:	89 f1                	mov    %esi,%ecx
  28375e:	0f af 4a 04          	imul   0x4(%edx),%ecx
  283762:	89 c3                	mov    %eax,%ebx
  283764:	03 1a                	add    (%edx),%ebx
  283766:	c6 04 0b 00          	movb   $0x0,(%ebx,%ecx,1)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
	{
		for(x=8;x<8+240;x++)
  28376a:	83 c0 01             	add    $0x1,%eax
  28376d:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283772:	75 e8                	jne    28375c <cmd_cls+0x15>

void cmd_cls(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
  283774:	83 c6 01             	add    $0x1,%esi
  283777:	81 fe 9c 00 00 00    	cmp    $0x9c,%esi
  28377d:	74 07                	je     283786 <cmd_cls+0x3f>
	cons_newline(cons);
	return;
}

void cmd_cls(struct CONSOLE *cons)
{
  28377f:	b8 08 00 00 00       	mov    $0x8,%eax
  283784:	eb d6                	jmp    28375c <cmd_cls+0x15>
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		}
	}
	sheet_refresh(sheet,8,28,8+240,28+128);
  283786:	83 ec 0c             	sub    $0xc,%esp
  283789:	68 9c 00 00 00       	push   $0x9c
  28378e:	68 f8 00 00 00       	push   $0xf8
  283793:	6a 1c                	push   $0x1c
  283795:	6a 08                	push   $0x8
  283797:	52                   	push   %edx
  283798:	e8 e1 ee ff ff       	call   28267e <sheet_refresh>
	cons->cur_y = 28;
  28379d:	c7 47 08 1c 00 00 00 	movl   $0x1c,0x8(%edi)
	return;
  2837a4:	83 c4 20             	add    $0x20,%esp
}
  2837a7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2837aa:	5b                   	pop    %ebx
  2837ab:	5e                   	pop    %esi
  2837ac:	5f                   	pop    %edi
  2837ad:	5d                   	pop    %ebp
  2837ae:	c3                   	ret    

002837af <cmd_dir>:

void cmd_dir(struct CONSOLE *cons)
{
  2837af:	55                   	push   %ebp
  2837b0:	89 e5                	mov    %esp,%ebp
  2837b2:	57                   	push   %edi
  2837b3:	56                   	push   %esi
  2837b4:	53                   	push   %ebx
  2837b5:	83 ec 2c             	sub    $0x2c,%esp
  2837b8:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  2837bb:	0f b6 05 20 26 10 00 	movzbl 0x102620,%eax
  2837c2:	84 c0                	test   %al,%al
  2837c4:	0f 84 87 00 00 00    	je     283851 <cmd_dir+0xa2>
  2837ca:	bb 00 26 10 00       	mov    $0x102600,%ebx
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  2837cf:	8d 75 ca             	lea    -0x36(%ebp),%esi
  2837d2:	eb 0b                	jmp    2837df <cmd_dir+0x30>
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  2837d4:	83 c3 40             	add    $0x40,%ebx
  2837d7:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  2837db:	84 c0                	test   %al,%al
  2837dd:	74 72                	je     283851 <cmd_dir+0xa2>
		if(finfo[i].name[0] != 0xe5)
  2837df:	3c e5                	cmp    $0xe5,%al
  2837e1:	74 66                	je     283849 <cmd_dir+0x9a>
		{
			if((finfo[i].type & 0x18) == 0)
  2837e3:	f6 43 2b 18          	testb  $0x18,0x2b(%ebx)
  2837e7:	75 60                	jne    283849 <cmd_dir+0x9a>
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  2837e9:	83 ec 04             	sub    $0x4,%esp
  2837ec:	ff 73 3c             	pushl  0x3c(%ebx)
  2837ef:	68 75 4a 28 00       	push   $0x284a75
  2837f4:	56                   	push   %esi
  2837f5:	e8 b3 e0 ff ff       	call   2818ad <sprintf>
  2837fa:	83 c4 10             	add    $0x10,%esp
				for(j=0;j<8;j++)
  2837fd:	b8 00 00 00 00       	mov    $0x0,%eax
				{
					s[j] = finfo[i].name[j];
  283802:	0f b6 54 03 20       	movzbl 0x20(%ebx,%eax,1),%edx
  283807:	88 14 30             	mov    %dl,(%eax,%esi,1)
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
				for(j=0;j<8;j++)
  28380a:	83 c0 01             	add    $0x1,%eax
  28380d:	83 f8 08             	cmp    $0x8,%eax
  283810:	75 f0                	jne    283802 <cmd_dir+0x53>
				{
					s[j] = finfo[i].name[j];
				}
				s[9] = finfo[i].ext[0];
  283812:	0f b6 43 28          	movzbl 0x28(%ebx),%eax
  283816:	88 45 d3             	mov    %al,-0x2d(%ebp)
				s[10] = finfo[i].ext[1];
  283819:	0f b6 43 29          	movzbl 0x29(%ebx),%eax
  28381d:	88 45 d4             	mov    %al,-0x2c(%ebp)
				s[11] = finfo[i].ext[2];
  283820:	0f b6 43 2a          	movzbl 0x2a(%ebx),%eax
  283824:	88 45 d5             	mov    %al,-0x2b(%ebp)
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283827:	83 ec 04             	sub    $0x4,%esp
  28382a:	6a 1e                	push   $0x1e
  28382c:	56                   	push   %esi
  28382d:	6a 00                	push   $0x0
  28382f:	6a 07                	push   $0x7
  283831:	ff 77 08             	pushl  0x8(%edi)
  283834:	6a 08                	push   $0x8
  283836:	ff 37                	pushl  (%edi)
  283838:	e8 b3 d7 ff ff       	call   280ff0 <putfonts8_asc_sht>
				cons_newline(cons);
  28383d:	83 c4 14             	add    $0x14,%esp
  283840:	57                   	push   %edi
  283841:	e8 ea fc ff ff       	call   283530 <cons_newline>
  283846:	83 c4 10             	add    $0x10,%esp
void cmd_dir(struct CONSOLE *cons)
{
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
  283849:	81 fb c0 5d 10 00    	cmp    $0x105dc0,%ebx
  28384f:	75 83                	jne    2837d4 <cmd_dir+0x25>
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
				cons_newline(cons);
			}
		}
	}
	cons_newline(cons);
  283851:	83 ec 0c             	sub    $0xc,%esp
  283854:	57                   	push   %edi
  283855:	e8 d6 fc ff ff       	call   283530 <cons_newline>
	return;
  28385a:	83 c4 10             	add    $0x10,%esp
}
  28385d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283860:	5b                   	pop    %ebx
  283861:	5e                   	pop    %esi
  283862:	5f                   	pop    %edi
  283863:	5d                   	pop    %ebp
  283864:	c3                   	ret    

00283865 <cmd_type>:

void cmd_type(struct CONSOLE *cons,int *fat,char *cmdline)
{
  283865:	55                   	push   %ebp
  283866:	89 e5                	mov    %esp,%ebp
  283868:	57                   	push   %edi
  283869:	56                   	push   %esi
  28386a:	53                   	push   %ebx
  28386b:	83 ec 10             	sub    $0x10,%esp
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo = file_search(cmdline +5,(struct FILEINFO *)(ADR_DISKIMG + 0x002600),224);
  28386e:	68 e0 00 00 00       	push   $0xe0
  283873:	68 00 26 10 00       	push   $0x102600
  283878:	8b 45 10             	mov    0x10(%ebp),%eax
  28387b:	83 c0 05             	add    $0x5,%eax
  28387e:	50                   	push   %eax
  28387f:	e8 39 fb ff ff       	call   2833bd <file_search>
	char *p;
	int i;
	if(finfo != 0)
  283884:	83 c4 10             	add    $0x10,%esp
  283887:	85 c0                	test   %eax,%eax
  283889:	74 6e                	je     2838f9 <cmd_type+0x94>
  28388b:	89 c6                	mov    %eax,%esi
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  28388d:	83 ec 08             	sub    $0x8,%esp
  283890:	ff 70 3c             	pushl  0x3c(%eax)
  283893:	68 00 00 3c 00       	push   $0x3c0000
  283898:	e8 80 e9 ff ff       	call   28221d <memman_alloc_4k>
  28389d:	89 c7                	mov    %eax,%edi
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  28389f:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  2838a6:	ff 75 0c             	pushl  0xc(%ebp)
  2838a9:	50                   	push   %eax
  2838aa:	ff 76 3c             	pushl  0x3c(%esi)
  2838ad:	0f b7 46 3a          	movzwl 0x3a(%esi),%eax
  2838b1:	50                   	push   %eax
  2838b2:	e8 5f fa ff ff       	call   283316 <file_loadfile>
		for(i=0;i<finfo->size;i++)
  2838b7:	8b 46 3c             	mov    0x3c(%esi),%eax
  2838ba:	83 c4 20             	add    $0x20,%esp
  2838bd:	85 c0                	test   %eax,%eax
  2838bf:	74 24                	je     2838e5 <cmd_type+0x80>
  2838c1:	bb 00 00 00 00       	mov    $0x0,%ebx
		{
			cons_putchar(cons,p[i],1);
  2838c6:	83 ec 04             	sub    $0x4,%esp
  2838c9:	6a 01                	push   $0x1
  2838cb:	0f be 04 3b          	movsbl (%ebx,%edi,1),%eax
  2838cf:	50                   	push   %eax
  2838d0:	ff 75 08             	pushl  0x8(%ebp)
  2838d3:	e8 23 fd ff ff       	call   2835fb <cons_putchar>
	int i;
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		for(i=0;i<finfo->size;i++)
  2838d8:	83 c3 01             	add    $0x1,%ebx
  2838db:	8b 46 3c             	mov    0x3c(%esi),%eax
  2838de:	83 c4 10             	add    $0x10,%esp
  2838e1:	39 d8                	cmp    %ebx,%eax
  2838e3:	77 e1                	ja     2838c6 <cmd_type+0x61>
		{
			cons_putchar(cons,p[i],1);
		}
		memman_free_4k(memman,(int)p,finfo->size);
  2838e5:	83 ec 04             	sub    $0x4,%esp
  2838e8:	50                   	push   %eax
  2838e9:	57                   	push   %edi
  2838ea:	68 00 00 3c 00       	push   $0x3c0000
  2838ef:	e8 55 e9 ff ff       	call   282249 <memman_free_4k>
  2838f4:	83 c4 10             	add    $0x10,%esp
  2838f7:	eb 2b                	jmp    283924 <cmd_type+0xbf>
	}
	else
	{
		putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"File not found.",15);
  2838f9:	83 ec 04             	sub    $0x4,%esp
  2838fc:	6a 0f                	push   $0xf
  2838fe:	68 85 4a 28 00       	push   $0x284a85
  283903:	6a 00                	push   $0x0
  283905:	6a 07                	push   $0x7
  283907:	8b 45 08             	mov    0x8(%ebp),%eax
  28390a:	ff 70 08             	pushl  0x8(%eax)
  28390d:	6a 08                	push   $0x8
  28390f:	ff 30                	pushl  (%eax)
  283911:	e8 da d6 ff ff       	call   280ff0 <putfonts8_asc_sht>
		cons_newline(cons);
  283916:	83 c4 14             	add    $0x14,%esp
  283919:	ff 75 08             	pushl  0x8(%ebp)
  28391c:	e8 0f fc ff ff       	call   283530 <cons_newline>
  283921:	83 c4 10             	add    $0x10,%esp
	}
	cons_newline(cons);
  283924:	83 ec 0c             	sub    $0xc,%esp
  283927:	ff 75 08             	pushl  0x8(%ebp)
  28392a:	e8 01 fc ff ff       	call   283530 <cons_newline>
	return;
  28392f:	83 c4 10             	add    $0x10,%esp
}
  283932:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283935:	5b                   	pop    %ebx
  283936:	5e                   	pop    %esi
  283937:	5f                   	pop    %edi
  283938:	5d                   	pop    %ebp
  283939:	c3                   	ret    

0028393a <cons_putstr0>:
	return 0;
}


void cons_putstr0(struct CONSOLE *cons,char *s)
{
  28393a:	55                   	push   %ebp
  28393b:	89 e5                	mov    %esp,%ebp
  28393d:	56                   	push   %esi
  28393e:	53                   	push   %ebx
  28393f:	8b 75 08             	mov    0x8(%ebp),%esi
  283942:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	for(;*s!=0;s++)
  283945:	0f b6 03             	movzbl (%ebx),%eax
  283948:	84 c0                	test   %al,%al
  28394a:	74 1c                	je     283968 <cons_putstr0+0x2e>
	{
		cons_putchar(cons,*s,1);
  28394c:	83 ec 04             	sub    $0x4,%esp
  28394f:	6a 01                	push   $0x1
  283951:	0f be c0             	movsbl %al,%eax
  283954:	50                   	push   %eax
  283955:	56                   	push   %esi
  283956:	e8 a0 fc ff ff       	call   2835fb <cons_putchar>
}


void cons_putstr0(struct CONSOLE *cons,char *s)
{
	for(;*s!=0;s++)
  28395b:	83 c3 01             	add    $0x1,%ebx
  28395e:	0f b6 03             	movzbl (%ebx),%eax
  283961:	83 c4 10             	add    $0x10,%esp
  283964:	84 c0                	test   %al,%al
  283966:	75 e4                	jne    28394c <cons_putstr0+0x12>
	{
		cons_putchar(cons,*s,1);
	}
	return;
}
  283968:	8d 65 f8             	lea    -0x8(%ebp),%esp
  28396b:	5b                   	pop    %ebx
  28396c:	5e                   	pop    %esi
  28396d:	5d                   	pop    %ebp
  28396e:	c3                   	ret    

0028396f <cmd_app>:
}



int cmd_app(struct CONSOLE *cons,int *fat,char *cmdline)
{
  28396f:	55                   	push   %ebp
  283970:	89 e5                	mov    %esp,%ebp
  283972:	57                   	push   %edi
  283973:	56                   	push   %esi
  283974:	53                   	push   %ebx
  283975:	83 ec 4c             	sub    $0x4c,%esp
  283978:	8b 75 10             	mov    0x10(%ebp),%esi
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
  28397b:	e8 b2 f2 ff ff       	call   282c32 <task_now>
  283980:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
  283983:	0f b6 06             	movzbl (%esi),%eax
  283986:	3c 20                	cmp    $0x20,%al
  283988:	0f 8f 6d 02 00 00    	jg     283bfb <cmd_app+0x28c>
  28398e:	eb 16                	jmp    2839a6 <cmd_app+0x37>
  283990:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
  283994:	3c 20                	cmp    $0x20,%al
  283996:	7e 13                	jle    2839ab <cmd_app+0x3c>
			break;
		name[i] = cmdline[i];
  283998:	88 44 1d d6          	mov    %al,-0x2a(%ebp,%ebx,1)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  28399c:	83 c3 01             	add    $0x1,%ebx
  28399f:	83 fb 0d             	cmp    $0xd,%ebx
  2839a2:	75 ec                	jne    283990 <cmd_app+0x21>
  2839a4:	eb 05                	jmp    2839ab <cmd_app+0x3c>
  2839a6:	bb 00 00 00 00       	mov    $0x0,%ebx
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
	}
	name[i] = 0;
  2839ab:	c6 44 1d d6 00       	movb   $0x0,-0x2a(%ebp,%ebx,1)

	finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  2839b0:	83 ec 04             	sub    $0x4,%esp
  2839b3:	68 e0 00 00 00       	push   $0xe0
  2839b8:	68 00 26 10 00       	push   $0x102600
  2839bd:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  2839c0:	50                   	push   %eax
  2839c1:	e8 f7 f9 ff ff       	call   2833bd <file_search>
  2839c6:	89 45 c0             	mov    %eax,-0x40(%ebp)
	if(finfo == 0 && name[i-1]!='.')
  2839c9:	83 c4 10             	add    $0x10,%esp
  2839cc:	85 c0                	test   %eax,%eax
  2839ce:	75 48                	jne    283a18 <cmd_app+0xa9>
  2839d0:	80 7c 1d d5 2e       	cmpb   $0x2e,-0x2b(%ebp,%ebx,1)
  2839d5:	0f 84 2d 02 00 00    	je     283c08 <cmd_app+0x299>
	{
		name[i  ] = '.';
  2839db:	c6 44 1d d6 2e       	movb   $0x2e,-0x2a(%ebp,%ebx,1)
		name[i+1] = 'B';
  2839e0:	c6 44 1d d7 42       	movb   $0x42,-0x29(%ebp,%ebx,1)
		name[i+2] = 'I';
  2839e5:	c6 44 1d d8 49       	movb   $0x49,-0x28(%ebp,%ebx,1)
		name[i+3] = 'N';
  2839ea:	c6 44 1d d9 4e       	movb   $0x4e,-0x27(%ebp,%ebx,1)
		name[i+4] = 0;
  2839ef:	c6 44 1d da 00       	movb   $0x0,-0x26(%ebp,%ebx,1)
		finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  2839f4:	83 ec 04             	sub    $0x4,%esp
  2839f7:	68 e0 00 00 00       	push   $0xe0
  2839fc:	68 00 26 10 00       	push   $0x102600
  283a01:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  283a04:	50                   	push   %eax
  283a05:	e8 b3 f9 ff ff       	call   2833bd <file_search>
  283a0a:	89 45 c0             	mov    %eax,-0x40(%ebp)
	}

	if(finfo != 0)
  283a0d:	83 c4 10             	add    $0x10,%esp
  283a10:	85 c0                	test   %eax,%eax
  283a12:	0f 84 dc 01 00 00    	je     283bf4 <cmd_app+0x285>
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  283a18:	83 ec 08             	sub    $0x8,%esp
  283a1b:	8b 7d c0             	mov    -0x40(%ebp),%edi
  283a1e:	ff 77 3c             	pushl  0x3c(%edi)
  283a21:	68 00 00 3c 00       	push   $0x3c0000
  283a26:	e8 f2 e7 ff ff       	call   28221d <memman_alloc_4k>
  283a2b:	89 c6                	mov    %eax,%esi
  283a2d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  283a30:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  283a37:	ff 75 0c             	pushl  0xc(%ebp)
  283a3a:	50                   	push   %eax
  283a3b:	ff 77 3c             	pushl  0x3c(%edi)
  283a3e:	0f b7 47 3a          	movzwl 0x3a(%edi),%eax
  283a42:	50                   	push   %eax
  283a43:	e8 ce f8 ff ff       	call   283316 <file_loadfile>
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
  283a48:	83 c4 20             	add    $0x20,%esp
  283a4b:	83 7f 3c 23          	cmpl   $0x23,0x3c(%edi)
  283a4f:	0f 86 61 01 00 00    	jbe    283bb6 <cmd_app+0x247>
  283a55:	83 ec 04             	sub    $0x4,%esp
  283a58:	6a 04                	push   $0x4
  283a5a:	68 95 4a 28 00       	push   $0x284a95
  283a5f:	89 f0                	mov    %esi,%eax
  283a61:	83 c0 04             	add    $0x4,%eax
  283a64:	50                   	push   %eax
  283a65:	e8 7e df ff ff       	call   2819e8 <strncmp>
  283a6a:	83 c4 10             	add    $0x10,%esp
  283a6d:	85 c0                	test   %eax,%eax
  283a6f:	0f 85 41 01 00 00    	jne    283bb6 <cmd_app+0x247>
  283a75:	80 3e 00             	cmpb   $0x0,(%esi)
  283a78:	0f 85 38 01 00 00    	jne    283bb6 <cmd_app+0x247>
		{
			int segsiz	=	*((int *)(p+0x0000));
  283a7e:	8b 45 bc             	mov    -0x44(%ebp),%eax
  283a81:	8b 08                	mov    (%eax),%ecx
			int esp		=	*((int *)(p+0x000c));
  283a83:	8b 70 0c             	mov    0xc(%eax),%esi
			int datsiz	=	*((int *)(p+0x0010));
  283a86:	8b 58 10             	mov    0x10(%eax),%ebx
			int dathrb	=	*((int *)(p+0x0014));
  283a89:	8b 78 14             	mov    0x14(%eax),%edi

			q = (char *)memman_alloc_4k(memman,segsiz);
  283a8c:	83 ec 08             	sub    $0x8,%esp
  283a8f:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  283a92:	51                   	push   %ecx
  283a93:	68 00 00 3c 00       	push   $0x3c0000
  283a98:	e8 80 e7 ff ff       	call   28221d <memman_alloc_4k>
  283a9d:	89 c2                	mov    %eax,%edx
			//*((int *)0xfe8) = (int) q;
			task->ds_base = (int)q;
  283a9f:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  283aa2:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  283aa5:	89 91 98 00 00 00    	mov    %edx,0x98(%ecx)
			set_segmdesc(gdt + task->sel/8 + 1000,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
  283aab:	68 fa 40 00 00       	push   $0x40fa
  283ab0:	ff 75 bc             	pushl  -0x44(%ebp)
  283ab3:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283ab6:	8b 40 3c             	mov    0x3c(%eax),%eax
  283ab9:	83 e8 01             	sub    $0x1,%eax
  283abc:	50                   	push   %eax
  283abd:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  283ac0:	8b 11                	mov    (%ecx),%edx
  283ac2:	8d 42 07             	lea    0x7(%edx),%eax
  283ac5:	85 d2                	test   %edx,%edx
  283ac7:	0f 49 c2             	cmovns %edx,%eax
  283aca:	c1 f8 03             	sar    $0x3,%eax
  283acd:	8d 04 c5 40 1f 27 00 	lea    0x271f40(,%eax,8),%eax
  283ad4:	50                   	push   %eax
  283ad5:	e8 68 d8 ff ff       	call   281342 <set_segmdesc>
			set_segmdesc(gdt + task->sel/8 + 2000,segsiz - 1,     (int)q,AR_DATA32_RW + 0x60);
  283ada:	83 c4 20             	add    $0x20,%esp
  283add:	68 f2 40 00 00       	push   $0x40f2
  283ae2:	ff 75 b4             	pushl  -0x4c(%ebp)
  283ae5:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  283ae8:	8d 41 ff             	lea    -0x1(%ecx),%eax
  283aeb:	50                   	push   %eax
  283aec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  283aef:	8b 10                	mov    (%eax),%edx
  283af1:	8d 42 07             	lea    0x7(%edx),%eax
  283af4:	85 d2                	test   %edx,%edx
  283af6:	0f 49 c2             	cmovns %edx,%eax
  283af9:	c1 f8 03             	sar    $0x3,%eax
  283afc:	8d 04 c5 80 3e 27 00 	lea    0x273e80(,%eax,8),%eax
  283b03:	50                   	push   %eax
  283b04:	e8 39 d8 ff ff       	call   281342 <set_segmdesc>
			for(int i = 0;i<datsiz;i++)
  283b09:	83 c4 10             	add    $0x10,%esp
  283b0c:	85 db                	test   %ebx,%ebx
  283b0e:	7e 1b                	jle    283b2b <cmd_app+0x1bc>
  283b10:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				q[esp + i] = p[dathrb + i];
  283b15:	03 7d bc             	add    -0x44(%ebp),%edi
  283b18:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  283b1b:	01 f2                	add    %esi,%edx
  283b1d:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  283b21:	88 0c 02             	mov    %cl,(%edx,%eax,1)
			q = (char *)memman_alloc_4k(memman,segsiz);
			//*((int *)0xfe8) = (int) q;
			task->ds_base = (int)q;
			set_segmdesc(gdt + task->sel/8 + 1000,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
			set_segmdesc(gdt + task->sel/8 + 2000,segsiz - 1,     (int)q,AR_DATA32_RW + 0x60);
			for(int i = 0;i<datsiz;i++)
  283b24:	83 c0 01             	add    $0x1,%eax
  283b27:	39 c3                	cmp    %eax,%ebx
  283b29:	75 f2                	jne    283b1d <cmd_app+0x1ae>
			{
				q[esp + i] = p[dathrb + i];
			}
			start_app(0x1b,task->sel + 1000*8,esp,task->sel + 2000*8,&(task->tss.esp0));
  283b2b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  283b2e:	8b 02                	mov    (%edx),%eax
  283b30:	83 ec 0c             	sub    $0xc,%esp
  283b33:	83 c2 30             	add    $0x30,%edx
  283b36:	52                   	push   %edx
  283b37:	8d 90 80 3e 00 00    	lea    0x3e80(%eax),%edx
  283b3d:	52                   	push   %edx
  283b3e:	56                   	push   %esi
  283b3f:	05 40 1f 00 00       	add    $0x1f40,%eax
  283b44:	50                   	push   %eax
  283b45:	6a 1b                	push   $0x1b
  283b47:	e8 04 02 00 00       	call   283d50 <start_app>
			struct SHEET *sht;
			struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
  283b4c:	8b 3d e4 0f 00 00    	mov    0xfe4,%edi
  283b52:	8d 9f 30 04 00 00    	lea    0x430(%edi),%ebx
  283b58:	8d b7 14 04 00 00    	lea    0x414(%edi),%esi
  283b5e:	81 c7 14 2c 00 00    	add    $0x2c14,%edi
  283b64:	83 c4 20             	add    $0x20,%esp
			for(int i=0;i<MAX_SHEETS;i++)
			{
				sht = &(shtctl->sheets0[i]);
				if((sht->flags&0x11) == 0x11 && sht->task == task)
  283b67:	8b 03                	mov    (%ebx),%eax
  283b69:	83 e0 11             	and    $0x11,%eax
  283b6c:	83 f8 11             	cmp    $0x11,%eax
  283b6f:	75 14                	jne    283b85 <cmd_app+0x216>
  283b71:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  283b74:	3b 43 08             	cmp    0x8(%ebx),%eax
  283b77:	75 0c                	jne    283b85 <cmd_app+0x216>
					sheet_free(sht);
  283b79:	83 ec 0c             	sub    $0xc,%esp
  283b7c:	56                   	push   %esi
  283b7d:	e8 78 ec ff ff       	call   2827fa <sheet_free>
  283b82:	83 c4 10             	add    $0x10,%esp
  283b85:	83 c3 28             	add    $0x28,%ebx
  283b88:	83 c6 28             	add    $0x28,%esi
				q[esp + i] = p[dathrb + i];
			}
			start_app(0x1b,task->sel + 1000*8,esp,task->sel + 2000*8,&(task->tss.esp0));
			struct SHEET *sht;
			struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
			for(int i=0;i<MAX_SHEETS;i++)
  283b8b:	39 f7                	cmp    %esi,%edi
  283b8d:	75 d8                	jne    283b67 <cmd_app+0x1f8>
			{
				sht = &(shtctl->sheets0[i]);
				if((sht->flags&0x11) == 0x11 && sht->task == task)
					sheet_free(sht);
			}
			timer_cancelall(&task->fifo);
  283b8f:	83 ec 0c             	sub    $0xc,%esp
  283b92:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  283b95:	83 c0 10             	add    $0x10,%eax
  283b98:	50                   	push   %eax
  283b99:	e8 05 ef ff ff       	call   282aa3 <timer_cancelall>
			memman_free_4k(memman,(int)q,segsiz);
  283b9e:	83 c4 0c             	add    $0xc,%esp
  283ba1:	ff 75 b8             	pushl  -0x48(%ebp)
  283ba4:	ff 75 b4             	pushl  -0x4c(%ebp)
  283ba7:	68 00 00 3c 00       	push   $0x3c0000
  283bac:	e8 98 e6 ff ff       	call   282249 <memman_free_4k>
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
		{
  283bb1:	83 c4 10             	add    $0x10,%esp
  283bb4:	eb 13                	jmp    283bc9 <cmd_app+0x25a>
			timer_cancelall(&task->fifo);
			memman_free_4k(memman,(int)q,segsiz);
		}
		else
		{
			cons_putstr0(cons,".bin file format error.\n");
  283bb6:	83 ec 08             	sub    $0x8,%esp
  283bb9:	68 9a 4a 28 00       	push   $0x284a9a
  283bbe:	ff 75 08             	pushl  0x8(%ebp)
  283bc1:	e8 74 fd ff ff       	call   28393a <cons_putstr0>
  283bc6:	83 c4 10             	add    $0x10,%esp
		}
		memman_free_4k(memman,(int)p,finfo->size);
  283bc9:	83 ec 04             	sub    $0x4,%esp
  283bcc:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283bcf:	ff 70 3c             	pushl  0x3c(%eax)
  283bd2:	ff 75 bc             	pushl  -0x44(%ebp)
  283bd5:	68 00 00 3c 00       	push   $0x3c0000
  283bda:	e8 6a e6 ff ff       	call   282249 <memman_free_4k>
		cons_newline(cons);
  283bdf:	83 c4 04             	add    $0x4,%esp
  283be2:	ff 75 08             	pushl  0x8(%ebp)
  283be5:	e8 46 f9 ff ff       	call   283530 <cons_newline>
		return 1;
  283bea:	83 c4 10             	add    $0x10,%esp
  283bed:	b8 01 00 00 00       	mov    $0x1,%eax
  283bf2:	eb 14                	jmp    283c08 <cmd_app+0x299>
	}
	return 0;
  283bf4:	b8 00 00 00 00       	mov    $0x0,%eax
  283bf9:	eb 0d                	jmp    283c08 <cmd_app+0x299>

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
  283bfb:	88 45 d6             	mov    %al,-0x2a(%ebp)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  283bfe:	bb 01 00 00 00       	mov    $0x1,%ebx
  283c03:	e9 88 fd ff ff       	jmp    283990 <cmd_app+0x21>
		memman_free_4k(memman,(int)p,finfo->size);
		cons_newline(cons);
		return 1;
	}
	return 0;
}
  283c08:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283c0b:	5b                   	pop    %ebx
  283c0c:	5e                   	pop    %esi
  283c0d:	5f                   	pop    %edi
  283c0e:	5d                   	pop    %ebp
  283c0f:	c3                   	ret    

00283c10 <cons_runcmd>:
	cons->cur_x = 8;
}

#include "string.h"
void cons_runcmd(char *cmdline,struct CONSOLE *cons,int *fat,unsigned int memtotal)
{
  283c10:	55                   	push   %ebp
  283c11:	89 e5                	mov    %esp,%ebp
  283c13:	53                   	push   %ebx
  283c14:	83 ec 0c             	sub    $0xc,%esp
  283c17:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(strcmp(cmdline,"mem") == 0)
  283c1a:	68 b3 4a 28 00       	push   $0x284ab3
  283c1f:	53                   	push   %ebx
  283c20:	e8 5d dd ff ff       	call   281982 <strcmp>
  283c25:	83 c4 10             	add    $0x10,%esp
  283c28:	85 c0                	test   %eax,%eax
  283c2a:	75 16                	jne    283c42 <cons_runcmd+0x32>
		cmd_mem(cons,memtotal);
  283c2c:	83 ec 08             	sub    $0x8,%esp
  283c2f:	ff 75 14             	pushl  0x14(%ebp)
  283c32:	ff 75 0c             	pushl  0xc(%ebp)
  283c35:	e8 7f fa ff ff       	call   2836b9 <cmd_mem>
  283c3a:	83 c4 10             	add    $0x10,%esp
  283c3d:	e9 c9 00 00 00       	jmp    283d0b <cons_runcmd+0xfb>
	else if(strcmp(cmdline,"cls") == 0)
  283c42:	83 ec 08             	sub    $0x8,%esp
  283c45:	68 b7 4a 28 00       	push   $0x284ab7
  283c4a:	53                   	push   %ebx
  283c4b:	e8 32 dd ff ff       	call   281982 <strcmp>
  283c50:	83 c4 10             	add    $0x10,%esp
  283c53:	85 c0                	test   %eax,%eax
  283c55:	75 13                	jne    283c6a <cons_runcmd+0x5a>
		cmd_cls(cons);
  283c57:	83 ec 0c             	sub    $0xc,%esp
  283c5a:	ff 75 0c             	pushl  0xc(%ebp)
  283c5d:	e8 e5 fa ff ff       	call   283747 <cmd_cls>
  283c62:	83 c4 10             	add    $0x10,%esp
  283c65:	e9 a1 00 00 00       	jmp    283d0b <cons_runcmd+0xfb>
	else if(strcmp(cmdline,"dir") == 0)
  283c6a:	83 ec 08             	sub    $0x8,%esp
  283c6d:	68 bb 4a 28 00       	push   $0x284abb
  283c72:	53                   	push   %ebx
  283c73:	e8 0a dd ff ff       	call   281982 <strcmp>
  283c78:	83 c4 10             	add    $0x10,%esp
  283c7b:	85 c0                	test   %eax,%eax
  283c7d:	75 10                	jne    283c8f <cons_runcmd+0x7f>
		cmd_dir(cons);
  283c7f:	83 ec 0c             	sub    $0xc,%esp
  283c82:	ff 75 0c             	pushl  0xc(%ebp)
  283c85:	e8 25 fb ff ff       	call   2837af <cmd_dir>
  283c8a:	83 c4 10             	add    $0x10,%esp
  283c8d:	eb 7c                	jmp    283d0b <cons_runcmd+0xfb>
	else if(strncmp(cmdline,"type ",5) == 0)
  283c8f:	83 ec 04             	sub    $0x4,%esp
  283c92:	6a 05                	push   $0x5
  283c94:	68 bf 4a 28 00       	push   $0x284abf
  283c99:	53                   	push   %ebx
  283c9a:	e8 49 dd ff ff       	call   2819e8 <strncmp>
  283c9f:	83 c4 10             	add    $0x10,%esp
  283ca2:	85 c0                	test   %eax,%eax
  283ca4:	75 14                	jne    283cba <cons_runcmd+0xaa>
		cmd_type(cons,fat,cmdline);
  283ca6:	83 ec 04             	sub    $0x4,%esp
  283ca9:	53                   	push   %ebx
  283caa:	ff 75 10             	pushl  0x10(%ebp)
  283cad:	ff 75 0c             	pushl  0xc(%ebp)
  283cb0:	e8 b0 fb ff ff       	call   283865 <cmd_type>
  283cb5:	83 c4 10             	add    $0x10,%esp
  283cb8:	eb 51                	jmp    283d0b <cons_runcmd+0xfb>
	else if(cmdline[0] != 0)
  283cba:	80 3b 00             	cmpb   $0x0,(%ebx)
  283cbd:	74 4c                	je     283d0b <cons_runcmd+0xfb>
	{
		if(cmd_app(cons,fat,cmdline) == 0)
  283cbf:	83 ec 04             	sub    $0x4,%esp
  283cc2:	53                   	push   %ebx
  283cc3:	ff 75 10             	pushl  0x10(%ebp)
  283cc6:	ff 75 0c             	pushl  0xc(%ebp)
  283cc9:	e8 a1 fc ff ff       	call   28396f <cmd_app>
  283cce:	83 c4 10             	add    $0x10,%esp
  283cd1:	85 c0                	test   %eax,%eax
  283cd3:	75 36                	jne    283d0b <cons_runcmd+0xfb>
		{
			putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"Bad command.",12);
  283cd5:	83 ec 04             	sub    $0x4,%esp
  283cd8:	6a 0c                	push   $0xc
  283cda:	68 c5 4a 28 00       	push   $0x284ac5
  283cdf:	6a 00                	push   $0x0
  283ce1:	6a 07                	push   $0x7
  283ce3:	8b 45 0c             	mov    0xc(%ebp),%eax
  283ce6:	ff 70 08             	pushl  0x8(%eax)
  283ce9:	6a 08                	push   $0x8
  283ceb:	ff 30                	pushl  (%eax)
  283ced:	e8 fe d2 ff ff       	call   280ff0 <putfonts8_asc_sht>
			cons_newline(cons);
  283cf2:	83 c4 14             	add    $0x14,%esp
  283cf5:	ff 75 0c             	pushl  0xc(%ebp)
  283cf8:	e8 33 f8 ff ff       	call   283530 <cons_newline>
			cons_newline(cons);
  283cfd:	83 c4 04             	add    $0x4,%esp
  283d00:	ff 75 0c             	pushl  0xc(%ebp)
  283d03:	e8 28 f8 ff ff       	call   283530 <cons_newline>
  283d08:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  283d0b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  283d0e:	c9                   	leave  
  283d0f:	c3                   	ret    

00283d10 <cons_putstr1>:
	}
	return;
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
  283d10:	55                   	push   %ebp
  283d11:	89 e5                	mov    %esp,%ebp
  283d13:	57                   	push   %edi
  283d14:	56                   	push   %esi
  283d15:	53                   	push   %ebx
  283d16:	83 ec 0c             	sub    $0xc,%esp
  283d19:	8b 7d 08             	mov    0x8(%ebp),%edi
  283d1c:	8b 75 0c             	mov    0xc(%ebp),%esi
  283d1f:	8b 45 10             	mov    0x10(%ebp),%eax
	int i;
	for(i=0;i<l;i++)
  283d22:	85 c0                	test   %eax,%eax
  283d24:	7e 1d                	jle    283d43 <cons_putstr1+0x33>
  283d26:	89 f3                	mov    %esi,%ebx
  283d28:	01 c6                	add    %eax,%esi
	{
		cons_putchar(cons,s[i],1);
  283d2a:	83 ec 04             	sub    $0x4,%esp
  283d2d:	6a 01                	push   $0x1
  283d2f:	0f be 03             	movsbl (%ebx),%eax
  283d32:	50                   	push   %eax
  283d33:	57                   	push   %edi
  283d34:	e8 c2 f8 ff ff       	call   2835fb <cons_putchar>
  283d39:	83 c3 01             	add    $0x1,%ebx
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
	int i;
	for(i=0;i<l;i++)
  283d3c:	83 c4 10             	add    $0x10,%esp
  283d3f:	39 f3                	cmp    %esi,%ebx
  283d41:	75 e7                	jne    283d2a <cons_putstr1+0x1a>
	{
		cons_putchar(cons,s[i],1);
	}
	return;
}
  283d43:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283d46:	5b                   	pop    %ebx
  283d47:	5e                   	pop    %esi
  283d48:	5f                   	pop    %edi
  283d49:	5d                   	pop    %ebp
  283d4a:	c3                   	ret    
  283d4b:	66 90                	xchg   %ax,%ax
  283d4d:	66 90                	xchg   %ax,%ax
  283d4f:	90                   	nop

00283d50 <start_app>:
  283d50:	60                   	pusha  
  283d51:	8b 44 24 24          	mov    0x24(%esp),%eax
  283d55:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  283d59:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  283d5d:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  283d61:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  283d65:	89 65 00             	mov    %esp,0x0(%ebp)
  283d68:	8c 55 04             	mov    %ss,0x4(%ebp)
  283d6b:	8e c3                	mov    %ebx,%es
  283d6d:	8e db                	mov    %ebx,%ds
  283d6f:	8e e3                	mov    %ebx,%fs
  283d71:	8e eb                	mov    %ebx,%gs
  283d73:	83 c9 03             	or     $0x3,%ecx
  283d76:	83 cb 03             	or     $0x3,%ebx
  283d79:	53                   	push   %ebx
  283d7a:	52                   	push   %edx
  283d7b:	51                   	push   %ecx
  283d7c:	50                   	push   %eax
  283d7d:	cb                   	lret   

00283d7e <sys_api>:
#include "header.h"
int *sys_api(int edi,int esi,int ebp,int esp,int ebx,int edx,int ecx,int eax)
{
  283d7e:	55                   	push   %ebp
  283d7f:	89 e5                	mov    %esp,%ebp
  283d81:	53                   	push   %ebx
  283d82:	83 ec 34             	sub    $0x34,%esp
	struct TASK *task = task_now();
  283d85:	e8 a8 ee ff ff       	call   282c32 <task_now>
  283d8a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct CONSOLE *cons = task->cons;
  283d8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  283d90:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
  283d96:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int ds_base = task->ds_base;
  283d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
  283d9c:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
  283da2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
  283da5:	b8 e4 0f 00 00       	mov    $0xfe4,%eax
  283daa:	8b 00                	mov    (%eax),%eax
  283dac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct SHEET *sht;
	int *reg = &eax + 1;
  283daf:	8d 45 24             	lea    0x24(%ebp),%eax
  283db2:	83 c0 04             	add    $0x4,%eax
  283db5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	   reg[0] = 1st_edi; reg[1] = 1st_esi ... reg[7] = 1st_eax
	   and the parameters:
	   edi = 2nd_edi; esi = 2nd_esi ... eax = 2nd_eax
	 */

	if(edx == 1) cons_putchar(cons,eax & 0xff,1);
  283db8:	83 7d 1c 01          	cmpl   $0x1,0x1c(%ebp)
  283dbc:	75 1c                	jne    283dda <sys_api+0x5c>
  283dbe:	8b 45 24             	mov    0x24(%ebp),%eax
  283dc1:	0f b6 c0             	movzbl %al,%eax
  283dc4:	83 ec 04             	sub    $0x4,%esp
  283dc7:	6a 01                	push   $0x1
  283dc9:	50                   	push   %eax
  283dca:	ff 75 f0             	pushl  -0x10(%ebp)
  283dcd:	e8 29 f8 ff ff       	call   2835fb <cons_putchar>
  283dd2:	83 c4 10             	add    $0x10,%esp
  283dd5:	e9 f8 05 00 00       	jmp    2843d2 <sys_api+0x654>
	else if(edx == 2) cons_putstr0(cons,(char *)ebx+ds_base);
  283dda:	83 7d 1c 02          	cmpl   $0x2,0x1c(%ebp)
  283dde:	75 1c                	jne    283dfc <sys_api+0x7e>
  283de0:	8b 55 ec             	mov    -0x14(%ebp),%edx
  283de3:	8b 45 18             	mov    0x18(%ebp),%eax
  283de6:	01 d0                	add    %edx,%eax
  283de8:	83 ec 08             	sub    $0x8,%esp
  283deb:	50                   	push   %eax
  283dec:	ff 75 f0             	pushl  -0x10(%ebp)
  283def:	e8 46 fb ff ff       	call   28393a <cons_putstr0>
  283df4:	83 c4 10             	add    $0x10,%esp
  283df7:	e9 d6 05 00 00       	jmp    2843d2 <sys_api+0x654>
	else if(edx == 3) cons_putstr1(cons,(char *)ebx+ds_base,ecx);
  283dfc:	83 7d 1c 03          	cmpl   $0x3,0x1c(%ebp)
  283e00:	75 1f                	jne    283e21 <sys_api+0xa3>
  283e02:	8b 55 ec             	mov    -0x14(%ebp),%edx
  283e05:	8b 45 18             	mov    0x18(%ebp),%eax
  283e08:	01 d0                	add    %edx,%eax
  283e0a:	83 ec 04             	sub    $0x4,%esp
  283e0d:	ff 75 20             	pushl  0x20(%ebp)
  283e10:	50                   	push   %eax
  283e11:	ff 75 f0             	pushl  -0x10(%ebp)
  283e14:	e8 f7 fe ff ff       	call   283d10 <cons_putstr1>
  283e19:	83 c4 10             	add    $0x10,%esp
  283e1c:	e9 b1 05 00 00       	jmp    2843d2 <sys_api+0x654>
	else if(edx == 4)
  283e21:	83 7d 1c 04          	cmpl   $0x4,0x1c(%ebp)
  283e25:	75 0b                	jne    283e32 <sys_api+0xb4>
	{
		//exit app
		return &(task->tss.esp0);
  283e27:	8b 45 f4             	mov    -0xc(%ebp),%eax
  283e2a:	83 c0 30             	add    $0x30,%eax
  283e2d:	e9 a5 05 00 00       	jmp    2843d7 <sys_api+0x659>
	}
	else if(edx == 5)
  283e32:	83 7d 1c 05          	cmpl   $0x5,0x1c(%ebp)
  283e36:	0f 85 ce 00 00 00    	jne    283f0a <sys_api+0x18c>
	{
		sht = sheet_alloc(shtctl);
  283e3c:	83 ec 0c             	sub    $0xc,%esp
  283e3f:	ff 75 e8             	pushl  -0x18(%ebp)
  283e42:	e8 c5 e4 ff ff       	call   28230c <sheet_alloc>
  283e47:	83 c4 10             	add    $0x10,%esp
  283e4a:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		sht->task = task;
  283e4d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283e50:	8b 55 f4             	mov    -0xc(%ebp),%edx
  283e53:	89 50 24             	mov    %edx,0x24(%eax)
		sht->flags |= 0x11;
  283e56:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283e59:	8b 40 1c             	mov    0x1c(%eax),%eax
  283e5c:	83 c8 11             	or     $0x11,%eax
  283e5f:	89 c2                	mov    %eax,%edx
  283e61:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283e64:	89 50 1c             	mov    %edx,0x1c(%eax)
		sheet_setbuf(sht,(char *)ebx+ds_base,esi,edi,eax);
  283e67:	8b 45 24             	mov    0x24(%ebp),%eax
  283e6a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  283e6d:	8b 55 18             	mov    0x18(%ebp),%edx
  283e70:	01 ca                	add    %ecx,%edx
  283e72:	83 ec 0c             	sub    $0xc,%esp
  283e75:	50                   	push   %eax
  283e76:	ff 75 08             	pushl  0x8(%ebp)
  283e79:	ff 75 0c             	pushl  0xc(%ebp)
  283e7c:	52                   	push   %edx
  283e7d:	ff 75 d4             	pushl  -0x2c(%ebp)
  283e80:	e8 fa e4 ff ff       	call   28237f <sheet_setbuf>
  283e85:	83 c4 20             	add    $0x20,%esp
		make_window8((char *)ebx+ds_base,esi,edi,(char *)ecx+ds_base,0);
  283e88:	8b 55 ec             	mov    -0x14(%ebp),%edx
  283e8b:	8b 45 20             	mov    0x20(%ebp),%eax
  283e8e:	01 d0                	add    %edx,%eax
  283e90:	89 c1                	mov    %eax,%ecx
  283e92:	8b 55 ec             	mov    -0x14(%ebp),%edx
  283e95:	8b 45 18             	mov    0x18(%ebp),%eax
  283e98:	01 d0                	add    %edx,%eax
  283e9a:	83 ec 0c             	sub    $0xc,%esp
  283e9d:	6a 00                	push   $0x0
  283e9f:	51                   	push   %ecx
  283ea0:	ff 75 08             	pushl  0x8(%ebp)
  283ea3:	ff 75 0c             	pushl  0xc(%ebp)
  283ea6:	50                   	push   %eax
  283ea7:	e8 e6 cf ff ff       	call   280e92 <make_window8>
  283eac:	83 c4 20             	add    $0x20,%esp
		sheet_slide(sht,(shtctl->xsize - esi)/2,(shtctl->ysize - edi)/2);
  283eaf:	8b 45 e8             	mov    -0x18(%ebp),%eax
  283eb2:	8b 40 0c             	mov    0xc(%eax),%eax
  283eb5:	2b 45 08             	sub    0x8(%ebp),%eax
  283eb8:	89 c2                	mov    %eax,%edx
  283eba:	c1 ea 1f             	shr    $0x1f,%edx
  283ebd:	01 d0                	add    %edx,%eax
  283ebf:	d1 f8                	sar    %eax
  283ec1:	89 c1                	mov    %eax,%ecx
  283ec3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  283ec6:	8b 40 08             	mov    0x8(%eax),%eax
  283ec9:	2b 45 0c             	sub    0xc(%ebp),%eax
  283ecc:	89 c2                	mov    %eax,%edx
  283ece:	c1 ea 1f             	shr    $0x1f,%edx
  283ed1:	01 d0                	add    %edx,%eax
  283ed3:	d1 f8                	sar    %eax
  283ed5:	83 ec 04             	sub    $0x4,%esp
  283ed8:	51                   	push   %ecx
  283ed9:	50                   	push   %eax
  283eda:	ff 75 d4             	pushl  -0x2c(%ebp)
  283edd:	e8 b9 e8 ff ff       	call   28279b <sheet_slide>
  283ee2:	83 c4 10             	add    $0x10,%esp
		sheet_updown(sht,shtctl->top);	//above task_a
  283ee5:	8b 45 e8             	mov    -0x18(%ebp),%eax
  283ee8:	8b 40 10             	mov    0x10(%eax),%eax
  283eeb:	83 ec 08             	sub    $0x8,%esp
  283eee:	50                   	push   %eax
  283eef:	ff 75 d4             	pushl  -0x2c(%ebp)
  283ef2:	e8 bb e7 ff ff       	call   2826b2 <sheet_updown>
  283ef7:	83 c4 10             	add    $0x10,%esp
		reg[7] = (int)sht;		//after sys_api ret and popad the eax will be sht
  283efa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  283efd:	8d 50 1c             	lea    0x1c(%eax),%edx
  283f00:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283f03:	89 02                	mov    %eax,(%edx)
  283f05:	e9 c8 04 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 6)
  283f0a:	83 7d 1c 06          	cmpl   $0x6,0x1c(%ebp)
  283f0e:	75 74                	jne    283f84 <sys_api+0x206>
	{
		sht = (struct SHEET *)ebx;
  283f10:	8b 45 18             	mov    0x18(%ebp),%eax
  283f13:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		putfonts8_asc(sht->buf,sht->bxsize,esi,edi,eax,(char *)ebp + ds_base);
  283f16:	8b 55 ec             	mov    -0x14(%ebp),%edx
  283f19:	8b 45 10             	mov    0x10(%ebp),%eax
  283f1c:	01 d0                	add    %edx,%eax
  283f1e:	89 c3                	mov    %eax,%ebx
  283f20:	8b 45 24             	mov    0x24(%ebp),%eax
  283f23:	0f be c8             	movsbl %al,%ecx
  283f26:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283f29:	8b 50 04             	mov    0x4(%eax),%edx
  283f2c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283f2f:	8b 00                	mov    (%eax),%eax
  283f31:	83 ec 08             	sub    $0x8,%esp
  283f34:	53                   	push   %ebx
  283f35:	51                   	push   %ecx
  283f36:	ff 75 08             	pushl  0x8(%ebp)
  283f39:	ff 75 0c             	pushl  0xc(%ebp)
  283f3c:	52                   	push   %edx
  283f3d:	50                   	push   %eax
  283f3e:	e8 b1 d3 ff ff       	call   2812f4 <putfonts8_asc>
  283f43:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  283f46:	8b 45 18             	mov    0x18(%ebp),%eax
  283f49:	83 e0 01             	and    $0x1,%eax
  283f4c:	85 c0                	test   %eax,%eax
  283f4e:	0f 85 7e 04 00 00    	jne    2843d2 <sys_api+0x654>
			sheet_refresh(sht,esi,edi,esi+ecx*8,edi+16);
  283f54:	8b 45 08             	mov    0x8(%ebp),%eax
  283f57:	8d 50 10             	lea    0x10(%eax),%edx
  283f5a:	8b 45 20             	mov    0x20(%ebp),%eax
  283f5d:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  283f64:	8b 45 0c             	mov    0xc(%ebp),%eax
  283f67:	01 c8                	add    %ecx,%eax
  283f69:	83 ec 0c             	sub    $0xc,%esp
  283f6c:	52                   	push   %edx
  283f6d:	50                   	push   %eax
  283f6e:	ff 75 08             	pushl  0x8(%ebp)
  283f71:	ff 75 0c             	pushl  0xc(%ebp)
  283f74:	ff 75 d4             	pushl  -0x2c(%ebp)
  283f77:	e8 02 e7 ff ff       	call   28267e <sheet_refresh>
  283f7c:	83 c4 20             	add    $0x20,%esp
  283f7f:	e9 4e 04 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 7)
  283f84:	83 7d 1c 07          	cmpl   $0x7,0x1c(%ebp)
  283f88:	75 68                	jne    283ff2 <sys_api+0x274>
	{
		sht = (struct SHEET *)ebx;
  283f8a:	8b 45 18             	mov    0x18(%ebp),%eax
  283f8d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
  283f90:	8b 5d 24             	mov    0x24(%ebp),%ebx
  283f93:	8b 45 10             	mov    0x10(%ebp),%eax
  283f96:	0f b6 c8             	movzbl %al,%ecx
  283f99:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283f9c:	8b 50 04             	mov    0x4(%eax),%edx
  283f9f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  283fa2:	8b 00                	mov    (%eax),%eax
  283fa4:	83 ec 04             	sub    $0x4,%esp
  283fa7:	ff 75 08             	pushl  0x8(%ebp)
  283faa:	ff 75 0c             	pushl  0xc(%ebp)
  283fad:	ff 75 20             	pushl  0x20(%ebp)
  283fb0:	53                   	push   %ebx
  283fb1:	51                   	push   %ecx
  283fb2:	52                   	push   %edx
  283fb3:	50                   	push   %eax
  283fb4:	e8 d8 cb ff ff       	call   280b91 <boxfill8>
  283fb9:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  283fbc:	8b 45 18             	mov    0x18(%ebp),%eax
  283fbf:	83 e0 01             	and    $0x1,%eax
  283fc2:	85 c0                	test   %eax,%eax
  283fc4:	0f 85 08 04 00 00    	jne    2843d2 <sys_api+0x654>
			sheet_refresh(sht,eax,ecx,esi+1,edi+1);
  283fca:	8b 45 08             	mov    0x8(%ebp),%eax
  283fcd:	8d 48 01             	lea    0x1(%eax),%ecx
  283fd0:	8b 45 0c             	mov    0xc(%ebp),%eax
  283fd3:	8d 50 01             	lea    0x1(%eax),%edx
  283fd6:	8b 45 24             	mov    0x24(%ebp),%eax
  283fd9:	83 ec 0c             	sub    $0xc,%esp
  283fdc:	51                   	push   %ecx
  283fdd:	52                   	push   %edx
  283fde:	ff 75 20             	pushl  0x20(%ebp)
  283fe1:	50                   	push   %eax
  283fe2:	ff 75 d4             	pushl  -0x2c(%ebp)
  283fe5:	e8 94 e6 ff ff       	call   28267e <sheet_refresh>
  283fea:	83 c4 20             	add    $0x20,%esp
  283fed:	e9 e0 03 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 8)
  283ff2:	83 7d 1c 08          	cmpl   $0x8,0x1c(%ebp)
  283ff6:	75 3b                	jne    284033 <sys_api+0x2b5>
	{
		memman_init((struct MEMMAN *)(ebx + ds_base));
  283ff8:	8b 55 18             	mov    0x18(%ebp),%edx
  283ffb:	8b 45 ec             	mov    -0x14(%ebp),%eax
  283ffe:	01 d0                	add    %edx,%eax
  284000:	83 ec 0c             	sub    $0xc,%esp
  284003:	50                   	push   %eax
  284004:	e8 72 de ff ff       	call   281e7b <memman_init>
  284009:	83 c4 10             	add    $0x10,%esp
		ecx &= 0xfffffff0;
  28400c:	83 65 20 f0          	andl   $0xfffffff0,0x20(%ebp)
		memman_free((struct MEMMAN *)(ebx + ds_base),eax,ecx);
  284010:	8b 45 20             	mov    0x20(%ebp),%eax
  284013:	8b 55 24             	mov    0x24(%ebp),%edx
  284016:	89 d3                	mov    %edx,%ebx
  284018:	8b 4d 18             	mov    0x18(%ebp),%ecx
  28401b:	8b 55 ec             	mov    -0x14(%ebp),%edx
  28401e:	01 ca                	add    %ecx,%edx
  284020:	83 ec 04             	sub    $0x4,%esp
  284023:	50                   	push   %eax
  284024:	53                   	push   %ebx
  284025:	52                   	push   %edx
  284026:	e8 9f df ff ff       	call   281fca <memman_free>
  28402b:	83 c4 10             	add    $0x10,%esp
  28402e:	e9 9f 03 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 9)
  284033:	83 7d 1c 09          	cmpl   $0x9,0x1c(%ebp)
  284037:	75 31                	jne    28406a <sys_api+0x2ec>
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;
  284039:	8b 45 20             	mov    0x20(%ebp),%eax
  28403c:	83 c0 0f             	add    $0xf,%eax
  28403f:	83 e0 f0             	and    $0xfffffff0,%eax
  284042:	89 45 20             	mov    %eax,0x20(%ebp)
		reg[7] = memman_alloc((struct MEMMAN *) (ebx + ds_base), ecx);
  284045:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  284048:	8d 58 1c             	lea    0x1c(%eax),%ebx
  28404b:	8b 45 20             	mov    0x20(%ebp),%eax
  28404e:	8b 4d 18             	mov    0x18(%ebp),%ecx
  284051:	8b 55 ec             	mov    -0x14(%ebp),%edx
  284054:	01 ca                	add    %ecx,%edx
  284056:	83 ec 08             	sub    $0x8,%esp
  284059:	50                   	push   %eax
  28405a:	52                   	push   %edx
  28405b:	e8 81 de ff ff       	call   281ee1 <memman_alloc>
  284060:	83 c4 10             	add    $0x10,%esp
  284063:	89 03                	mov    %eax,(%ebx)
  284065:	e9 68 03 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 10)
  28406a:	83 7d 1c 0a          	cmpl   $0xa,0x1c(%ebp)
  28406e:	75 2f                	jne    28409f <sys_api+0x321>
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;
  284070:	8b 45 20             	mov    0x20(%ebp),%eax
  284073:	83 c0 0f             	add    $0xf,%eax
  284076:	83 e0 f0             	and    $0xfffffff0,%eax
  284079:	89 45 20             	mov    %eax,0x20(%ebp)
		memman_free((struct MEMMAN *)(edx + ds_base),eax,ecx);
  28407c:	8b 45 20             	mov    0x20(%ebp),%eax
  28407f:	8b 55 24             	mov    0x24(%ebp),%edx
  284082:	89 d3                	mov    %edx,%ebx
  284084:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  284087:	8b 55 ec             	mov    -0x14(%ebp),%edx
  28408a:	01 ca                	add    %ecx,%edx
  28408c:	83 ec 04             	sub    $0x4,%esp
  28408f:	50                   	push   %eax
  284090:	53                   	push   %ebx
  284091:	52                   	push   %edx
  284092:	e8 33 df ff ff       	call   281fca <memman_free>
  284097:	83 c4 10             	add    $0x10,%esp
  28409a:	e9 33 03 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 11)
  28409f:	83 7d 1c 0b          	cmpl   $0xb,0x1c(%ebp)
  2840a3:	75 58                	jne    2840fd <sys_api+0x37f>
	{
		sht = (struct SHEET *)ebx;
  2840a5:	8b 45 18             	mov    0x18(%ebp),%eax
  2840a8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		sht->buf[sht->bxsize * edi + esi] = eax;
  2840ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  2840ae:	8b 10                	mov    (%eax),%edx
  2840b0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  2840b3:	8b 40 04             	mov    0x4(%eax),%eax
  2840b6:	0f af 45 08          	imul   0x8(%ebp),%eax
  2840ba:	89 c1                	mov    %eax,%ecx
  2840bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  2840bf:	01 c8                	add    %ecx,%eax
  2840c1:	01 d0                	add    %edx,%eax
  2840c3:	8b 55 24             	mov    0x24(%ebp),%edx
  2840c6:	88 10                	mov    %dl,(%eax)
		if(!(ebx&1))
  2840c8:	8b 45 18             	mov    0x18(%ebp),%eax
  2840cb:	83 e0 01             	and    $0x1,%eax
  2840ce:	85 c0                	test   %eax,%eax
  2840d0:	0f 85 fc 02 00 00    	jne    2843d2 <sys_api+0x654>
			sheet_refresh(sht,esi,edi,esi+1,edi+1);
  2840d6:	8b 45 08             	mov    0x8(%ebp),%eax
  2840d9:	8d 50 01             	lea    0x1(%eax),%edx
  2840dc:	8b 45 0c             	mov    0xc(%ebp),%eax
  2840df:	83 c0 01             	add    $0x1,%eax
  2840e2:	83 ec 0c             	sub    $0xc,%esp
  2840e5:	52                   	push   %edx
  2840e6:	50                   	push   %eax
  2840e7:	ff 75 08             	pushl  0x8(%ebp)
  2840ea:	ff 75 0c             	pushl  0xc(%ebp)
  2840ed:	ff 75 d4             	pushl  -0x2c(%ebp)
  2840f0:	e8 89 e5 ff ff       	call   28267e <sheet_refresh>
  2840f5:	83 c4 20             	add    $0x20,%esp
  2840f8:	e9 d5 02 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 12)
  2840fd:	83 7d 1c 0c          	cmpl   $0xc,0x1c(%ebp)
  284101:	75 26                	jne    284129 <sys_api+0x3ab>
	{
		sht = (struct SHEET *)ebx;
  284103:	8b 45 18             	mov    0x18(%ebp),%eax
  284106:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		sheet_refresh(sht,eax,ecx,esi,edi);
  284109:	8b 45 24             	mov    0x24(%ebp),%eax
  28410c:	83 ec 0c             	sub    $0xc,%esp
  28410f:	ff 75 08             	pushl  0x8(%ebp)
  284112:	ff 75 0c             	pushl  0xc(%ebp)
  284115:	ff 75 20             	pushl  0x20(%ebp)
  284118:	50                   	push   %eax
  284119:	ff 75 d4             	pushl  -0x2c(%ebp)
  28411c:	e8 5d e5 ff ff       	call   28267e <sheet_refresh>
  284121:	83 c4 20             	add    $0x20,%esp
  284124:	e9 a9 02 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 13)
  284129:	83 7d 1c 0d          	cmpl   $0xd,0x1c(%ebp)
  28412d:	75 5d                	jne    28418c <sys_api+0x40e>
	{
		sht = (struct SHEET *)(ebx & 0xfffffffe);
  28412f:	8b 45 18             	mov    0x18(%ebp),%eax
  284132:	83 e0 fe             	and    $0xfffffffe,%eax
  284135:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		drawline8_sht(sht,eax,ecx,esi,edi,ebp);
  284138:	8b 45 24             	mov    0x24(%ebp),%eax
  28413b:	83 ec 08             	sub    $0x8,%esp
  28413e:	ff 75 10             	pushl  0x10(%ebp)
  284141:	ff 75 08             	pushl  0x8(%ebp)
  284144:	ff 75 0c             	pushl  0xc(%ebp)
  284147:	ff 75 20             	pushl  0x20(%ebp)
  28414a:	50                   	push   %eax
  28414b:	ff 75 d4             	pushl  -0x2c(%ebp)
  28414e:	e8 2b d0 ff ff       	call   28117e <drawline8_sht>
  284153:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  284156:	8b 45 18             	mov    0x18(%ebp),%eax
  284159:	83 e0 01             	and    $0x1,%eax
  28415c:	85 c0                	test   %eax,%eax
  28415e:	0f 85 6e 02 00 00    	jne    2843d2 <sys_api+0x654>
			sheet_refresh(sht,eax,ecx,esi+1,edi+1);
  284164:	8b 45 08             	mov    0x8(%ebp),%eax
  284167:	8d 48 01             	lea    0x1(%eax),%ecx
  28416a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28416d:	8d 50 01             	lea    0x1(%eax),%edx
  284170:	8b 45 24             	mov    0x24(%ebp),%eax
  284173:	83 ec 0c             	sub    $0xc,%esp
  284176:	51                   	push   %ecx
  284177:	52                   	push   %edx
  284178:	ff 75 20             	pushl  0x20(%ebp)
  28417b:	50                   	push   %eax
  28417c:	ff 75 d4             	pushl  -0x2c(%ebp)
  28417f:	e8 fa e4 ff ff       	call   28267e <sheet_refresh>
  284184:	83 c4 20             	add    $0x20,%esp
  284187:	e9 46 02 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 14)
  28418c:	83 7d 1c 0e          	cmpl   $0xe,0x1c(%ebp)
  284190:	75 14                	jne    2841a6 <sys_api+0x428>
	{
		sheet_free((struct SHEET *)ebx);
  284192:	8b 45 18             	mov    0x18(%ebp),%eax
  284195:	83 ec 0c             	sub    $0xc,%esp
  284198:	50                   	push   %eax
  284199:	e8 5c e6 ff ff       	call   2827fa <sheet_free>
  28419e:	83 c4 10             	add    $0x10,%esp
  2841a1:	e9 2c 02 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 15)
  2841a6:	83 7d 1c 0f          	cmpl   $0xf,0x1c(%ebp)
  2841aa:	0f 85 f3 00 00 00    	jne    2842a3 <sys_api+0x525>
	{
		for(;;)
		{
			io_cli();
  2841b0:	e8 ed c7 ff ff       	call   2809a2 <io_cli>
			if(fifo32_status(&task->fifo) == 0)
  2841b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2841b8:	83 c0 10             	add    $0x10,%eax
  2841bb:	83 ec 0c             	sub    $0xc,%esp
  2841be:	50                   	push   %eax
  2841bf:	e8 82 d9 ff ff       	call   281b46 <fifo32_status>
  2841c4:	83 c4 10             	add    $0x10,%esp
  2841c7:	85 c0                	test   %eax,%eax
  2841c9:	75 32                	jne    2841fd <sys_api+0x47f>
			{
				if(eax != 0)
  2841cb:	8b 45 24             	mov    0x24(%ebp),%eax
  2841ce:	85 c0                	test   %eax,%eax
  2841d0:	74 10                	je     2841e2 <sys_api+0x464>
					task_sleep(task);
  2841d2:	83 ec 0c             	sub    $0xc,%esp
  2841d5:	ff 75 f4             	pushl  -0xc(%ebp)
  2841d8:	e8 bc ed ff ff       	call   282f99 <task_sleep>
  2841dd:	83 c4 10             	add    $0x10,%esp
  2841e0:	eb 1b                	jmp    2841fd <sys_api+0x47f>
				else
				{
					io_sti();
  2841e2:	e8 bd c7 ff ff       	call   2809a4 <io_sti>
					reg[7] = -1;
  2841e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  2841ea:	83 c0 1c             	add    $0x1c,%eax
  2841ed:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
					return 0;
  2841f3:	b8 00 00 00 00       	mov    $0x0,%eax
  2841f8:	e9 da 01 00 00       	jmp    2843d7 <sys_api+0x659>
				}
			}
			int i = fifo32_get(&task->fifo);
  2841fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  284200:	83 c0 10             	add    $0x10,%eax
  284203:	83 ec 0c             	sub    $0xc,%esp
  284206:	50                   	push   %eax
  284207:	e8 ff d8 ff ff       	call   281b0b <fifo32_get>
  28420c:	83 c4 10             	add    $0x10,%esp
  28420f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			io_sti();
  284212:	e8 8d c7 ff ff       	call   2809a4 <io_sti>
			if(i <= 1)
  284217:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
  28421b:	7f 34                	jg     284251 <sys_api+0x4d3>
			{
				timer_init(cons->timer,&task->fifo,1);
  28421d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  284220:	8d 50 10             	lea    0x10(%eax),%edx
  284223:	8b 45 f0             	mov    -0x10(%ebp),%eax
  284226:	8b 40 10             	mov    0x10(%eax),%eax
  284229:	83 ec 04             	sub    $0x4,%esp
  28422c:	6a 01                	push   $0x1
  28422e:	52                   	push   %edx
  28422f:	50                   	push   %eax
  284230:	e8 b7 e6 ff ff       	call   2828ec <timer_init>
  284235:	83 c4 10             	add    $0x10,%esp
				timer_settime(cons->timer,50);
  284238:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28423b:	8b 40 10             	mov    0x10(%eax),%eax
  28423e:	83 ec 08             	sub    $0x8,%esp
  284241:	6a 32                	push   $0x32
  284243:	50                   	push   %eax
  284244:	e8 b7 e6 ff ff       	call   282900 <timer_settime>
  284249:	83 c4 10             	add    $0x10,%esp
  28424c:	e9 5f ff ff ff       	jmp    2841b0 <sys_api+0x432>
			}
			else if(i == 2)
  284251:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
  284255:	75 0f                	jne    284266 <sys_api+0x4e8>
			{
				cons->cur_c = COL8_FFFFFF;
  284257:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28425a:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
  284261:	e9 4a ff ff ff       	jmp    2841b0 <sys_api+0x432>
			}
			else if(i == 3)
  284266:	83 7d e0 03          	cmpl   $0x3,-0x20(%ebp)
  28426a:	75 0f                	jne    28427b <sys_api+0x4fd>
			{
				cons->cur_c = -1;
  28426c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28426f:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
  284276:	e9 35 ff ff ff       	jmp    2841b0 <sys_api+0x432>
			}
			else if(i>=256)
  28427b:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%ebp)
  284282:	0f 8e 28 ff ff ff    	jle    2841b0 <sys_api+0x432>
			{
				reg[7] = i-256;
  284288:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  28428b:	83 c0 1c             	add    $0x1c,%eax
  28428e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  284291:	81 ea 00 01 00 00    	sub    $0x100,%edx
  284297:	89 10                	mov    %edx,(%eax)
				return 0;
  284299:	b8 00 00 00 00       	mov    $0x0,%eax
  28429e:	e9 34 01 00 00       	jmp    2843d7 <sys_api+0x659>
			}
		}
	}
	else if(edx == 16)
  2842a3:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  2842a7:	75 1e                	jne    2842c7 <sys_api+0x549>
	{
		reg[7] = (int)timer_alloc();
  2842a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  2842ac:	8d 58 1c             	lea    0x1c(%eax),%ebx
  2842af:	e8 6a e5 ff ff       	call   28281e <timer_alloc>
  2842b4:	89 03                	mov    %eax,(%ebx)
		((struct TIMER *)reg[7])->flags2 = 1;
  2842b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  2842b9:	83 c0 1c             	add    $0x1c,%eax
  2842bc:	8b 00                	mov    (%eax),%eax
  2842be:	c6 40 09 01          	movb   $0x1,0x9(%eax)
  2842c2:	e9 0b 01 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 17)
  2842c7:	83 7d 1c 11          	cmpl   $0x11,0x1c(%ebp)
  2842cb:	75 25                	jne    2842f2 <sys_api+0x574>
	{
		timer_init((struct TIMER *)ebx,&task->fifo,eax+256);
  2842cd:	8b 45 24             	mov    0x24(%ebp),%eax
  2842d0:	8d 88 00 01 00 00    	lea    0x100(%eax),%ecx
  2842d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2842d9:	8d 50 10             	lea    0x10(%eax),%edx
  2842dc:	8b 45 18             	mov    0x18(%ebp),%eax
  2842df:	83 ec 04             	sub    $0x4,%esp
  2842e2:	51                   	push   %ecx
  2842e3:	52                   	push   %edx
  2842e4:	50                   	push   %eax
  2842e5:	e8 02 e6 ff ff       	call   2828ec <timer_init>
  2842ea:	83 c4 10             	add    $0x10,%esp
  2842ed:	e9 e0 00 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 18)
  2842f2:	83 7d 1c 12          	cmpl   $0x12,0x1c(%ebp)
  2842f6:	75 1a                	jne    284312 <sys_api+0x594>
	{
		timer_settime((struct TIMER *)ebx,eax);
  2842f8:	8b 45 24             	mov    0x24(%ebp),%eax
  2842fb:	89 c2                	mov    %eax,%edx
  2842fd:	8b 45 18             	mov    0x18(%ebp),%eax
  284300:	83 ec 08             	sub    $0x8,%esp
  284303:	52                   	push   %edx
  284304:	50                   	push   %eax
  284305:	e8 f6 e5 ff ff       	call   282900 <timer_settime>
  28430a:	83 c4 10             	add    $0x10,%esp
  28430d:	e9 c0 00 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 19)
  284312:	83 7d 1c 13          	cmpl   $0x13,0x1c(%ebp)
  284316:	75 14                	jne    28432c <sys_api+0x5ae>
	{
		timer_free((struct TIMER *)ebx);
  284318:	8b 45 18             	mov    0x18(%ebp),%eax
  28431b:	83 ec 0c             	sub    $0xc,%esp
  28431e:	50                   	push   %eax
  28431f:	e8 bc e5 ff ff       	call   2828e0 <timer_free>
  284324:	83 c4 10             	add    $0x10,%esp
  284327:	e9 a6 00 00 00       	jmp    2843d2 <sys_api+0x654>
	}
	else if(edx == 20)
  28432c:	83 7d 1c 14          	cmpl   $0x14,0x1c(%ebp)
  284330:	0f 85 9c 00 00 00    	jne    2843d2 <sys_api+0x654>
	{
		if(eax == 0)
  284336:	8b 45 24             	mov    0x24(%ebp),%eax
  284339:	85 c0                	test   %eax,%eax
  28433b:	75 26                	jne    284363 <sys_api+0x5e5>
		{
			int i = io_in8(0x61);
  28433d:	83 ec 0c             	sub    $0xc,%esp
  284340:	6a 61                	push   $0x61
  284342:	e8 6d c6 ff ff       	call   2809b4 <io_in8>
  284347:	83 c4 10             	add    $0x10,%esp
  28434a:	89 45 dc             	mov    %eax,-0x24(%ebp)
			io_out8(0x61,i&0x0d);
  28434d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  284350:	83 e0 0d             	and    $0xd,%eax
  284353:	83 ec 08             	sub    $0x8,%esp
  284356:	50                   	push   %eax
  284357:	6a 61                	push   $0x61
  284359:	e8 78 c6 ff ff       	call   2809d6 <io_out8>
  28435e:	83 c4 10             	add    $0x10,%esp
  284361:	eb 6f                	jmp    2843d2 <sys_api+0x654>
		}
		else
		{
			int i = 1193180000/eax;
  284363:	8b 5d 24             	mov    0x24(%ebp),%ebx
  284366:	b8 60 7b 1e 47       	mov    $0x471e7b60,%eax
  28436b:	99                   	cltd   
  28436c:	f7 fb                	idiv   %ebx
  28436e:	89 45 d8             	mov    %eax,-0x28(%ebp)
			io_out8(0x43,0xb6);
  284371:	83 ec 08             	sub    $0x8,%esp
  284374:	68 b6 00 00 00       	push   $0xb6
  284379:	6a 43                	push   $0x43
  28437b:	e8 56 c6 ff ff       	call   2809d6 <io_out8>
  284380:	83 c4 10             	add    $0x10,%esp
			io_out8(0x42,i&0xff);
  284383:	8b 45 d8             	mov    -0x28(%ebp),%eax
  284386:	0f b6 c0             	movzbl %al,%eax
  284389:	83 ec 08             	sub    $0x8,%esp
  28438c:	50                   	push   %eax
  28438d:	6a 42                	push   $0x42
  28438f:	e8 42 c6 ff ff       	call   2809d6 <io_out8>
  284394:	83 c4 10             	add    $0x10,%esp
			io_out8(0x42,i>>8);
  284397:	8b 45 d8             	mov    -0x28(%ebp),%eax
  28439a:	c1 f8 08             	sar    $0x8,%eax
  28439d:	83 ec 08             	sub    $0x8,%esp
  2843a0:	50                   	push   %eax
  2843a1:	6a 42                	push   $0x42
  2843a3:	e8 2e c6 ff ff       	call   2809d6 <io_out8>
  2843a8:	83 c4 10             	add    $0x10,%esp
			i=io_in8(0x61);
  2843ab:	83 ec 0c             	sub    $0xc,%esp
  2843ae:	6a 61                	push   $0x61
  2843b0:	e8 ff c5 ff ff       	call   2809b4 <io_in8>
  2843b5:	83 c4 10             	add    $0x10,%esp
  2843b8:	89 45 d8             	mov    %eax,-0x28(%ebp)
			io_out8(0x61,(i|0x03)&0x0f);
  2843bb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2843be:	83 e0 0c             	and    $0xc,%eax
  2843c1:	83 c8 03             	or     $0x3,%eax
  2843c4:	83 ec 08             	sub    $0x8,%esp
  2843c7:	50                   	push   %eax
  2843c8:	6a 61                	push   $0x61
  2843ca:	e8 07 c6 ff ff       	call   2809d6 <io_out8>
  2843cf:	83 c4 10             	add    $0x10,%esp
		}
	}
	return 0;
  2843d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2843d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2843da:	c9                   	leave  
  2843db:	c3                   	ret    
  2843dc:	66 90                	xchg   %ax,%ax
  2843de:	66 90                	xchg   %ax,%ax

002843e0 <api_putchar>:
  2843e0:	ba 01 00 00 00       	mov    $0x1,%edx
  2843e5:	8a 44 24 04          	mov    0x4(%esp),%al
  2843e9:	cd 40                	int    $0x40
  2843eb:	c3                   	ret    

002843ec <api_putstr>:
  2843ec:	ba 02 00 00 00       	mov    $0x2,%edx
  2843f1:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  2843f5:	cd 40                	int    $0x40
  2843f7:	c3                   	ret    

002843f8 <api_end>:
  2843f8:	ba 04 00 00 00       	mov    $0x4,%edx
  2843fd:	cd 40                	int    $0x40

002843ff <api_test>:
  2843ff:	05 80 00 00 00       	add    $0x80,%eax
  284404:	c3                   	ret    

00284405 <api_openwin>:
  284405:	57                   	push   %edi
  284406:	56                   	push   %esi
  284407:	53                   	push   %ebx
  284408:	ba 05 00 00 00       	mov    $0x5,%edx
  28440d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  284411:	8b 74 24 14          	mov    0x14(%esp),%esi
  284415:	8b 7c 24 18          	mov    0x18(%esp),%edi
  284419:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  28441d:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  284421:	cd 40                	int    $0x40
  284423:	5b                   	pop    %ebx
  284424:	5e                   	pop    %esi
  284425:	5f                   	pop    %edi
  284426:	c3                   	ret    

00284427 <api_putstrwin>:
  284427:	57                   	push   %edi
  284428:	56                   	push   %esi
  284429:	55                   	push   %ebp
  28442a:	53                   	push   %ebx
  28442b:	ba 06 00 00 00       	mov    $0x6,%edx
  284430:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  284434:	8b 74 24 18          	mov    0x18(%esp),%esi
  284438:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  28443c:	8b 44 24 20          	mov    0x20(%esp),%eax
  284440:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  284444:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  284448:	cd 40                	int    $0x40
  28444a:	5b                   	pop    %ebx
  28444b:	5d                   	pop    %ebp
  28444c:	5e                   	pop    %esi
  28444d:	5f                   	pop    %edi
  28444e:	c3                   	ret    

0028444f <api_boxfilwin>:
  28444f:	57                   	push   %edi
  284450:	56                   	push   %esi
  284451:	55                   	push   %ebp
  284452:	53                   	push   %ebx
  284453:	ba 07 00 00 00       	mov    $0x7,%edx
  284458:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  28445c:	8b 44 24 18          	mov    0x18(%esp),%eax
  284460:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  284464:	8b 74 24 20          	mov    0x20(%esp),%esi
  284468:	8b 7c 24 24          	mov    0x24(%esp),%edi
  28446c:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  284470:	cd 40                	int    $0x40
  284472:	5b                   	pop    %ebx
  284473:	5d                   	pop    %ebp
  284474:	5e                   	pop    %esi
  284475:	5f                   	pop    %edi
  284476:	c3                   	ret    

00284477 <api_initmalloc>:
  284477:	53                   	push   %ebx
  284478:	ba 08 00 00 00       	mov    $0x8,%edx
  28447d:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  284484:	89 d8                	mov    %ebx,%eax
  284486:	05 00 80 00 00       	add    $0x8000,%eax
  28448b:	2e 8b 0d 00 00 00 00 	mov    %cs:0x0,%ecx
  284492:	29 c1                	sub    %eax,%ecx
  284494:	cd 40                	int    $0x40
  284496:	5b                   	pop    %ebx
  284497:	c3                   	ret    

00284498 <api_malloc>:
  284498:	53                   	push   %ebx
  284499:	ba 09 00 00 00       	mov    $0x9,%edx
  28449e:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  2844a5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  2844a9:	cd 40                	int    $0x40
  2844ab:	5b                   	pop    %ebx
  2844ac:	c3                   	ret    

002844ad <api_free>:
  2844ad:	53                   	push   %ebx
  2844ae:	ba 0a 00 00 00       	mov    $0xa,%edx
  2844b3:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  2844ba:	8b 44 24 08          	mov    0x8(%esp),%eax
  2844be:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  2844c2:	cd 40                	int    $0x40
  2844c4:	5b                   	pop    %ebx
  2844c5:	c3                   	ret    

002844c6 <api_pointwin>:
  2844c6:	57                   	push   %edi
  2844c7:	56                   	push   %esi
  2844c8:	53                   	push   %ebx
  2844c9:	ba 0b 00 00 00       	mov    $0xb,%edx
  2844ce:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  2844d2:	8b 74 24 14          	mov    0x14(%esp),%esi
  2844d6:	8b 7c 24 18          	mov    0x18(%esp),%edi
  2844da:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  2844de:	cd 40                	int    $0x40
  2844e0:	5b                   	pop    %ebx
  2844e1:	5e                   	pop    %esi
  2844e2:	5f                   	pop    %edi
  2844e3:	c3                   	ret    

002844e4 <api_refreshwin>:
  2844e4:	57                   	push   %edi
  2844e5:	56                   	push   %esi
  2844e6:	53                   	push   %ebx
  2844e7:	ba 0c 00 00 00       	mov    $0xc,%edx
  2844ec:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  2844f0:	8b 44 24 14          	mov    0x14(%esp),%eax
  2844f4:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  2844f8:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  2844fc:	8b 7c 24 20          	mov    0x20(%esp),%edi
  284500:	cd 40                	int    $0x40
  284502:	5b                   	pop    %ebx
  284503:	5e                   	pop    %esi
  284504:	5f                   	pop    %edi
  284505:	c3                   	ret    

00284506 <api_linewin>:
  284506:	57                   	push   %edi
  284507:	56                   	push   %esi
  284508:	55                   	push   %ebp
  284509:	53                   	push   %ebx
  28450a:	ba 0d 00 00 00       	mov    $0xd,%edx
  28450f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  284513:	8b 44 24 18          	mov    0x18(%esp),%eax
  284517:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  28451b:	8b 74 24 20          	mov    0x20(%esp),%esi
  28451f:	8b 7c 24 24          	mov    0x24(%esp),%edi
  284523:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  284527:	cd 40                	int    $0x40
  284529:	5b                   	pop    %ebx
  28452a:	5d                   	pop    %ebp
  28452b:	5e                   	pop    %esi
  28452c:	5f                   	pop    %edi
  28452d:	c3                   	ret    

0028452e <api_closewin>:
  28452e:	53                   	push   %ebx
  28452f:	ba 0e 00 00 00       	mov    $0xe,%edx
  284534:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  284538:	cd 40                	int    $0x40
  28453a:	5b                   	pop    %ebx
  28453b:	c3                   	ret    

0028453c <api_getkey>:
  28453c:	ba 0f 00 00 00       	mov    $0xf,%edx
  284541:	8b 44 24 04          	mov    0x4(%esp),%eax
  284545:	cd 40                	int    $0x40
  284547:	c3                   	ret    

00284548 <api_alloctimer>:
  284548:	ba 10 00 00 00       	mov    $0x10,%edx
  28454d:	cd 40                	int    $0x40
  28454f:	c3                   	ret    

00284550 <api_inittimer>:
  284550:	53                   	push   %ebx
  284551:	ba 11 00 00 00       	mov    $0x11,%edx
  284556:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  28455a:	8b 44 24 0c          	mov    0xc(%esp),%eax
  28455e:	cd 40                	int    $0x40
  284560:	5b                   	pop    %ebx
  284561:	c3                   	ret    

00284562 <api_settimer>:
  284562:	53                   	push   %ebx
  284563:	ba 12 00 00 00       	mov    $0x12,%edx
  284568:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  28456c:	8b 44 24 0c          	mov    0xc(%esp),%eax
  284570:	cd 40                	int    $0x40
  284572:	5b                   	pop    %ebx
  284573:	c3                   	ret    

00284574 <api_freetimer>:
  284574:	53                   	push   %ebx
  284575:	ba 13 00 00 00       	mov    $0x13,%edx
  28457a:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  28457e:	cd 40                	int    $0x40
  284580:	5b                   	pop    %ebx
  284581:	c3                   	ret    

00284582 <api_beep>:
  284582:	ba 14 00 00 00       	mov    $0x14,%edx
  284587:	8b 44 24 04          	mov    0x4(%esp),%eax
  28458b:	cd 40                	int    $0x40
  28458d:	c3                   	ret    

0028458e <change_wtitle8>:
	}
	return;
}

void change_wtitle8(struct SHEET *sht,char act)
{
  28458e:	55                   	push   %ebp
  28458f:	89 e5                	mov    %esp,%ebp
  284591:	57                   	push   %edi
  284592:	56                   	push   %esi
  284593:	53                   	push   %ebx
  284594:	83 ec 2c             	sub    $0x2c,%esp
  284597:	8b 45 0c             	mov    0xc(%ebp),%eax
	int x,y,xsize = sht->bxsize;
  28459a:	8b 7d 08             	mov    0x8(%ebp),%edi
  28459d:	8b 7f 04             	mov    0x4(%edi),%edi
  2845a0:	89 fe                	mov    %edi,%esi
  2845a2:	89 7d cc             	mov    %edi,-0x34(%ebp)
	else
	{
		tc_new = COL8_C6C6C6;
		tbc_new = COL8_848484;
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
  2845a5:	3c 01                	cmp    $0x1,%al
  2845a7:	19 ff                	sbb    %edi,%edi
  2845a9:	89 fb                	mov    %edi,%ebx
  2845ab:	83 e3 fd             	and    $0xfffffffd,%ebx
  2845ae:	83 c3 0f             	add    $0xf,%ebx
  2845b1:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  2845b4:	89 fb                	mov    %edi,%ebx
  2845b6:	83 c3 08             	add    $0x8,%ebx
  2845b9:	88 5d e7             	mov    %bl,-0x19(%ebp)
  2845bc:	83 e7 03             	and    $0x3,%edi
  2845bf:	83 c7 0c             	add    $0xc,%edi
  2845c2:	3c 01                	cmp    $0x1,%al
  2845c4:	19 c0                	sbb    %eax,%eax
  2845c6:	f7 d0                	not    %eax
  2845c8:	83 c0 08             	add    $0x8,%eax
  2845cb:	88 45 e5             	mov    %al,-0x1b(%ebp)
  2845ce:	89 f0                	mov    %esi,%eax
  2845d0:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  2845d3:	8d 0c 76             	lea    (%esi,%esi,2),%ecx
  2845d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2845d9:	03 0b                	add    (%ebx),%ecx
			{
				c = tc_new;
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
  2845db:	c7 45 d8 12 00 00 00 	movl   $0x12,-0x28(%ebp)
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
  2845e2:	8d 5e fc             	lea    -0x4(%esi),%ebx
  2845e5:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  2845e8:	83 e8 03             	sub    $0x3,%eax
  2845eb:	89 45 e0             	mov    %eax,-0x20(%ebp)
		{
			c = buf[y*xsize + x];
			if(c == tc_old && x<=xsize -22)
  2845ee:	8d 46 ea             	lea    -0x16(%esi),%eax
  2845f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
  2845f4:	eb 32                	jmp    284628 <change_wtitle8+0x9a>
  2845f6:	89 ce                	mov    %ecx,%esi
  2845f8:	89 d3                	mov    %edx,%ebx
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
		{
			c = buf[y*xsize + x];
  2845fa:	0f b6 04 11          	movzbl (%ecx,%edx,1),%eax
			if(c == tc_old && x<=xsize -22)
  2845fe:	38 45 e7             	cmp    %al,-0x19(%ebp)
  284601:	75 05                	jne    284608 <change_wtitle8+0x7a>
  284603:	39 55 dc             	cmp    %edx,-0x24(%ebp)
  284606:	7d 08                	jge    284610 <change_wtitle8+0x82>
			{
				c = tc_new;
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
  284608:	38 45 e6             	cmp    %al,-0x1a(%ebp)
  28460b:	0f 44 c7             	cmove  %edi,%eax
  28460e:	eb 04                	jmp    284614 <change_wtitle8+0x86>
		for(x=3;x<=xsize-4;x++)
		{
			c = buf[y*xsize + x];
			if(c == tc_old && x<=xsize -22)
			{
				c = tc_new;
  284610:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
			}
			buf[y*xsize+x] = c;
  284614:	88 04 1e             	mov    %al,(%esi,%ebx,1)
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
  284617:	83 c2 01             	add    $0x1,%edx
  28461a:	3b 55 e0             	cmp    -0x20(%ebp),%edx
  28461d:	75 d7                	jne    2845f6 <change_wtitle8+0x68>
  28461f:	03 4d d4             	add    -0x2c(%ebp),%ecx
		tc_new = COL8_C6C6C6;
		tbc_new = COL8_848484;
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
  284622:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  284626:	74 0d                	je     284635 <change_wtitle8+0xa7>
	{
		for(x=3;x<=xsize-4;x++)
  284628:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
  28462c:	7e f1                	jle    28461f <change_wtitle8+0x91>
  28462e:	ba 03 00 00 00       	mov    $0x3,%edx
  284633:	eb c1                	jmp    2845f6 <change_wtitle8+0x68>
				c = tbc_new;
			}
			buf[y*xsize+x] = c;
		}
	}
	sheet_refresh(sht,3,3,xsize,21);
  284635:	83 ec 0c             	sub    $0xc,%esp
  284638:	6a 15                	push   $0x15
  28463a:	ff 75 cc             	pushl  -0x34(%ebp)
  28463d:	6a 03                	push   $0x3
  28463f:	6a 03                	push   $0x3
  284641:	ff 75 08             	pushl  0x8(%ebp)
  284644:	e8 35 e0 ff ff       	call   28267e <sheet_refresh>
	return;
  284649:	83 c4 20             	add    $0x20,%esp
}
  28464c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28464f:	5b                   	pop    %ebx
  284650:	5e                   	pop    %esi
  284651:	5f                   	pop    %edi
  284652:	5d                   	pop    %ebp
  284653:	c3                   	ret    

00284654 <keywin_off>:
#include "common.h"
#include "graphics.h"
void keywin_off(struct SHEET *key_win)
{
  284654:	55                   	push   %ebp
  284655:	89 e5                	mov    %esp,%ebp
  284657:	53                   	push   %ebx
  284658:	83 ec 0c             	sub    $0xc,%esp
  28465b:	8b 5d 08             	mov    0x8(%ebp),%ebx
	change_wtitle8(key_win,0);
  28465e:	6a 00                	push   $0x0
  284660:	53                   	push   %ebx
  284661:	e8 28 ff ff ff       	call   28458e <change_wtitle8>
	if((key_win->flags & 0x20))
  284666:	83 c4 10             	add    $0x10,%esp
  284669:	f6 43 1c 20          	testb  $0x20,0x1c(%ebx)
  28466d:	74 14                	je     284683 <keywin_off+0x2f>
	{
		fifo32_put(&key_win->task->fifo,3);
  28466f:	83 ec 08             	sub    $0x8,%esp
  284672:	6a 03                	push   $0x3
  284674:	8b 43 24             	mov    0x24(%ebx),%eax
  284677:	83 c0 10             	add    $0x10,%eax
  28467a:	50                   	push   %eax
  28467b:	e8 19 d4 ff ff       	call   281a99 <fifo32_put>
  284680:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  284683:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  284686:	c9                   	leave  
  284687:	c3                   	ret    

00284688 <keywin_on>:

void keywin_on(struct SHEET *key_win)
{
  284688:	55                   	push   %ebp
  284689:	89 e5                	mov    %esp,%ebp
  28468b:	53                   	push   %ebx
  28468c:	83 ec 0c             	sub    $0xc,%esp
  28468f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	change_wtitle8(key_win,1);
  284692:	6a 01                	push   $0x1
  284694:	53                   	push   %ebx
  284695:	e8 f4 fe ff ff       	call   28458e <change_wtitle8>
	if((key_win->flags & 0x20))
  28469a:	83 c4 10             	add    $0x10,%esp
  28469d:	f6 43 1c 20          	testb  $0x20,0x1c(%ebx)
  2846a1:	74 14                	je     2846b7 <keywin_on+0x2f>
	{
		fifo32_put(&key_win->task->fifo,2);
  2846a3:	83 ec 08             	sub    $0x8,%esp
  2846a6:	6a 02                	push   $0x2
  2846a8:	8b 43 24             	mov    0x24(%ebx),%eax
  2846ab:	83 c0 10             	add    $0x10,%eax
  2846ae:	50                   	push   %eax
  2846af:	e8 e5 d3 ff ff       	call   281a99 <fifo32_put>
  2846b4:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  2846b7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2846ba:	c9                   	leave  
  2846bb:	c3                   	ret    

002846bc <test>:
#include "test.h"
int test(int screenx, int screeny)
{
  2846bc:	55                   	push   %ebp
  2846bd:	89 e5                	mov    %esp,%ebp
	return screenx*screeny;
  2846bf:	8b 45 0c             	mov    0xc(%ebp),%eax
  2846c2:	0f af 45 08          	imul   0x8(%ebp),%eax
}
  2846c6:	5d                   	pop    %ebp
  2846c7:	c3                   	ret    
