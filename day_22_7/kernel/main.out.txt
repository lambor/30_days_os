
main.out.o:     file format elf32-i386


Disassembly of section .text:

00280000 <bootmain>:
#include "header.h"


int bootmain()
{
  280000:	55                   	push   %ebp
	//the buf for all strings.
	char s[50] = {0};
  280001:	31 c0                	xor    %eax,%eax
  280003:	b9 32 00 00 00       	mov    $0x32,%ecx
#include "header.h"


int bootmain()
{
  280008:	89 e5                	mov    %esp,%ebp
  28000a:	57                   	push   %edi
  28000b:	56                   	push   %esi
	//the buf for all strings.
	char s[50] = {0};
  28000c:	8d bd 36 fc ff ff    	lea    -0x3ca(%ebp),%edi
#include "header.h"


int bootmain()
{
  280012:	53                   	push   %ebx
  280013:	81 ec 5c 04 00 00    	sub    $0x45c,%esp
	//the buf for all strings.
	char s[50] = {0};
  280019:	f3 aa                	rep stos %al,%es:(%edi)
	struct BOOTINFO *binfo = (struct BOOTINFO *)0xff0;

	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
  28001b:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
  280021:	6a 00                	push   $0x0
  280023:	50                   	push   %eax
  280024:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  28002a:	68 80 00 00 00       	push   $0x80
  28002f:	50                   	push   %eax
  280030:	e8 73 1a 00 00       	call   281aa8 <fifo32_init>
	fifo32_init(&keycmd,32,keycmd_buf,0);
  280035:	8d 85 68 fc ff ff    	lea    -0x398(%ebp),%eax
  28003b:	6a 00                	push   $0x0
  28003d:	50                   	push   %eax
  28003e:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  280044:	6a 20                	push   $0x20
  280046:	50                   	push   %eax
  280047:	e8 5c 1a 00 00       	call   281aa8 <fifo32_init>
	
	int key_leds = (binfo->leds>>4)&7;
  28004c:	a0 f1 0f 00 00       	mov    0xff1,%al

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280051:	83 c4 18             	add    $0x18,%esp
  280054:	68 ed 00 00 00       	push   $0xed
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
	fifo32_init(&keycmd,32,keycmd_buf,0);
	
	int key_leds = (binfo->leds>>4)&7;
  280059:	c0 f8 04             	sar    $0x4,%al
  28005c:	83 e0 07             	and    $0x7,%eax
  28005f:	89 85 e0 fb ff ff    	mov    %eax,-0x420(%ebp)

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280065:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  28006b:	50                   	push   %eax
  28006c:	e8 68 1a 00 00       	call   281ad9 <fifo32_put>
	fifo32_put(&keycmd,key_leds);
  280071:	58                   	pop    %eax
  280072:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  280078:	5a                   	pop    %edx
  280079:	ff b5 e0 fb ff ff    	pushl  -0x420(%ebp)
  28007f:	50                   	push   %eax
  280080:	e8 54 1a 00 00       	call   281ad9 <fifo32_put>

	//init gdt idt pic and enable cpu interrupt
	init_gdtidt();
  280085:	e8 70 13 00 00       	call   2813fa <init_gdtidt>
	init_pic();
  28008a:	e8 2f 15 00 00       	call   2815be <init_pic>
	io_sti();
  28008f:	e8 c0 0a 00 00       	call   280b54 <io_sti>

	//init keyboard and mouse
	init_keyboard(&fifo,256);
  280094:	59                   	pop    %ecx
  280095:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  28009b:	5b                   	pop    %ebx
  28009c:	68 00 01 00 00       	push   $0x100
  2800a1:	50                   	push   %eax
  2800a2:	e8 3b 1c 00 00       	call   281ce2 <init_keyboard>
	struct MOUSE_DEC mdec;
	enable_mouse(&fifo,512,&mdec);
  2800a7:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  2800ad:	83 c4 0c             	add    $0xc,%esp
  2800b0:	50                   	push   %eax
  2800b1:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  2800b7:	68 00 02 00 00       	push   $0x200
  2800bc:	50                   	push   %eax
  2800bd:	e8 d2 1a 00 00       	call   281b94 <enable_mouse>
	
	//init timer
	init_pit();
  2800c2:	e8 e4 27 00 00       	call   2828ab <init_pit>
	
	io_out8(PIC0_IMR,0xf8);
  2800c7:	5e                   	pop    %esi
  2800c8:	5f                   	pop    %edi
  2800c9:	68 f8 00 00 00       	push   $0xf8
  2800ce:	6a 21                	push   $0x21
  2800d0:	e8 b1 0a 00 00       	call   280b86 <io_out8>
	io_out8(PIC1_IMR,0xef);
  2800d5:	58                   	pop    %eax
  2800d6:	5a                   	pop    %edx
  2800d7:	68 ef 00 00 00       	push   $0xef
  2800dc:	68 a1 00 00 00       	push   $0xa1
  2800e1:	e8 a0 0a 00 00       	call   280b86 <io_out8>

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800e6:	59                   	pop    %ecx
  2800e7:	5b                   	pop    %ebx
  2800e8:	68 ff ff ff bf       	push   $0xbfffffff
  2800ed:	68 00 00 40 00       	push   $0x400000
  2800f2:	e8 85 1c 00 00       	call   281d7c <memtest>
	memman_init(memman);
  2800f7:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
	io_out8(PIC1_IMR,0xef);

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800fe:	89 c7                	mov    %eax,%edi
	memman_init(memman);
  280100:	e8 b6 1d 00 00       	call   281ebb <memman_init>
	//init memman with two mem block:0x00001000-0x0009efff and 0x00400000-memtotal
	memman_free(memman,0x00001000,0x0009e000);
  280105:	83 c4 0c             	add    $0xc,%esp
  280108:	68 00 e0 09 00       	push   $0x9e000
  28010d:	68 00 10 00 00       	push   $0x1000
  280112:	68 00 00 3c 00       	push   $0x3c0000
  280117:	e8 ee 1e 00 00       	call   28200a <memman_free>
	memman_free(memman,0x00400000,memtotal-0x00400000);
  28011c:	8d 87 00 00 c0 ff    	lea    -0x400000(%edi),%eax
  280122:	83 c4 0c             	add    $0xc,%esp
  280125:	50                   	push   %eax
  280126:	68 00 00 40 00       	push   $0x400000
  28012b:	68 00 00 3c 00       	push   $0x3c0000
  280130:	e8 d5 1e 00 00       	call   28200a <memman_free>
	struct SHTCTL *shtctl;
	struct SHEET *sht_bg, *sht_mouse, *sht_window, *sht_console;
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;
	
	init_palette();
  280135:	e8 81 0b 00 00       	call   280cbb <init_palette>
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  28013a:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  280141:	50                   	push   %eax
  280142:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280149:	50                   	push   %eax
  28014a:	ff 35 f8 0f 00 00    	pushl  0xff8
  280150:	68 00 00 3c 00       	push   $0x3c0000
  280155:	e8 5e 21 00 00       	call   2822b8 <shtctl_init>
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  28015a:	83 c4 14             	add    $0x14,%esp
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;
	
	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	*((int *)0x0fe4) = (int)shtctl;
  28015d:	a3 e4 0f 00 00       	mov    %eax,0xfe4
	struct SHEET *sht_bg, *sht_mouse, *sht_window, *sht_console;
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;
	
	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  280162:	89 c6                	mov    %eax,%esi
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  280164:	68 00 00 3c 00       	push   $0x3c0000
  280169:	e8 bc 2b 00 00       	call   282d2a <task_init>
	fifo.task = task_a;
	task_run(task_a,1,0);
  28016e:	83 c4 0c             	add    $0xc,%esp
	struct TASK *task_a, *task_console;
	
	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  280171:	89 85 a8 fb ff ff    	mov    %eax,-0x458(%ebp)
	fifo.task = task_a;
  280177:	89 85 14 fc ff ff    	mov    %eax,-0x3ec(%ebp)
	task_run(task_a,1,0);
  28017d:	6a 00                	push   $0x0
  28017f:	6a 01                	push   $0x1
  280181:	50                   	push   %eax
  280182:	e8 10 2b 00 00       	call   282c97 <task_run>

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
  280187:	89 34 24             	mov    %esi,(%esp)
  28018a:	e8 bd 21 00 00       	call   28234c <sheet_alloc>
  28018f:	89 85 c0 fb ff ff    	mov    %eax,-0x440(%ebp)
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  280195:	58                   	pop    %eax
  280196:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  28019d:	5a                   	pop    %edx
  28019e:	0f bf 15 f4 0f 00 00 	movswl 0xff4,%edx
  2801a5:	0f af c2             	imul   %edx,%eax
  2801a8:	50                   	push   %eax
  2801a9:	68 00 00 3c 00       	push   $0x3c0000
  2801ae:	e8 aa 20 00 00       	call   28225d <memman_alloc_4k>
  2801b3:	89 c3                	mov    %eax,%ebx
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
  2801b5:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801bc:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  2801c3:	50                   	push   %eax
  2801c4:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801cb:	50                   	push   %eax
  2801cc:	53                   	push   %ebx
  2801cd:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2801d3:	e8 db 21 00 00       	call   2823b3 <sheet_setbuf>
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
  2801d8:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801df:	83 c4 1c             	add    $0x1c,%esp
  2801e2:	50                   	push   %eax
  2801e3:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801ea:	50                   	push   %eax
  2801eb:	53                   	push   %ebx
  2801ec:	e8 53 0b 00 00       	call   280d44 <init_screen8>
	
	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
  2801f1:	89 34 24             	mov    %esi,(%esp)
  2801f4:	e8 53 21 00 00       	call   28234c <sheet_alloc>
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  2801f9:	59                   	pop    %ecx
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
	
	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
  2801fa:	89 c3                	mov    %eax,%ebx
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  2801fc:	58                   	pop    %eax
  2801fd:	68 80 20 00 00       	push   $0x2080
  280202:	68 00 00 3c 00       	push   $0x3c0000
  280207:	e8 51 20 00 00       	call   28225d <memman_alloc_4k>
	sheet_setbuf(sht_window,buf_window,144,52,-1);
  28020c:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  280213:	6a 34                	push   $0x34
  280215:	68 90 00 00 00       	push   $0x90
  28021a:	50                   	push   %eax
  28021b:	53                   	push   %ebx
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
	
	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  28021c:	89 85 b8 fb ff ff    	mov    %eax,-0x448(%ebp)
	sheet_setbuf(sht_window,buf_window,144,52,-1);
  280222:	e8 8c 21 00 00       	call   2823b3 <sheet_setbuf>
	make_window8(buf_window,144,52,"task_a",1);
  280227:	83 c4 14             	add    $0x14,%esp
  28022a:	6a 01                	push   $0x1
  28022c:	68 00 3f 28 00       	push   $0x283f00
  280231:	6a 34                	push   $0x34
  280233:	68 90 00 00 00       	push   $0x90
  280238:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  28023e:	e8 92 0d 00 00       	call   280fd5 <make_window8>
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
  280243:	83 c4 18             	add    $0x18,%esp
  280246:	6a 07                	push   $0x7
  280248:	6a 10                	push   $0x10
  28024a:	68 80 00 00 00       	push   $0x80
  28024f:	6a 1c                	push   $0x1c
  280251:	6a 08                	push   $0x8
  280253:	53                   	push   %ebx
  280254:	e8 3f 0f 00 00       	call   281198 <make_textbox8>
	cursor_x = 8;
	cursor_c = COL8_FFFFFF;
	//timer for cursor.
	struct TIMER *timer;
	timer = timer_alloc();
  280259:	83 c4 20             	add    $0x20,%esp
  28025c:	e8 f6 25 00 00       	call   282857 <timer_alloc>
  280261:	89 85 bc fb ff ff    	mov    %eax,-0x444(%ebp)
	timer_init(timer,&fifo,1);
  280267:	50                   	push   %eax
  280268:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  28026e:	6a 01                	push   $0x1
  280270:	50                   	push   %eax
  280271:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280277:	e8 ac 26 00 00       	call   282928 <timer_init>
	timer_settime(timer,50);
  28027c:	58                   	pop    %eax
  28027d:	5a                   	pop    %edx
  28027e:	6a 32                	push   $0x32
  280280:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280286:	e8 b1 26 00 00       	call   28293c <timer_settime>

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  28028b:	89 34 24             	mov    %esi,(%esp)
  28028e:	e8 b9 20 00 00       	call   28234c <sheet_alloc>
  280293:	89 85 b4 fb ff ff    	mov    %eax,-0x44c(%ebp)
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  280299:	8d 85 e8 fc ff ff    	lea    -0x318(%ebp),%eax
  28029f:	c7 04 24 63 00 00 00 	movl   $0x63,(%esp)
  2802a6:	6a 10                	push   $0x10
  2802a8:	6a 10                	push   $0x10
  2802aa:	50                   	push   %eax
  2802ab:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  2802b1:	89 85 e4 fb ff ff    	mov    %eax,-0x41c(%ebp)
  2802b7:	e8 f7 20 00 00       	call   2823b3 <sheet_setbuf>
	init_mouse_cursor8(buf_mouse,99);
  2802bc:	8b 85 e4 fb ff ff    	mov    -0x41c(%ebp),%eax
  2802c2:	83 c4 18             	add    $0x18,%esp
  2802c5:	6a 63                	push   $0x63
  2802c7:	50                   	push   %eax
  2802c8:	e8 e6 0b 00 00       	call   280eb3 <init_mouse_cursor8>
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  2802cd:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2802d4:	b9 02 00 00 00       	mov    $0x2,%ecx
  2802d9:	83 e8 10             	sub    $0x10,%eax
  2802dc:	99                   	cltd   
  2802dd:	f7 f9                	idiv   %ecx
  2802df:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
	int my = (binfo->scrny-28-16)/2;
  2802e5:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax

	//console sheet
	sht_console = sheet_alloc(shtctl);
  2802ec:	89 34 24             	mov    %esi,(%esp)
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
  2802ef:	83 e8 2c             	sub    $0x2c,%eax
  2802f2:	99                   	cltd   
  2802f3:	f7 f9                	idiv   %ecx
  2802f5:	89 85 cc fb ff ff    	mov    %eax,-0x434(%ebp)

	//console sheet
	sht_console = sheet_alloc(shtctl);
  2802fb:	e8 4c 20 00 00       	call   28234c <sheet_alloc>
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
  280300:	59                   	pop    %ecx
  280301:	5e                   	pop    %esi
  280302:	68 00 a5 00 00       	push   $0xa500
  280307:	68 00 00 3c 00       	push   $0x3c0000
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;

	//console sheet
	sht_console = sheet_alloc(shtctl);
  28030c:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
  280312:	e8 46 1f 00 00       	call   28225d <memman_alloc_4k>
	sheet_setbuf(sht_console,buf_console,256,165,-1);
  280317:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  28031e:	68 a5 00 00 00       	push   $0xa5
  280323:	68 00 01 00 00       	push   $0x100
  280328:	50                   	push   %eax
  280329:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;

	//console sheet
	sht_console = sheet_alloc(shtctl);
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
  28032f:	89 85 b0 fb ff ff    	mov    %eax,-0x450(%ebp)
	sheet_setbuf(sht_console,buf_console,256,165,-1);
  280335:	e8 79 20 00 00       	call   2823b3 <sheet_setbuf>
	make_window8(buf_console,256,165,"console",0);
  28033a:	83 c4 14             	add    $0x14,%esp
  28033d:	6a 00                	push   $0x0
  28033f:	68 0c 3f 28 00       	push   $0x283f0c
  280344:	68 a5 00 00 00       	push   $0xa5
  280349:	68 00 01 00 00       	push   $0x100
  28034e:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  280354:	e8 7c 0c 00 00       	call   280fd5 <make_window8>
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
  280359:	83 c4 18             	add    $0x18,%esp
  28035c:	6a 00                	push   $0x0
  28035e:	68 80 00 00 00       	push   $0x80
  280363:	68 f0 00 00 00       	push   $0xf0
  280368:	6a 1c                	push   $0x1c
  28036a:	6a 08                	push   $0x8
  28036c:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280372:	e8 21 0e 00 00       	call   281198 <make_textbox8>
	task_console = task_alloc();
  280377:	83 c4 20             	add    $0x20,%esp
  28037a:	e8 29 27 00 00       	call   282aa8 <task_alloc>
  28037f:	89 c6                	mov    %eax,%esi
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  280381:	50                   	push   %eax
  280382:	50                   	push   %eax
  280383:	68 00 00 01 00       	push   $0x10000
  280388:	68 00 00 3c 00       	push   $0x3c0000
  28038d:	e8 cb 1e 00 00       	call   28225d <memman_alloc_4k>
	task_console->tss.cs = 3*8;
	task_console->tss.ss = 1*8;
	task_console->tss.ds = 1*8;
	task_console->tss.fs = 1*8;
	task_console->tss.gs = 1*8;
	*((int *)(task_console->tss.esp + 4)) = sht_console;
  280392:	8b 8d d4 fb ff ff    	mov    -0x42c(%ebp),%ecx
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
	sheet_setbuf(sht_console,buf_console,256,165,-1);
	make_window8(buf_console,256,165,"console",0);
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
	task_console = task_alloc();
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  280398:	8d 90 f4 ff 00 00    	lea    0xfff4(%eax),%edx
	task_console->tss.eip = (int)&console_task - 0x280000;
  28039e:	c7 46 4c 4b 2f 00 00 	movl   $0x2f4b,0x4c(%esi)
	task_console->tss.es = 1*8;
  2803a5:	c7 46 74 08 00 00 00 	movl   $0x8,0x74(%esi)
	task_console->tss.cs = 3*8;
  2803ac:	c7 46 78 18 00 00 00 	movl   $0x18,0x78(%esi)
	task_console->tss.ds = 1*8;
	task_console->tss.fs = 1*8;
	task_console->tss.gs = 1*8;
	*((int *)(task_console->tss.esp + 4)) = sht_console;
	*((int *)(task_console->tss.esp + 8)) = memtotal;
	task_run(task_console,2,2);
  2803b3:	83 c4 0c             	add    $0xc,%esp
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
	sheet_setbuf(sht_console,buf_console,256,165,-1);
	make_window8(buf_console,256,165,"console",0);
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
	task_console = task_alloc();
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  2803b6:	89 56 64             	mov    %edx,0x64(%esi)
	task_console->tss.eip = (int)&console_task - 0x280000;
	task_console->tss.es = 1*8;
	task_console->tss.cs = 3*8;
	task_console->tss.ss = 1*8;
  2803b9:	c7 46 7c 08 00 00 00 	movl   $0x8,0x7c(%esi)
	task_console->tss.ds = 1*8;
  2803c0:	c7 86 80 00 00 00 08 	movl   $0x8,0x80(%esi)
  2803c7:	00 00 00 
	task_console->tss.fs = 1*8;
  2803ca:	c7 86 84 00 00 00 08 	movl   $0x8,0x84(%esi)
  2803d1:	00 00 00 
	task_console->tss.gs = 1*8;
  2803d4:	c7 86 88 00 00 00 08 	movl   $0x8,0x88(%esi)
  2803db:	00 00 00 
	*((int *)(task_console->tss.esp + 4)) = sht_console;
  2803de:	89 88 f8 ff 00 00    	mov    %ecx,0xfff8(%eax)
	*((int *)(task_console->tss.esp + 8)) = memtotal;
  2803e4:	8b 46 64             	mov    0x64(%esi),%eax
  2803e7:	89 78 08             	mov    %edi,0x8(%eax)
	task_run(task_console,2,2);
  2803ea:	6a 02                	push   $0x2
  2803ec:	6a 02                	push   $0x2
  2803ee:	56                   	push   %esi
  2803ef:	e8 a3 28 00 00       	call   282c97 <task_run>


	sheet_slide(sht_bg,0,0);
  2803f4:	83 c4 0c             	add    $0xc,%esp
  2803f7:	6a 00                	push   $0x0
  2803f9:	6a 00                	push   $0x0
  2803fb:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  280401:	e8 ce 23 00 00       	call   2827d4 <sheet_slide>
	sheet_slide(sht_console,32,4);
  280406:	83 c4 0c             	add    $0xc,%esp
  280409:	6a 04                	push   $0x4
  28040b:	6a 20                	push   $0x20
  28040d:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280413:	e8 bc 23 00 00       	call   2827d4 <sheet_slide>
	sheet_slide(sht_window,	64, 56);
  280418:	83 c4 0c             	add    $0xc,%esp
  28041b:	6a 38                	push   $0x38
  28041d:	6a 40                	push   $0x40
  28041f:	53                   	push   %ebx
  280420:	e8 af 23 00 00       	call   2827d4 <sheet_slide>
	sheet_slide(sht_mouse,mx,my);
  280425:	83 c4 0c             	add    $0xc,%esp
  280428:	ff b5 cc fb ff ff    	pushl  -0x434(%ebp)
  28042e:	ff b5 d0 fb ff ff    	pushl  -0x430(%ebp)
  280434:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  28043a:	e8 95 23 00 00       	call   2827d4 <sheet_slide>
	sheet_updown(sht_bg,0);
  28043f:	58                   	pop    %eax
  280440:	5a                   	pop    %edx
  280441:	6a 00                	push   $0x0
  280443:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  280449:	e8 9d 22 00 00       	call   2826eb <sheet_updown>
	sheet_updown(sht_console,1);
  28044e:	59                   	pop    %ecx
  28044f:	5f                   	pop    %edi
  280450:	6a 01                	push   $0x1
  280452:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280458:	e8 8e 22 00 00       	call   2826eb <sheet_updown>
	sheet_updown(sht_window,2);
  28045d:	58                   	pop    %eax
  28045e:	5a                   	pop    %edx
  28045f:	6a 02                	push   $0x2
  280461:	53                   	push   %ebx
  280462:	e8 84 22 00 00       	call   2826eb <sheet_updown>
	sheet_updown(sht_mouse,3);
  280467:	59                   	pop    %ecx
  280468:	5f                   	pop    %edi
  280469:	6a 03                	push   $0x3
  28046b:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
	sheet_setbuf(sht_window,buf_window,144,52,-1);
	make_window8(buf_window,144,52,"task_a",1);
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
	cursor_x = 8;
  280471:	bf 08 00 00 00       	mov    $0x8,%edi
	sheet_slide(sht_window,	64, 56);
	sheet_slide(sht_mouse,mx,my);
	sheet_updown(sht_bg,0);
	sheet_updown(sht_console,1);
	sheet_updown(sht_window,2);
	sheet_updown(sht_mouse,3);
  280476:	e8 70 22 00 00       	call   2826eb <sheet_updown>

	int key_to = 0,key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  28047b:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
	sheet_slide(sht_window,	64, 56);
	sheet_slide(sht_mouse,mx,my);
	sheet_updown(sht_bg,0);
	sheet_updown(sht_console,1);
	sheet_updown(sht_window,2);
	sheet_updown(sht_mouse,3);
  280481:	83 c4 10             	add    $0x10,%esp
	
	extern struct TIMERCTL timerctl;

	int key_to = 0,key_shift = 0,keycmd_wait = -1;
  280484:	c7 85 c4 fb ff ff ff 	movl   $0xffffffff,-0x43c(%ebp)
  28048b:	ff ff ff 
  28048e:	c7 85 d8 fb ff ff 00 	movl   $0x0,-0x428(%ebp)
  280495:	00 00 00 
  280498:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  28049f:	00 00 00 

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  2804a2:	89 85 c8 fb ff ff    	mov    %eax,-0x438(%ebp)
			keycmd_wait = fifo32_get(&keycmd);
			wait_KBC_sendready();
			io_out8(PORT_KEYDAT,keycmd_wait);
		}
		io_cli();
		if(fifo32_status(&fifo) == 0)
  2804a8:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
	make_window8(buf_window,144,52,"task_a",1);
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
	cursor_x = 8;
	cursor_c = COL8_FFFFFF;
  2804ae:	c7 85 dc fb ff ff 07 	movl   $0x7,-0x424(%ebp)
  2804b5:	00 00 00 
			keycmd_wait = fifo32_get(&keycmd);
			wait_KBC_sendready();
			io_out8(PORT_KEYDAT,keycmd_wait);
		}
		io_cli();
		if(fifo32_status(&fifo) == 0)
  2804b8:	89 85 ac fb ff ff    	mov    %eax,-0x454(%ebp)

	int key_to = 0,key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  2804be:	83 ec 0c             	sub    $0xc,%esp
  2804c1:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2804c7:	e8 ba 16 00 00       	call   281b86 <fifo32_status>
  2804cc:	8b 8d c4 fb ff ff    	mov    -0x43c(%ebp),%ecx
  2804d2:	83 c4 10             	add    $0x10,%esp
  2804d5:	c1 e9 1f             	shr    $0x1f,%ecx
  2804d8:	74 2f                	je     280509 <bootmain+0x509>
  2804da:	85 c0                	test   %eax,%eax
  2804dc:	7e 2b                	jle    280509 <bootmain+0x509>
		{
			keycmd_wait = fifo32_get(&keycmd);
  2804de:	83 ec 0c             	sub    $0xc,%esp
  2804e1:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2804e7:	e8 5f 16 00 00       	call   281b4b <fifo32_get>
  2804ec:	89 85 c4 fb ff ff    	mov    %eax,-0x43c(%ebp)
			wait_KBC_sendready();
  2804f2:	e8 d2 17 00 00       	call   281cc9 <wait_KBC_sendready>
			io_out8(PORT_KEYDAT,keycmd_wait);
  2804f7:	59                   	pop    %ecx
  2804f8:	58                   	pop    %eax
  2804f9:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  2804ff:	6a 60                	push   $0x60
  280501:	e8 80 06 00 00       	call   280b86 <io_out8>
  280506:	83 c4 10             	add    $0x10,%esp
		}
		io_cli();
  280509:	e8 44 06 00 00       	call   280b52 <io_cli>
		if(fifo32_status(&fifo) == 0)
  28050e:	83 ec 0c             	sub    $0xc,%esp
  280511:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280517:	e8 6a 16 00 00       	call   281b86 <fifo32_status>
  28051c:	83 c4 10             	add    $0x10,%esp
  28051f:	85 c0                	test   %eax,%eax
  280521:	75 18                	jne    28053b <bootmain+0x53b>
		{	
			task_sleep(task_a);
  280523:	83 ec 0c             	sub    $0xc,%esp
  280526:	ff b5 a8 fb ff ff    	pushl  -0x458(%ebp)
  28052c:	e8 d8 29 00 00       	call   282f09 <task_sleep>
			io_sti();
  280531:	e8 1e 06 00 00       	call   280b54 <io_sti>
  280536:	e9 ba 05 00 00       	jmp    280af5 <bootmain+0xaf5>
		}
		else
		{
			int i = fifo32_get(&fifo);
  28053b:	83 ec 0c             	sub    $0xc,%esp
  28053e:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280544:	e8 02 16 00 00       	call   281b4b <fifo32_get>
  280549:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
			io_sti();
  28054f:	e8 00 06 00 00       	call   280b54 <io_sti>
			if(256<=i && i<=511)
  280554:	8b 95 a4 fb ff ff    	mov    -0x45c(%ebp),%edx
  28055a:	83 c4 10             	add    $0x10,%esp
  28055d:	8d 82 00 ff ff ff    	lea    -0x100(%edx),%eax
  280563:	3d ff 00 00 00       	cmp    $0xff,%eax
  280568:	0f 87 63 04 00 00    	ja     2809d1 <bootmain+0x9d1>
			{
				xtoa(i-256,s);
  28056e:	8d 8d 36 fc ff ff    	lea    -0x3ca(%ebp),%ecx
  280574:	89 95 9c fb ff ff    	mov    %edx,-0x464(%ebp)
  28057a:	52                   	push   %edx
  28057b:	52                   	push   %edx
  28057c:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
  280582:	51                   	push   %ecx
  280583:	50                   	push   %eax
  280584:	89 8d a0 fb ff ff    	mov    %ecx,-0x460(%ebp)
  28058a:	e8 c7 12 00 00       	call   281856 <xtoa>
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);
  28058f:	8b 8d a0 fb ff ff    	mov    -0x460(%ebp),%ecx
  280595:	83 c4 0c             	add    $0xc,%esp
  280598:	6a 04                	push   $0x4
  28059a:	51                   	push   %ecx
  28059b:	6a 00                	push   $0x0
  28059d:	6a 07                	push   $0x7
  28059f:	6a 10                	push   $0x10
  2805a1:	6a 00                	push   $0x0
  2805a3:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2805a9:	e8 85 0b 00 00       	call   281133 <putfonts8_asc_sht>
				
				s[0] = key_char(i-256,key_shift);
  2805ae:	8b 85 a4 fb ff ff    	mov    -0x45c(%ebp),%eax
  2805b4:	83 c4 18             	add    $0x18,%esp
  2805b7:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  2805bd:	50                   	push   %eax
  2805be:	e8 91 17 00 00       	call   281d54 <key_char>
				s[1] = 0;

				if('A' <= s[0] && s[0] <= 'Z')
  2805c3:	8d 48 bf             	lea    -0x41(%eax),%ecx
  2805c6:	83 c4 10             	add    $0x10,%esp
			if(256<=i && i<=511)
			{
				xtoa(i-256,s);
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);
				
				s[0] = key_char(i-256,key_shift);
  2805c9:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				s[1] = 0;
  2805cf:	c6 85 37 fc ff ff 00 	movb   $0x0,-0x3c9(%ebp)

				if('A' <= s[0] && s[0] <= 'Z')
  2805d6:	8b 95 9c fb ff ff    	mov    -0x464(%ebp),%edx
  2805dc:	80 f9 19             	cmp    $0x19,%cl
  2805df:	77 26                	ja     280607 <bootmain+0x607>
				{
					if((key_leds&4) == 0 && key_shift != 0 ||	//keyboard led off and shift on
  2805e1:	f6 85 e0 fb ff ff 04 	testb  $0x4,-0x420(%ebp)
  2805e8:	75 0b                	jne    2805f5 <bootmain+0x5f5>
  2805ea:	83 bd d8 fb ff ff 00 	cmpl   $0x0,-0x428(%ebp)
  2805f1:	75 0b                	jne    2805fe <bootmain+0x5fe>
  2805f3:	eb 12                	jmp    280607 <bootmain+0x607>
						(key_leds&4) != 0 && key_shift == 0)			//keyboard led on and shift off
  2805f5:	83 bd d8 fb ff ff 00 	cmpl   $0x0,-0x428(%ebp)
  2805fc:	75 09                	jne    280607 <bootmain+0x607>
						s[0] += 0x20;		//uppercase 2 lowercases					
  2805fe:	83 c0 20             	add    $0x20,%eax
  280601:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				}
				if(s[0]!=0)//visible char
  280607:	0f be 85 36 fc ff ff 	movsbl -0x3ca(%ebp),%eax
  28060e:	84 c0                	test   %al,%al
  280610:	74 73                	je     280685 <bootmain+0x685>
				{
					if(key_to == 0 && cursor_x <128)
  280612:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  280619:	75 30                	jne    28064b <bootmain+0x64b>
  28061b:	83 ff 7f             	cmp    $0x7f,%edi
  28061e:	7f 2b                	jg     28064b <bootmain+0x64b>
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF,s,1);
  280620:	8d 85 36 fc ff ff    	lea    -0x3ca(%ebp),%eax
  280626:	51                   	push   %ecx
  280627:	6a 01                	push   $0x1
  280629:	89 95 a4 fb ff ff    	mov    %edx,-0x45c(%ebp)
  28062f:	50                   	push   %eax
  280630:	6a 07                	push   $0x7
  280632:	6a 00                	push   $0x0
  280634:	6a 1c                	push   $0x1c
  280636:	57                   	push   %edi
  280637:	53                   	push   %ebx
						cursor_x += 8;
  280638:	83 c7 08             	add    $0x8,%edi
				}
				if(s[0]!=0)//visible char
				{
					if(key_to == 0 && cursor_x <128)
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF,s,1);
  28063b:	e8 f3 0a 00 00       	call   281133 <putfonts8_asc_sht>
  280640:	83 c4 20             	add    $0x20,%esp
  280643:	8b 95 a4 fb ff ff    	mov    -0x45c(%ebp),%edx
  280649:	eb 3a                	jmp    280685 <bootmain+0x685>
						cursor_x += 8;
					}
					else if(key_to == 1)
  28064b:	83 bd e4 fb ff ff 01 	cmpl   $0x1,-0x41c(%ebp)
  280652:	75 31                	jne    280685 <bootmain+0x685>
					{
						fifo32_put(&task_console->fifo,s[0]+256); //send key to console fifo
  280654:	05 00 01 00 00       	add    $0x100,%eax
  280659:	89 95 a4 fb ff ff    	mov    %edx,-0x45c(%ebp)
  28065f:	52                   	push   %edx
  280660:	52                   	push   %edx
  280661:	50                   	push   %eax
  280662:	8d 46 10             	lea    0x10(%esi),%eax
  280665:	50                   	push   %eax
  280666:	e8 6e 14 00 00       	call   281ad9 <fifo32_put>
					}
					
				}
				if(i == 256 + 0x0f) //tab key
  28066b:	8b 95 a4 fb ff ff    	mov    -0x45c(%ebp),%edx
  280671:	83 c4 10             	add    $0x10,%esp
  280674:	81 fa 0f 01 00 00    	cmp    $0x10f,%edx
  28067a:	0f 85 7f 01 00 00    	jne    2807ff <bootmain+0x7ff>
  280680:	e9 84 00 00 00       	jmp    280709 <bootmain+0x709>
  280685:	81 fa 0f 01 00 00    	cmp    $0x10f,%edx
  28068b:	0f 85 ff 00 00 00    	jne    280790 <bootmain+0x790>
				{
					if(key_to == 0)
  280691:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  280698:	75 6f                	jne    280709 <bootmain+0x709>
					{
						//switch to task_console window
						key_to = 1;
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",0);
  28069a:	6a 00                	push   $0x0
  28069c:	68 00 3f 28 00       	push   $0x283f00
  2806a1:	ff 73 04             	pushl  0x4(%ebx)
  2806a4:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  2806aa:	e8 6e 08 00 00       	call   280f1d <make_wtitle8>
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",1);
  2806af:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  2806b5:	6a 01                	push   $0x1
  2806b7:	68 07 3f 28 00       	push   $0x283f07
  2806bc:	ff 70 04             	pushl  0x4(%eax)
  2806bf:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  2806c5:	e8 53 08 00 00       	call   280f1d <make_wtitle8>
						cursor_c = -1;	//set cursor color to null(-1) to hide
						boxfill8(sht_window->buf,sht_window->bxsize,COL8_FFFFFF,cursor_x,28,cursor_x+7,43);
  2806ca:	8d 47 07             	lea    0x7(%edi),%eax
  2806cd:	83 c4 1c             	add    $0x1c,%esp
  2806d0:	6a 2b                	push   $0x2b
  2806d2:	50                   	push   %eax
  2806d3:	6a 1c                	push   $0x1c
  2806d5:	57                   	push   %edi
  2806d6:	6a 07                	push   $0x7
  2806d8:	ff 73 04             	pushl  0x4(%ebx)
  2806db:	ff 33                	pushl  (%ebx)
  2806dd:	e8 f2 05 00 00       	call   280cd4 <boxfill8>
						fifo32_put(&task_console->fifo,2); //wake console cursor
  2806e2:	8d 46 10             	lea    0x10(%esi),%eax
  2806e5:	83 c4 18             	add    $0x18,%esp
  2806e8:	6a 02                	push   $0x2
  2806ea:	50                   	push   %eax
  2806eb:	e8 e9 13 00 00       	call   281ad9 <fifo32_put>
  2806f0:	83 c4 10             	add    $0x10,%esp
				if(i == 256 + 0x0f) //tab key
				{
					if(key_to == 0)
					{
						//switch to task_console window
						key_to = 1;
  2806f3:	c7 85 e4 fb ff ff 01 	movl   $0x1,-0x41c(%ebp)
  2806fa:	00 00 00 
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",0);
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",1);
						cursor_c = -1;	//set cursor color to null(-1) to hide
  2806fd:	c7 85 dc fb ff ff ff 	movl   $0xffffffff,-0x424(%ebp)
  280704:	ff ff ff 
  280707:	eb 55                	jmp    28075e <bootmain+0x75e>
					}
					else
					{
						//back to task_a window
						key_to = 0;
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",1);
  280709:	6a 01                	push   $0x1
  28070b:	68 00 3f 28 00       	push   $0x283f00
  280710:	ff 73 04             	pushl  0x4(%ebx)
  280713:	ff b5 b8 fb ff ff    	pushl  -0x448(%ebp)
  280719:	e8 ff 07 00 00       	call   280f1d <make_wtitle8>
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",0);
  28071e:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  280724:	6a 00                	push   $0x0
  280726:	68 07 3f 28 00       	push   $0x283f07
  28072b:	ff 70 04             	pushl  0x4(%eax)
  28072e:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  280734:	e8 e4 07 00 00       	call   280f1d <make_wtitle8>
						cursor_c = COL8_000000;//show the cursor
						fifo32_put(&task_console->fifo,3); //stop console cursor
  280739:	8d 46 10             	lea    0x10(%esi),%eax
  28073c:	83 c4 18             	add    $0x18,%esp
  28073f:	6a 03                	push   $0x3
  280741:	50                   	push   %eax
  280742:	e8 92 13 00 00       	call   281ad9 <fifo32_put>
  280747:	83 c4 10             	add    $0x10,%esp
						fifo32_put(&task_console->fifo,2); //wake console cursor
					}
					else
					{
						//back to task_a window
						key_to = 0;
  28074a:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  280751:	00 00 00 
						make_wtitle8(buf_window,sht_window->bxsize,"task_a",1);
						make_wtitle8(buf_console,sht_console->bxsize,"task_console",0);
						cursor_c = COL8_000000;//show the cursor
  280754:	c7 85 dc fb ff ff 00 	movl   $0x0,-0x424(%ebp)
  28075b:	00 00 00 
						fifo32_put(&task_console->fifo,3); //stop console cursor
					}
					sheet_refresh(sht_window,0,0,sht_window->bxsize,21);
  28075e:	83 ec 0c             	sub    $0xc,%esp
  280761:	6a 15                	push   $0x15
  280763:	ff 73 04             	pushl  0x4(%ebx)
  280766:	6a 00                	push   $0x0
  280768:	6a 00                	push   $0x0
  28076a:	53                   	push   %ebx
  28076b:	e8 42 1f 00 00       	call   2826b2 <sheet_refresh>
					sheet_refresh(sht_console,0,0,sht_console->bxsize,21);
  280770:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  280776:	83 c4 14             	add    $0x14,%esp
  280779:	6a 15                	push   $0x15
  28077b:	ff 70 04             	pushl  0x4(%eax)
  28077e:	6a 00                	push   $0x0
  280780:	6a 00                	push   $0x0
  280782:	50                   	push   %eax
  280783:	e8 2a 1f 00 00       	call   2826b2 <sheet_refresh>
  280788:	83 c4 20             	add    $0x20,%esp
  28078b:	e9 bc 01 00 00       	jmp    28094c <bootmain+0x94c>
				}
			 	else if(i == 256 + 0x0e) //back key
  280790:	81 fa 0e 01 00 00    	cmp    $0x10e,%edx
  280796:	75 6f                	jne    280807 <bootmain+0x807>
				{
					if(key_to == 0 && cursor_x >8)
  280798:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  28079f:	75 2f                	jne    2807d0 <bootmain+0x7d0>
  2807a1:	83 ff 08             	cmp    $0x8,%edi
  2807a4:	7e 2a                	jle    2807d0 <bootmain+0x7d0>
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF," ",1);
  2807a6:	50                   	push   %eax
  2807a7:	6a 01                	push   $0x1
  2807a9:	68 e3 42 28 00       	push   $0x2842e3
  2807ae:	6a 07                	push   $0x7
  2807b0:	6a 00                	push   $0x0
  2807b2:	6a 1c                	push   $0x1c
  2807b4:	57                   	push   %edi
  2807b5:	53                   	push   %ebx
						cursor_x -= 8;
  2807b6:	83 ef 08             	sub    $0x8,%edi
				}
			 	else if(i == 256 + 0x0e) //back key
				{
					if(key_to == 0 && cursor_x >8)
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF," ",1);
  2807b9:	e8 75 09 00 00       	call   281133 <putfonts8_asc_sht>
  2807be:	83 c4 20             	add    $0x20,%esp
  2807c1:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  2807c8:	00 00 00 
  2807cb:	e9 7c 01 00 00       	jmp    28094c <bootmain+0x94c>
						cursor_x -= 8;
					}
					else if(key_to == 1)
  2807d0:	83 bd e4 fb ff ff 01 	cmpl   $0x1,-0x41c(%ebp)
  2807d7:	0f 85 6f 01 00 00    	jne    28094c <bootmain+0x94c>
					{
						fifo32_put(&task_console->fifo,8+256);
  2807dd:	50                   	push   %eax
  2807de:	50                   	push   %eax
  2807df:	8d 46 10             	lea    0x10(%esi),%eax
  2807e2:	68 08 01 00 00       	push   $0x108
  2807e7:	50                   	push   %eax
  2807e8:	e8 ec 12 00 00       	call   281ad9 <fifo32_put>
  2807ed:	83 c4 10             	add    $0x10,%esp
  2807f0:	c7 85 e4 fb ff ff 01 	movl   $0x1,-0x41c(%ebp)
  2807f7:	00 00 00 
  2807fa:	e9 4d 01 00 00       	jmp    28094c <bootmain+0x94c>
						fifo32_put(&task_console->fifo,3); //stop console cursor
					}
					sheet_refresh(sht_window,0,0,sht_window->bxsize,21);
					sheet_refresh(sht_console,0,0,sht_console->bxsize,21);
				}
			 	else if(i == 256 + 0x0e) //back key
  2807ff:	81 fa 0e 01 00 00    	cmp    $0x10e,%edx
  280805:	74 d6                	je     2807dd <bootmain+0x7dd>
					else if(key_to == 1)
					{
						fifo32_put(&task_console->fifo,8+256);
					}
				}
				else if(i == 256 + 0x1c)  //return key
  280807:	81 fa 1c 01 00 00    	cmp    $0x11c,%edx
  28080d:	75 1a                	jne    280829 <bootmain+0x829>
				{
					if(key_to!=0) //forcus on task_console window
  28080f:	83 bd e4 fb ff ff 00 	cmpl   $0x0,-0x41c(%ebp)
  280816:	0f 84 30 01 00 00    	je     28094c <bootmain+0x94c>
					{
						fifo32_put(&task_console->fifo,10+256);
  28081c:	8d 46 10             	lea    0x10(%esi),%eax
  28081f:	51                   	push   %ecx
  280820:	51                   	push   %ecx
  280821:	68 0a 01 00 00       	push   $0x10a
  280826:	50                   	push   %eax
  280827:	eb 7f                	jmp    2808a8 <bootmain+0x8a8>
					}
				}
				else if(i == 256 + 0x2a)  //left shift on
  280829:	81 fa 2a 01 00 00    	cmp    $0x12a,%edx
  28082f:	75 0c                	jne    28083d <bootmain+0x83d>
				{
					key_shift |= 1;
  280831:	83 8d d8 fb ff ff 01 	orl    $0x1,-0x428(%ebp)
  280838:	e9 0f 01 00 00       	jmp    28094c <bootmain+0x94c>
				} 
				else if(i == 256 + 0x36) //right shift on
  28083d:	81 fa 36 01 00 00    	cmp    $0x136,%edx
  280843:	75 0c                	jne    280851 <bootmain+0x851>
				{
					key_shift |= 2;
  280845:	83 8d d8 fb ff ff 02 	orl    $0x2,-0x428(%ebp)
  28084c:	e9 fb 00 00 00       	jmp    28094c <bootmain+0x94c>
				}
				else if(i == 256 + 0xaa)  //left shift off
  280851:	81 fa aa 01 00 00    	cmp    $0x1aa,%edx
  280857:	75 0c                	jne    280865 <bootmain+0x865>
				{
					key_shift &= ~1;
  280859:	83 a5 d8 fb ff ff fe 	andl   $0xfffffffe,-0x428(%ebp)
  280860:	e9 e7 00 00 00       	jmp    28094c <bootmain+0x94c>
				} 
				else if(i == 256 + 0xb6) //right shift off
  280865:	81 fa b6 01 00 00    	cmp    $0x1b6,%edx
  28086b:	75 0c                	jne    280879 <bootmain+0x879>
				{
					key_shift &= ~2;
  28086d:	83 a5 d8 fb ff ff fd 	andl   $0xfffffffd,-0x428(%ebp)
  280874:	e9 d3 00 00 00       	jmp    28094c <bootmain+0x94c>
				}
				else if(i == 256 + 0x3a) //CapsLock
  280879:	81 fa 3a 01 00 00    	cmp    $0x13a,%edx
  28087f:	75 34                	jne    2808b5 <bootmain+0x8b5>
				{
					key_leds ^= 4;
  280881:	83 b5 e0 fb ff ff 04 	xorl   $0x4,-0x420(%ebp)
					fifo32_put(&keycmd,KEYCMD_LED);
  280888:	51                   	push   %ecx
  280889:	51                   	push   %ecx
  28088a:	68 ed 00 00 00       	push   $0xed
  28088f:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  280895:	e8 3f 12 00 00       	call   281ad9 <fifo32_put>
					fifo32_put(&keycmd,key_leds);
  28089a:	58                   	pop    %eax
  28089b:	5a                   	pop    %edx
  28089c:	ff b5 e0 fb ff ff    	pushl  -0x420(%ebp)
  2808a2:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2808a8:	e8 2c 12 00 00       	call   281ad9 <fifo32_put>
  2808ad:	83 c4 10             	add    $0x10,%esp
  2808b0:	e9 97 00 00 00       	jmp    28094c <bootmain+0x94c>
				}
				else if(i == 256 + 0x45) //NumLock
  2808b5:	81 fa 45 01 00 00    	cmp    $0x145,%edx
  2808bb:	75 09                	jne    2808c6 <bootmain+0x8c6>
				{
					key_leds ^= 2;
  2808bd:	83 b5 e0 fb ff ff 02 	xorl   $0x2,-0x420(%ebp)
  2808c4:	eb c2                	jmp    280888 <bootmain+0x888>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x46) //ScrollLock
  2808c6:	81 fa 46 01 00 00    	cmp    $0x146,%edx
  2808cc:	75 09                	jne    2808d7 <bootmain+0x8d7>
				{
					key_leds ^= 1;
  2808ce:	83 b5 e0 fb ff ff 01 	xorl   $0x1,-0x420(%ebp)
  2808d5:	eb b1                	jmp    280888 <bootmain+0x888>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0xfa)
  2808d7:	81 fa fa 01 00 00    	cmp    $0x1fa,%edx
  2808dd:	74 63                	je     280942 <bootmain+0x942>
				{
					keycmd_wait = -1;
				}
				else if(i == 256 + 0xfe)
  2808df:	81 fa fe 01 00 00    	cmp    $0x1fe,%edx
  2808e5:	75 16                	jne    2808fd <bootmain+0x8fd>
				{
					wait_KBC_sendready();
  2808e7:	e8 dd 13 00 00       	call   281cc9 <wait_KBC_sendready>
					io_out8(PORT_KEYDAT,keycmd_wait);
  2808ec:	52                   	push   %edx
  2808ed:	52                   	push   %edx
  2808ee:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  2808f4:	6a 60                	push   $0x60
  2808f6:	e8 8b 02 00 00       	call   280b86 <io_out8>
  2808fb:	eb b0                	jmp    2808ad <bootmain+0x8ad>
				}
				else if(i == 256 + 0x3b && key_shift != 0 && task_console->tss.esp0 != 0)	//shift + F1
  2808fd:	81 fa 3b 01 00 00    	cmp    $0x13b,%edx
  280903:	75 47                	jne    28094c <bootmain+0x94c>
  280905:	83 bd d8 fb ff ff 00 	cmpl   $0x0,-0x428(%ebp)
  28090c:	74 3e                	je     28094c <bootmain+0x94c>
  28090e:	83 7e 30 00          	cmpl   $0x0,0x30(%esi)
  280912:	74 38                	je     28094c <bootmain+0x94c>
				{
					struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
					extern void asm_end_app();
					cons_putstr0(cons,"\nBreak(key):\n");
  280914:	50                   	push   %eax
  280915:	50                   	push   %eax
  280916:	68 14 3f 28 00       	push   $0x283f14
  28091b:	ff 35 ec 0f 00 00    	pushl  0xfec
  280921:	e8 b3 2f 00 00       	call   2838d9 <cons_putstr0>
					io_cli();
  280926:	e8 27 02 00 00       	call   280b52 <io_cli>
					task_console->tss.eax = (int)&(task_console->tss.esp0);
  28092b:	8d 46 30             	lea    0x30(%esi),%eax
					task_console->tss.eip = (int)asm_end_app;
  28092e:	c7 46 4c 90 2a 28 00 	movl   $0x282a90,0x4c(%esi)
				{
					struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
					extern void asm_end_app();
					cons_putstr0(cons,"\nBreak(key):\n");
					io_cli();
					task_console->tss.eax = (int)&(task_console->tss.esp0);
  280935:	89 46 54             	mov    %eax,0x54(%esi)
					task_console->tss.eip = (int)asm_end_app;
					io_sti();
  280938:	e8 17 02 00 00       	call   280b54 <io_sti>
  28093d:	e9 6b ff ff ff       	jmp    2808ad <bootmain+0x8ad>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0xfa)
				{
					keycmd_wait = -1;
  280942:	c7 85 c4 fb ff ff ff 	movl   $0xffffffff,-0x43c(%ebp)
  280949:	ff ff ff 
					io_cli();
					task_console->tss.eax = (int)&(task_console->tss.esp0);
					task_console->tss.eip = (int)asm_end_app;
					io_sti();
				}
				if(cursor_c >= 0)
  28094c:	83 bd dc fb ff ff 00 	cmpl   $0x0,-0x424(%ebp)
  280953:	78 1d                	js     280972 <bootmain+0x972>
				{
					//show cursor after show character
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
  280955:	50                   	push   %eax
  280956:	8d 47 07             	lea    0x7(%edi),%eax
  280959:	6a 2b                	push   $0x2b
  28095b:	50                   	push   %eax
  28095c:	6a 1c                	push   $0x1c
  28095e:	57                   	push   %edi
  28095f:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280965:	ff 73 04             	pushl  0x4(%ebx)
  280968:	ff 33                	pushl  (%ebx)
  28096a:	e8 65 03 00 00       	call   280cd4 <boxfill8>
  28096f:	83 c4 20             	add    $0x20,%esp
				}
				sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
  280972:	8d 47 08             	lea    0x8(%edi),%eax
  280975:	83 ec 0c             	sub    $0xc,%esp
  280978:	6a 2c                	push   $0x2c
  28097a:	50                   	push   %eax
  28097b:	6a 1c                	push   $0x1c
  28097d:	57                   	push   %edi
  28097e:	53                   	push   %ebx
  28097f:	e8 2e 1d 00 00       	call   2826b2 <sheet_refresh>
				sprintf(s,"%d,%d",key_leds,key_shift);
  280984:	8d 85 36 fc ff ff    	lea    -0x3ca(%ebp),%eax
  28098a:	83 c4 20             	add    $0x20,%esp
  28098d:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280993:	ff b5 e0 fb ff ff    	pushl  -0x420(%ebp)
  280999:	68 22 3f 28 00       	push   $0x283f22
  28099e:	50                   	push   %eax
  28099f:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
  2809a5:	e8 43 0f 00 00       	call   2818ed <sprintf>
				putfonts8_asc_sht(sht_bg,0,32,COL8_FFFFFF,COL8_000000,s,4);
  2809aa:	8b 85 a4 fb ff ff    	mov    -0x45c(%ebp),%eax
  2809b0:	83 c4 0c             	add    $0xc,%esp
  2809b3:	6a 04                	push   $0x4
  2809b5:	50                   	push   %eax
  2809b6:	6a 00                	push   $0x0
  2809b8:	6a 07                	push   $0x7
  2809ba:	6a 20                	push   $0x20
  2809bc:	6a 00                	push   $0x0
  2809be:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2809c4:	e8 6a 07 00 00       	call   281133 <putfonts8_asc_sht>
  2809c9:	83 c4 20             	add    $0x20,%esp
  2809cc:	e9 ed fa ff ff       	jmp    2804be <bootmain+0x4be>

			}
			else if(512<=i && i<=767)
  2809d1:	8d 82 00 fe ff ff    	lea    -0x200(%edx),%eax
  2809d7:	3d ff 00 00 00       	cmp    $0xff,%eax
  2809dc:	0f 87 b5 00 00 00    	ja     280a97 <bootmain+0xa97>
			{
				if(mouse_decode(&mdec,i-512)!=0)
  2809e2:	50                   	push   %eax
  2809e3:	50                   	push   %eax
  2809e4:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  2809ea:	0f b6 d2             	movzbl %dl,%edx
  2809ed:	52                   	push   %edx
  2809ee:	50                   	push   %eax
  2809ef:	e8 ea 11 00 00       	call   281bde <mouse_decode>
  2809f4:	83 c4 10             	add    $0x10,%esp
  2809f7:	85 c0                	test   %eax,%eax
  2809f9:	0f 84 bf fa ff ff    	je     2804be <bootmain+0x4be>
  2809ff:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  280a05:	31 c9                	xor    %ecx,%ecx
  280a07:	03 85 f0 fb ff ff    	add    -0x410(%ebp),%eax
  280a0d:	0f 48 c1             	cmovs  %ecx,%eax
  280a10:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
  280a16:	8b 85 cc fb ff ff    	mov    -0x434(%ebp),%eax
  280a1c:	03 85 f4 fb ff ff    	add    -0x40c(%ebp),%eax
  280a22:	0f 49 c8             	cmovns %eax,%ecx
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  280a25:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280a2c:	39 85 d0 fb ff ff    	cmp    %eax,-0x430(%ebp)
  280a32:	8d 50 ff             	lea    -0x1(%eax),%edx
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  280a35:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  280a3c:	0f 4c 95 d0 fb ff ff 	cmovl  -0x430(%ebp),%edx
  280a43:	89 95 d0 fb ff ff    	mov    %edx,-0x430(%ebp)
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  280a49:	8d 50 ff             	lea    -0x1(%eax),%edx
  280a4c:	39 c1                	cmp    %eax,%ecx
					sheet_slide(sht_mouse,mx,my);
  280a4e:	50                   	push   %eax
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  280a4f:	0f 4c d1             	cmovl  %ecx,%edx
					sheet_slide(sht_mouse,mx,my);
  280a52:	52                   	push   %edx
  280a53:	ff b5 d0 fb ff ff    	pushl  -0x430(%ebp)
  280a59:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  280a5f:	89 95 cc fb ff ff    	mov    %edx,-0x434(%ebp)
					sheet_slide(sht_mouse,mx,my);
  280a65:	e8 6a 1d 00 00       	call   2827d4 <sheet_slide>
					if(mdec.btn & 0x01)
  280a6a:	83 c4 10             	add    $0x10,%esp
  280a6d:	f6 85 f8 fb ff ff 01 	testb  $0x1,-0x408(%ebp)
  280a74:	0f 84 44 fa ff ff    	je     2804be <bootmain+0x4be>
					{
						sheet_slide(sht_window,mx-80,my-8);
  280a7a:	50                   	push   %eax
  280a7b:	8b 85 cc fb ff ff    	mov    -0x434(%ebp),%eax
  280a81:	83 e8 08             	sub    $0x8,%eax
  280a84:	50                   	push   %eax
  280a85:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  280a8b:	83 e8 50             	sub    $0x50,%eax
  280a8e:	50                   	push   %eax
  280a8f:	53                   	push   %ebx
  280a90:	e8 3f 1d 00 00       	call   2827d4 <sheet_slide>
  280a95:	eb 5e                	jmp    280af5 <bootmain+0xaf5>
					}
				}
			}
			else if(i<=1)
  280a97:	83 fa 01             	cmp    $0x1,%edx
  280a9a:	0f 8f 1e fa ff ff    	jg     2804be <bootmain+0x4be>
			{
				if(i != 0)
  280aa0:	85 d2                	test   %edx,%edx
  280aa2:	74 22                	je     280ac6 <bootmain+0xac6>
				{
					timer_init(timer,&fifo,0);
  280aa4:	50                   	push   %eax
  280aa5:	6a 00                	push   $0x0
  280aa7:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280aad:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280ab3:	e8 70 1e 00 00       	call   282928 <timer_init>
					if(cursor_c>=0) cursor_c = COL8_000000;
  280ab8:	83 c4 10             	add    $0x10,%esp
  280abb:	83 bd dc fb ff ff 00 	cmpl   $0x0,-0x424(%ebp)
  280ac2:	79 39                	jns    280afd <bootmain+0xafd>
  280ac4:	eb 20                	jmp    280ae6 <bootmain+0xae6>
				}
				else
				{
					timer_init(timer,&fifo,1);
  280ac6:	51                   	push   %ecx
  280ac7:	6a 01                	push   $0x1
  280ac9:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280acf:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280ad5:	e8 4e 1e 00 00       	call   282928 <timer_init>
					if(cursor_c>=0) cursor_c = COL8_FFFFFF;
  280ada:	83 c4 10             	add    $0x10,%esp
  280add:	83 bd dc fb ff ff 00 	cmpl   $0x0,-0x424(%ebp)
  280ae4:	79 23                	jns    280b09 <bootmain+0xb09>
				if(cursor_c >= 0) // check if the color invalid
				{
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
					sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
				}
				timer_settime(timer,50);
  280ae6:	52                   	push   %edx
  280ae7:	52                   	push   %edx
  280ae8:	6a 32                	push   $0x32
  280aea:	ff b5 bc fb ff ff    	pushl  -0x444(%ebp)
  280af0:	e8 47 1e 00 00       	call   28293c <timer_settime>
  280af5:	83 c4 10             	add    $0x10,%esp
  280af8:	e9 c1 f9 ff ff       	jmp    2804be <bootmain+0x4be>
			else if(i<=1)
			{
				if(i != 0)
				{
					timer_init(timer,&fifo,0);
					if(cursor_c>=0) cursor_c = COL8_000000;
  280afd:	c7 85 dc fb ff ff 00 	movl   $0x0,-0x424(%ebp)
  280b04:	00 00 00 
  280b07:	eb 0a                	jmp    280b13 <bootmain+0xb13>
				}
				else
				{
					timer_init(timer,&fifo,1);
					if(cursor_c>=0) cursor_c = COL8_FFFFFF;
  280b09:	c7 85 dc fb ff ff 07 	movl   $0x7,-0x424(%ebp)
  280b10:	00 00 00 
				}
				if(cursor_c >= 0) // check if the color invalid
				{
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
  280b13:	50                   	push   %eax
  280b14:	8d 47 07             	lea    0x7(%edi),%eax
  280b17:	6a 2b                	push   $0x2b
  280b19:	50                   	push   %eax
  280b1a:	6a 1c                	push   $0x1c
  280b1c:	57                   	push   %edi
  280b1d:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280b23:	ff 73 04             	pushl  0x4(%ebx)
  280b26:	ff 33                	pushl  (%ebx)
  280b28:	e8 a7 01 00 00       	call   280cd4 <boxfill8>
					sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
  280b2d:	8d 47 08             	lea    0x8(%edi),%eax
  280b30:	83 c4 14             	add    $0x14,%esp
  280b33:	6a 2c                	push   $0x2c
  280b35:	50                   	push   %eax
  280b36:	6a 1c                	push   $0x1c
  280b38:	57                   	push   %edi
  280b39:	53                   	push   %ebx
  280b3a:	e8 73 1b 00 00       	call   2826b2 <sheet_refresh>
  280b3f:	83 c4 20             	add    $0x20,%esp
  280b42:	eb a2                	jmp    280ae6 <bootmain+0xae6>
  280b44:	66 90                	xchg   %ax,%ax
  280b46:	66 90                	xchg   %ax,%ax
  280b48:	66 90                	xchg   %ax,%ax
  280b4a:	66 90                	xchg   %ax,%ax
  280b4c:	66 90                	xchg   %ax,%ax
  280b4e:	66 90                	xchg   %ax,%ax

00280b50 <io_hlt>:
  280b50:	f4                   	hlt    
  280b51:	c3                   	ret    

00280b52 <io_cli>:
  280b52:	fa                   	cli    
  280b53:	c3                   	ret    

00280b54 <io_sti>:
  280b54:	fb                   	sti    
  280b55:	c3                   	ret    

00280b56 <io_stihlt>:
  280b56:	fb                   	sti    
  280b57:	f4                   	hlt    
  280b58:	c3                   	ret    

00280b59 <write_mem8>:
  280b59:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  280b5d:	8a 44 24 08          	mov    0x8(%esp),%al
  280b61:	88 01                	mov    %al,(%ecx)
  280b63:	c3                   	ret    

00280b64 <io_in8>:
  280b64:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b68:	b8 00 00 00 00       	mov    $0x0,%eax
  280b6d:	ec                   	in     (%dx),%al
  280b6e:	c3                   	ret    

00280b6f <io_in16>:
  280b6f:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b73:	b8 00 00 00 00       	mov    $0x0,%eax
  280b78:	66 ed                	in     (%dx),%ax
  280b7a:	c3                   	ret    

00280b7b <io_in32>:
  280b7b:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  280b84:	ed                   	in     (%dx),%eax
  280b85:	c3                   	ret    

00280b86 <io_out8>:
  280b86:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b8a:	8b 44 24 08          	mov    0x8(%esp),%eax
  280b8e:	ee                   	out    %al,(%dx)
  280b8f:	c3                   	ret    

00280b90 <io_out16>:
  280b90:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b94:	8b 44 24 08          	mov    0x8(%esp),%eax
  280b98:	66 ef                	out    %ax,(%dx)
  280b9a:	c3                   	ret    

00280b9b <io_out32>:
  280b9b:	8b 54 24 04          	mov    0x4(%esp),%edx
  280b9f:	8b 44 24 08          	mov    0x8(%esp),%eax
  280ba3:	ef                   	out    %eax,(%dx)
  280ba4:	c3                   	ret    

00280ba5 <io_load_eflags>:
  280ba5:	9c                   	pushf  
  280ba6:	58                   	pop    %eax
  280ba7:	c3                   	ret    

00280ba8 <io_store_eflags>:
  280ba8:	8b 44 24 04          	mov    0x4(%esp),%eax
  280bac:	50                   	push   %eax
  280bad:	9d                   	popf   
  280bae:	c3                   	ret    

00280baf <load_gdtr>:
  280baf:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280bb4:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280bb9:	0f 01 54 24 06       	lgdtl  0x6(%esp)
  280bbe:	c3                   	ret    

00280bbf <load_idtr>:
  280bbf:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280bc4:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280bc9:	0f 01 5c 24 06       	lidtl  0x6(%esp)
  280bce:	c3                   	ret    

00280bcf <load_cr0>:
  280bcf:	0f 20 c0             	mov    %cr0,%eax
  280bd2:	c3                   	ret    

00280bd3 <store_cr0>:
  280bd3:	8b 44 24 04          	mov    0x4(%esp),%eax
  280bd7:	0f 22 c0             	mov    %eax,%cr0
  280bda:	c3                   	ret    

00280bdb <_memtest_sub>:
  280bdb:	57                   	push   %edi
  280bdc:	56                   	push   %esi
  280bdd:	53                   	push   %ebx
  280bde:	be 55 aa 55 aa       	mov    $0xaa55aa55,%esi
  280be3:	bf aa 55 aa 55       	mov    $0x55aa55aa,%edi
  280be8:	8b 44 24 10          	mov    0x10(%esp),%eax

00280bec <mts_loop>:
  280bec:	89 c3                	mov    %eax,%ebx
  280bee:	81 c3 fc 0f 00 00    	add    $0xffc,%ebx
  280bf4:	8b 13                	mov    (%ebx),%edx
  280bf6:	89 33                	mov    %esi,(%ebx)
  280bf8:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280bfb:	3b 3b                	cmp    (%ebx),%edi
  280bfd:	75 18                	jne    280c17 <mts_qit>
  280bff:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280c02:	3b 33                	cmp    (%ebx),%esi
  280c04:	75 11                	jne    280c17 <mts_qit>
  280c06:	89 13                	mov    %edx,(%ebx)
  280c08:	05 00 10 00 00       	add    $0x1000,%eax
  280c0d:	3b 44 24 14          	cmp    0x14(%esp),%eax
  280c11:	76 d9                	jbe    280bec <mts_loop>

00280c13 <mts_ret>:
  280c13:	5b                   	pop    %ebx
  280c14:	5e                   	pop    %esi
  280c15:	5f                   	pop    %edi
  280c16:	c3                   	ret    

00280c17 <mts_qit>:
  280c17:	89 13                	mov    %edx,(%ebx)
  280c19:	5b                   	pop    %ebx
  280c1a:	5e                   	pop    %esi
  280c1b:	5f                   	pop    %edi
  280c1c:	c3                   	ret    

00280c1d <set_palette>:
	set_palette(0,15,table_rgb);
	return;	
}

void set_palette(int start, int end, unsigned char *rgb)
{
  280c1d:	55                   	push   %ebp
  280c1e:	89 e5                	mov    %esp,%ebp
  280c20:	57                   	push   %edi
  280c21:	56                   	push   %esi
  280c22:	53                   	push   %ebx
  280c23:	83 ec 1c             	sub    $0x1c,%esp
  280c26:	8b 75 08             	mov    0x8(%ebp),%esi
  280c29:	8b 7d 0c             	mov    0xc(%ebp),%edi
  280c2c:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int i,eflags;
	eflags = io_load_eflags();
  280c2f:	e8 71 ff ff ff       	call   280ba5 <io_load_eflags>
  280c34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	io_cli();
  280c37:	e8 16 ff ff ff       	call   280b52 <io_cli>
	io_out8(0x03c8,start);
  280c3c:	83 ec 08             	sub    $0x8,%esp
  280c3f:	56                   	push   %esi
  280c40:	68 c8 03 00 00       	push   $0x3c8
  280c45:	e8 3c ff ff ff       	call   280b86 <io_out8>
	for(i=start;i<=end;i++)
  280c4a:	83 c4 10             	add    $0x10,%esp
  280c4d:	39 fe                	cmp    %edi,%esi
  280c4f:	7f 54                	jg     280ca5 <set_palette+0x88>
	{
		io_out8(0x03c9,rgb[0]/4);
  280c51:	83 ec 08             	sub    $0x8,%esp
  280c54:	0f b6 03             	movzbl (%ebx),%eax
  280c57:	c0 e8 02             	shr    $0x2,%al
  280c5a:	0f b6 c0             	movzbl %al,%eax
  280c5d:	50                   	push   %eax
  280c5e:	68 c9 03 00 00       	push   $0x3c9
  280c63:	e8 1e ff ff ff       	call   280b86 <io_out8>
		io_out8(0x03c9,rgb[1]/4);
  280c68:	83 c4 08             	add    $0x8,%esp
  280c6b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  280c6f:	c0 e8 02             	shr    $0x2,%al
  280c72:	0f b6 c0             	movzbl %al,%eax
  280c75:	50                   	push   %eax
  280c76:	68 c9 03 00 00       	push   $0x3c9
  280c7b:	e8 06 ff ff ff       	call   280b86 <io_out8>
		io_out8(0x03c9,rgb[2]/4);
  280c80:	83 c4 08             	add    $0x8,%esp
  280c83:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
  280c87:	c0 e8 02             	shr    $0x2,%al
  280c8a:	0f b6 c0             	movzbl %al,%eax
  280c8d:	50                   	push   %eax
  280c8e:	68 c9 03 00 00       	push   $0x3c9
  280c93:	e8 ee fe ff ff       	call   280b86 <io_out8>
		rgb+=3;
  280c98:	83 c3 03             	add    $0x3,%ebx
{
	int i,eflags;
	eflags = io_load_eflags();
	io_cli();
	io_out8(0x03c8,start);
	for(i=start;i<=end;i++)
  280c9b:	83 c6 01             	add    $0x1,%esi
  280c9e:	83 c4 10             	add    $0x10,%esp
  280ca1:	39 f7                	cmp    %esi,%edi
  280ca3:	7d ac                	jge    280c51 <set_palette+0x34>
		io_out8(0x03c9,rgb[0]/4);
		io_out8(0x03c9,rgb[1]/4);
		io_out8(0x03c9,rgb[2]/4);
		rgb+=3;
	}
	io_store_eflags(eflags);
  280ca5:	83 ec 0c             	sub    $0xc,%esp
  280ca8:	ff 75 e4             	pushl  -0x1c(%ebp)
  280cab:	e8 f8 fe ff ff       	call   280ba8 <io_store_eflags>
	return;
  280cb0:	83 c4 10             	add    $0x10,%esp
}
  280cb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280cb6:	5b                   	pop    %ebx
  280cb7:	5e                   	pop    %esi
  280cb8:	5f                   	pop    %edi
  280cb9:	5d                   	pop    %ebp
  280cba:	c3                   	ret    

00280cbb <init_palette>:
#include "graphics.h"

void init_palette(void)
{
  280cbb:	55                   	push   %ebp
  280cbc:	89 e5                	mov    %esp,%ebp
  280cbe:	83 ec 0c             	sub    $0xc,%esp
		0x00, 0x00, 0x84,	//dark blue
		0x84, 0x00, 0x84,	//dark purple
		0x00, 0x84, 0x84,	//dark light blue
		0x84, 0x84, 0x84,	//dark gray
	};
	set_palette(0,15,table_rgb);
  280cc1:	68 20 50 28 00       	push   $0x285020
  280cc6:	6a 0f                	push   $0xf
  280cc8:	6a 00                	push   $0x0
  280cca:	e8 4e ff ff ff       	call   280c1d <set_palette>
	return;	
  280ccf:	83 c4 10             	add    $0x10,%esp
}
  280cd2:	c9                   	leave  
  280cd3:	c3                   	ret    

00280cd4 <boxfill8>:
	io_store_eflags(eflags);
	return;
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
  280cd4:	55                   	push   %ebp
  280cd5:	89 e5                	mov    %esp,%ebp
  280cd7:	57                   	push   %edi
  280cd8:	56                   	push   %esi
  280cd9:	53                   	push   %ebx
  280cda:	83 ec 04             	sub    $0x4,%esp
  280cdd:	8b 55 0c             	mov    0xc(%ebp),%edx
  280ce0:	8b 7d 14             	mov    0x14(%ebp),%edi
  280ce3:	8b 75 18             	mov    0x18(%ebp),%esi
  280ce6:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  280ce9:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
	int x,y;
	for(y=y0;y<=y1;y++)
  280ced:	3b 75 20             	cmp    0x20(%ebp),%esi
  280cf0:	7f 28                	jg     280d1a <boxfill8+0x46>
  280cf2:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280cf5:	0f af d6             	imul   %esi,%edx
  280cf8:	03 55 08             	add    0x8(%ebp),%edx
  280cfb:	eb 15                	jmp    280d12 <boxfill8+0x3e>
	{
		for(x=x0;x<=x1;x++)
			vram[y*xsize+x]=c;
  280cfd:	88 1c 02             	mov    %bl,(%edx,%eax,1)
void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
	{
		for(x=x0;x<=x1;x++)
  280d00:	83 c0 01             	add    $0x1,%eax
  280d03:	39 c1                	cmp    %eax,%ecx
  280d05:	7d f6                	jge    280cfd <boxfill8+0x29>
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
  280d07:	83 c6 01             	add    $0x1,%esi
  280d0a:	03 55 f0             	add    -0x10(%ebp),%edx
  280d0d:	39 75 20             	cmp    %esi,0x20(%ebp)
  280d10:	7c 08                	jl     280d1a <boxfill8+0x46>
	{
		for(x=x0;x<=x1;x++)
  280d12:	89 f8                	mov    %edi,%eax
  280d14:	39 cf                	cmp    %ecx,%edi
  280d16:	7e e5                	jle    280cfd <boxfill8+0x29>
  280d18:	eb ed                	jmp    280d07 <boxfill8+0x33>
			vram[y*xsize+x]=c;
	}
		
	return;
}
  280d1a:	83 c4 04             	add    $0x4,%esp
  280d1d:	5b                   	pop    %ebx
  280d1e:	5e                   	pop    %esi
  280d1f:	5f                   	pop    %edi
  280d20:	5d                   	pop    %ebp
  280d21:	c3                   	ret    

00280d22 <boxfill8_test>:

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
  280d22:	55                   	push   %ebp
  280d23:	89 e5                	mov    %esp,%ebp
  280d25:	53                   	push   %ebx
  280d26:	8b 5d 08             	mov    0x8(%ebp),%ebx
  280d29:	8b 55 10             	mov    0x10(%ebp),%edx
  280d2c:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	int i;
	for(i=0;i<size;i++)
  280d30:	85 d2                	test   %edx,%edx
  280d32:	7e 0d                	jle    280d41 <boxfill8_test+0x1f>
  280d34:	89 d8                	mov    %ebx,%eax
  280d36:	01 da                	add    %ebx,%edx
	{
		vram[i] = c;
  280d38:	88 08                	mov    %cl,(%eax)
  280d3a:	83 c0 01             	add    $0x1,%eax
}

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
	int i;
	for(i=0;i<size;i++)
  280d3d:	39 d0                	cmp    %edx,%eax
  280d3f:	75 f7                	jne    280d38 <boxfill8_test+0x16>
	{
		vram[i] = c;
	}
	//vram[TRY_BG_SIZE-1] = c;
}
  280d41:	5b                   	pop    %ebx
  280d42:	5d                   	pop    %ebp
  280d43:	c3                   	ret    

00280d44 <init_screen8>:

void init_screen8(unsigned char *vram, int xsize, int ysize)
{
  280d44:	55                   	push   %ebp
  280d45:	89 e5                	mov    %esp,%ebp
  280d47:	57                   	push   %edi
  280d48:	56                   	push   %esi
  280d49:	53                   	push   %ebx
  280d4a:	83 ec 14             	sub    $0x14,%esp
  280d4d:	8b 7d 08             	mov    0x8(%ebp),%edi
  280d50:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280d53:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(vram,310,COL8_008484,0,0,310,190);
  280d56:	68 be 00 00 00       	push   $0xbe
  280d5b:	68 36 01 00 00       	push   $0x136
  280d60:	6a 00                	push   $0x0
  280d62:	6a 00                	push   $0x0
  280d64:	6a 0e                	push   $0xe
  280d66:	68 36 01 00 00       	push   $0x136
  280d6b:	57                   	push   %edi
  280d6c:	e8 63 ff ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_008484,0,      0,          xsize-1,    ysize-29);
  280d71:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280d74:	89 c2                	mov    %eax,%edx
  280d76:	8d 46 e3             	lea    -0x1d(%esi),%eax
  280d79:	50                   	push   %eax
  280d7a:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280d7d:	52                   	push   %edx
  280d7e:	6a 00                	push   $0x0
  280d80:	6a 00                	push   $0x0
  280d82:	6a 0e                	push   $0xe
  280d84:	53                   	push   %ebx
  280d85:	57                   	push   %edi
  280d86:	e8 49 ff ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-28,   xsize-1,    ysize-28);
  280d8b:	8d 46 e4             	lea    -0x1c(%esi),%eax
  280d8e:	83 c4 38             	add    $0x38,%esp
  280d91:	50                   	push   %eax
  280d92:	ff 75 f0             	pushl  -0x10(%ebp)
  280d95:	50                   	push   %eax
  280d96:	6a 00                	push   $0x0
  280d98:	6a 08                	push   $0x8
  280d9a:	53                   	push   %ebx
  280d9b:	57                   	push   %edi
  280d9c:	e8 33 ff ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,0,      ysize-27,   xsize-1,    ysize-27);
  280da1:	8d 46 e5             	lea    -0x1b(%esi),%eax
  280da4:	50                   	push   %eax
  280da5:	ff 75 f0             	pushl  -0x10(%ebp)
  280da8:	50                   	push   %eax
  280da9:	6a 00                	push   $0x0
  280dab:	6a 07                	push   $0x7
  280dad:	53                   	push   %ebx
  280dae:	57                   	push   %edi
  280daf:	e8 20 ff ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-26,   xsize-1,    ysize- 1);
  280db4:	83 c4 38             	add    $0x38,%esp
  280db7:	8d 46 ff             	lea    -0x1(%esi),%eax
  280dba:	50                   	push   %eax
  280dbb:	ff 75 f0             	pushl  -0x10(%ebp)
  280dbe:	8d 46 e6             	lea    -0x1a(%esi),%eax
  280dc1:	50                   	push   %eax
  280dc2:	6a 00                	push   $0x0
  280dc4:	6a 08                	push   $0x8
  280dc6:	53                   	push   %ebx
  280dc7:	57                   	push   %edi
  280dc8:	e8 07 ff ff ff       	call   280cd4 <boxfill8>
	
	
	boxfill8(vram,xsize,COL8_FFFFFF,3,      ysize-24,   59,         ysize-24);
  280dcd:	8d 46 e8             	lea    -0x18(%esi),%eax
  280dd0:	50                   	push   %eax
  280dd1:	6a 3b                	push   $0x3b
  280dd3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  280dd6:	50                   	push   %eax
  280dd7:	6a 03                	push   $0x3
  280dd9:	6a 07                	push   $0x7
  280ddb:	53                   	push   %ebx
  280ddc:	57                   	push   %edi
  280ddd:	e8 f2 fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,2,      ysize-24,    2,         ysize- 4);
  280de2:	8d 4e fc             	lea    -0x4(%esi),%ecx
  280de5:	83 c4 38             	add    $0x38,%esp
  280de8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  280deb:	51                   	push   %ecx
  280dec:	6a 02                	push   $0x2
  280dee:	ff 75 f0             	pushl  -0x10(%ebp)
  280df1:	6a 02                	push   $0x2
  280df3:	6a 07                	push   $0x7
  280df5:	53                   	push   %ebx
  280df6:	57                   	push   %edi
  280df7:	e8 d8 fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,3,      ysize- 4,   59,         ysize- 4);
  280dfc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  280dff:	51                   	push   %ecx
  280e00:	6a 3b                	push   $0x3b
  280e02:	51                   	push   %ecx
  280e03:	6a 03                	push   $0x3
  280e05:	6a 0f                	push   $0xf
  280e07:	53                   	push   %ebx
  280e08:	57                   	push   %edi
  280e09:	e8 c6 fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,59,     ysize-23,   59,         ysize- 5);
  280e0e:	8d 56 e9             	lea    -0x17(%esi),%edx
  280e11:	83 c4 38             	add    $0x38,%esp
  280e14:	8d 46 fb             	lea    -0x5(%esi),%eax
  280e17:	50                   	push   %eax
  280e18:	6a 3b                	push   $0x3b
  280e1a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  280e1d:	52                   	push   %edx
  280e1e:	6a 3b                	push   $0x3b
  280e20:	6a 0f                	push   $0xf
  280e22:	53                   	push   %ebx
  280e23:	57                   	push   %edi
  280e24:	e8 ab fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,2,      ysize- 3,   59,         ysize- 3);
  280e29:	83 ee 03             	sub    $0x3,%esi
  280e2c:	56                   	push   %esi
  280e2d:	6a 3b                	push   $0x3b
  280e2f:	56                   	push   %esi
  280e30:	6a 02                	push   $0x2
  280e32:	6a 00                	push   $0x0
  280e34:	53                   	push   %ebx
  280e35:	57                   	push   %edi
  280e36:	e8 99 fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,60,     ysize-24,   60,         ysize- 3);
  280e3b:	83 c4 38             	add    $0x38,%esp
  280e3e:	56                   	push   %esi
  280e3f:	6a 3c                	push   $0x3c
  280e41:	ff 75 f0             	pushl  -0x10(%ebp)
  280e44:	6a 3c                	push   $0x3c
  280e46:	6a 00                	push   $0x0
  280e48:	53                   	push   %ebx
  280e49:	57                   	push   %edi
  280e4a:	e8 85 fe ff ff       	call   280cd4 <boxfill8>
	
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-24,   xsize- 4,   ysize-24);
  280e4f:	8d 4b fc             	lea    -0x4(%ebx),%ecx
  280e52:	8d 53 d1             	lea    -0x2f(%ebx),%edx
  280e55:	8b 45 f0             	mov    -0x10(%ebp),%eax
  280e58:	50                   	push   %eax
  280e59:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  280e5c:	51                   	push   %ecx
  280e5d:	50                   	push   %eax
  280e5e:	89 55 e8             	mov    %edx,-0x18(%ebp)
  280e61:	52                   	push   %edx
  280e62:	6a 0f                	push   $0xf
  280e64:	53                   	push   %ebx
  280e65:	57                   	push   %edi
  280e66:	e8 69 fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-23,   xsize-47,   ysize- 4);
  280e6b:	83 c4 38             	add    $0x38,%esp
  280e6e:	ff 75 ec             	pushl  -0x14(%ebp)
  280e71:	8b 55 e8             	mov    -0x18(%ebp),%edx
  280e74:	52                   	push   %edx
  280e75:	ff 75 e4             	pushl  -0x1c(%ebp)
  280e78:	52                   	push   %edx
  280e79:	6a 0f                	push   $0xf
  280e7b:	53                   	push   %ebx
  280e7c:	57                   	push   %edi
  280e7d:	e8 52 fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize-47,       ysize- 3,   xsize- 4,   ysize- 3);
  280e82:	56                   	push   %esi
  280e83:	ff 75 e0             	pushl  -0x20(%ebp)
  280e86:	56                   	push   %esi
  280e87:	ff 75 e8             	pushl  -0x18(%ebp)
  280e8a:	6a 07                	push   $0x7
  280e8c:	53                   	push   %ebx
  280e8d:	57                   	push   %edi
  280e8e:	e8 41 fe ff ff       	call   280cd4 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
  280e93:	8d 43 fd             	lea    -0x3(%ebx),%eax
  280e96:	83 c4 38             	add    $0x38,%esp
  280e99:	56                   	push   %esi
  280e9a:	50                   	push   %eax
  280e9b:	ff 75 f0             	pushl  -0x10(%ebp)
  280e9e:	50                   	push   %eax
  280e9f:	6a 07                	push   $0x7
  280ea1:	53                   	push   %ebx
  280ea2:	57                   	push   %edi
  280ea3:	e8 2c fe ff ff       	call   280cd4 <boxfill8>
}
  280ea8:	83 c4 1c             	add    $0x1c,%esp
  280eab:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280eae:	5b                   	pop    %ebx
  280eaf:	5e                   	pop    %esi
  280eb0:	5f                   	pop    %edi
  280eb1:	5d                   	pop    %ebp
  280eb2:	c3                   	ret    

00280eb3 <init_mouse_cursor8>:


void init_mouse_cursor8(char *mouse, char bc)
{
  280eb3:	55                   	push   %ebp
  280eb4:	89 e5                	mov    %esp,%ebp
  280eb6:	57                   	push   %edi
  280eb7:	56                   	push   %esi
  280eb8:	53                   	push   %ebx
  280eb9:	83 ec 08             	sub    $0x8,%esp
  280ebc:	8b 75 08             	mov    0x8(%ebp),%esi
  280ebf:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
  280ec3:	89 75 f0             	mov    %esi,-0x10(%ebp)
  280ec6:	8d 86 00 01 00 00    	lea    0x100(%esi),%eax
  280ecc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  280ecf:	eb 38                	jmp    280f09 <init_mouse_cursor8+0x56>
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280ed1:	0f b6 94 03 20 40 28 	movzbl 0x284020(%ebx,%eax,1),%edx
  280ed8:	00 
  280ed9:	80 fa 2a             	cmp    $0x2a,%dl
  280edc:	75 06                	jne    280ee4 <init_mouse_cursor8+0x31>
				mouse[y*16+x] = COL8_000000;
  280ede:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
  280ee2:	eb 15                	jmp    280ef9 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == 'O')
  280ee4:	80 fa 4f             	cmp    $0x4f,%dl
  280ee7:	75 06                	jne    280eef <init_mouse_cursor8+0x3c>
				mouse[y*16+x] = COL8_FFFFFF;
  280ee9:	c6 04 06 07          	movb   $0x7,(%esi,%eax,1)
  280eed:	eb 0a                	jmp    280ef9 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == '.')
  280eef:	80 fa 2e             	cmp    $0x2e,%dl
  280ef2:	75 05                	jne    280ef9 <init_mouse_cursor8+0x46>
				mouse[y*16+x] = bc;
  280ef4:	89 fa                	mov    %edi,%edx
  280ef6:	88 14 06             	mov    %dl,(%esi,%eax,1)
	};
	int x,y;
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
  280ef9:	83 c0 01             	add    $0x1,%eax
  280efc:	83 f8 10             	cmp    $0x10,%eax
  280eff:	75 d0                	jne    280ed1 <init_mouse_cursor8+0x1e>
  280f01:	83 c6 10             	add    $0x10,%esi
        "............*OO*",
        ".............***"
	};
	int x,y;
	
	for(y=0;y<16;y++)
  280f04:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  280f07:	74 0c                	je     280f15 <init_mouse_cursor8+0x62>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
}


void init_mouse_cursor8(char *mouse, char bc)
{
  280f09:	b8 00 00 00 00       	mov    $0x0,%eax
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  280f0e:	89 f3                	mov    %esi,%ebx
  280f10:	2b 5d f0             	sub    -0x10(%ebp),%ebx
  280f13:	eb bc                	jmp    280ed1 <init_mouse_cursor8+0x1e>
			else if(cursor[y][x] == '.')
				mouse[y*16+x] = bc;
		}
	}
	return;
}
  280f15:	83 c4 08             	add    $0x8,%esp
  280f18:	5b                   	pop    %ebx
  280f19:	5e                   	pop    %esi
  280f1a:	5f                   	pop    %edi
  280f1b:	5d                   	pop    %ebp
  280f1c:	c3                   	ret    

00280f1d <make_wtitle8>:
	make_wtitle8(buf,xsize,title,act);
	return;
}

void make_wtitle8(unsigned char *buf,int xsize,char *title,char act)
{
  280f1d:	55                   	push   %ebp
  280f1e:	89 e5                	mov    %esp,%ebp
  280f20:	57                   	push   %edi
  280f21:	56                   	push   %esi
  280f22:	53                   	push   %ebx
  280f23:	83 ec 1c             	sub    $0x1c,%esp
  280f26:	8b 75 08             	mov    0x8(%ebp),%esi
  280f29:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280f2c:	8b 55 14             	mov    0x14(%ebp),%edx
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
		tbc= COL8_848484;
  280f2f:	80 fa 01             	cmp    $0x1,%dl
  280f32:	19 c0                	sbb    %eax,%eax
  280f34:	83 e0 03             	and    $0x3,%eax
  280f37:	83 c0 0c             	add    $0xc,%eax
  280f3a:	80 fa 01             	cmp    $0x1,%dl
  280f3d:	19 ff                	sbb    %edi,%edi
  280f3f:	f7 d7                	not    %edi
  280f41:	83 c7 08             	add    $0x8,%edi
	}
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
  280f44:	6a 14                	push   $0x14
  280f46:	8d 53 fc             	lea    -0x4(%ebx),%edx
  280f49:	52                   	push   %edx
  280f4a:	6a 03                	push   $0x3
  280f4c:	6a 03                	push   $0x3
  280f4e:	0f b6 c0             	movzbl %al,%eax
  280f51:	50                   	push   %eax
  280f52:	53                   	push   %ebx
  280f53:	56                   	push   %esi
  280f54:	e8 7b fd ff ff       	call   280cd4 <boxfill8>
	putfonts8_asc(buf,xsize,24,4,tc,title);
  280f59:	83 c4 04             	add    $0x4,%esp
  280f5c:	ff 75 10             	pushl  0x10(%ebp)
  280f5f:	89 f8                	mov    %edi,%eax
  280f61:	0f be f8             	movsbl %al,%edi
  280f64:	57                   	push   %edi
  280f65:	6a 04                	push   $0x4
  280f67:	6a 18                	push   $0x18
  280f69:	53                   	push   %ebx
  280f6a:	56                   	push   %esi
  280f6b:	e8 b9 03 00 00       	call   281329 <putfonts8_asc>
  280f70:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  280f73:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
  280f76:	01 fb                	add    %edi,%ebx
  280f78:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
  280f7b:	83 c4 30             	add    $0x30,%esp
  280f7e:	be 00 00 00 00       	mov    $0x0,%esi
  280f83:	eb 41                	jmp    280fc6 <make_wtitle8+0xa9>
  280f85:	89 c1                	mov    %eax,%ecx
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
		{
			c=closebtn[y][x];
  280f87:	0f b6 9c 06 40 3f 28 	movzbl 0x283f40(%esi,%eax,1),%ebx
  280f8e:	00 
			if(c == '@') c=COL8_000000;
  280f8f:	ba 00 00 00 00       	mov    $0x0,%edx
  280f94:	80 fb 40             	cmp    $0x40,%bl
  280f97:	74 13                	je     280fac <make_wtitle8+0x8f>
			else if(c == '$') c=COL8_848484;
  280f99:	ba 0f 00 00 00       	mov    $0xf,%edx
  280f9e:	80 fb 24             	cmp    $0x24,%bl
  280fa1:	74 09                	je     280fac <make_wtitle8+0x8f>
			else if(c == 'Q') c=COL8_C6C6C6;
			else c=COL8_FFFFFF;
  280fa3:	80 fb 51             	cmp    $0x51,%bl
  280fa6:	0f 94 c2             	sete   %dl
  280fa9:	83 c2 07             	add    $0x7,%edx
			buf[(5+y)*xsize+(xsize-21+x)] = c;
  280fac:	88 54 0f eb          	mov    %dl,-0x15(%edi,%ecx,1)
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
  280fb0:	83 c0 01             	add    $0x1,%eax
  280fb3:	83 f8 10             	cmp    $0x10,%eax
  280fb6:	75 cd                	jne    280f85 <make_wtitle8+0x68>
  280fb8:	03 7d e4             	add    -0x1c(%ebp),%edi
  280fbb:	83 c6 10             	add    $0x10,%esi
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
  280fbe:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
  280fc4:	74 07                	je     280fcd <make_wtitle8+0xb0>
		tc = COL8_FFFFFF;
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
  280fc6:	b8 00 00 00 00       	mov    $0x0,%eax
  280fcb:	eb b8                	jmp    280f85 <make_wtitle8+0x68>
			else c=COL8_FFFFFF;
			buf[(5+y)*xsize+(xsize-21+x)] = c;
		}
	}
	return;
}
  280fcd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280fd0:	5b                   	pop    %ebx
  280fd1:	5e                   	pop    %esi
  280fd2:	5f                   	pop    %edi
  280fd3:	5d                   	pop    %ebp
  280fd4:	c3                   	ret    

00280fd5 <make_window8>:
	}
	return;
}

void make_window8(unsigned char *buf,int xsize,int ysize,char *title,char act)
{
  280fd5:	55                   	push   %ebp
  280fd6:	89 e5                	mov    %esp,%ebp
  280fd8:	57                   	push   %edi
  280fd9:	56                   	push   %esi
  280fda:	53                   	push   %ebx
  280fdb:	83 ec 1c             	sub    $0x1c,%esp
  280fde:	8b 75 08             	mov    0x8(%ebp),%esi
  280fe1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280fe4:	8b 45 18             	mov    0x18(%ebp),%eax
  280fe7:	89 45 d8             	mov    %eax,-0x28(%ebp)
	boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , xsize - 1, 0  );
  280fea:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280fed:	6a 00                	push   $0x0
  280fef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  280ff2:	50                   	push   %eax
  280ff3:	6a 00                	push   $0x0
  280ff5:	6a 00                	push   $0x0
  280ff7:	6a 08                	push   $0x8
  280ff9:	53                   	push   %ebx
  280ffa:	56                   	push   %esi
  280ffb:	e8 d4 fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , xsize - 2, 1  );
  281000:	8d 53 fe             	lea    -0x2(%ebx),%edx
  281003:	6a 01                	push   $0x1
  281005:	89 55 e0             	mov    %edx,-0x20(%ebp)
  281008:	52                   	push   %edx
  281009:	6a 01                	push   $0x1
  28100b:	6a 01                	push   $0x1
  28100d:	6a 07                	push   $0x7
  28100f:	53                   	push   %ebx
  281010:	56                   	push   %esi
  281011:	e8 be fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , 0     , ysize-1);
  281016:	8b 7d 10             	mov    0x10(%ebp),%edi
  281019:	8d 4f ff             	lea    -0x1(%edi),%ecx
  28101c:	83 c4 38             	add    $0x38,%esp
  28101f:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  281022:	51                   	push   %ecx
  281023:	6a 00                	push   $0x0
  281025:	6a 00                	push   $0x0
  281027:	6a 00                	push   $0x0
  281029:	6a 08                	push   $0x8
  28102b:	53                   	push   %ebx
  28102c:	56                   	push   %esi
  28102d:	e8 a2 fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , 1     , ysize-2);
  281032:	8b 7d 10             	mov    0x10(%ebp),%edi
  281035:	83 ef 02             	sub    $0x2,%edi
  281038:	57                   	push   %edi
  281039:	6a 01                	push   $0x1
  28103b:	6a 01                	push   $0x1
  28103d:	6a 01                	push   $0x1
  28103f:	6a 07                	push   $0x7
  281041:	53                   	push   %ebx
  281042:	56                   	push   %esi
  281043:	e8 8c fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, xsize-2,1     , xsize-2,ysize-2);
  281048:	83 c4 38             	add    $0x38,%esp
  28104b:	57                   	push   %edi
  28104c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  28104f:	52                   	push   %edx
  281050:	6a 01                	push   $0x1
  281052:	52                   	push   %edx
  281053:	6a 0f                	push   $0xf
  281055:	53                   	push   %ebx
  281056:	56                   	push   %esi
  281057:	e8 78 fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, xsize-1,0     , xsize-1,ysize-1);
  28105c:	ff 75 dc             	pushl  -0x24(%ebp)
  28105f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  281062:	50                   	push   %eax
  281063:	6a 00                	push   $0x0
  281065:	50                   	push   %eax
  281066:	6a 00                	push   $0x0
  281068:	53                   	push   %ebx
  281069:	56                   	push   %esi
  28106a:	e8 65 fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 2     , 2     , xsize-3,ysize-3);
  28106f:	83 c4 38             	add    $0x38,%esp
  281072:	8b 55 10             	mov    0x10(%ebp),%edx
  281075:	8d 42 fd             	lea    -0x3(%edx),%eax
  281078:	50                   	push   %eax
  281079:	8d 43 fd             	lea    -0x3(%ebx),%eax
  28107c:	50                   	push   %eax
  28107d:	6a 02                	push   $0x2
  28107f:	6a 02                	push   $0x2
  281081:	6a 08                	push   $0x8
  281083:	53                   	push   %ebx
  281084:	56                   	push   %esi
  281085:	e8 4a fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, 1     , ysize-2,xsize-2,ysize-2);
  28108a:	57                   	push   %edi
  28108b:	ff 75 e0             	pushl  -0x20(%ebp)
  28108e:	57                   	push   %edi
  28108f:	6a 01                	push   $0x1
  281091:	6a 0f                	push   $0xf
  281093:	53                   	push   %ebx
  281094:	56                   	push   %esi
  281095:	e8 3a fc ff ff       	call   280cd4 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, 0     , ysize-1,xsize-1,ysize-1);
  28109a:	83 c4 38             	add    $0x38,%esp
  28109d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  2810a0:	51                   	push   %ecx
  2810a1:	ff 75 e4             	pushl  -0x1c(%ebp)
  2810a4:	51                   	push   %ecx
  2810a5:	6a 00                	push   $0x0
  2810a7:	6a 00                	push   $0x0
  2810a9:	53                   	push   %ebx
  2810aa:	56                   	push   %esi
  2810ab:	e8 24 fc ff ff       	call   280cd4 <boxfill8>
	make_wtitle8(buf,xsize,title,act);
  2810b0:	83 c4 1c             	add    $0x1c,%esp
  2810b3:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  2810b7:	50                   	push   %eax
  2810b8:	ff 75 14             	pushl  0x14(%ebp)
  2810bb:	53                   	push   %ebx
  2810bc:	56                   	push   %esi
  2810bd:	e8 5b fe ff ff       	call   280f1d <make_wtitle8>
	return;
  2810c2:	83 c4 10             	add    $0x10,%esp
}
  2810c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2810c8:	5b                   	pop    %ebx
  2810c9:	5e                   	pop    %esi
  2810ca:	5f                   	pop    %edi
  2810cb:	5d                   	pop    %ebp
  2810cc:	c3                   	ret    

002810cd <putblock8_8>:
	}
	return;
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
  2810cd:	55                   	push   %ebp
  2810ce:	89 e5                	mov    %esp,%ebp
  2810d0:	57                   	push   %edi
  2810d1:	56                   	push   %esi
  2810d2:	53                   	push   %ebx
  2810d3:	83 ec 04             	sub    $0x4,%esp
  2810d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  2810d9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int x,y;
	for(y=0;y<pysize;y++)
  2810dc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  2810e0:	7e 49                	jle    28112b <putblock8_8+0x5e>
  2810e2:	8b 7d 24             	mov    0x24(%ebp),%edi
  2810e5:	8b 4d 20             	mov    0x20(%ebp),%ecx
  2810e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  2810eb:	0f af 45 1c          	imul   0x1c(%ebp),%eax
  2810ef:	03 45 18             	add    0x18(%ebp),%eax
  2810f2:	89 c2                	mov    %eax,%edx
  2810f4:	03 55 08             	add    0x8(%ebp),%edx
  2810f7:	be 00 00 00 00       	mov    $0x0,%esi
  2810fc:	eb 22                	jmp    281120 <putblock8_8+0x53>
  2810fe:	89 5d 10             	mov    %ebx,0x10(%ebp)
		for(x=0;x<pxsize;x++)
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];
  281101:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
  281105:	88 1c 02             	mov    %bl,(%edx,%eax,1)

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
		for(x=0;x<pxsize;x++)
  281108:	83 c0 01             	add    $0x1,%eax
  28110b:	39 45 10             	cmp    %eax,0x10(%ebp)
  28110e:	75 f1                	jne    281101 <putblock8_8+0x34>
  281110:	8b 5d 10             	mov    0x10(%ebp),%ebx
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
  281113:	83 c6 01             	add    $0x1,%esi
  281116:	01 f9                	add    %edi,%ecx
  281118:	03 55 f0             	add    -0x10(%ebp),%edx
  28111b:	39 75 14             	cmp    %esi,0x14(%ebp)
  28111e:	74 0b                	je     28112b <putblock8_8+0x5e>
		for(x=0;x<pxsize;x++)
  281120:	b8 00 00 00 00       	mov    $0x0,%eax
  281125:	85 db                	test   %ebx,%ebx
  281127:	7f d5                	jg     2810fe <putblock8_8+0x31>
  281129:	eb e8                	jmp    281113 <putblock8_8+0x46>
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];

	return;
}
  28112b:	83 c4 04             	add    $0x4,%esp
  28112e:	5b                   	pop    %ebx
  28112f:	5e                   	pop    %esi
  281130:	5f                   	pop    %edi
  281131:	5d                   	pop    %ebp
  281132:	c3                   	ret    

00281133 <putfonts8_asc_sht>:
//b background color
//c font color
void putfonts8_asc_sht(struct SHEET *sht,int x,int y,int c,int b,char *s,int l)
{
  281133:	55                   	push   %ebp
  281134:	89 e5                	mov    %esp,%ebp
  281136:	57                   	push   %edi
  281137:	56                   	push   %esi
  281138:	53                   	push   %ebx
  281139:	83 ec 0c             	sub    $0xc,%esp
  28113c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  28113f:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(sht->buf,sht->bxsize,b,x,y,x+l*8-1,y+15);
  281142:	8b 45 20             	mov    0x20(%ebp),%eax
  281145:	8b 55 0c             	mov    0xc(%ebp),%edx
  281148:	8d 3c c2             	lea    (%edx,%eax,8),%edi
  28114b:	8d 46 0f             	lea    0xf(%esi),%eax
  28114e:	50                   	push   %eax
  28114f:	8d 47 ff             	lea    -0x1(%edi),%eax
  281152:	50                   	push   %eax
  281153:	56                   	push   %esi
  281154:	52                   	push   %edx
  281155:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  281159:	50                   	push   %eax
  28115a:	ff 73 04             	pushl  0x4(%ebx)
  28115d:	ff 33                	pushl  (%ebx)
  28115f:	e8 70 fb ff ff       	call   280cd4 <boxfill8>
	putfonts8_asc(sht->buf,sht->bxsize,x,y,c,s);
  281164:	83 c4 04             	add    $0x4,%esp
  281167:	ff 75 1c             	pushl  0x1c(%ebp)
  28116a:	ff 75 14             	pushl  0x14(%ebp)
  28116d:	56                   	push   %esi
  28116e:	ff 75 0c             	pushl  0xc(%ebp)
  281171:	ff 73 04             	pushl  0x4(%ebx)
  281174:	ff 33                	pushl  (%ebx)
  281176:	e8 ae 01 00 00       	call   281329 <putfonts8_asc>
	sheet_refresh(sht,x,y,x+l*8,y+16);
  28117b:	83 c4 24             	add    $0x24,%esp
  28117e:	8d 46 10             	lea    0x10(%esi),%eax
  281181:	50                   	push   %eax
  281182:	57                   	push   %edi
  281183:	56                   	push   %esi
  281184:	ff 75 0c             	pushl  0xc(%ebp)
  281187:	53                   	push   %ebx
  281188:	e8 25 15 00 00       	call   2826b2 <sheet_refresh>
}
  28118d:	83 c4 20             	add    $0x20,%esp
  281190:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281193:	5b                   	pop    %ebx
  281194:	5e                   	pop    %esi
  281195:	5f                   	pop    %edi
  281196:	5d                   	pop    %ebp
  281197:	c3                   	ret    

00281198 <make_textbox8>:

void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c)
{
  281198:	55                   	push   %ebp
  281199:	89 e5                	mov    %esp,%ebp
  28119b:	57                   	push   %edi
  28119c:	56                   	push   %esi
  28119d:	53                   	push   %ebx
  28119e:	83 ec 18             	sub    $0x18,%esp
  2811a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int x1 = x0 + sx, y1 = y0 + sy;
  2811a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  2811a7:	03 45 14             	add    0x14(%ebp),%eax
  2811aa:	8b 55 10             	mov    0x10(%ebp),%edx
  2811ad:	03 55 18             	add    0x18(%ebp),%edx
  2811b0:	89 d7                	mov    %edx,%edi
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 2, y0 - 3, x1 + 1, y0 - 3);
  2811b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  2811b5:	8d 48 01             	lea    0x1(%eax),%ecx
  2811b8:	8b 75 10             	mov    0x10(%ebp),%esi
  2811bb:	83 ee 03             	sub    $0x3,%esi
  2811be:	8b 55 0c             	mov    0xc(%ebp),%edx
  2811c1:	83 ea 02             	sub    $0x2,%edx
  2811c4:	56                   	push   %esi
  2811c5:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  2811c8:	51                   	push   %ecx
  2811c9:	56                   	push   %esi
  2811ca:	89 55 f0             	mov    %edx,-0x10(%ebp)
  2811cd:	52                   	push   %edx
  2811ce:	6a 0f                	push   $0xf
  2811d0:	ff 73 04             	pushl  0x4(%ebx)
  2811d3:	ff 33                	pushl  (%ebx)
  2811d5:	e8 fa fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 3, y0 - 3, x0 - 3, y1 + 1);
  2811da:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  2811dd:	8d 7f 01             	lea    0x1(%edi),%edi
  2811e0:	89 f9                	mov    %edi,%ecx
  2811e2:	8b 7d 0c             	mov    0xc(%ebp),%edi
  2811e5:	83 ef 03             	sub    $0x3,%edi
  2811e8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  2811eb:	51                   	push   %ecx
  2811ec:	57                   	push   %edi
  2811ed:	56                   	push   %esi
  2811ee:	57                   	push   %edi
  2811ef:	6a 0f                	push   $0xf
  2811f1:	ff 73 04             	pushl  0x4(%ebx)
  2811f4:	ff 33                	pushl  (%ebx)
  2811f6:	e8 d9 fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x0 - 3, y1 + 2, x1 + 1, y1 + 2);
  2811fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  2811fe:	8d 4a 02             	lea    0x2(%edx),%ecx
  281201:	83 c4 38             	add    $0x38,%esp
  281204:	51                   	push   %ecx
  281205:	ff 75 e0             	pushl  -0x20(%ebp)
  281208:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  28120b:	51                   	push   %ecx
  28120c:	57                   	push   %edi
  28120d:	6a 07                	push   $0x7
  28120f:	ff 73 04             	pushl  0x4(%ebx)
  281212:	ff 33                	pushl  (%ebx)
  281214:	e8 bb fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x1 + 2, y0 - 3, x1 + 2, y1 + 2);
  281219:	8b 45 e8             	mov    -0x18(%ebp),%eax
  28121c:	83 c0 02             	add    $0x2,%eax
  28121f:	ff 75 dc             	pushl  -0x24(%ebp)
  281222:	50                   	push   %eax
  281223:	56                   	push   %esi
  281224:	50                   	push   %eax
  281225:	6a 07                	push   $0x7
  281227:	ff 73 04             	pushl  0x4(%ebx)
  28122a:	ff 33                	pushl  (%ebx)
  28122c:	e8 a3 fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 1, y0 - 2, x1 + 0, y0 - 2);
  281231:	8b 75 10             	mov    0x10(%ebp),%esi
  281234:	8d 7e fe             	lea    -0x2(%esi),%edi
  281237:	8b 75 0c             	mov    0xc(%ebp),%esi
  28123a:	83 ee 01             	sub    $0x1,%esi
  28123d:	83 c4 38             	add    $0x38,%esp
  281240:	57                   	push   %edi
  281241:	ff 75 e8             	pushl  -0x18(%ebp)
  281244:	57                   	push   %edi
  281245:	56                   	push   %esi
  281246:	6a 00                	push   $0x0
  281248:	ff 73 04             	pushl  0x4(%ebx)
  28124b:	ff 33                	pushl  (%ebx)
  28124d:	e8 82 fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 2, y0 - 2, x0 - 2, y1 + 0);
  281252:	ff 75 e4             	pushl  -0x1c(%ebp)
  281255:	8b 55 f0             	mov    -0x10(%ebp),%edx
  281258:	52                   	push   %edx
  281259:	57                   	push   %edi
  28125a:	52                   	push   %edx
  28125b:	6a 00                	push   $0x0
  28125d:	ff 73 04             	pushl  0x4(%ebx)
  281260:	ff 33                	pushl  (%ebx)
  281262:	e8 6d fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x0 - 2, y1 + 1, x1 + 0, y1 + 1);
  281267:	83 c4 38             	add    $0x38,%esp
  28126a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  28126d:	50                   	push   %eax
  28126e:	ff 75 e8             	pushl  -0x18(%ebp)
  281271:	50                   	push   %eax
  281272:	ff 75 f0             	pushl  -0x10(%ebp)
  281275:	6a 08                	push   $0x8
  281277:	ff 73 04             	pushl  0x4(%ebx)
  28127a:	ff 33                	pushl  (%ebx)
  28127c:	e8 53 fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x1 + 1, y0 - 2, x1 + 1, y1 + 1);
  281281:	ff 75 ec             	pushl  -0x14(%ebp)
  281284:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  281287:	51                   	push   %ecx
  281288:	57                   	push   %edi
  281289:	51                   	push   %ecx
  28128a:	6a 08                	push   $0x8
  28128c:	ff 73 04             	pushl  0x4(%ebx)
  28128f:	ff 33                	pushl  (%ebx)
  281291:	e8 3e fa ff ff       	call   280cd4 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, c,           x0 - 1, y0 - 1, x1 + 0, y1 + 0);
  281296:	83 c4 38             	add    $0x38,%esp
  281299:	ff 75 e4             	pushl  -0x1c(%ebp)
  28129c:	ff 75 e8             	pushl  -0x18(%ebp)
  28129f:	8b 45 10             	mov    0x10(%ebp),%eax
  2812a2:	83 e8 01             	sub    $0x1,%eax
  2812a5:	50                   	push   %eax
  2812a6:	56                   	push   %esi
  2812a7:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  2812ab:	50                   	push   %eax
  2812ac:	ff 73 04             	pushl  0x4(%ebx)
  2812af:	ff 33                	pushl  (%ebx)
  2812b1:	e8 1e fa ff ff       	call   280cd4 <boxfill8>
    return;
  2812b6:	83 c4 1c             	add    $0x1c,%esp
}
  2812b9:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2812bc:	5b                   	pop    %ebx
  2812bd:	5e                   	pop    %esi
  2812be:	5f                   	pop    %edi
  2812bf:	5d                   	pop    %ebp
  2812c0:	c3                   	ret    

002812c1 <putfont8>:
#include "fontascii.h"
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
  2812c1:	55                   	push   %ebp
  2812c2:	89 e5                	mov    %esp,%ebp
  2812c4:	57                   	push   %edi
  2812c5:	56                   	push   %esi
  2812c6:	53                   	push   %ebx
  2812c7:	83 ec 08             	sub    $0x8,%esp
  2812ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  2812cd:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  2812d0:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  2812d4:	89 fb                	mov    %edi,%ebx
  2812d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  2812d9:	0f af 45 14          	imul   0x14(%ebp),%eax
  2812dd:	03 45 10             	add    0x10(%ebp),%eax
  2812e0:	89 c1                	mov    %eax,%ecx
  2812e2:	03 4d 08             	add    0x8(%ebp),%ecx
  2812e5:	83 c7 10             	add    $0x10,%edi
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
  2812e8:	0f b6 13             	movzbl (%ebx),%edx
		int col = HKK_TABLE_COL-1;
  2812eb:	b8 07 00 00 00       	mov    $0x7,%eax
  2812f0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  2812f3:	89 f1                	mov    %esi,%ecx
  2812f5:	89 de                	mov    %ebx,%esi
  2812f7:	89 cb                	mov    %ecx,%ebx
		for(;col>=0;col--)
		{
			if(d&0x1) p[col] = c;
  2812f9:	f6 c2 01             	test   $0x1,%dl
  2812fc:	74 06                	je     281304 <putfont8+0x43>
  2812fe:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  281301:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
			d=d>>1;
  281304:	d0 ea                	shr    %dl
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
		int col = HKK_TABLE_COL-1;
		for(;col>=0;col--)
  281306:	83 e8 01             	sub    $0x1,%eax
  281309:	83 f8 ff             	cmp    $0xffffffff,%eax
  28130c:	75 eb                	jne    2812f9 <putfont8+0x38>
  28130e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  281311:	89 d8                	mov    %ebx,%eax
  281313:	89 f3                	mov    %esi,%ebx
  281315:	89 c6                	mov    %eax,%esi
  281317:	83 c3 01             	add    $0x1,%ebx
  28131a:	03 4d ec             	add    -0x14(%ebp),%ecx
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
	int i;
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
  28131d:	39 fb                	cmp    %edi,%ebx
  28131f:	75 c7                	jne    2812e8 <putfont8+0x27>
			if(d&0x1) p[col] = c;
			d=d>>1;
		}
	}

}
  281321:	83 c4 08             	add    $0x8,%esp
  281324:	5b                   	pop    %ebx
  281325:	5e                   	pop    %esi
  281326:	5f                   	pop    %edi
  281327:	5d                   	pop    %ebp
  281328:	c3                   	ret    

00281329 <putfonts8_asc>:

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
  281329:	55                   	push   %ebp
  28132a:	89 e5                	mov    %esp,%ebp
  28132c:	57                   	push   %edi
  28132d:	56                   	push   %esi
  28132e:	53                   	push   %ebx
  28132f:	8b 75 10             	mov    0x10(%ebp),%esi
  281332:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  281335:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
	extern char hankaku[];
	for(;*s !=0x00;s++)
  281339:	0f b6 03             	movzbl (%ebx),%eax
  28133c:	84 c0                	test   %al,%al
  28133e:	74 2f                	je     28136f <putfonts8_asc+0x46>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
  281340:	0f be fa             	movsbl %dl,%edi
  281343:	0f b6 c0             	movzbl %al,%eax
  281346:	c1 e0 04             	shl    $0x4,%eax
  281349:	05 60 50 28 00       	add    $0x285060,%eax
  28134e:	50                   	push   %eax
  28134f:	57                   	push   %edi
  281350:	ff 75 14             	pushl  0x14(%ebp)
  281353:	56                   	push   %esi
  281354:	ff 75 0c             	pushl  0xc(%ebp)
  281357:	ff 75 08             	pushl  0x8(%ebp)
  28135a:	e8 62 ff ff ff       	call   2812c1 <putfont8>
		x+=HKK_TABLE_COL;
  28135f:	83 c6 08             	add    $0x8,%esi
}

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
	extern char hankaku[];
	for(;*s !=0x00;s++)
  281362:	83 c3 01             	add    $0x1,%ebx
  281365:	0f b6 03             	movzbl (%ebx),%eax
  281368:	83 c4 18             	add    $0x18,%esp
  28136b:	84 c0                	test   %al,%al
  28136d:	75 d4                	jne    281343 <putfonts8_asc+0x1a>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
		x+=HKK_TABLE_COL;
	}
	return; 
}
  28136f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281372:	5b                   	pop    %ebx
  281373:	5e                   	pop    %esi
  281374:	5f                   	pop    %edi
  281375:	5d                   	pop    %ebp
  281376:	c3                   	ret    

00281377 <set_segmdesc>:
#include "dsctbl.h"
#include "io.h"

void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit,int base,int ar)
{
  281377:	55                   	push   %ebp
  281378:	89 e5                	mov    %esp,%ebp
  28137a:	57                   	push   %edi
  28137b:	56                   	push   %esi
  28137c:	53                   	push   %ebx
  28137d:	8b 55 08             	mov    0x8(%ebp),%edx
  281380:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281383:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281386:	8b 7d 14             	mov    0x14(%ebp),%edi
	if(limit>0xfffff)
  281389:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
  28138f:	76 09                	jbe    28139a <set_segmdesc+0x23>
	{
		ar |= 0x8000;
  281391:	81 cf 00 80 00 00    	or     $0x8000,%edi
		limit /= 0x1000;
  281397:	c1 eb 0c             	shr    $0xc,%ebx
	}
	sd->limit_low = limit&0xffff;
  28139a:	66 89 1a             	mov    %bx,(%edx)
	sd->base_low = base&0xffff;
  28139d:	66 89 4a 02          	mov    %cx,0x2(%edx)
	sd->base_mid = (base>>16) & 0xff;
  2813a1:	89 ce                	mov    %ecx,%esi
  2813a3:	c1 fe 10             	sar    $0x10,%esi
  2813a6:	89 f0                	mov    %esi,%eax
  2813a8:	88 42 04             	mov    %al,0x4(%edx)
	sd->access_right = ar & 0xff;
  2813ab:	89 f8                	mov    %edi,%eax
  2813ad:	88 42 05             	mov    %al,0x5(%edx)
	sd->limit_high = ((limit>>16)&0x0f) | ((ar>>8)&0xf0);
  2813b0:	c1 eb 10             	shr    $0x10,%ebx
  2813b3:	83 e3 0f             	and    $0xf,%ebx
  2813b6:	89 f8                	mov    %edi,%eax
  2813b8:	c1 f8 08             	sar    $0x8,%eax
  2813bb:	83 e0 f0             	and    $0xfffffff0,%eax
  2813be:	09 d8                	or     %ebx,%eax
  2813c0:	88 42 06             	mov    %al,0x6(%edx)
	sd->base_high = (base>>24)&0xff;
  2813c3:	c1 e9 18             	shr    $0x18,%ecx
  2813c6:	88 4a 07             	mov    %cl,0x7(%edx)
	return;
}
  2813c9:	5b                   	pop    %ebx
  2813ca:	5e                   	pop    %esi
  2813cb:	5f                   	pop    %edi
  2813cc:	5d                   	pop    %ebp
  2813cd:	c3                   	ret    

002813ce <set_gatedesc>:

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
  2813ce:	55                   	push   %ebp
  2813cf:	89 e5                	mov    %esp,%ebp
  2813d1:	53                   	push   %ebx
  2813d2:	8b 45 08             	mov    0x8(%ebp),%eax
  2813d5:	8b 55 0c             	mov    0xc(%ebp),%edx
  2813d8:	8b 4d 14             	mov    0x14(%ebp),%ecx
	gd->offset_low = offset & 0xffff;
  2813db:	66 89 10             	mov    %dx,(%eax)
	gd->selector = selector;
  2813de:	8b 5d 10             	mov    0x10(%ebp),%ebx
  2813e1:	66 89 58 02          	mov    %bx,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  2813e5:	89 cb                	mov    %ecx,%ebx
  2813e7:	c1 fb 08             	sar    $0x8,%ebx
  2813ea:	88 58 04             	mov    %bl,0x4(%eax)
	gd->access_right = ar&0xff;
  2813ed:	88 48 05             	mov    %cl,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  2813f0:	c1 ea 10             	shr    $0x10,%edx
  2813f3:	66 89 50 06          	mov    %dx,0x6(%eax)
	return;
}
  2813f7:	5b                   	pop    %ebx
  2813f8:	5d                   	pop    %ebp
  2813f9:	c3                   	ret    

002813fa <init_gdtidt>:

void init_gdtidt(void)
{
  2813fa:	55                   	push   %ebp
  2813fb:	89 e5                	mov    %esp,%ebp
  2813fd:	53                   	push   %ebx
  2813fe:	83 ec 04             	sub    $0x4,%esp
  281401:	bb 00 00 27 00       	mov    $0x270000,%ebx
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
	{
		set_segmdesc(gdt+i,0,0,0);
  281406:	6a 00                	push   $0x0
  281408:	6a 00                	push   $0x0
  28140a:	6a 00                	push   $0x0
  28140c:	53                   	push   %ebx
  28140d:	e8 65 ff ff ff       	call   281377 <set_segmdesc>
  281412:	83 c3 08             	add    $0x8,%ebx
{
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
  281415:	83 c4 10             	add    $0x10,%esp
  281418:	81 fb 00 00 28 00    	cmp    $0x280000,%ebx
  28141e:	75 e6                	jne    281406 <init_gdtidt+0xc>
	{
		set_segmdesc(gdt+i,0,0,0);
	}
	//must be similiar with bootstrap gdt.
	//otherwise the code will run with different segment descriptor.
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
  281420:	68 92 40 00 00       	push   $0x4092
  281425:	6a 00                	push   $0x0
  281427:	6a ff                	push   $0xffffffff
  281429:	68 08 00 27 00       	push   $0x270008
  28142e:	e8 44 ff ff ff       	call   281377 <set_segmdesc>
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
  281433:	68 9a 40 00 00       	push   $0x409a
  281438:	6a 00                	push   $0x0
  28143a:	68 ff ff 0f 00       	push   $0xfffff
  28143f:	68 10 00 27 00       	push   $0x270010
  281444:	e8 2e ff ff ff       	call   281377 <set_segmdesc>
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
  281449:	83 c4 20             	add    $0x20,%esp
  28144c:	68 9a 40 00 00       	push   $0x409a
  281451:	68 00 00 28 00       	push   $0x280000
  281456:	68 ff ff 07 00       	push   $0x7ffff
  28145b:	68 18 00 27 00       	push   $0x270018
  281460:	e8 12 ff ff ff       	call   281377 <set_segmdesc>
	load_gdtr(LIMIT_GDT,ADR_GDT);
  281465:	83 c4 08             	add    $0x8,%esp
  281468:	68 00 00 27 00       	push   $0x270000
  28146d:	68 ff ff 00 00       	push   $0xffff
  281472:	e8 38 f7 ff ff       	call   280baf <load_gdtr>
  281477:	83 c4 10             	add    $0x10,%esp
  28147a:	b8 00 f8 26 00       	mov    $0x26f800,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28147f:	66 c7 00 00 00       	movw   $0x0,(%eax)
	gd->selector = selector;
  281484:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  28148a:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	gd->access_right = ar&0xff;
  28148e:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  281492:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
  281498:	83 c0 08             	add    $0x8,%eax
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
	load_gdtr(LIMIT_GDT,ADR_GDT);

	for(i=0;i<256;i++)
  28149b:	3d 00 00 27 00       	cmp    $0x270000,%eax
  2814a0:	75 dd                	jne    28147f <init_gdtidt+0x85>
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
  2814a2:	b8 4e 17 00 00       	mov    $0x174e,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2814a7:	66 a3 00 f9 26 00    	mov    %ax,0x26f900
	gd->selector = selector;
  2814ad:	66 c7 05 02 f9 26 00 	movw   $0x18,0x26f902
  2814b4:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2814b6:	c6 05 04 f9 26 00 00 	movb   $0x0,0x26f904
	gd->access_right = ar&0xff;
  2814bd:	c6 05 05 f9 26 00 8e 	movb   $0x8e,0x26f905
	gd->offset_high = (offset>>16)&0xffff;
  2814c4:	c1 e8 10             	shr    $0x10,%eax
  2814c7:	66 a3 06 f9 26 00    	mov    %ax,0x26f906
	for(i=0;i<256;i++)
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
  2814cd:	b8 20 17 00 00       	mov    $0x1720,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2814d2:	66 a3 08 f9 26 00    	mov    %ax,0x26f908
	gd->selector = selector;
  2814d8:	66 c7 05 0a f9 26 00 	movw   $0x18,0x26f90a
  2814df:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2814e1:	c6 05 0c f9 26 00 00 	movb   $0x0,0x26f90c
	gd->access_right = ar&0xff;
  2814e8:	c6 05 0d f9 26 00 8e 	movb   $0x8e,0x26f90d
	gd->offset_high = (offset>>16)&0xffff;
  2814ef:	c1 e8 10             	shr    $0x10,%eax
  2814f2:	66 a3 0e f9 26 00    	mov    %ax,0x26f90e
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
  2814f8:	b8 37 17 00 00       	mov    $0x1737,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2814fd:	66 a3 60 f9 26 00    	mov    %ax,0x26f960
	gd->selector = selector;
  281503:	66 c7 05 62 f9 26 00 	movw   $0x18,0x26f962
  28150a:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  28150c:	c6 05 64 f9 26 00 00 	movb   $0x0,0x26f964
	gd->access_right = ar&0xff;
  281513:	c6 05 65 f9 26 00 8e 	movb   $0x8e,0x26f965
	gd->offset_high = (offset>>16)&0xffff;
  28151a:	c1 e8 10             	shr    $0x10,%eax
  28151d:	66 a3 66 f9 26 00    	mov    %ax,0x26f966
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
  281523:	b8 65 17 00 00       	mov    $0x1765,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281528:	66 a3 00 fa 26 00    	mov    %ax,0x26fa00
	gd->selector = selector;
  28152e:	66 c7 05 02 fa 26 00 	movw   $0x18,0x26fa02
  281535:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281537:	c6 05 04 fa 26 00 00 	movb   $0x0,0x26fa04
	gd->access_right = ar&0xff;
  28153e:	c6 05 05 fa 26 00 ee 	movb   $0xee,0x26fa05
	gd->offset_high = (offset>>16)&0xffff;
  281545:	c1 e8 10             	shr    $0x10,%eax
  281548:	66 a3 06 fa 26 00    	mov    %ax,0x26fa06
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
  28154e:	b8 86 17 00 00       	mov    $0x1786,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281553:	66 a3 68 f8 26 00    	mov    %ax,0x26f868
	gd->selector = selector;
  281559:	66 c7 05 6a f8 26 00 	movw   $0x18,0x26f86a
  281560:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281562:	c6 05 6c f8 26 00 00 	movb   $0x0,0x26f86c
	gd->access_right = ar&0xff;
  281569:	c6 05 6d f8 26 00 8e 	movb   $0x8e,0x26f86d
	gd->offset_high = (offset>>16)&0xffff;
  281570:	c1 e8 10             	shr    $0x10,%eax
  281573:	66 a3 6e f8 26 00    	mov    %ax,0x26f86e
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
  281579:	b8 a6 17 00 00       	mov    $0x17a6,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28157e:	66 a3 60 f8 26 00    	mov    %ax,0x26f860
	gd->selector = selector;
  281584:	66 c7 05 62 f8 26 00 	movw   $0x18,0x26f862
  28158b:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  28158d:	c6 05 64 f8 26 00 00 	movb   $0x0,0x26f864
	gd->access_right = ar&0xff;
  281594:	c6 05 65 f8 26 00 8e 	movb   $0x8e,0x26f865
	gd->offset_high = (offset>>16)&0xffff;
  28159b:	c1 e8 10             	shr    $0x10,%eax
  28159e:	66 a3 66 f8 26 00    	mov    %ax,0x26f866
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
	load_idtr(LIMIT_IDT,ADR_IDT);
  2815a4:	83 ec 08             	sub    $0x8,%esp
  2815a7:	68 00 f8 26 00       	push   $0x26f800
  2815ac:	68 ff 07 00 00       	push   $0x7ff
  2815b1:	e8 09 f6 ff ff       	call   280bbf <load_idtr>

	return;
  2815b6:	83 c4 10             	add    $0x10,%esp
}
  2815b9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2815bc:	c9                   	leave  
  2815bd:	c3                   	ret    

002815be <init_pic>:
#include "const.h"
#include "fifo.h"
#include "timer.h"
#include "string.h"
void init_pic(void)
{
  2815be:	55                   	push   %ebp
  2815bf:	89 e5                	mov    %esp,%ebp
  2815c1:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIC0_IMR, 0xff);	//disable all pic0 int
  2815c4:	68 ff 00 00 00       	push   $0xff
  2815c9:	6a 21                	push   $0x21
  2815cb:	e8 b6 f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC1_IMR, 0xff);	//disable all pic1 int
  2815d0:	83 c4 08             	add    $0x8,%esp
  2815d3:	68 ff 00 00 00       	push   $0xff
  2815d8:	68 a1 00 00 00       	push   $0xa1
  2815dd:	e8 a4 f5 ff ff       	call   280b86 <io_out8>

	io_out8(PIC0_ICW1, 0x11);	
  2815e2:	83 c4 08             	add    $0x8,%esp
  2815e5:	6a 11                	push   $0x11
  2815e7:	6a 20                	push   $0x20
  2815e9:	e8 98 f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC0_ICW2, 0x20);
  2815ee:	83 c4 08             	add    $0x8,%esp
  2815f1:	6a 20                	push   $0x20
  2815f3:	6a 21                	push   $0x21
  2815f5:	e8 8c f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC0_ICW3, 1 << 2);
  2815fa:	83 c4 08             	add    $0x8,%esp
  2815fd:	6a 04                	push   $0x4
  2815ff:	6a 21                	push   $0x21
  281601:	e8 80 f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC0_ICW4, 0x01);
  281606:	83 c4 08             	add    $0x8,%esp
  281609:	6a 01                	push   $0x1
  28160b:	6a 21                	push   $0x21
  28160d:	e8 74 f5 ff ff       	call   280b86 <io_out8>

	io_out8(PIC1_ICW1, 0x11);
  281612:	83 c4 08             	add    $0x8,%esp
  281615:	6a 11                	push   $0x11
  281617:	68 a0 00 00 00       	push   $0xa0
  28161c:	e8 65 f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC1_ICW2, 0x28);
  281621:	83 c4 08             	add    $0x8,%esp
  281624:	6a 28                	push   $0x28
  281626:	68 a1 00 00 00       	push   $0xa1
  28162b:	e8 56 f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC1_ICW3, 2);
  281630:	83 c4 08             	add    $0x8,%esp
  281633:	6a 02                	push   $0x2
  281635:	68 a1 00 00 00       	push   $0xa1
  28163a:	e8 47 f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC1_ICW4, 0x01);
  28163f:	83 c4 08             	add    $0x8,%esp
  281642:	6a 01                	push   $0x1
  281644:	68 a1 00 00 00       	push   $0xa1
  281649:	e8 38 f5 ff ff       	call   280b86 <io_out8>

	io_out8(PIC0_IMR, 0xfb);
  28164e:	83 c4 08             	add    $0x8,%esp
  281651:	68 fb 00 00 00       	push   $0xfb
  281656:	6a 21                	push   $0x21
  281658:	e8 29 f5 ff ff       	call   280b86 <io_out8>
	io_out8(PIC1_IMR, 0xff);
  28165d:	83 c4 08             	add    $0x8,%esp
  281660:	68 ff 00 00 00       	push   $0xff
  281665:	68 a1 00 00 00       	push   $0xa1
  28166a:	e8 17 f5 ff ff       	call   280b86 <io_out8>
}
  28166f:	83 c4 10             	add    $0x10,%esp
  281672:	c9                   	leave  
  281673:	c3                   	ret    

00281674 <inthandler0d>:

//when app code execute or access sys code or mem
int *inthandler0d(int *esp)
{
  281674:	55                   	push   %ebp
  281675:	89 e5                	mov    %esp,%ebp
  281677:	57                   	push   %edi
  281678:	56                   	push   %esi
  281679:	53                   	push   %ebx
  28167a:	83 ec 2c             	sub    $0x2c,%esp
	struct CONSOLE *cons = (struct CONSOLE *)*((int *)0x0fec);
  28167d:	8b 35 ec 0f 00 00    	mov    0xfec,%esi
	struct TASK *task = task_now();
  281683:	e8 1a 15 00 00       	call   282ba2 <task_now>
  281688:	89 c3                	mov    %eax,%ebx
	cons_putstr0(cons,"\nINT 0D:\n General Protected Exception.\n");
  28168a:	83 ec 08             	sub    $0x8,%esp
  28168d:	68 20 41 28 00       	push   $0x284120
  281692:	56                   	push   %esi
  281693:	e8 41 22 00 00       	call   2838d9 <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  281698:	83 c4 0c             	add    $0xc,%esp
  28169b:	8b 45 08             	mov    0x8(%ebp),%eax
  28169e:	ff 70 2c             	pushl  0x2c(%eax)
  2816a1:	68 48 41 28 00       	push   $0x284148
  2816a6:	8d 7d ca             	lea    -0x36(%ebp),%edi
  2816a9:	57                   	push   %edi
  2816aa:	e8 3e 02 00 00       	call   2818ed <sprintf>
	cons_putstr0(cons,s);
  2816af:	83 c4 08             	add    $0x8,%esp
  2816b2:	57                   	push   %edi
  2816b3:	56                   	push   %esi
  2816b4:	e8 20 22 00 00       	call   2838d9 <cons_putstr0>
	return &(task->tss.esp0);
  2816b9:	8d 43 30             	lea    0x30(%ebx),%eax
}
  2816bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2816bf:	5b                   	pop    %ebx
  2816c0:	5e                   	pop    %esi
  2816c1:	5f                   	pop    %edi
  2816c2:	5d                   	pop    %ebp
  2816c3:	c3                   	ret    

002816c4 <inthandler0c>:


//when code write beyond stack too much
int *inthandler0c(int *esp)
{
  2816c4:	55                   	push   %ebp
  2816c5:	89 e5                	mov    %esp,%ebp
  2816c7:	57                   	push   %edi
  2816c8:	56                   	push   %esi
  2816c9:	53                   	push   %ebx
  2816ca:	83 ec 2c             	sub    $0x2c,%esp
	struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
  2816cd:	8b 35 ec 0f 00 00    	mov    0xfec,%esi
	struct TASK *task = task_now();
  2816d3:	e8 ca 14 00 00       	call   282ba2 <task_now>
  2816d8:	89 c3                	mov    %eax,%ebx
	cons_putstr0(cons,"\nINT 0C:\n Stack Exception.\n");
  2816da:	83 ec 08             	sub    $0x8,%esp
  2816dd:	68 50 41 28 00       	push   $0x284150
  2816e2:	56                   	push   %esi
  2816e3:	e8 f1 21 00 00       	call   2838d9 <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  2816e8:	83 c4 0c             	add    $0xc,%esp
  2816eb:	8b 45 08             	mov    0x8(%ebp),%eax
  2816ee:	ff 70 2c             	pushl  0x2c(%eax)
  2816f1:	68 48 41 28 00       	push   $0x284148
  2816f6:	8d 7d ca             	lea    -0x36(%ebp),%edi
  2816f9:	57                   	push   %edi
  2816fa:	e8 ee 01 00 00       	call   2818ed <sprintf>
	cons_putstr0(cons,s);
  2816ff:	83 c4 08             	add    $0x8,%esp
  281702:	57                   	push   %edi
  281703:	56                   	push   %esi
  281704:	e8 d0 21 00 00       	call   2838d9 <cons_putstr0>
	return &(task->tss.esp0);
  281709:	8d 43 30             	lea    0x30(%ebx),%eax
}
  28170c:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28170f:	5b                   	pop    %ebx
  281710:	5e                   	pop    %esi
  281711:	5f                   	pop    %edi
  281712:	5d                   	pop    %ebp
  281713:	c3                   	ret    
  281714:	66 90                	xchg   %ax,%ax
  281716:	66 90                	xchg   %ax,%ax
  281718:	66 90                	xchg   %ax,%ax
  28171a:	66 90                	xchg   %ax,%ax
  28171c:	66 90                	xchg   %ax,%ax
  28171e:	66 90                	xchg   %ax,%ax

00281720 <asm_inthandler21>:
  281720:	06                   	push   %es
  281721:	1e                   	push   %ds
  281722:	60                   	pusha  
  281723:	89 e0                	mov    %esp,%eax
  281725:	50                   	push   %eax
  281726:	66 8c d0             	mov    %ss,%ax
  281729:	8e d8                	mov    %eax,%ds
  28172b:	8e c0                	mov    %eax,%es
  28172d:	e8 ed 05 00 00       	call   281d1f <inthandler21>
  281732:	58                   	pop    %eax
  281733:	61                   	popa   
  281734:	1f                   	pop    %ds
  281735:	07                   	pop    %es
  281736:	cf                   	iret   

00281737 <asm_inthandler2c>:
  281737:	06                   	push   %es
  281738:	1e                   	push   %ds
  281739:	60                   	pusha  
  28173a:	89 e0                	mov    %esp,%eax
  28173c:	50                   	push   %eax
  28173d:	66 8c d0             	mov    %ss,%ax
  281740:	8e d8                	mov    %eax,%ds
  281742:	8e c0                	mov    %eax,%es
  281744:	e8 3c 05 00 00       	call   281c85 <inthandler2c>
  281749:	58                   	pop    %eax
  28174a:	61                   	popa   
  28174b:	1f                   	pop    %ds
  28174c:	07                   	pop    %es
  28174d:	cf                   	iret   

0028174e <asm_inthandler20>:
  28174e:	06                   	push   %es
  28174f:	1e                   	push   %ds
  281750:	60                   	pusha  
  281751:	89 e0                	mov    %esp,%eax
  281753:	50                   	push   %eax
  281754:	66 8c d0             	mov    %ss,%ax
  281757:	8e d8                	mov    %eax,%ds
  281759:	8e c0                	mov    %eax,%es
  28175b:	e8 78 12 00 00       	call   2829d8 <inthandler20>
  281760:	58                   	pop    %eax
  281761:	61                   	popa   
  281762:	1f                   	pop    %ds
  281763:	07                   	pop    %es
  281764:	cf                   	iret   

00281765 <asm_sys_api>:
  281765:	fb                   	sti    
  281766:	1e                   	push   %ds
  281767:	06                   	push   %es
  281768:	60                   	pusha  
  281769:	60                   	pusha  
  28176a:	66 8c d0             	mov    %ss,%ax
  28176d:	8e d8                	mov    %eax,%ds
  28176f:	8e c0                	mov    %eax,%es
  281771:	e8 28 25 00 00       	call   283c9e <sys_api>
  281776:	83 f8 00             	cmp    $0x0,%eax
  281779:	75 07                	jne    281782 <end_app>
  28177b:	83 c4 20             	add    $0x20,%esp
  28177e:	61                   	popa   
  28177f:	07                   	pop    %es
  281780:	1f                   	pop    %ds
  281781:	cf                   	iret   

00281782 <end_app>:
  281782:	8b 20                	mov    (%eax),%esp
  281784:	61                   	popa   
  281785:	c3                   	ret    

00281786 <asm_inthandler0d>:
  281786:	fb                   	sti    
  281787:	06                   	push   %es
  281788:	1e                   	push   %ds
  281789:	60                   	pusha  
  28178a:	89 e0                	mov    %esp,%eax
  28178c:	50                   	push   %eax
  28178d:	66 8c d0             	mov    %ss,%ax
  281790:	8e d8                	mov    %eax,%ds
  281792:	8e c0                	mov    %eax,%es
  281794:	e8 db fe ff ff       	call   281674 <inthandler0d>
  281799:	83 f8 00             	cmp    $0x0,%eax
  28179c:	75 e4                	jne    281782 <end_app>
  28179e:	58                   	pop    %eax
  28179f:	61                   	popa   
  2817a0:	1f                   	pop    %ds
  2817a1:	07                   	pop    %es
  2817a2:	83 c4 04             	add    $0x4,%esp
  2817a5:	cf                   	iret   

002817a6 <asm_inthandler0c>:
  2817a6:	fb                   	sti    
  2817a7:	06                   	push   %es
  2817a8:	1e                   	push   %ds
  2817a9:	60                   	pusha  
  2817aa:	89 e0                	mov    %esp,%eax
  2817ac:	50                   	push   %eax
  2817ad:	66 8c d0             	mov    %ss,%ax
  2817b0:	8e d8                	mov    %eax,%ds
  2817b2:	8e c0                	mov    %eax,%es
  2817b4:	e8 0b ff ff ff       	call   2816c4 <inthandler0c>
  2817b9:	83 f8 00             	cmp    $0x0,%eax
  2817bc:	75 c4                	jne    281782 <end_app>
  2817be:	58                   	pop    %eax
  2817bf:	61                   	popa   
  2817c0:	1f                   	pop    %ds
  2817c1:	07                   	pop    %es
  2817c2:	83 c4 04             	add    $0x4,%esp
  2817c5:	cf                   	iret   

002817c6 <itoa>:
#include"string.h"
void itoa(int value,char *buf){
  2817c6:	55                   	push   %ebp
  2817c7:	89 e5                	mov    %esp,%ebp
  2817c9:	57                   	push   %edi
  2817ca:	56                   	push   %esi
  2817cb:	53                   	push   %ebx
  2817cc:	83 ec 10             	sub    $0x10,%esp
  2817cf:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2817d2:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char tmp_buf[10] = {0};
  2817d5:	c7 45 ea 00 00 00 00 	movl   $0x0,-0x16(%ebp)
  2817dc:	c7 45 ee 00 00 00 00 	movl   $0x0,-0x12(%ebp)
  2817e3:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
  2817e9:	85 c9                	test   %ecx,%ecx
  2817eb:	79 08                	jns    2817f5 <itoa+0x2f>
		*buf++ = '-';
  2817ed:	c6 07 2d             	movb   $0x2d,(%edi)
		value = ~value + 1; 
  2817f0:	f7 d9                	neg    %ecx
#include"string.h"
void itoa(int value,char *buf){
	char tmp_buf[10] = {0};
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
		*buf++ = '-';
  2817f2:	8d 7f 01             	lea    0x1(%edi),%edi
  2817f5:	8d 5d ea             	lea    -0x16(%ebp),%ebx
		value = ~value + 1; 
	}

	do{
		*tbp++ = ('0' + (char)(value % 10));
  2817f8:	be 67 66 66 66       	mov    $0x66666667,%esi
  2817fd:	83 c3 01             	add    $0x1,%ebx
  281800:	89 c8                	mov    %ecx,%eax
  281802:	f7 ee                	imul   %esi
  281804:	c1 fa 02             	sar    $0x2,%edx
  281807:	89 c8                	mov    %ecx,%eax
  281809:	c1 f8 1f             	sar    $0x1f,%eax
  28180c:	29 c2                	sub    %eax,%edx
  28180e:	8d 04 92             	lea    (%edx,%edx,4),%eax
  281811:	01 c0                	add    %eax,%eax
  281813:	29 c1                	sub    %eax,%ecx
  281815:	83 c1 30             	add    $0x30,%ecx
  281818:	88 4b ff             	mov    %cl,-0x1(%ebx)
		value /= 10;
  28181b:	89 d1                	mov    %edx,%ecx
	}while(value);
  28181d:	85 d2                	test   %edx,%edx
  28181f:	75 dc                	jne    2817fd <itoa+0x37>
	while(tmp_buf != tbp--)
  281821:	8d 73 ff             	lea    -0x1(%ebx),%esi
  281824:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281827:	39 c3                	cmp    %eax,%ebx
  281829:	74 20                	je     28184b <itoa+0x85>
  28182b:	89 f0                	mov    %esi,%eax
  28182d:	89 fa                	mov    %edi,%edx
  28182f:	8d 5d e9             	lea    -0x17(%ebp),%ebx
		*buf++ = *tbp;
  281832:	83 c2 01             	add    $0x1,%edx
  281835:	0f b6 08             	movzbl (%eax),%ecx
  281838:	88 4a ff             	mov    %cl,-0x1(%edx)

	do{
		*tbp++ = ('0' + (char)(value % 10));
		value /= 10;
	}while(value);
	while(tmp_buf != tbp--)
  28183b:	83 e8 01             	sub    $0x1,%eax
  28183e:	39 d8                	cmp    %ebx,%eax
  281840:	75 f0                	jne    281832 <itoa+0x6c>
  281842:	8d 45 f4             	lea    -0xc(%ebp),%eax
  281845:	29 c6                	sub    %eax,%esi
  281847:	8d 7c 37 0b          	lea    0xb(%edi,%esi,1),%edi
		*buf++ = *tbp;
	*buf='\0';
  28184b:	c6 07 00             	movb   $0x0,(%edi)
}
  28184e:	83 c4 10             	add    $0x10,%esp
  281851:	5b                   	pop    %ebx
  281852:	5e                   	pop    %esi
  281853:	5f                   	pop    %edi
  281854:	5d                   	pop    %ebp
  281855:	c3                   	ret    

00281856 <xtoa>:
    else
        value = value + 48;
    return value;
}

void xtoa(unsigned int value,char *buf){
  281856:	55                   	push   %ebp
  281857:	89 e5                	mov    %esp,%ebp
  281859:	57                   	push   %edi
  28185a:	56                   	push   %esi
  28185b:	53                   	push   %ebx
  28185c:	83 ec 20             	sub    $0x20,%esp
  28185f:	8b 45 08             	mov    0x8(%ebp),%eax
    char tmp_buf[30] = {0};
  281862:	bb 00 00 00 00       	mov    $0x0,%ebx
  281867:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
  28186e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  281875:	b9 1c 00 00 00       	mov    $0x1c,%ecx
  28187a:	ba 00 00 00 00       	mov    $0x0,%edx
  28187f:	89 5c 15 d8          	mov    %ebx,-0x28(%ebp,%edx,1)
  281883:	83 c2 04             	add    $0x4,%edx
  281886:	39 ca                	cmp    %ecx,%edx
  281888:	72 f5                	jb     28187f <xtoa+0x29>
    char *tbp = tmp_buf;

    *buf++='0';
  28188a:	8b 75 0c             	mov    0xc(%ebp),%esi
  28188d:	c6 06 30             	movb   $0x30,(%esi)
    *buf++='x';
  281890:	83 c6 02             	add    $0x2,%esi
  281893:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281896:	c6 43 01 78          	movb   $0x78,0x1(%ebx)
    return value;
}

void xtoa(unsigned int value,char *buf){
    char tmp_buf[30] = {0};
    char *tbp = tmp_buf;
  28189a:	8d 5d d6             	lea    -0x2a(%ebp),%ebx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  28189d:	83 c3 01             	add    $0x1,%ebx
  2818a0:	89 c1                	mov    %eax,%ecx
  2818a2:	83 e1 0f             	and    $0xf,%ecx
	*str='\0';
}

static  inline char fourbtoc(int value){
    if(value >= 10)
        value = value - 10 + 65;
  2818a5:	8d 79 37             	lea    0x37(%ecx),%edi
  2818a8:	8d 51 30             	lea    0x30(%ecx),%edx
  2818ab:	83 f9 0a             	cmp    $0xa,%ecx
  2818ae:	0f 4d d7             	cmovge %edi,%edx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//得到低位数字
		*tbp++=fourbtoc(value&0x0000000f);
  2818b1:	88 53 ff             	mov    %dl,-0x1(%ebx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
  2818b4:	c1 e8 04             	shr    $0x4,%eax
    }while(value);
  2818b7:	85 c0                	test   %eax,%eax
  2818b9:	75 e2                	jne    28189d <xtoa+0x47>
    
    while(tmp_buf != tbp){
  2818bb:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  2818be:	39 c3                	cmp    %eax,%ebx
  2818c0:	74 20                	je     2818e2 <xtoa+0x8c>
  2818c2:	89 d8                	mov    %ebx,%eax
  2818c4:	89 f1                	mov    %esi,%ecx
  2818c6:	8d 7d d6             	lea    -0x2a(%ebp),%edi
      tbp--;
  2818c9:	83 e8 01             	sub    $0x1,%eax
      *buf++ = *tbp;
  2818cc:	83 c1 01             	add    $0x1,%ecx
  2818cf:	0f b6 10             	movzbl (%eax),%edx
  2818d2:	88 51 ff             	mov    %dl,-0x1(%ecx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//得到低位数字
		value >>= 4;
    }while(value);
    
    while(tmp_buf != tbp){
  2818d5:	39 f8                	cmp    %edi,%eax
  2818d7:	75 f0                	jne    2818c9 <xtoa+0x73>
  2818d9:	8d 45 f4             	lea    -0xc(%ebp),%eax
  2818dc:	29 c3                	sub    %eax,%ebx
  2818de:	8d 74 1e 1e          	lea    0x1e(%esi,%ebx,1),%esi
      tbp--;
      *buf++ = *tbp;
    }
    *buf='\0';
  2818e2:	c6 06 00             	movb   $0x0,(%esi)
}
  2818e5:	83 c4 20             	add    $0x20,%esp
  2818e8:	5b                   	pop    %ebx
  2818e9:	5e                   	pop    %esi
  2818ea:	5f                   	pop    %edi
  2818eb:	5d                   	pop    %ebp
  2818ec:	c3                   	ret    

002818ed <sprintf>:
	while(tmp_buf != tbp--)
		*buf++ = *tbp;
	*buf='\0';
}

void sprintf(char *str,char *format ,...){
  2818ed:	55                   	push   %ebp
  2818ee:	89 e5                	mov    %esp,%ebp
  2818f0:	57                   	push   %edi
  2818f1:	56                   	push   %esi
  2818f2:	53                   	push   %ebx
  2818f3:	83 ec 10             	sub    $0x10,%esp
  2818f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
  2818f9:	8d 7d 10             	lea    0x10(%ebp),%edi
	char buffer[10];
	char *buf=buffer;
	while(*format){
  2818fc:	e9 a8 00 00 00       	jmp    2819a9 <sprintf+0xbc>
		if(*format!='%'){
  281901:	3c 25                	cmp    $0x25,%al
  281903:	74 10                	je     281915 <sprintf+0x28>
			*str++=*format++;
  281905:	83 c6 01             	add    $0x1,%esi
  281908:	89 75 0c             	mov    %esi,0xc(%ebp)
  28190b:	88 03                	mov    %al,(%ebx)
  28190d:	8d 5b 01             	lea    0x1(%ebx),%ebx
			continue;
  281910:	e9 94 00 00 00       	jmp    2819a9 <sprintf+0xbc>
		}
		else{
			format++;
  281915:	8d 46 01             	lea    0x1(%esi),%eax
  281918:	89 45 0c             	mov    %eax,0xc(%ebp)
			switch (*format){
  28191b:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  28191f:	3c 73                	cmp    $0x73,%al
  281921:	74 5e                	je     281981 <sprintf+0x94>
  281923:	3c 78                	cmp    $0x78,%al
  281925:	74 2f                	je     281956 <sprintf+0x69>
  281927:	3c 64                	cmp    $0x64,%al
  281929:	75 75                	jne    2819a0 <sprintf+0xb3>
				case 'd':itoa(*var,buf);while(*buf){*str++=*buf++;};break;
  28192b:	8d 45 ea             	lea    -0x16(%ebp),%eax
  28192e:	50                   	push   %eax
  28192f:	ff 37                	pushl  (%edi)
  281931:	e8 90 fe ff ff       	call   2817c6 <itoa>
  281936:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  28193a:	83 c4 08             	add    $0x8,%esp
  28193d:	84 c0                	test   %al,%al
  28193f:	74 5f                	je     2819a0 <sprintf+0xb3>
  281941:	8d 55 ea             	lea    -0x16(%ebp),%edx
  281944:	83 c3 01             	add    $0x1,%ebx
  281947:	83 c2 01             	add    $0x1,%edx
  28194a:	88 43 ff             	mov    %al,-0x1(%ebx)
  28194d:	0f b6 02             	movzbl (%edx),%eax
  281950:	84 c0                	test   %al,%al
  281952:	75 f0                	jne    281944 <sprintf+0x57>
  281954:	eb 4a                	jmp    2819a0 <sprintf+0xb3>
				case 'x':xtoa(*var,buf);while(*buf){*str++=*buf++;};break;
  281956:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281959:	50                   	push   %eax
  28195a:	ff 37                	pushl  (%edi)
  28195c:	e8 f5 fe ff ff       	call   281856 <xtoa>
  281961:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281965:	83 c4 08             	add    $0x8,%esp
  281968:	84 c0                	test   %al,%al
  28196a:	74 34                	je     2819a0 <sprintf+0xb3>
  28196c:	8d 55 ea             	lea    -0x16(%ebp),%edx
  28196f:	83 c3 01             	add    $0x1,%ebx
  281972:	83 c2 01             	add    $0x1,%edx
  281975:	88 43 ff             	mov    %al,-0x1(%ebx)
  281978:	0f b6 02             	movzbl (%edx),%eax
  28197b:	84 c0                	test   %al,%al
  28197d:	75 f0                	jne    28196f <sprintf+0x82>
  28197f:	eb 1f                	jmp    2819a0 <sprintf+0xb3>
				case 's':buf=(char*)(*var);while(*buf){*str++=*buf++;};break;
  281981:	8b 0f                	mov    (%edi),%ecx
  281983:	0f b6 11             	movzbl (%ecx),%edx
  281986:	84 d2                	test   %dl,%dl
  281988:	74 16                	je     2819a0 <sprintf+0xb3>
  28198a:	89 d8                	mov    %ebx,%eax
  28198c:	83 c0 01             	add    $0x1,%eax
  28198f:	88 50 ff             	mov    %dl,-0x1(%eax)
  281992:	89 c2                	mov    %eax,%edx
  281994:	29 da                	sub    %ebx,%edx
  281996:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
  28199a:	84 d2                	test   %dl,%dl
  28199c:	75 ee                	jne    28198c <sprintf+0x9f>
  28199e:	89 c3                	mov    %eax,%ebx
			}
			buf=buffer;
			var++;
  2819a0:	83 c7 04             	add    $0x4,%edi
			format++;
  2819a3:	83 c6 02             	add    $0x2,%esi
  2819a6:	89 75 0c             	mov    %esi,0xc(%ebp)

void sprintf(char *str,char *format ,...){
	int *var=(int *)(&format)+1; //得到第一个可变参数的地址
	char buffer[10];
	char *buf=buffer;
	while(*format){
  2819a9:	8b 75 0c             	mov    0xc(%ebp),%esi
  2819ac:	0f b6 06             	movzbl (%esi),%eax
  2819af:	84 c0                	test   %al,%al
  2819b1:	0f 85 4a ff ff ff    	jne    281901 <sprintf+0x14>
			buf=buffer;
			var++;
			format++;
		}
	}
	*str='\0';
  2819b7:	c6 03 00             	movb   $0x0,(%ebx)
}
  2819ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2819bd:	5b                   	pop    %ebx
  2819be:	5e                   	pop    %esi
  2819bf:	5f                   	pop    %edi
  2819c0:	5d                   	pop    %ebp
  2819c1:	c3                   	ret    

002819c2 <strcmp>:
    }
    *buf='\0';
}

int strcmp(const char *str1,const char *str2)
{
  2819c2:	55                   	push   %ebp
  2819c3:	89 e5                	mov    %esp,%ebp
  2819c5:	57                   	push   %edi
  2819c6:	56                   	push   %esi
  2819c7:	53                   	push   %ebx
  2819c8:	8b 7d 08             	mov    0x8(%ebp),%edi
  2819cb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  2819ce:	0f b6 17             	movzbl (%edi),%edx
  2819d1:	be 00 00 00 00       	mov    $0x0,%esi
  2819d6:	84 d2                	test   %dl,%dl
  2819d8:	74 40                	je     281a1a <strcmp+0x58>
  2819da:	eb 1d                	jmp    2819f9 <strcmp+0x37>
	{
		if(c1==c2) i++;
  2819dc:	38 ca                	cmp    %cl,%dl
  2819de:	75 0f                	jne    2819ef <strcmp+0x2d>
  2819e0:	83 c0 01             	add    $0x1,%eax

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  2819e3:	89 c6                	mov    %eax,%esi
  2819e5:	0f b6 14 07          	movzbl (%edi,%eax,1),%edx
  2819e9:	84 d2                	test   %dl,%dl
  2819eb:	75 1e                	jne    281a0b <strcmp+0x49>
  2819ed:	eb 2b                	jmp    281a1a <strcmp+0x58>
	{
		if(c1==c2) i++;
		else return c1-c2;
  2819ef:	0f be c2             	movsbl %dl,%eax
  2819f2:	0f be c9             	movsbl %cl,%ecx
  2819f5:	29 c8                	sub    %ecx,%eax
  2819f7:	eb 2a                	jmp    281a23 <strcmp+0x61>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  2819f9:	0f b6 0b             	movzbl (%ebx),%ecx
  2819fc:	84 c9                	test   %cl,%cl
  2819fe:	74 15                	je     281a15 <strcmp+0x53>
	{
		if(c1==c2) i++;
  281a00:	b8 00 00 00 00       	mov    $0x0,%eax
  281a05:	38 ca                	cmp    %cl,%dl
  281a07:	74 d7                	je     2819e0 <strcmp+0x1e>
  281a09:	eb e4                	jmp    2819ef <strcmp+0x2d>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281a0b:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  281a0f:	84 c9                	test   %cl,%cl
  281a11:	75 c9                	jne    2819dc <strcmp+0x1a>
  281a13:	eb 05                	jmp    281a1a <strcmp+0x58>
  281a15:	be 00 00 00 00       	mov    $0x0,%esi
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281a1a:	0f be c2             	movsbl %dl,%eax
  281a1d:	0f be 14 33          	movsbl (%ebx,%esi,1),%edx
  281a21:	29 d0                	sub    %edx,%eax
}
  281a23:	5b                   	pop    %ebx
  281a24:	5e                   	pop    %esi
  281a25:	5f                   	pop    %edi
  281a26:	5d                   	pop    %ebp
  281a27:	c3                   	ret    

00281a28 <strncmp>:

int strncmp(const char *str1,const char *str2,unsigned int n)
{
  281a28:	55                   	push   %ebp
  281a29:	89 e5                	mov    %esp,%ebp
  281a2b:	57                   	push   %edi
  281a2c:	56                   	push   %esi
  281a2d:	53                   	push   %ebx
  281a2e:	8b 75 08             	mov    0x8(%ebp),%esi
  281a31:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281a34:	8b 7d 10             	mov    0x10(%ebp),%edi
	if(n == 0) return 0;
  281a37:	b8 00 00 00 00       	mov    $0x0,%eax
  281a3c:	85 ff                	test   %edi,%edi
  281a3e:	74 63                	je     281aa3 <strncmp+0x7b>
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a40:	83 ef 01             	sub    $0x1,%edi
  281a43:	89 fa                	mov    %edi,%edx
  281a45:	74 52                	je     281a99 <strncmp+0x71>
  281a47:	eb 19                	jmp    281a62 <strncmp+0x3a>
	{
		if(c1==c2) i++;
  281a49:	38 c8                	cmp    %cl,%al
  281a4b:	75 0b                	jne    281a58 <strncmp+0x30>
  281a4d:	83 c2 01             	add    $0x1,%edx
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a50:	39 fa                	cmp    %edi,%edx
  281a52:	75 27                	jne    281a7b <strncmp+0x53>
	{
		if(c1==c2) i++;
  281a54:	89 fa                	mov    %edi,%edx
  281a56:	eb 41                	jmp    281a99 <strncmp+0x71>
		else return c1-c2;
  281a58:	0f be c0             	movsbl %al,%eax
  281a5b:	0f be c9             	movsbl %cl,%ecx
  281a5e:	29 c8                	sub    %ecx,%eax
  281a60:	eb 41                	jmp    281aa3 <strncmp+0x7b>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a62:	0f b6 06             	movzbl (%esi),%eax
  281a65:	84 c0                	test   %al,%al
  281a67:	74 24                	je     281a8d <strncmp+0x65>
  281a69:	0f b6 0b             	movzbl (%ebx),%ecx
  281a6c:	84 c9                	test   %cl,%cl
  281a6e:	74 24                	je     281a94 <strncmp+0x6c>
	{
		if(c1==c2) i++;
  281a70:	ba 00 00 00 00       	mov    $0x0,%edx
  281a75:	38 c8                	cmp    %cl,%al
  281a77:	74 d4                	je     281a4d <strncmp+0x25>
  281a79:	eb dd                	jmp    281a58 <strncmp+0x30>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281a7b:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
  281a7f:	84 c0                	test   %al,%al
  281a81:	74 16                	je     281a99 <strncmp+0x71>
  281a83:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  281a87:	84 c9                	test   %cl,%cl
  281a89:	75 be                	jne    281a49 <strncmp+0x21>
  281a8b:	eb 0c                	jmp    281a99 <strncmp+0x71>
  281a8d:	ba 00 00 00 00       	mov    $0x0,%edx
  281a92:	eb 05                	jmp    281a99 <strncmp+0x71>
  281a94:	ba 00 00 00 00       	mov    $0x0,%edx
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281a99:	0f be 04 16          	movsbl (%esi,%edx,1),%eax
  281a9d:	0f be 14 13          	movsbl (%ebx,%edx,1),%edx
  281aa1:	29 d0                	sub    %edx,%eax
}
  281aa3:	5b                   	pop    %ebx
  281aa4:	5e                   	pop    %esi
  281aa5:	5f                   	pop    %edi
  281aa6:	5d                   	pop    %ebp
  281aa7:	c3                   	ret    

00281aa8 <fifo32_init>:
#include "fifo.h"
#include "task.h"
void fifo32_init(struct FIFO32 *fifo,int size,int *buf,struct TASK *task)
{
  281aa8:	55                   	push   %ebp
  281aa9:	89 e5                	mov    %esp,%ebp
  281aab:	8b 45 08             	mov    0x8(%ebp),%eax
  281aae:	8b 55 0c             	mov    0xc(%ebp),%edx
	fifo->size=size;
  281ab1:	89 50 0c             	mov    %edx,0xc(%eax)
	fifo->buf=buf;
  281ab4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281ab7:	89 08                	mov    %ecx,(%eax)
	fifo->free = size;
  281ab9:	89 50 10             	mov    %edx,0x10(%eax)
	fifo->flags = 0;
  281abc:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	fifo->p = 0;
  281ac3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->q = 0;
  281aca:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	fifo->task = task;
  281ad1:	8b 55 14             	mov    0x14(%ebp),%edx
  281ad4:	89 50 18             	mov    %edx,0x18(%eax)
	return;
}
  281ad7:	5d                   	pop    %ebp
  281ad8:	c3                   	ret    

00281ad9 <fifo32_put>:
#define FLAGS_OVERRUN 0x0001
#include "timer.h"
extern struct TIMERCTL timerctl;

int fifo32_put(struct FIFO32 *fifo,int data)
{
  281ad9:	55                   	push   %ebp
  281ada:	89 e5                	mov    %esp,%ebp
  281adc:	53                   	push   %ebx
  281add:	83 ec 04             	sub    $0x4,%esp
  281ae0:	8b 45 08             	mov    0x8(%ebp),%eax
	if(fifo->free == 0)
  281ae3:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  281ae7:	75 0b                	jne    281af4 <fifo32_put+0x1b>
	{
		fifo->flags |= FLAGS_OVERRUN;
  281ae9:	83 48 14 01          	orl    $0x1,0x14(%eax)
		return -1;
  281aed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  281af2:	eb 52                	jmp    281b46 <fifo32_put+0x6d>
	}
	fifo->buf[fifo->p] = data;
  281af4:	8b 48 04             	mov    0x4(%eax),%ecx
  281af7:	8b 10                	mov    (%eax),%edx
  281af9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281afc:	89 1c 8a             	mov    %ebx,(%edx,%ecx,4)
	fifo->p++;
  281aff:	8b 48 04             	mov    0x4(%eax),%ecx
  281b02:	8d 51 01             	lea    0x1(%ecx),%edx
  281b05:	89 50 04             	mov    %edx,0x4(%eax)
	if(fifo->p == fifo->size)
  281b08:	3b 50 0c             	cmp    0xc(%eax),%edx
  281b0b:	75 07                	jne    281b14 <fifo32_put+0x3b>
		fifo->p = 0;
  281b0d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->free--;
  281b14:	83 68 10 01          	subl   $0x1,0x10(%eax)

	//wake up task
	if(fifo->task!=0)
  281b18:	8b 50 18             	mov    0x18(%eax),%edx
  281b1b:	85 d2                	test   %edx,%edx
  281b1d:	74 22                	je     281b41 <fifo32_put+0x68>
		if(fifo->task->flags!=2)
		{
			task_run(fifo->task,-1,0);
		}
	}
	return 0;
  281b1f:	b8 00 00 00 00       	mov    $0x0,%eax
	fifo->free--;

	//wake up task
	if(fifo->task!=0)
	{
		if(fifo->task->flags!=2)
  281b24:	83 7a 04 02          	cmpl   $0x2,0x4(%edx)
  281b28:	74 1c                	je     281b46 <fifo32_put+0x6d>
		{
			task_run(fifo->task,-1,0);
  281b2a:	83 ec 04             	sub    $0x4,%esp
  281b2d:	6a 00                	push   $0x0
  281b2f:	6a ff                	push   $0xffffffff
  281b31:	52                   	push   %edx
  281b32:	e8 60 11 00 00       	call   282c97 <task_run>
  281b37:	83 c4 10             	add    $0x10,%esp
		}
	}
	return 0;
  281b3a:	b8 00 00 00 00       	mov    $0x0,%eax
  281b3f:	eb 05                	jmp    281b46 <fifo32_put+0x6d>
  281b41:	b8 00 00 00 00       	mov    $0x0,%eax
}
  281b46:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  281b49:	c9                   	leave  
  281b4a:	c3                   	ret    

00281b4b <fifo32_get>:

int fifo32_get(struct FIFO32 *fifo)
{
  281b4b:	55                   	push   %ebp
  281b4c:	89 e5                	mov    %esp,%ebp
  281b4e:	56                   	push   %esi
  281b4f:	53                   	push   %ebx
  281b50:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if(fifo->free == fifo->size)
  281b53:	8b 59 10             	mov    0x10(%ecx),%ebx
  281b56:	8b 71 0c             	mov    0xc(%ecx),%esi
  281b59:	39 f3                	cmp    %esi,%ebx
  281b5b:	74 20                	je     281b7d <fifo32_get+0x32>
		return -1;
	int data = fifo->buf[fifo->q];
  281b5d:	8b 51 08             	mov    0x8(%ecx),%edx
  281b60:	8b 01                	mov    (%ecx),%eax
  281b62:	8b 04 90             	mov    (%eax,%edx,4),%eax
	fifo->q++;
  281b65:	83 c2 01             	add    $0x1,%edx
	if(fifo->q == fifo->size)
  281b68:	39 d6                	cmp    %edx,%esi
int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
	int data = fifo->buf[fifo->q];
	fifo->q++;
  281b6a:	be 00 00 00 00       	mov    $0x0,%esi
  281b6f:	0f 44 d6             	cmove  %esi,%edx
  281b72:	89 51 08             	mov    %edx,0x8(%ecx)
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
  281b75:	83 c3 01             	add    $0x1,%ebx
  281b78:	89 59 10             	mov    %ebx,0x10(%ecx)
	return data;
  281b7b:	eb 05                	jmp    281b82 <fifo32_get+0x37>
}

int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
  281b7d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	fifo->q++;
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
	return data;
}
  281b82:	5b                   	pop    %ebx
  281b83:	5e                   	pop    %esi
  281b84:	5d                   	pop    %ebp
  281b85:	c3                   	ret    

00281b86 <fifo32_status>:

int fifo32_status(struct FIFO32 *fifo)
{
  281b86:	55                   	push   %ebp
  281b87:	89 e5                	mov    %esp,%ebp
  281b89:	8b 55 08             	mov    0x8(%ebp),%edx
	return fifo->size - fifo->free;
  281b8c:	8b 42 0c             	mov    0xc(%edx),%eax
  281b8f:	2b 42 10             	sub    0x10(%edx),%eax
}
  281b92:	5d                   	pop    %ebp
  281b93:	c3                   	ret    

00281b94 <enable_mouse>:
#include "mouse.h"
struct FIFO32 *mousefifo;
int mousedata0;
void enable_mouse(struct FIFO32 *fifo,int data0,struct MOUSE_DEC *mdec)
{
  281b94:	55                   	push   %ebp
  281b95:	89 e5                	mov    %esp,%ebp
  281b97:	83 ec 08             	sub    $0x8,%esp
	mousefifo = fifo;
  281b9a:	8b 45 08             	mov    0x8(%ebp),%eax
  281b9d:	a3 44 6a 28 00       	mov    %eax,0x286a44
	mousedata0 = data0;
  281ba2:	8b 45 0c             	mov    0xc(%ebp),%eax
  281ba5:	a3 40 6a 28 00       	mov    %eax,0x286a40

	wait_KBC_sendready();
  281baa:	e8 1a 01 00 00       	call   281cc9 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_SENDTO_MOUSE);
  281baf:	83 ec 08             	sub    $0x8,%esp
  281bb2:	68 d4 00 00 00       	push   $0xd4
  281bb7:	6a 64                	push   $0x64
  281bb9:	e8 c8 ef ff ff       	call   280b86 <io_out8>
	wait_KBC_sendready();
  281bbe:	e8 06 01 00 00       	call   281cc9 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,MOUSECMD_ENABLE);
  281bc3:	83 c4 08             	add    $0x8,%esp
  281bc6:	68 f4 00 00 00       	push   $0xf4
  281bcb:	6a 60                	push   $0x60
  281bcd:	e8 b4 ef ff ff       	call   280b86 <io_out8>
	mdec->phase = 0;
  281bd2:	8b 45 10             	mov    0x10(%ebp),%eax
  281bd5:	c6 40 03 00          	movb   $0x0,0x3(%eax)
	return;
  281bd9:	83 c4 10             	add    $0x10,%esp
}
  281bdc:	c9                   	leave  
  281bdd:	c3                   	ret    

00281bde <mouse_decode>:

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
  281bde:	55                   	push   %ebp
  281bdf:	89 e5                	mov    %esp,%ebp
  281be1:	56                   	push   %esi
  281be2:	53                   	push   %ebx
  281be3:	8b 55 08             	mov    0x8(%ebp),%edx
  281be6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if(mdec->phase == 0)
  281be9:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  281bed:	84 c0                	test   %al,%al
  281bef:	75 14                	jne    281c05 <mouse_decode+0x27>
	{
		if(dat == 0xfa)
			mdec->phase = 1;
		return 0;
  281bf1:	b8 00 00 00 00       	mov    $0x0,%eax

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
	if(mdec->phase == 0)
	{
		if(dat == 0xfa)
  281bf6:	80 f9 fa             	cmp    $0xfa,%cl
  281bf9:	0f 85 82 00 00 00    	jne    281c81 <mouse_decode+0xa3>
			mdec->phase = 1;
  281bff:	c6 42 03 01          	movb   $0x1,0x3(%edx)
  281c03:	eb 7c                	jmp    281c81 <mouse_decode+0xa3>
		return 0;
	}
	if(mdec->phase == 1)
  281c05:	3c 01                	cmp    $0x1,%al
  281c07:	75 17                	jne    281c20 <mouse_decode+0x42>
	{
		if((dat&0xc8) == 0x08)
  281c09:	89 cb                	mov    %ecx,%ebx
  281c0b:	83 e3 c8             	and    $0xffffffc8,%ebx
		{
			mdec->buf[0] = dat;
			mdec->phase = 2;
		}
		return 0;
  281c0e:	b8 00 00 00 00       	mov    $0x0,%eax
			mdec->phase = 1;
		return 0;
	}
	if(mdec->phase == 1)
	{
		if((dat&0xc8) == 0x08)
  281c13:	80 fb 08             	cmp    $0x8,%bl
  281c16:	75 69                	jne    281c81 <mouse_decode+0xa3>
		{
			mdec->buf[0] = dat;
  281c18:	88 0a                	mov    %cl,(%edx)
			mdec->phase = 2;
  281c1a:	c6 42 03 02          	movb   $0x2,0x3(%edx)
  281c1e:	eb 61                	jmp    281c81 <mouse_decode+0xa3>
		}
		return 0;
	}
	if(mdec->phase == 2)
  281c20:	3c 02                	cmp    $0x2,%al
  281c22:	75 0e                	jne    281c32 <mouse_decode+0x54>
	{
		mdec->buf[1] = dat;
  281c24:	88 4a 01             	mov    %cl,0x1(%edx)
		mdec->phase = 3;
  281c27:	c6 42 03 03          	movb   $0x3,0x3(%edx)
		return 0;
  281c2b:	b8 00 00 00 00       	mov    $0x0,%eax
  281c30:	eb 4f                	jmp    281c81 <mouse_decode+0xa3>
	}
	if(mdec->phase == 3)
  281c32:	3c 03                	cmp    $0x3,%al
  281c34:	75 46                	jne    281c7c <mouse_decode+0x9e>
	{
		mdec->buf[2] = dat;
  281c36:	88 4a 02             	mov    %cl,0x2(%edx)
		mdec->phase = 1;
  281c39:	c6 42 03 01          	movb   $0x1,0x3(%edx)
		mdec->btn = mdec->buf[0] & 0x07;
  281c3d:	0f b6 02             	movzbl (%edx),%eax
  281c40:	89 c3                	mov    %eax,%ebx
  281c42:	83 e3 07             	and    $0x7,%ebx
  281c45:	89 5a 0c             	mov    %ebx,0xc(%edx)
		mdec->x = mdec->buf[1];
  281c48:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
  281c4c:	0f b6 f3             	movzbl %bl,%esi
  281c4f:	89 72 04             	mov    %esi,0x4(%edx)
		
		mdec->y = mdec->buf[2];
  281c52:	0f b6 f1             	movzbl %cl,%esi
  281c55:	89 72 08             	mov    %esi,0x8(%edx)
		if((mdec->buf[0] & 0x10)!=0)
  281c58:	a8 10                	test   $0x10,%al
  281c5a:	74 09                	je     281c65 <mouse_decode+0x87>
		{
			mdec->x |= 0xffffff00;
  281c5c:	81 cb 00 ff ff ff    	or     $0xffffff00,%ebx
  281c62:	89 5a 04             	mov    %ebx,0x4(%edx)
		}
		if((mdec->buf[0] & 0x20)!=0)
  281c65:	a8 20                	test   $0x20,%al
  281c67:	74 09                	je     281c72 <mouse_decode+0x94>
		{
			mdec->y |= 0xffffff00;
  281c69:	81 c9 00 ff ff ff    	or     $0xffffff00,%ecx
  281c6f:	89 4a 08             	mov    %ecx,0x8(%edx)
		}
		mdec->y = -mdec->y;
  281c72:	f7 5a 08             	negl   0x8(%edx)
		return 1;
  281c75:	b8 01 00 00 00       	mov    $0x1,%eax
  281c7a:	eb 05                	jmp    281c81 <mouse_decode+0xa3>
	}
	return -1;
  281c7c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  281c81:	5b                   	pop    %ebx
  281c82:	5e                   	pop    %esi
  281c83:	5d                   	pop    %ebp
  281c84:	c3                   	ret    

00281c85 <inthandler2c>:
#include "fifo.h"


//hanlder for int 2c (mouse interrupts)
void inthandler2c(int *esp)
{
  281c85:	55                   	push   %ebp
  281c86:	89 e5                	mov    %esp,%ebp
  281c88:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic continue watch 2c int
	io_out8(PIC1_OCW2,0X64);
  281c8b:	6a 64                	push   $0x64
  281c8d:	68 a0 00 00 00       	push   $0xa0
  281c92:	e8 ef ee ff ff       	call   280b86 <io_out8>
	io_out8(PIC0_OCW2,0x62);
  281c97:	83 c4 08             	add    $0x8,%esp
  281c9a:	6a 62                	push   $0x62
  281c9c:	6a 20                	push   $0x20
  281c9e:	e8 e3 ee ff ff       	call   280b86 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281ca3:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281caa:	e8 b5 ee ff ff       	call   280b64 <io_in8>
	fifo32_put(mousefifo,data+mousedata0);
  281caf:	83 c4 08             	add    $0x8,%esp
  281cb2:	03 05 40 6a 28 00    	add    0x286a40,%eax
  281cb8:	50                   	push   %eax
  281cb9:	ff 35 44 6a 28 00    	pushl  0x286a44
  281cbf:	e8 15 fe ff ff       	call   281ad9 <fifo32_put>
	return;
  281cc4:	83 c4 10             	add    $0x10,%esp
}
  281cc7:	c9                   	leave  
  281cc8:	c3                   	ret    

00281cc9 <wait_KBC_sendready>:

struct FIFO32 *keyfifo;
int keydata0;

void wait_KBC_sendready(void)
{
  281cc9:	55                   	push   %ebp
  281cca:	89 e5                	mov    %esp,%ebp
  281ccc:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		if((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0)
  281ccf:	83 ec 0c             	sub    $0xc,%esp
  281cd2:	6a 64                	push   $0x64
  281cd4:	e8 8b ee ff ff       	call   280b64 <io_in8>
  281cd9:	83 c4 10             	add    $0x10,%esp
  281cdc:	a8 02                	test   $0x2,%al
  281cde:	75 ef                	jne    281ccf <wait_KBC_sendready+0x6>
			break;
	}
	return;
}
  281ce0:	c9                   	leave  
  281ce1:	c3                   	ret    

00281ce2 <init_keyboard>:

void init_keyboard(struct FIFO32 *fifo,int data0)
{
  281ce2:	55                   	push   %ebp
  281ce3:	89 e5                	mov    %esp,%ebp
  281ce5:	83 ec 08             	sub    $0x8,%esp
	keyfifo = fifo;
  281ce8:	8b 45 08             	mov    0x8(%ebp),%eax
  281ceb:	a3 48 6a 28 00       	mov    %eax,0x286a48
	keydata0 = data0;
  281cf0:	8b 45 0c             	mov    0xc(%ebp),%eax
  281cf3:	a3 4c 6a 28 00       	mov    %eax,0x286a4c
	wait_KBC_sendready();
  281cf8:	e8 cc ff ff ff       	call   281cc9 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_WRITE_MODE);
  281cfd:	83 ec 08             	sub    $0x8,%esp
  281d00:	6a 60                	push   $0x60
  281d02:	6a 64                	push   $0x64
  281d04:	e8 7d ee ff ff       	call   280b86 <io_out8>
	wait_KBC_sendready();
  281d09:	e8 bb ff ff ff       	call   281cc9 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,KBC_MODE);
  281d0e:	83 c4 08             	add    $0x8,%esp
  281d11:	6a 47                	push   $0x47
  281d13:	6a 60                	push   $0x60
  281d15:	e8 6c ee ff ff       	call   280b86 <io_out8>
	return;
  281d1a:	83 c4 10             	add    $0x10,%esp
}
  281d1d:	c9                   	leave  
  281d1e:	c3                   	ret    

00281d1f <inthandler21>:
#include "fifo.h"


//handler for int 21 (keyboard interrupts)
void inthandler21(int *esp)
{
  281d1f:	55                   	push   %ebp
  281d20:	89 e5                	mov    %esp,%ebp
  281d22:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic contine watch 21 int
	io_out8(PIC0_OCW2,0x61);
  281d25:	6a 61                	push   $0x61
  281d27:	6a 20                	push   $0x20
  281d29:	e8 58 ee ff ff       	call   280b86 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281d2e:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281d35:	e8 2a ee ff ff       	call   280b64 <io_in8>
	fifo32_put(keyfifo,data + keydata0);
  281d3a:	83 c4 08             	add    $0x8,%esp
  281d3d:	03 05 4c 6a 28 00    	add    0x286a4c,%eax
  281d43:	50                   	push   %eax
  281d44:	ff 35 48 6a 28 00    	pushl  0x286a48
  281d4a:	e8 8a fd ff ff       	call   281ad9 <fifo32_put>
	return;
  281d4f:	83 c4 10             	add    $0x10,%esp
}
  281d52:	c9                   	leave  
  281d53:	c3                   	ret    

00281d54 <key_char>:
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
  281d54:	55                   	push   %ebp
  281d55:	89 e5                	mov    %esp,%ebp
  281d57:	8b 55 08             	mov    0x8(%ebp),%edx
	if(key>=0 && key<0x80)
	{
		if(key_shift==0) return keytable0[key];
		else return keytable1[key];
	}
	else return 0;
  281d5a:	b8 00 00 00 00       	mov    $0x0,%eax
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
	if(key>=0 && key<0x80)
  281d5f:	83 fa 7f             	cmp    $0x7f,%edx
  281d62:	77 16                	ja     281d7a <key_char+0x26>
	{
		if(key_shift==0) return keytable0[key];
  281d64:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  281d68:	75 09                	jne    281d73 <key_char+0x1f>
  281d6a:	0f b6 82 00 42 28 00 	movzbl 0x284200(%edx),%eax
  281d71:	eb 07                	jmp    281d7a <key_char+0x26>
		else return keytable1[key];
  281d73:	0f b6 82 80 41 28 00 	movzbl 0x284180(%edx),%eax
	}
	else return 0;
}
  281d7a:	5d                   	pop    %ebp
  281d7b:	c3                   	ret    

00281d7c <memtest>:
#include "memory.h"
#include "io.h"

extern unsigned int _memtest_sub(unsigned int start,unsigned int end);
unsigned int memtest(unsigned int start,unsigned int end)
{
  281d7c:	55                   	push   %ebp
  281d7d:	89 e5                	mov    %esp,%ebp
  281d7f:	83 ec 18             	sub    $0x18,%esp
	char flg486 = 0;
  281d82:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	unsigned int eflg,cr0,i;
	
	//check cpu type
	eflg = io_load_eflags();
  281d86:	e8 1a ee ff ff       	call   280ba5 <io_load_eflags>
  281d8b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	eflg != EFLAGS_AC_BIT;
	io_store_eflags(eflg);
  281d8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281d91:	83 ec 0c             	sub    $0xc,%esp
  281d94:	50                   	push   %eax
  281d95:	e8 0e ee ff ff       	call   280ba8 <io_store_eflags>
  281d9a:	83 c4 10             	add    $0x10,%esp
	eflg = io_load_eflags();
  281d9d:	e8 03 ee ff ff       	call   280ba5 <io_load_eflags>
  281da2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if((eflg & EFLAGS_AC_BIT) !=0)
  281da5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281da8:	25 00 00 04 00       	and    $0x40000,%eax
  281dad:	85 c0                	test   %eax,%eax
  281daf:	74 04                	je     281db5 <memtest+0x39>
		flg486 = 1;
  281db1:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
	eflg &= ~EFLAGS_AC_BIT;
  281db5:	81 65 f0 ff ff fb ff 	andl   $0xfffbffff,-0x10(%ebp)
	io_store_eflags(eflg);
  281dbc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281dbf:	83 ec 0c             	sub    $0xc,%esp
  281dc2:	50                   	push   %eax
  281dc3:	e8 e0 ed ff ff       	call   280ba8 <io_store_eflags>
  281dc8:	83 c4 10             	add    $0x10,%esp
	
	//disable cpu cache
	if(flg486)
  281dcb:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  281dcf:	74 1d                	je     281dee <memtest+0x72>
	{
		cr0 = load_cr0;
  281dd1:	c7 45 ec cf 0b 28 00 	movl   $0x280bcf,-0x14(%ebp)
		cr0 |= CR0_CACHE_DISABLE;
  281dd8:	81 4d ec 00 00 00 60 	orl    $0x60000000,-0x14(%ebp)
		store_cr0(cr0);
  281ddf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  281de2:	83 ec 0c             	sub    $0xc,%esp
  281de5:	50                   	push   %eax
  281de6:	e8 e8 ed ff ff       	call   280bd3 <store_cr0>
  281deb:	83 c4 10             	add    $0x10,%esp
	}
	
	//i = memtest_sub(start,end);
	i = _memtest_sub(start,end);
  281dee:	83 ec 08             	sub    $0x8,%esp
  281df1:	ff 75 0c             	pushl  0xc(%ebp)
  281df4:	ff 75 08             	pushl  0x8(%ebp)
  281df7:	e8 df ed ff ff       	call   280bdb <_memtest_sub>
  281dfc:	83 c4 10             	add    $0x10,%esp
  281dff:	89 45 e8             	mov    %eax,-0x18(%ebp)
	
	//enable cpu cache
	if(flg486)
  281e02:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  281e06:	74 1e                	je     281e26 <memtest+0xaa>
	{
		cr0 = load_cr0();
  281e08:	e8 c2 ed ff ff       	call   280bcf <load_cr0>
  281e0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cr0 &= ~CR0_CACHE_DISABLE;
  281e10:	81 65 ec ff ff ff 9f 	andl   $0x9fffffff,-0x14(%ebp)
		store_cr0(cr0);
  281e17:	8b 45 ec             	mov    -0x14(%ebp),%eax
  281e1a:	83 ec 0c             	sub    $0xc,%esp
  281e1d:	50                   	push   %eax
  281e1e:	e8 b0 ed ff ff       	call   280bd3 <store_cr0>
  281e23:	83 c4 10             	add    $0x10,%esp
	}

	return i;
  281e26:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  281e29:	c9                   	leave  
  281e2a:	c3                   	ret    

00281e2b <memtest_sub>:

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
  281e2b:	55                   	push   %ebp
  281e2c:	89 e5                	mov    %esp,%ebp
  281e2e:	83 ec 20             	sub    $0x20,%esp
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
  281e31:	c7 45 f8 55 aa 55 aa 	movl   $0xaa55aa55,-0x8(%ebp)
  281e38:	c7 45 f4 aa 55 aa 55 	movl   $0x55aa55aa,-0xc(%ebp)
	for(i=start;i<=end;i+=0x1000)
  281e3f:	8b 45 08             	mov    0x8(%ebp),%eax
  281e42:	89 45 fc             	mov    %eax,-0x4(%ebp)
  281e45:	eb 67                	jmp    281eae <memtest_sub+0x83>
	{
		p = (unsigned int *) (i+0xffc);
  281e47:	8b 45 fc             	mov    -0x4(%ebp),%eax
  281e4a:	05 fc 0f 00 00       	add    $0xffc,%eax
  281e4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		old = *p;
  281e52:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e55:	8b 00                	mov    (%eax),%eax
  281e57:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*p = pat0;
  281e5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e5d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281e60:	89 10                	mov    %edx,(%eax)
		*p ^= 0xffffffff;
  281e62:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e65:	8b 00                	mov    (%eax),%eax
  281e67:	f7 d0                	not    %eax
  281e69:	89 c2                	mov    %eax,%edx
  281e6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e6e:	89 10                	mov    %edx,(%eax)
		if(*p != pat1)
  281e70:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e73:	8b 00                	mov    (%eax),%eax
  281e75:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  281e78:	74 0d                	je     281e87 <memtest_sub+0x5c>
  281e7a:	eb 01                	jmp    281e7d <memtest_sub+0x52>
			break;
		}
		*p ^= 0xffffffff;
		if(*p != pat0)
		{
			goto not_memory;
  281e7c:	90                   	nop
		*p = pat0;
		*p ^= 0xffffffff;
		if(*p != pat1)
		{
not_memory:
			*p = old;
  281e7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e80:	8b 55 ec             	mov    -0x14(%ebp),%edx
  281e83:	89 10                	mov    %edx,(%eax)
			break;
  281e85:	eb 2f                	jmp    281eb6 <memtest_sub+0x8b>
		}
		*p ^= 0xffffffff;
  281e87:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e8a:	8b 00                	mov    (%eax),%eax
  281e8c:	f7 d0                	not    %eax
  281e8e:	89 c2                	mov    %eax,%edx
  281e90:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e93:	89 10                	mov    %edx,(%eax)
		if(*p != pat0)
  281e95:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281e98:	8b 00                	mov    (%eax),%eax
  281e9a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281e9d:	75 dd                	jne    281e7c <memtest_sub+0x51>
		{
			goto not_memory;
		}
		*p = old;
  281e9f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281ea2:	8b 55 ec             	mov    -0x14(%ebp),%edx
  281ea5:	89 10                	mov    %edx,(%eax)

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
	for(i=start;i<=end;i+=0x1000)
  281ea7:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%ebp)
  281eae:	8b 45 fc             	mov    -0x4(%ebp),%eax
  281eb1:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281eb4:	76 91                	jbe    281e47 <memtest_sub+0x1c>
		{
			goto not_memory;
		}
		*p = old;
	}
	return i;
  281eb6:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  281eb9:	c9                   	leave  
  281eba:	c3                   	ret    

00281ebb <memman_init>:

void memman_init(struct MEMMAN *man)
{
  281ebb:	55                   	push   %ebp
  281ebc:	89 e5                	mov    %esp,%ebp
	man->frees = 0;
  281ebe:	8b 45 08             	mov    0x8(%ebp),%eax
  281ec1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	man->maxfrees = 0;
  281ec7:	8b 45 08             	mov    0x8(%ebp),%eax
  281eca:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	man->lostsize = 0;
  281ed1:	8b 45 08             	mov    0x8(%ebp),%eax
  281ed4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	man->losts = 0;
  281edb:	8b 45 08             	mov    0x8(%ebp),%eax
  281ede:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return;
  281ee5:	90                   	nop
}
  281ee6:	5d                   	pop    %ebp
  281ee7:	c3                   	ret    

00281ee8 <memman_total>:

unsigned int memman_total(struct MEMMAN *man)
{
  281ee8:	55                   	push   %ebp
  281ee9:	89 e5                	mov    %esp,%ebp
  281eeb:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,t = 0;
  281eee:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;i<man->frees;i++)
  281ef5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  281efc:	eb 14                	jmp    281f12 <memman_total+0x2a>
	{
		t+=man->free[i].size;
  281efe:	8b 45 08             	mov    0x8(%ebp),%eax
  281f01:	8b 55 fc             	mov    -0x4(%ebp),%edx
  281f04:	83 c2 02             	add    $0x2,%edx
  281f07:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281f0b:	01 45 f8             	add    %eax,-0x8(%ebp)
}

unsigned int memman_total(struct MEMMAN *man)
{
	unsigned int i,t = 0;
	for(i=0;i<man->frees;i++)
  281f0e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  281f12:	8b 45 08             	mov    0x8(%ebp),%eax
  281f15:	8b 00                	mov    (%eax),%eax
  281f17:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  281f1a:	77 e2                	ja     281efe <memman_total+0x16>
	{
		t+=man->free[i].size;
	}
	return t;
  281f1c:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  281f1f:	c9                   	leave  
  281f20:	c3                   	ret    

00281f21 <memman_alloc>:

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
  281f21:	55                   	push   %ebp
  281f22:	89 e5                	mov    %esp,%ebp
  281f24:	53                   	push   %ebx
  281f25:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  281f28:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  281f2f:	e9 bd 00 00 00       	jmp    281ff1 <memman_alloc+0xd0>
	{
		if(man->free[i].size >= size)
  281f34:	8b 45 08             	mov    0x8(%ebp),%eax
  281f37:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f3a:	83 c2 02             	add    $0x2,%edx
  281f3d:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281f41:	3b 45 0c             	cmp    0xc(%ebp),%eax
  281f44:	0f 82 a3 00 00 00    	jb     281fed <memman_alloc+0xcc>
		{
			a = man->free[i].addr;
  281f4a:	8b 45 08             	mov    0x8(%ebp),%eax
  281f4d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f50:	83 c2 02             	add    $0x2,%edx
  281f53:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  281f56:	89 45 f4             	mov    %eax,-0xc(%ebp)
			man->free[i].addr+=size;
  281f59:	8b 45 08             	mov    0x8(%ebp),%eax
  281f5c:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f5f:	83 c2 02             	add    $0x2,%edx
  281f62:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  281f65:	8b 45 0c             	mov    0xc(%ebp),%eax
  281f68:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  281f6b:	8b 45 08             	mov    0x8(%ebp),%eax
  281f6e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f71:	83 c2 02             	add    $0x2,%edx
  281f74:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
			man->free[i].size-=size;
  281f77:	8b 45 08             	mov    0x8(%ebp),%eax
  281f7a:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f7d:	83 c2 02             	add    $0x2,%edx
  281f80:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281f84:	2b 45 0c             	sub    0xc(%ebp),%eax
  281f87:	89 c2                	mov    %eax,%edx
  281f89:	8b 45 08             	mov    0x8(%ebp),%eax
  281f8c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  281f8f:	83 c1 02             	add    $0x2,%ecx
  281f92:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
			if(man->free[i].size == 0)
  281f96:	8b 45 08             	mov    0x8(%ebp),%eax
  281f99:	8b 55 f8             	mov    -0x8(%ebp),%edx
  281f9c:	83 c2 02             	add    $0x2,%edx
  281f9f:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  281fa3:	85 c0                	test   %eax,%eax
  281fa5:	75 41                	jne    281fe8 <memman_alloc+0xc7>
			{
				man->frees--;
  281fa7:	8b 45 08             	mov    0x8(%ebp),%eax
  281faa:	8b 00                	mov    (%eax),%eax
  281fac:	8d 50 ff             	lea    -0x1(%eax),%edx
  281faf:	8b 45 08             	mov    0x8(%ebp),%eax
  281fb2:	89 10                	mov    %edx,(%eax)
				for(;i<man->frees;i++)
  281fb4:	eb 28                	jmp    281fde <memman_alloc+0xbd>
				{
					man->free[i] = man->free[i+1];
  281fb6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281fb9:	8d 50 01             	lea    0x1(%eax),%edx
  281fbc:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281fbf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  281fc2:	8d 58 02             	lea    0x2(%eax),%ebx
  281fc5:	8b 45 08             	mov    0x8(%ebp),%eax
  281fc8:	83 c2 02             	add    $0x2,%edx
  281fcb:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  281fce:	8b 02                	mov    (%edx),%eax
  281fd0:	8b 52 04             	mov    0x4(%edx),%edx
  281fd3:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  281fd6:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
			man->free[i].addr+=size;
			man->free[i].size-=size;
			if(man->free[i].size == 0)
			{
				man->frees--;
				for(;i<man->frees;i++)
  281fda:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281fde:	8b 45 08             	mov    0x8(%ebp),%eax
  281fe1:	8b 00                	mov    (%eax),%eax
  281fe3:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281fe6:	77 ce                	ja     281fb6 <memman_alloc+0x95>
				{
					man->free[i] = man->free[i+1];
				}
			}
			return a;
  281fe8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  281feb:	eb 17                	jmp    282004 <memman_alloc+0xe3>
}

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  281fed:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  281ff1:	8b 45 08             	mov    0x8(%ebp),%eax
  281ff4:	8b 00                	mov    (%eax),%eax
  281ff6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  281ff9:	0f 87 35 ff ff ff    	ja     281f34 <memman_alloc+0x13>
				}
			}
			return a;
		}
	}
	return 0;
  281fff:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282004:	83 c4 10             	add    $0x10,%esp
  282007:	5b                   	pop    %ebx
  282008:	5d                   	pop    %ebp
  282009:	c3                   	ret    

0028200a <memman_free>:

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  28200a:	55                   	push   %ebp
  28200b:	89 e5                	mov    %esp,%ebp
  28200d:	53                   	push   %ebx
  28200e:	83 ec 10             	sub    $0x10,%esp
	int i,j;
	
	for(i=0;i<man->frees;i++)
  282011:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  282018:	eb 15                	jmp    28202f <memman_free+0x25>
	{
		if(man->free[i].addr>addr) break;
  28201a:	8b 45 08             	mov    0x8(%ebp),%eax
  28201d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282020:	83 c2 02             	add    $0x2,%edx
  282023:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282026:	3b 45 0c             	cmp    0xc(%ebp),%eax
  282029:	77 10                	ja     28203b <memman_free+0x31>

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
	int i,j;
	
	for(i=0;i<man->frees;i++)
  28202b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  28202f:	8b 45 08             	mov    0x8(%ebp),%eax
  282032:	8b 00                	mov    (%eax),%eax
  282034:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282037:	7f e1                	jg     28201a <memman_free+0x10>
  282039:	eb 01                	jmp    28203c <memman_free+0x32>
	{
		if(man->free[i].addr>addr) break;
  28203b:	90                   	nop
	}

	//if prev combinable.
	if(i>0 && (man->free[i-1].addr+man->free[i-1].size == addr))
  28203c:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  282040:	0f 8e f2 00 00 00    	jle    282138 <memman_free+0x12e>
  282046:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282049:	8d 50 ff             	lea    -0x1(%eax),%edx
  28204c:	8b 45 08             	mov    0x8(%ebp),%eax
  28204f:	83 c2 02             	add    $0x2,%edx
  282052:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  282055:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282058:	8d 48 ff             	lea    -0x1(%eax),%ecx
  28205b:	8b 45 08             	mov    0x8(%ebp),%eax
  28205e:	83 c1 02             	add    $0x2,%ecx
  282061:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  282065:	01 d0                	add    %edx,%eax
  282067:	3b 45 0c             	cmp    0xc(%ebp),%eax
  28206a:	0f 85 c8 00 00 00    	jne    282138 <memman_free+0x12e>
	{
		//combine with prev
		man->free[i-1].size += size;
  282070:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282073:	8d 58 ff             	lea    -0x1(%eax),%ebx
  282076:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282079:	8d 50 ff             	lea    -0x1(%eax),%edx
  28207c:	8b 45 08             	mov    0x8(%ebp),%eax
  28207f:	83 c2 02             	add    $0x2,%edx
  282082:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282086:	8b 45 10             	mov    0x10(%ebp),%eax
  282089:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28208c:	8b 45 08             	mov    0x8(%ebp),%eax
  28208f:	8d 53 02             	lea    0x2(%ebx),%edx
  282092:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)

		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
  282096:	8b 45 08             	mov    0x8(%ebp),%eax
  282099:	8b 00                	mov    (%eax),%eax
  28209b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28209e:	0f 8e 8a 00 00 00    	jle    28212e <memman_free+0x124>
  2820a4:	8b 55 0c             	mov    0xc(%ebp),%edx
  2820a7:	8b 45 10             	mov    0x10(%ebp),%eax
  2820aa:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2820ad:	8b 45 08             	mov    0x8(%ebp),%eax
  2820b0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2820b3:	83 c2 02             	add    $0x2,%edx
  2820b6:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  2820b9:	39 c1                	cmp    %eax,%ecx
  2820bb:	75 71                	jne    28212e <memman_free+0x124>
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
  2820bd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2820c0:	8d 58 ff             	lea    -0x1(%eax),%ebx
  2820c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2820c6:	8d 50 ff             	lea    -0x1(%eax),%edx
  2820c9:	8b 45 08             	mov    0x8(%ebp),%eax
  2820cc:	83 c2 02             	add    $0x2,%edx
  2820cf:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  2820d3:	8b 45 08             	mov    0x8(%ebp),%eax
  2820d6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  2820d9:	83 c1 02             	add    $0x2,%ecx
  2820dc:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  2820e0:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2820e3:	8b 45 08             	mov    0x8(%ebp),%eax
  2820e6:	8d 53 02             	lea    0x2(%ebx),%edx
  2820e9:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
			for(;i<man->frees;i++)
  2820ed:	eb 28                	jmp    282117 <memman_free+0x10d>
				man->free[i] = man->free[i+1];
  2820ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2820f2:	8d 50 01             	lea    0x1(%eax),%edx
  2820f5:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2820f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2820fb:	8d 58 02             	lea    0x2(%eax),%ebx
  2820fe:	8b 45 08             	mov    0x8(%ebp),%eax
  282101:	83 c2 02             	add    $0x2,%edx
  282104:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  282107:	8b 02                	mov    (%edx),%eax
  282109:	8b 52 04             	mov    0x4(%edx),%edx
  28210c:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  28210f:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
			for(;i<man->frees;i++)
  282113:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  282117:	8b 45 08             	mov    0x8(%ebp),%eax
  28211a:	8b 00                	mov    (%eax),%eax
  28211c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28211f:	7f ce                	jg     2820ef <memman_free+0xe5>
				man->free[i] = man->free[i+1];
			man->frees--;
  282121:	8b 45 08             	mov    0x8(%ebp),%eax
  282124:	8b 00                	mov    (%eax),%eax
  282126:	8d 50 ff             	lea    -0x1(%eax),%edx
  282129:	8b 45 08             	mov    0x8(%ebp),%eax
  28212c:	89 10                	mov    %edx,(%eax)
		}
		
		return 0;
  28212e:	b8 00 00 00 00       	mov    $0x0,%eax
  282133:	e9 1f 01 00 00       	jmp    282257 <memman_free+0x24d>
	}

	//if next combinable
	if(i<man->frees && (addr + size == man->free[i].addr))
  282138:	8b 45 08             	mov    0x8(%ebp),%eax
  28213b:	8b 00                	mov    (%eax),%eax
  28213d:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282140:	7e 52                	jle    282194 <memman_free+0x18a>
  282142:	8b 55 0c             	mov    0xc(%ebp),%edx
  282145:	8b 45 10             	mov    0x10(%ebp),%eax
  282148:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28214b:	8b 45 08             	mov    0x8(%ebp),%eax
  28214e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282151:	83 c2 02             	add    $0x2,%edx
  282154:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282157:	39 c1                	cmp    %eax,%ecx
  282159:	75 39                	jne    282194 <memman_free+0x18a>
	{
		man->free[i].addr = addr;
  28215b:	8b 45 08             	mov    0x8(%ebp),%eax
  28215e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282161:	8d 4a 02             	lea    0x2(%edx),%ecx
  282164:	8b 55 0c             	mov    0xc(%ebp),%edx
  282167:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size += size;
  28216a:	8b 45 08             	mov    0x8(%ebp),%eax
  28216d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282170:	83 c2 02             	add    $0x2,%edx
  282173:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282177:	8b 45 10             	mov    0x10(%ebp),%eax
  28217a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28217d:	8b 45 08             	mov    0x8(%ebp),%eax
  282180:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282183:	83 c2 02             	add    $0x2,%edx
  282186:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
		return 0;
  28218a:	b8 00 00 00 00       	mov    $0x0,%eax
  28218f:	e9 c3 00 00 00       	jmp    282257 <memman_free+0x24d>
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
  282194:	8b 45 08             	mov    0x8(%ebp),%eax
  282197:	8b 00                	mov    (%eax),%eax
  282199:	3d f9 0f 00 00       	cmp    $0xff9,%eax
  28219e:	0f 8f 8a 00 00 00    	jg     28222e <memman_free+0x224>
	{
		for(j=man->frees-1;j>=i;j--)
  2821a4:	8b 45 08             	mov    0x8(%ebp),%eax
  2821a7:	8b 00                	mov    (%eax),%eax
  2821a9:	83 e8 01             	sub    $0x1,%eax
  2821ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
  2821af:	eb 28                	jmp    2821d9 <memman_free+0x1cf>
			man->free[j+1] = man->free[j];
  2821b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2821b4:	83 c0 01             	add    $0x1,%eax
  2821b7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2821ba:	8d 58 02             	lea    0x2(%eax),%ebx
  2821bd:	8b 45 08             	mov    0x8(%ebp),%eax
  2821c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
  2821c3:	83 c2 02             	add    $0x2,%edx
  2821c6:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  2821c9:	8b 02                	mov    (%edx),%eax
  2821cb:	8b 52 04             	mov    0x4(%edx),%edx
  2821ce:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  2821d1:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
	{
		for(j=man->frees-1;j>=i;j--)
  2821d5:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  2821d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2821dc:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  2821df:	7d d0                	jge    2821b1 <memman_free+0x1a7>
			man->free[j+1] = man->free[j];
		if(man->maxfrees < man->frees) man->maxfrees = man->frees;
  2821e1:	8b 45 08             	mov    0x8(%ebp),%eax
  2821e4:	8b 50 04             	mov    0x4(%eax),%edx
  2821e7:	8b 45 08             	mov    0x8(%ebp),%eax
  2821ea:	8b 00                	mov    (%eax),%eax
  2821ec:	39 c2                	cmp    %eax,%edx
  2821ee:	7d 0b                	jge    2821fb <memman_free+0x1f1>
  2821f0:	8b 45 08             	mov    0x8(%ebp),%eax
  2821f3:	8b 10                	mov    (%eax),%edx
  2821f5:	8b 45 08             	mov    0x8(%ebp),%eax
  2821f8:	89 50 04             	mov    %edx,0x4(%eax)
		man->free[i].addr = addr;
  2821fb:	8b 45 08             	mov    0x8(%ebp),%eax
  2821fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282201:	8d 4a 02             	lea    0x2(%edx),%ecx
  282204:	8b 55 0c             	mov    0xc(%ebp),%edx
  282207:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size = size;
  28220a:	8b 45 08             	mov    0x8(%ebp),%eax
  28220d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282210:	8d 4a 02             	lea    0x2(%edx),%ecx
  282213:	8b 55 10             	mov    0x10(%ebp),%edx
  282216:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
		man->frees++;
  28221a:	8b 45 08             	mov    0x8(%ebp),%eax
  28221d:	8b 00                	mov    (%eax),%eax
  28221f:	8d 50 01             	lea    0x1(%eax),%edx
  282222:	8b 45 08             	mov    0x8(%ebp),%eax
  282225:	89 10                	mov    %edx,(%eax)
		return 0;
  282227:	b8 00 00 00 00       	mov    $0x0,%eax
  28222c:	eb 29                	jmp    282257 <memman_free+0x24d>
	}

	//no room for new free
	man->losts++;
  28222e:	8b 45 08             	mov    0x8(%ebp),%eax
  282231:	8b 40 0c             	mov    0xc(%eax),%eax
  282234:	8d 50 01             	lea    0x1(%eax),%edx
  282237:	8b 45 08             	mov    0x8(%ebp),%eax
  28223a:	89 50 0c             	mov    %edx,0xc(%eax)
	man->lostsize += size;
  28223d:	8b 45 08             	mov    0x8(%ebp),%eax
  282240:	8b 40 08             	mov    0x8(%eax),%eax
  282243:	89 c2                	mov    %eax,%edx
  282245:	8b 45 10             	mov    0x10(%ebp),%eax
  282248:	01 d0                	add    %edx,%eax
  28224a:	89 c2                	mov    %eax,%edx
  28224c:	8b 45 08             	mov    0x8(%ebp),%eax
  28224f:	89 50 08             	mov    %edx,0x8(%eax)
	return -1;
  282252:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  282257:	83 c4 10             	add    $0x10,%esp
  28225a:	5b                   	pop    %ebx
  28225b:	5d                   	pop    %ebp
  28225c:	c3                   	ret    

0028225d <memman_alloc_4k>:

unsigned int memman_alloc_4k(struct MEMMAN *man,unsigned int size)
{
  28225d:	55                   	push   %ebp
  28225e:	89 e5                	mov    %esp,%ebp
  282260:	83 ec 10             	sub    $0x10,%esp
	unsigned int a;
	size = (size+0xfff) & 0xfffff000;
  282263:	8b 45 0c             	mov    0xc(%ebp),%eax
  282266:	05 ff 0f 00 00       	add    $0xfff,%eax
  28226b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  282270:	89 45 0c             	mov    %eax,0xc(%ebp)
	a = memman_alloc(man,size);
  282273:	ff 75 0c             	pushl  0xc(%ebp)
  282276:	ff 75 08             	pushl  0x8(%ebp)
  282279:	e8 a3 fc ff ff       	call   281f21 <memman_alloc>
  28227e:	83 c4 08             	add    $0x8,%esp
  282281:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return a;
  282284:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  282287:	c9                   	leave  
  282288:	c3                   	ret    

00282289 <memman_free_4k>:

int memman_free_4k(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  282289:	55                   	push   %ebp
  28228a:	89 e5                	mov    %esp,%ebp
  28228c:	83 ec 10             	sub    $0x10,%esp
	int i;
	size = (size+0xfff) & 0xfffff000;
  28228f:	8b 45 10             	mov    0x10(%ebp),%eax
  282292:	05 ff 0f 00 00       	add    $0xfff,%eax
  282297:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  28229c:	89 45 10             	mov    %eax,0x10(%ebp)
	i = memman_free(man,addr,size);
  28229f:	ff 75 10             	pushl  0x10(%ebp)
  2822a2:	ff 75 0c             	pushl  0xc(%ebp)
  2822a5:	ff 75 08             	pushl  0x8(%ebp)
  2822a8:	e8 5d fd ff ff       	call   28200a <memman_free>
  2822ad:	83 c4 0c             	add    $0xc,%esp
  2822b0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return i;
  2822b3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  2822b6:	c9                   	leave  
  2822b7:	c3                   	ret    

002822b8 <shtctl_init>:
#include "map_sheet.h"

struct SHTCTL* shtctl_init(struct MEMMAN *man,unsigned char *vram,int xsize,int ysize)
{
  2822b8:	55                   	push   %ebp
  2822b9:	89 e5                	mov    %esp,%ebp
  2822bb:	57                   	push   %edi
  2822bc:	56                   	push   %esi
  2822bd:	53                   	push   %ebx
  2822be:	83 ec 14             	sub    $0x14,%esp
  2822c1:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct SHTCTL *ctl;
	int i;
	ctl = (struct SHTCTL *)memman_alloc_4k(man,sizeof(struct SHTCTL));
  2822c4:	68 14 28 00 00       	push   $0x2814
  2822c9:	57                   	push   %edi
  2822ca:	e8 8e ff ff ff       	call   28225d <memman_alloc_4k>
  2822cf:	89 c6                	mov    %eax,%esi
	if(ctl == 0)
  2822d1:	83 c4 10             	add    $0x10,%esp
  2822d4:	85 c0                	test   %eax,%eax
  2822d6:	74 6a                	je     282342 <shtctl_init+0x8a>
  2822d8:	89 c3                	mov    %eax,%ebx
		goto err;
	ctl->vram = vram;
  2822da:	8b 45 0c             	mov    0xc(%ebp),%eax
  2822dd:	89 06                	mov    %eax,(%esi)
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
  2822df:	83 ec 08             	sub    $0x8,%esp
  2822e2:	8b 45 10             	mov    0x10(%ebp),%eax
  2822e5:	0f af 45 14          	imul   0x14(%ebp),%eax
  2822e9:	50                   	push   %eax
  2822ea:	57                   	push   %edi
  2822eb:	e8 6d ff ff ff       	call   28225d <memman_alloc_4k>
  2822f0:	89 46 04             	mov    %eax,0x4(%esi)
	if(ctl->map == 0)
  2822f3:	83 c4 10             	add    $0x10,%esp
  2822f6:	85 c0                	test   %eax,%eax
  2822f8:	75 19                	jne    282313 <shtctl_init+0x5b>
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
  2822fa:	83 ec 04             	sub    $0x4,%esp
  2822fd:	68 14 28 00 00       	push   $0x2814
  282302:	56                   	push   %esi
  282303:	57                   	push   %edi
  282304:	e8 80 ff ff ff       	call   282289 <memman_free_4k>
		ctl = 0;
		goto err;
  282309:	83 c4 10             	add    $0x10,%esp
	ctl->vram = vram;
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
	if(ctl->map == 0)
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
		ctl = 0;
  28230c:	be 00 00 00 00       	mov    $0x0,%esi
		goto err;
  282311:	eb 2f                	jmp    282342 <shtctl_init+0x8a>
	}
	ctl->xsize= xsize;
  282313:	8b 45 10             	mov    0x10(%ebp),%eax
  282316:	89 46 08             	mov    %eax,0x8(%esi)
	ctl->ysize= ysize;
  282319:	8b 45 14             	mov    0x14(%ebp),%eax
  28231c:	89 46 0c             	mov    %eax,0xc(%esi)
	ctl->top = -1;
  28231f:	c7 46 10 ff ff ff ff 	movl   $0xffffffff,0x10(%esi)
  282326:	8d 86 30 04 00 00    	lea    0x430(%esi),%eax
  28232c:	81 c3 30 28 00 00    	add    $0x2830,%ebx
	for(i=0;i<MAX_SHEETS;i++)
	{
		ctl->sheets0[i].flags = 0;
  282332:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ctl->sheets0[i].ctl = ctl;
  282338:	89 70 04             	mov    %esi,0x4(%eax)
  28233b:	83 c0 24             	add    $0x24,%eax
		goto err;
	}
	ctl->xsize= xsize;
	ctl->ysize= ysize;
	ctl->top = -1;
	for(i=0;i<MAX_SHEETS;i++)
  28233e:	39 d8                	cmp    %ebx,%eax
  282340:	75 f0                	jne    282332 <shtctl_init+0x7a>
		ctl->sheets0[i].flags = 0;
		ctl->sheets0[i].ctl = ctl;
	}
	err:
		return ctl;
}
  282342:	89 f0                	mov    %esi,%eax
  282344:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282347:	5b                   	pop    %ebx
  282348:	5e                   	pop    %esi
  282349:	5f                   	pop    %edi
  28234a:	5d                   	pop    %ebp
  28234b:	c3                   	ret    

0028234c <sheet_alloc>:

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
  28234c:	55                   	push   %ebp
  28234d:	89 e5                	mov    %esp,%ebp
  28234f:	56                   	push   %esi
  282350:	53                   	push   %ebx
  282351:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
	{
		if(ctl->sheets0[i].flags == 0)
  282354:	83 b9 30 04 00 00 00 	cmpl   $0x0,0x430(%ecx)
  28235b:	74 12                	je     28236f <sheet_alloc+0x23>
  28235d:	8d 91 54 04 00 00    	lea    0x454(%ecx),%edx

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  282363:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(ctl->sheets0[i].flags == 0)
  282368:	83 3a 00             	cmpl   $0x0,(%edx)
  28236b:	75 30                	jne    28239d <sheet_alloc+0x51>
  28236d:	eb 05                	jmp    282374 <sheet_alloc+0x28>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  28236f:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(ctl->sheets0[i].flags == 0)
		{
			sht = &ctl->sheets0[i];
  282374:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
  28237b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
			sht->flags = SHEET_USE;
  28237e:	c7 84 99 30 04 00 00 	movl   $0x1,0x430(%ecx,%ebx,4)
  282385:	01 00 00 00 
			sht->height = -1;
  282389:	c7 84 99 2c 04 00 00 	movl   $0xffffffff,0x42c(%ecx,%ebx,4)
  282390:	ff ff ff ff 
			return sht;
  282394:	8d 84 99 14 04 00 00 	lea    0x414(%ecx,%ebx,4),%eax
  28239b:	eb 12                	jmp    2823af <sheet_alloc+0x63>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  28239d:	83 c0 01             	add    $0x1,%eax
  2823a0:	83 c2 24             	add    $0x24,%edx
  2823a3:	3d 00 01 00 00       	cmp    $0x100,%eax
  2823a8:	75 be                	jne    282368 <sheet_alloc+0x1c>
			sht->flags = SHEET_USE;
			sht->height = -1;
			return sht;
		}
	}
	return 0;
  2823aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2823af:	5b                   	pop    %ebx
  2823b0:	5e                   	pop    %esi
  2823b1:	5d                   	pop    %ebp
  2823b2:	c3                   	ret    

002823b3 <sheet_setbuf>:

void sheet_setbuf(struct SHEET *sht,unsigned char *buf,int xsize,int ysize,int col_inv)
{
  2823b3:	55                   	push   %ebp
  2823b4:	89 e5                	mov    %esp,%ebp
  2823b6:	8b 45 08             	mov    0x8(%ebp),%eax
	sht->buf = buf;
  2823b9:	8b 55 0c             	mov    0xc(%ebp),%edx
  2823bc:	89 10                	mov    %edx,(%eax)
	sht->bxsize = xsize;
  2823be:	8b 55 10             	mov    0x10(%ebp),%edx
  2823c1:	89 50 04             	mov    %edx,0x4(%eax)
	sht->bysize = ysize;
  2823c4:	8b 55 14             	mov    0x14(%ebp),%edx
  2823c7:	89 50 08             	mov    %edx,0x8(%eax)
	sht->col_inv = col_inv;
  2823ca:	8b 55 18             	mov    0x18(%ebp),%edx
  2823cd:	89 50 14             	mov    %edx,0x14(%eax)
	return;
}
  2823d0:	5d                   	pop    %ebp
  2823d1:	c3                   	ret    

002823d2 <sheet_refresh_ob>:
}

//not good refresh
//obsolete
void sheet_refresh_ob(struct SHTCTL *ctl)
{
  2823d2:	55                   	push   %ebp
  2823d3:	89 e5                	mov    %esp,%ebp
  2823d5:	57                   	push   %edi
  2823d6:	56                   	push   %esi
  2823d7:	53                   	push   %ebx
  2823d8:	83 ec 10             	sub    $0x10,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
  2823db:	8b 45 08             	mov    0x8(%ebp),%eax
  2823de:	8b 00                	mov    (%eax),%eax
  2823e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  2823e3:	8b 45 08             	mov    0x8(%ebp),%eax
  2823e6:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  2823ea:	0f 88 80 00 00 00    	js     282470 <sheet_refresh_ob+0x9e>
  2823f0:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	{
		sht = ctl->sheets[h];
  2823f7:	8b 45 08             	mov    0x8(%ebp),%eax
  2823fa:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  2823fd:	8b 54 b8 14          	mov    0x14(%eax,%edi,4),%edx
		buf = sht->buf;
  282401:	8b 02                	mov    (%edx),%eax
  282403:	89 45 f0             	mov    %eax,-0x10(%ebp)
		for(by=0;by<sht->bysize;by++)
  282406:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  28240a:	7e 55                	jle    282461 <sheet_refresh_ob+0x8f>
  28240c:	bf 00 00 00 00       	mov    $0x0,%edi
		{
			vy = sht->vy0+by;
  282411:	89 f8                	mov    %edi,%eax
  282413:	03 42 10             	add    0x10(%edx),%eax
  282416:	89 45 ec             	mov    %eax,-0x14(%ebp)
			for(bx=0;bx<sht->bxsize;bx++)
  282419:	8b 4a 04             	mov    0x4(%edx),%ecx
  28241c:	85 c9                	test   %ecx,%ecx
  28241e:	7e 39                	jle    282459 <sheet_refresh_ob+0x87>
  282420:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				vx = sht->vx0+bx;
				c=buf[by*sht->bxsize+bx];
  282425:	0f af cf             	imul   %edi,%ecx
  282428:	8b 75 f0             	mov    -0x10(%ebp),%esi
  28242b:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  28242e:	0f b6 1c 0b          	movzbl (%ebx,%ecx,1),%ebx
				if(c!=sht->col_inv)
  282432:	0f b6 cb             	movzbl %bl,%ecx
  282435:	3b 4a 14             	cmp    0x14(%edx),%ecx
  282438:	74 15                	je     28244f <sheet_refresh_ob+0x7d>
					vram[vy*ctl->xsize+vx] = c;
  28243a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  28243d:	8b 75 ec             	mov    -0x14(%ebp),%esi
  282440:	0f af 71 08          	imul   0x8(%ecx),%esi
  282444:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  282447:	01 c1                	add    %eax,%ecx
  282449:	03 4a 0c             	add    0xc(%edx),%ecx
  28244c:	88 1c 31             	mov    %bl,(%ecx,%esi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0+by;
			for(bx=0;bx<sht->bxsize;bx++)
  28244f:	83 c0 01             	add    $0x1,%eax
  282452:	8b 4a 04             	mov    0x4(%edx),%ecx
  282455:	39 c1                	cmp    %eax,%ecx
  282457:	7f cc                	jg     282425 <sheet_refresh_ob+0x53>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  282459:	83 c7 01             	add    $0x1,%edi
  28245c:	39 7a 08             	cmp    %edi,0x8(%edx)
  28245f:	7f b0                	jg     282411 <sheet_refresh_ob+0x3f>
void sheet_refresh_ob(struct SHTCTL *ctl)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282461:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  282465:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  282468:	8b 7d 08             	mov    0x8(%ebp),%edi
  28246b:	39 47 10             	cmp    %eax,0x10(%edi)
  28246e:	7d 87                	jge    2823f7 <sheet_refresh_ob+0x25>
					vram[vy*ctl->xsize+vx] = c;
			}
		}
	}
	return;
}
  282470:	83 c4 10             	add    $0x10,%esp
  282473:	5b                   	pop    %ebx
  282474:	5e                   	pop    %esi
  282475:	5f                   	pop    %edi
  282476:	5d                   	pop    %ebp
  282477:	c3                   	ret    

00282478 <sheet_refreshsub1>:



void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
  282478:	55                   	push   %ebp
  282479:	89 e5                	mov    %esp,%ebp
  28247b:	57                   	push   %edi
  28247c:	56                   	push   %esi
  28247d:	53                   	push   %ebx
  28247e:	83 ec 14             	sub    $0x14,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
  282481:	8b 45 08             	mov    0x8(%ebp),%eax
  282484:	8b 00                	mov    (%eax),%eax
  282486:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282489:	8b 45 08             	mov    0x8(%ebp),%eax
  28248c:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  282490:	0f 88 a7 00 00 00    	js     28253d <sheet_refreshsub1+0xc5>
  282496:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	{
		sht = ctl->sheets[h];
  28249d:	8b 45 08             	mov    0x8(%ebp),%eax
  2824a0:	8b 7d e0             	mov    -0x20(%ebp),%edi
  2824a3:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  2824a7:	8b 01                	mov    (%ecx),%eax
  2824a9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(by=0;by<sht->bysize;by++)
  2824ac:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  2824b0:	7e 78                	jle    28252a <sheet_refreshsub1+0xb2>
  2824b2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		{
			vy = sht->vy0 + by;
  2824b9:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  2824bc:	03 59 10             	add    0x10(%ecx),%ebx
			for(bx=0;bx<sht->bxsize;bx++)
  2824bf:	8b 71 04             	mov    0x4(%ecx),%esi
  2824c2:	85 f6                	test   %esi,%esi
  2824c4:	7e 58                	jle    28251e <sheet_refreshsub1+0xa6>
  2824c6:	b8 00 00 00 00       	mov    $0x0,%eax
  2824cb:	89 5d f0             	mov    %ebx,-0x10(%ebp)
			{
				vx = sht->vx0 + bx;
  2824ce:	89 c2                	mov    %eax,%edx
  2824d0:	03 51 0c             	add    0xc(%ecx),%edx
				if(vx0<=vx && vx<vx1 && vy0<=vy && vy<vy1)
  2824d3:	3b 55 0c             	cmp    0xc(%ebp),%edx
  2824d6:	7c 3c                	jl     282514 <sheet_refreshsub1+0x9c>
  2824d8:	3b 55 14             	cmp    0x14(%ebp),%edx
  2824db:	7d 37                	jge    282514 <sheet_refreshsub1+0x9c>
  2824dd:	8b 7d f0             	mov    -0x10(%ebp),%edi
  2824e0:	3b 7d 10             	cmp    0x10(%ebp),%edi
  2824e3:	7c 2f                	jl     282514 <sheet_refreshsub1+0x9c>
  2824e5:	3b 7d 18             	cmp    0x18(%ebp),%edi
  2824e8:	7d 2a                	jge    282514 <sheet_refreshsub1+0x9c>
				{
					c = buf[by*sht->bxsize+bx];
  2824ea:	0f af 75 ec          	imul   -0x14(%ebp),%esi
  2824ee:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  2824f1:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
  2824f4:	0f b6 34 37          	movzbl (%edi,%esi,1),%esi
					if(c!=sht->col_inv)
  2824f8:	89 f3                	mov    %esi,%ebx
  2824fa:	0f b6 fb             	movzbl %bl,%edi
  2824fd:	3b 79 14             	cmp    0x14(%ecx),%edi
  282500:	74 12                	je     282514 <sheet_refreshsub1+0x9c>
						vram[vy*ctl->xsize+vx] = c;
  282502:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282505:	8b 7d f0             	mov    -0x10(%ebp),%edi
  282508:	0f af 7b 08          	imul   0x8(%ebx),%edi
  28250c:	03 55 e4             	add    -0x1c(%ebp),%edx
  28250f:	89 f3                	mov    %esi,%ebx
  282511:	88 1c 3a             	mov    %bl,(%edx,%edi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0 + by;
			for(bx=0;bx<sht->bxsize;bx++)
  282514:	83 c0 01             	add    $0x1,%eax
  282517:	8b 71 04             	mov    0x4(%ecx),%esi
  28251a:	39 c6                	cmp    %eax,%esi
  28251c:	7f b0                	jg     2824ce <sheet_refreshsub1+0x56>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  28251e:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  282522:	8b 45 ec             	mov    -0x14(%ebp),%eax
  282525:	39 41 08             	cmp    %eax,0x8(%ecx)
  282528:	7f 8f                	jg     2824b9 <sheet_refreshsub1+0x41>
void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  28252a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  28252e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  282531:	8b 7d 08             	mov    0x8(%ebp),%edi
  282534:	39 47 10             	cmp    %eax,0x10(%edi)
  282537:	0f 8d 60 ff ff ff    	jge    28249d <sheet_refreshsub1+0x25>
						vram[vy*ctl->xsize+vx] = c;
				}
			}
		}
	}
}
  28253d:	83 c4 14             	add    $0x14,%esp
  282540:	5b                   	pop    %ebx
  282541:	5e                   	pop    %esi
  282542:	5f                   	pop    %edi
  282543:	5d                   	pop    %ebp
  282544:	c3                   	ret    

00282545 <sheet_refreshsub2>:

void sheet_refreshsub2(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1,int h0)
{
  282545:	55                   	push   %ebp
  282546:	89 e5                	mov    %esp,%ebp
  282548:	57                   	push   %edi
  282549:	56                   	push   %esi
  28254a:	53                   	push   %ebx
  28254b:	83 ec 30             	sub    $0x30,%esp
  28254e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  282551:	8b 55 10             	mov    0x10(%ebp),%edx
  282554:	8b 75 14             	mov    0x14(%ebp),%esi
  282557:	8b 7d 18             	mov    0x18(%ebp),%edi
  28255a:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	int h,bx,by,vx,vy,bx0,by0,bx1,by1;
	unsigned char *buf,c,*vram = ctl->vram,*map = ctl->map;
  28255d:	8b 45 08             	mov    0x8(%ebp),%eax
  282560:	8b 00                	mov    (%eax),%eax
  282562:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  282565:	8b 45 08             	mov    0x8(%ebp),%eax
  282568:	8b 40 04             	mov    0x4(%eax),%eax
  28256b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  28256e:	b8 00 00 00 00       	mov    $0x0,%eax
  282573:	85 c9                	test   %ecx,%ecx
  282575:	0f 48 c8             	cmovs  %eax,%ecx
  282578:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  28257b:	85 d2                	test   %edx,%edx
  28257d:	0f 48 d0             	cmovs  %eax,%edx
  282580:	89 55 d0             	mov    %edx,-0x30(%ebp)
	struct SHEET *sht;
	
	//limit the refresh rect in the visible rect.
	if(vx0<0) vx0 = 0;
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
  282583:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282586:	8b 51 08             	mov    0x8(%ecx),%edx
  282589:	39 f2                	cmp    %esi,%edx
  28258b:	0f 4e f2             	cmovle %edx,%esi
  28258e:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
  282591:	8b 51 0c             	mov    0xc(%ecx),%edx
  282594:	39 fa                	cmp    %edi,%edx
  282596:	0f 4e fa             	cmovle %edx,%edi
  282599:	89 7d cc             	mov    %edi,-0x34(%ebp)
  28259c:	85 db                	test   %ebx,%ebx
  28259e:	0f 49 c3             	cmovns %ebx,%eax
  2825a1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  2825a4:	39 41 10             	cmp    %eax,0x10(%ecx)
  2825a7:	0f 8c b3 00 00 00    	jl     282660 <sheet_refreshsub2+0x11b>
	{
		//calculate the need-refresh rect of each sheet.
		sht = ctl->sheets[h];
  2825ad:	8b 45 08             	mov    0x8(%ebp),%eax
  2825b0:	8b 7d d8             	mov    -0x28(%ebp),%edi
  2825b3:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  2825b7:	8b 01                	mov    (%ecx),%eax
  2825b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		bx0 = vx0 - sht->vx0;
  2825bc:	8b 41 0c             	mov    0xc(%ecx),%eax
		by0 = vy0 - sht->vy0;
  2825bf:	8b 71 10             	mov    0x10(%ecx),%esi
		bx1 = vx1 - sht->vx0;
  2825c2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  2825c5:	29 c2                	sub    %eax,%edx
		by1 = vy1 - sht->vy0;
  2825c7:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  2825ca:	29 f3                	sub    %esi,%ebx
  2825cc:	8b 7d c8             	mov    -0x38(%ebp),%edi
  2825cf:	29 c7                	sub    %eax,%edi
  2825d1:	89 f8                	mov    %edi,%eax
  2825d3:	bf 00 00 00 00       	mov    $0x0,%edi
  2825d8:	0f 48 c7             	cmovs  %edi,%eax
  2825db:	89 45 dc             	mov    %eax,-0x24(%ebp)
  2825de:	8b 45 d0             	mov    -0x30(%ebp),%eax
  2825e1:	29 f0                	sub    %esi,%eax
  2825e3:	0f 49 f8             	cmovns %eax,%edi

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
  2825e6:	8b 41 04             	mov    0x4(%ecx),%eax
  2825e9:	39 c2                	cmp    %eax,%edx
  2825eb:	0f 4e c2             	cmovle %edx,%eax
  2825ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(by1>sht->bysize) by1=sht->bysize;
  2825f1:	8b 41 08             	mov    0x8(%ecx),%eax
  2825f4:	39 c3                	cmp    %eax,%ebx
  2825f6:	0f 4e c3             	cmovle %ebx,%eax
  2825f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for(by=by0;by<by1;by++)
  2825fc:	39 f8                	cmp    %edi,%eax
  2825fe:	7e 4d                	jle    28264d <sheet_refreshsub2+0x108>
		{
			vy = sht->vy0+by;
  282600:	89 f8                	mov    %edi,%eax
  282602:	03 41 10             	add    0x10(%ecx),%eax
  282605:	89 45 e8             	mov    %eax,-0x18(%ebp)
			for(bx=bx0;bx<bx1;bx++)
  282608:	8b 45 dc             	mov    -0x24(%ebp),%eax
  28260b:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  28260e:	7e 35                	jle    282645 <sheet_refreshsub2+0x100>
			{
				vx = sht->vx0+bx;
				c  = buf[by*sht->bxsize+bx];
  282610:	89 fa                	mov    %edi,%edx
  282612:	0f af 51 04          	imul   0x4(%ecx),%edx
  282616:	8b 75 ec             	mov    -0x14(%ebp),%esi
  282619:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  28261c:	0f b6 1c 13          	movzbl (%ebx,%edx,1),%ebx
				if(c!=sht->col_inv)
  282620:	0f b6 d3             	movzbl %bl,%edx
  282623:	3b 51 14             	cmp    0x14(%ecx),%edx
  282626:	74 15                	je     28263d <sheet_refreshsub2+0xf8>
					map[vy*ctl->xsize+vx] = c;
  282628:	8b 55 08             	mov    0x8(%ebp),%edx
  28262b:	8b 75 e8             	mov    -0x18(%ebp),%esi
  28262e:	0f af 72 08          	imul   0x8(%edx),%esi
  282632:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  282635:	01 c2                	add    %eax,%edx
  282637:	03 51 0c             	add    0xc(%ecx),%edx
  28263a:	88 1c 32             	mov    %bl,(%edx,%esi,1)
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
		{
			vy = sht->vy0+by;
			for(bx=bx0;bx<bx1;bx++)
  28263d:	83 c0 01             	add    $0x1,%eax
  282640:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  282643:	75 cb                	jne    282610 <sheet_refreshsub2+0xcb>

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
  282645:	83 c7 01             	add    $0x1,%edi
  282648:	39 7d e0             	cmp    %edi,-0x20(%ebp)
  28264b:	75 b3                	jne    282600 <sheet_refreshsub2+0xbb>
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  28264d:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  282651:	8b 45 d8             	mov    -0x28(%ebp),%eax
  282654:	8b 7d 08             	mov    0x8(%ebp),%edi
  282657:	39 47 10             	cmp    %eax,0x10(%edi)
  28265a:	0f 8d 4d ff ff ff    	jge    2825ad <sheet_refreshsub2+0x68>
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  282660:	8b 7d d0             	mov    -0x30(%ebp),%edi
  282663:	39 7d cc             	cmp    %edi,-0x34(%ebp)
  282666:	7f 2a                	jg     282692 <sheet_refreshsub2+0x14d>
  282668:	eb 40                	jmp    2826aa <sheet_refreshsub2+0x165>
  28266a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
		for(vx=vx0;vx<vx1;vx++)
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
  28266d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282670:	0f af 47 08          	imul   0x8(%edi),%eax
  282674:	01 d0                	add    %edx,%eax
  282676:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  28267a:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
		for(vx=vx0;vx<vx1;vx++)
  28267d:	83 c2 01             	add    $0x1,%edx
  282680:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
  282683:	75 e8                	jne    28266d <sheet_refreshsub2+0x128>
  282685:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  282688:	83 c1 01             	add    $0x1,%ecx
  28268b:	3b 4d cc             	cmp    -0x34(%ebp),%ecx
  28268e:	74 1a                	je     2826aa <sheet_refreshsub2+0x165>
  282690:	eb 0c                	jmp    28269e <sheet_refreshsub2+0x159>
  282692:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  282695:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  282698:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  28269b:	8b 7d 08             	mov    0x8(%ebp),%edi
		for(vx=vx0;vx<vx1;vx++)
  28269e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  2826a1:	89 c2                	mov    %eax,%edx
  2826a3:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  2826a6:	7f c2                	jg     28266a <sheet_refreshsub2+0x125>
  2826a8:	eb de                	jmp    282688 <sheet_refreshsub2+0x143>
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
}
  2826aa:	83 c4 30             	add    $0x30,%esp
  2826ad:	5b                   	pop    %ebx
  2826ae:	5e                   	pop    %esi
  2826af:	5f                   	pop    %edi
  2826b0:	5d                   	pop    %ebp
  2826b1:	c3                   	ret    

002826b2 <sheet_refresh>:

void sheet_refresh(struct SHEET *sht,int bx0,int by0,int bx1,int by1)
{
  2826b2:	55                   	push   %ebp
  2826b3:	89 e5                	mov    %esp,%ebp
  2826b5:	53                   	push   %ebx
  2826b6:	8b 45 08             	mov    0x8(%ebp),%eax
	if(sht->height >= 0)
  2826b9:	8b 58 18             	mov    0x18(%eax),%ebx
  2826bc:	85 db                	test   %ebx,%ebx
  2826be:	78 26                	js     2826e6 <sheet_refresh+0x34>
	{
		struct SHTCTL *ctl = sht->ctl;
		sheet_refreshsub2(ctl,sht->vx0+bx0,sht->vy0+by0,sht->vx0+bx1,sht->vy0+by1,sht->height);
  2826c0:	8b 48 10             	mov    0x10(%eax),%ecx
  2826c3:	8b 50 0c             	mov    0xc(%eax),%edx
  2826c6:	53                   	push   %ebx
  2826c7:	89 cb                	mov    %ecx,%ebx
  2826c9:	03 5d 18             	add    0x18(%ebp),%ebx
  2826cc:	53                   	push   %ebx
  2826cd:	89 d3                	mov    %edx,%ebx
  2826cf:	03 5d 14             	add    0x14(%ebp),%ebx
  2826d2:	53                   	push   %ebx
  2826d3:	03 4d 10             	add    0x10(%ebp),%ecx
  2826d6:	51                   	push   %ecx
  2826d7:	03 55 0c             	add    0xc(%ebp),%edx
  2826da:	52                   	push   %edx
  2826db:	ff 70 20             	pushl  0x20(%eax)
  2826de:	e8 62 fe ff ff       	call   282545 <sheet_refreshsub2>
  2826e3:	83 c4 18             	add    $0x18,%esp
	}
	return;
}
  2826e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  2826e9:	c9                   	leave  
  2826ea:	c3                   	ret    

002826eb <sheet_updown>:
	return;
}

//update the sheet with new height
void sheet_updown(struct SHEET *sht,int height)
{
  2826eb:	55                   	push   %ebp
  2826ec:	89 e5                	mov    %esp,%ebp
  2826ee:	57                   	push   %edi
  2826ef:	56                   	push   %esi
  2826f0:	53                   	push   %ebx
  2826f1:	8b 75 08             	mov    0x8(%ebp),%esi
  2826f4:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct SHTCTL *ctl = sht->ctl;
  2826f7:	8b 4e 20             	mov    0x20(%esi),%ecx
	int h,old = sht->height;
  2826fa:	8b 46 18             	mov    0x18(%esi),%eax
	if(height>ctl->top+1) height = ctl->top + 1;
  2826fd:	8b 79 10             	mov    0x10(%ecx),%edi
  282700:	8d 57 01             	lea    0x1(%edi),%edx
  282703:	39 da                	cmp    %ebx,%edx
  282705:	0f 4f d3             	cmovg  %ebx,%edx
  282708:	85 d2                	test   %edx,%edx
  28270a:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  28270f:	0f 49 da             	cmovns %edx,%ebx
	if(height<-1) height = -1;
	sht->height = height;
  282712:	89 5e 18             	mov    %ebx,0x18(%esi)

	//push down the sheet
	if(old>height)
  282715:	39 d8                	cmp    %ebx,%eax
  282717:	7e 59                	jle    282772 <sheet_updown+0x87>
	{
		//if the sheet still shows
		if(height >=0 )
  282719:	85 db                	test   %ebx,%ebx
  28271b:	79 09                	jns    282726 <sheet_updown+0x3b>
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  28271d:	8b 59 10             	mov    0x10(%ecx),%ebx
  282720:	39 d8                	cmp    %ebx,%eax
  282722:	7c 1c                	jl     282740 <sheet_updown+0x55>
  282724:	eb 31                	jmp    282757 <sheet_updown+0x6c>
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  282726:	8d 50 ff             	lea    -0x1(%eax),%edx
  282729:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  28272d:	89 7c 91 18          	mov    %edi,0x18(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282731:	89 47 18             	mov    %eax,0x18(%edi)
	if(old>height)
	{
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
  282734:	89 d0                	mov    %edx,%eax
  282736:	39 d3                	cmp    %edx,%ebx
  282738:	75 ec                	jne    282726 <sheet_updown+0x3b>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;	
  28273a:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  28273e:	eb 1d                	jmp    28275d <sheet_updown+0x72>
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  282740:	8d 50 01             	lea    0x1(%eax),%edx
  282743:	8b 5c 91 14          	mov    0x14(%ecx,%edx,4),%ebx
  282747:	89 5c 91 10          	mov    %ebx,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  28274b:	89 43 18             	mov    %eax,0x18(%ebx)
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  28274e:	8b 59 10             	mov    0x10(%ecx),%ebx
  282751:	89 d0                	mov    %edx,%eax
  282753:	39 d3                	cmp    %edx,%ebx
  282755:	7f e9                	jg     282740 <sheet_updown+0x55>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->top--;
  282757:	83 eb 01             	sub    $0x1,%ebx
  28275a:	89 59 10             	mov    %ebx,0x10(%ecx)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  28275d:	ff 76 08             	pushl  0x8(%esi)
  282760:	ff 76 04             	pushl  0x4(%esi)
  282763:	6a 00                	push   $0x0
  282765:	6a 00                	push   $0x0
  282767:	56                   	push   %esi
  282768:	e8 45 ff ff ff       	call   2826b2 <sheet_refresh>
  28276d:	83 c4 14             	add    $0x14,%esp
  282770:	eb 5a                	jmp    2827cc <sheet_updown+0xe1>
	}
	else if(old<height) //pop up the sheet
  282772:	39 d8                	cmp    %ebx,%eax
  282774:	7d 56                	jge    2827cc <sheet_updown+0xe1>
	{
		if(old >= 0) //the sheet still shows.
  282776:	85 c0                	test   %eax,%eax
  282778:	78 1a                	js     282794 <sheet_updown+0xa9>
		{
			for(h=old;h<height;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  28277a:	8d 50 01             	lea    0x1(%eax),%edx
  28277d:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  282781:	89 7c 91 10          	mov    %edi,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282785:	89 47 18             	mov    %eax,0x18(%edi)
	}
	else if(old<height) //pop up the sheet
	{
		if(old >= 0) //the sheet still shows.
		{
			for(h=old;h<height;h++)
  282788:	89 d0                	mov    %edx,%eax
  28278a:	39 d3                	cmp    %edx,%ebx
  28278c:	75 ec                	jne    28277a <sheet_updown+0x8f>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  28278e:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  282792:	eb 25                	jmp    2827b9 <sheet_updown+0xce>
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
  282794:	8b 41 10             	mov    0x10(%ecx),%eax
  282797:	8d 50 01             	lea    0x1(%eax),%edx
  28279a:	89 51 10             	mov    %edx,0x10(%ecx)
			for(h=ctl->top;h>height;h--)
  28279d:	39 d3                	cmp    %edx,%ebx
  28279f:	7d 14                	jge    2827b5 <sheet_updown+0xca>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  2827a1:	8d 42 ff             	lea    -0x1(%edx),%eax
  2827a4:	8b 7c 81 14          	mov    0x14(%ecx,%eax,4),%edi
  2827a8:	89 7c 81 18          	mov    %edi,0x18(%ecx,%eax,4)
				ctl->sheets[h]->height = h;
  2827ac:	89 57 18             	mov    %edx,0x18(%edi)
			ctl->sheets[height] = sht;
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
			for(h=ctl->top;h>height;h--)
  2827af:	89 c2                	mov    %eax,%edx
  2827b1:	39 c3                	cmp    %eax,%ebx
  2827b3:	75 ec                	jne    2827a1 <sheet_updown+0xb6>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  2827b5:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  2827b9:	ff 76 08             	pushl  0x8(%esi)
  2827bc:	ff 76 04             	pushl  0x4(%esi)
  2827bf:	6a 00                	push   $0x0
  2827c1:	6a 00                	push   $0x0
  2827c3:	56                   	push   %esi
  2827c4:	e8 e9 fe ff ff       	call   2826b2 <sheet_refresh>
  2827c9:	83 c4 14             	add    $0x14,%esp
	}
	//else height not change.
	return;
}
  2827cc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2827cf:	5b                   	pop    %ebx
  2827d0:	5e                   	pop    %esi
  2827d1:	5f                   	pop    %edi
  2827d2:	5d                   	pop    %ebp
  2827d3:	c3                   	ret    

002827d4 <sheet_slide>:
	}
	return;
}

void sheet_slide(struct SHEET *sht,int vx0,int vy0)
{
  2827d4:	55                   	push   %ebp
  2827d5:	89 e5                	mov    %esp,%ebp
  2827d7:	57                   	push   %edi
  2827d8:	56                   	push   %esi
  2827d9:	53                   	push   %ebx
  2827da:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2827dd:	8b 75 10             	mov    0x10(%ebp),%esi
	//(vx0,vy0): the sheet buf in the vram pos.
	int old_vx0 = sht->vx0,old_vy0 = sht->vy0;
  2827e0:	8b 43 0c             	mov    0xc(%ebx),%eax
  2827e3:	8b 53 10             	mov    0x10(%ebx),%edx
	sht->vx0 = vx0;
  2827e6:	8b 7d 0c             	mov    0xc(%ebp),%edi
  2827e9:	89 7b 0c             	mov    %edi,0xc(%ebx)
	sht->vy0 = vy0;
  2827ec:	89 73 10             	mov    %esi,0x10(%ebx)
	if(sht->height >= 0)
  2827ef:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  2827f3:	78 36                	js     28282b <sheet_slide+0x57>
	{
		struct SHTCTL *ctl = sht->ctl;
  2827f5:	8b 7b 20             	mov    0x20(%ebx),%edi
		sheet_refreshsub2(ctl,old_vx0,old_vy0,old_vx0+sht->bxsize,old_vy0+sht->bysize, 0);
  2827f8:	6a 00                	push   $0x0
  2827fa:	89 d1                	mov    %edx,%ecx
  2827fc:	03 4b 08             	add    0x8(%ebx),%ecx
  2827ff:	51                   	push   %ecx
  282800:	89 c1                	mov    %eax,%ecx
  282802:	03 4b 04             	add    0x4(%ebx),%ecx
  282805:	51                   	push   %ecx
  282806:	52                   	push   %edx
  282807:	50                   	push   %eax
  282808:	57                   	push   %edi
  282809:	e8 37 fd ff ff       	call   282545 <sheet_refreshsub2>
		sheet_refreshsub2(ctl,vx0,vy0,vx0+sht->bxsize,vy0+sht->bysize,sht->height);
  28280e:	ff 73 18             	pushl  0x18(%ebx)
  282811:	89 f0                	mov    %esi,%eax
  282813:	03 43 08             	add    0x8(%ebx),%eax
  282816:	50                   	push   %eax
  282817:	8b 45 0c             	mov    0xc(%ebp),%eax
  28281a:	03 43 04             	add    0x4(%ebx),%eax
  28281d:	50                   	push   %eax
  28281e:	56                   	push   %esi
  28281f:	ff 75 0c             	pushl  0xc(%ebp)
  282822:	57                   	push   %edi
  282823:	e8 1d fd ff ff       	call   282545 <sheet_refreshsub2>
  282828:	83 c4 30             	add    $0x30,%esp
	}
	return;
}
  28282b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28282e:	5b                   	pop    %ebx
  28282f:	5e                   	pop    %esi
  282830:	5f                   	pop    %edi
  282831:	5d                   	pop    %ebp
  282832:	c3                   	ret    

00282833 <sheet_free>:

void sheet_free(struct SHEET *sht)
{
  282833:	55                   	push   %ebp
  282834:	89 e5                	mov    %esp,%ebp
  282836:	53                   	push   %ebx
  282837:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(sht->height >= 0)
  28283a:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  28283e:	78 0b                	js     28284b <sheet_free+0x18>
	{
		sheet_updown(sht,-1); //hide the sheet
  282840:	6a ff                	push   $0xffffffff
  282842:	53                   	push   %ebx
  282843:	e8 a3 fe ff ff       	call   2826eb <sheet_updown>
  282848:	83 c4 08             	add    $0x8,%esp
	}
	sht->flags = 0; //set sheet unused.
  28284b:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	return;
}
  282852:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  282855:	c9                   	leave  
  282856:	c3                   	ret    

00282857 <timer_alloc>:
	timerctl.next = 0xffffffff;
	return;
}

struct TIMER *timer_alloc(void)
{
  282857:	55                   	push   %ebp
  282858:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TIMER;i++)
	{
		if(timerctl.timers0[i].flags == 0)
  28285a:	83 3d 70 6a 28 00 00 	cmpl   $0x0,0x286a70
  282861:	74 11                	je     282874 <timer_alloc+0x1d>
  282863:	ba 84 6a 28 00       	mov    $0x286a84,%edx
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282868:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(timerctl.timers0[i].flags == 0)
  28286d:	83 3a 00             	cmpl   $0x0,(%edx)
  282870:	75 25                	jne    282897 <timer_alloc+0x40>
  282872:	eb 05                	jmp    282879 <timer_alloc+0x22>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282874:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(timerctl.timers0[i].flags == 0)
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
  282879:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  282880:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282883:	c7 04 8d 70 6a 28 00 	movl   $0x1,0x286a70(,%ecx,4)
  28288a:	01 00 00 00 
			return &timerctl.timers0[i];
  28288e:	8d 04 8d 68 6a 28 00 	lea    0x286a68(,%ecx,4),%eax
  282895:	eb 12                	jmp    2828a9 <timer_alloc+0x52>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282897:	83 c0 01             	add    $0x1,%eax
  28289a:	83 c2 14             	add    $0x14,%edx
  28289d:	3d f4 01 00 00       	cmp    $0x1f4,%eax
  2828a2:	75 c9                	jne    28286d <timer_alloc+0x16>
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
			return &timerctl.timers0[i];
		}
	}
	return 0;
  2828a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2828a9:	5d                   	pop    %ebp
  2828aa:	c3                   	ret    

002828ab <init_pit>:
#include "task.h"

struct TIMERCTL timerctl;

void init_pit(void)
{
  2828ab:	55                   	push   %ebp
  2828ac:	89 e5                	mov    %esp,%ebp
  2828ae:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIT_CTRL,0X34);
  2828b1:	6a 34                	push   $0x34
  2828b3:	6a 43                	push   $0x43
  2828b5:	e8 cc e2 ff ff       	call   280b86 <io_out8>
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
  2828ba:	83 c4 08             	add    $0x8,%esp
  2828bd:	68 9c 00 00 00       	push   $0x9c
  2828c2:	6a 40                	push   $0x40
  2828c4:	e8 bd e2 ff ff       	call   280b86 <io_out8>
	io_out8(PIT_CNT0,0x2e);
  2828c9:	83 c4 08             	add    $0x8,%esp
  2828cc:	6a 2e                	push   $0x2e
  2828ce:	6a 40                	push   $0x40
  2828d0:	e8 b1 e2 ff ff       	call   280b86 <io_out8>
  2828d5:	b8 70 6a 28 00       	mov    $0x286a70,%eax
  2828da:	ba 80 91 28 00       	mov    $0x289180,%edx
  2828df:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<MAX_TIMER;i++)
		timerctl.timers0[i].flags = 0;
  2828e2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  2828e8:	83 c0 14             	add    $0x14,%eax
{
	io_out8(PIT_CTRL,0X34);
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
	io_out8(PIT_CNT0,0x2e);
	for(int i=0;i<MAX_TIMER;i++)
  2828eb:	39 d0                	cmp    %edx,%eax
  2828ed:	75 f3                	jne    2828e2 <init_pit+0x37>
		timerctl.timers0[i].flags = 0;
	struct TIMER *t = timer_alloc();
  2828ef:	e8 63 ff ff ff       	call   282857 <timer_alloc>
	t->next = 0;
  2828f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	t->timeout = 0xffffffff;
  2828fa:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
	t->flags = TIMER_FLAGS_USING;
  282901:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	timerctl.t0 = t;
  282908:	a3 78 91 28 00       	mov    %eax,0x289178
	timerctl.next = 0xffffffff;
  28290d:	c7 05 64 6a 28 00 ff 	movl   $0xffffffff,0x286a64
  282914:	ff ff ff 
	return;
}
  282917:	c9                   	leave  
  282918:	c3                   	ret    

00282919 <timer_free>:
	}
	return 0;
}

void timer_free(struct TIMER *timer)
{
  282919:	55                   	push   %ebp
  28291a:	89 e5                	mov    %esp,%ebp
	timer->flags = 0;
  28291c:	8b 45 08             	mov    0x8(%ebp),%eax
  28291f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return;
}
  282926:	5d                   	pop    %ebp
  282927:	c3                   	ret    

00282928 <timer_init>:

void timer_init(struct TIMER *timer,struct FIFO32 *fifo,unsigned char data)
{
  282928:	55                   	push   %ebp
  282929:	89 e5                	mov    %esp,%ebp
  28292b:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->fifo = fifo;
  28292e:	8b 55 0c             	mov    0xc(%ebp),%edx
  282931:	89 50 0c             	mov    %edx,0xc(%eax)
	timer->data = data;
  282934:	8b 55 10             	mov    0x10(%ebp),%edx
  282937:	88 50 10             	mov    %dl,0x10(%eax)
	return ;
}
  28293a:	5d                   	pop    %ebp
  28293b:	c3                   	ret    

0028293c <timer_settime>:

void timer_settime(struct TIMER *timer,unsigned int timeout)
{
  28293c:	55                   	push   %ebp
  28293d:	89 e5                	mov    %esp,%ebp
  28293f:	57                   	push   %edi
  282940:	56                   	push   %esi
  282941:	53                   	push   %ebx
  282942:	83 ec 0c             	sub    $0xc,%esp
  282945:	8b 5d 08             	mov    0x8(%ebp),%ebx
	timer->timeout = timeout + timerctl.count;
  282948:	a1 60 6a 28 00       	mov    0x286a60,%eax
  28294d:	03 45 0c             	add    0xc(%ebp),%eax
  282950:	89 43 04             	mov    %eax,0x4(%ebx)
	timer->flags = TIMER_FLAGS_USING;
  282953:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%ebx)
	int e = io_load_eflags();
  28295a:	e8 46 e2 ff ff       	call   280ba5 <io_load_eflags>
  28295f:	89 c6                	mov    %eax,%esi
	io_cli();
  282961:	e8 ec e1 ff ff       	call   280b52 <io_cli>
	struct TIMER *t, *s;
	if(timer->timeout<=timerctl.t0->timeout)
  282966:	8b 4b 04             	mov    0x4(%ebx),%ecx
  282969:	8b 3d 78 91 28 00    	mov    0x289178,%edi
  28296f:	3b 4f 04             	cmp    0x4(%edi),%ecx
  282972:	77 1e                	ja     282992 <timer_settime+0x56>
	{
		timer->next = timerctl.t0;
  282974:	89 3b                	mov    %edi,(%ebx)
		timerctl.t0 = timer;
  282976:	89 1d 78 91 28 00    	mov    %ebx,0x289178
		timerctl.next = timer->timeout;
  28297c:	8b 43 04             	mov    0x4(%ebx),%eax
  28297f:	a3 64 6a 28 00       	mov    %eax,0x286a64
		io_store_eflags(e);
  282984:	83 ec 0c             	sub    $0xc,%esp
  282987:	56                   	push   %esi
  282988:	e8 1b e2 ff ff       	call   280ba8 <io_store_eflags>
		return;
  28298d:	83 c4 10             	add    $0x10,%esp
  282990:	eb 3e                	jmp    2829d0 <timer_settime+0x94>
	}
	t = timerctl.t0->next;
  282992:	8b 17                	mov    (%edi),%edx
	s = timerctl.t0;
	while(t)
  282994:	85 d2                	test   %edx,%edx
  282996:	74 2c                	je     2829c4 <timer_settime+0x88>
	{
		if(timer->timeout<=t->timeout)
  282998:	3b 4a 04             	cmp    0x4(%edx),%ecx
  28299b:	77 21                	ja     2829be <timer_settime+0x82>
  28299d:	eb 07                	jmp    2829a6 <timer_settime+0x6a>
  28299f:	3b 48 04             	cmp    0x4(%eax),%ecx
  2829a2:	77 18                	ja     2829bc <timer_settime+0x80>
  2829a4:	eb 04                	jmp    2829aa <timer_settime+0x6e>
		timerctl.t0 = timer;
		timerctl.next = timer->timeout;
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
  2829a6:	89 d0                	mov    %edx,%eax
	s = timerctl.t0;
  2829a8:	89 fa                	mov    %edi,%edx
	while(t)
	{
		if(timer->timeout<=t->timeout)
		{
			timer->next = t;
  2829aa:	89 03                	mov    %eax,(%ebx)
			s->next = timer;
  2829ac:	89 1a                	mov    %ebx,(%edx)
			io_store_eflags(e);
  2829ae:	83 ec 0c             	sub    $0xc,%esp
  2829b1:	56                   	push   %esi
  2829b2:	e8 f1 e1 ff ff       	call   280ba8 <io_store_eflags>
			return;
  2829b7:	83 c4 10             	add    $0x10,%esp
  2829ba:	eb 14                	jmp    2829d0 <timer_settime+0x94>
		}
		s = t;
		t = t->next;
  2829bc:	89 c2                	mov    %eax,%edx
  2829be:	8b 02                	mov    (%edx),%eax
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
	s = timerctl.t0;
	while(t)
  2829c0:	85 c0                	test   %eax,%eax
  2829c2:	75 db                	jne    28299f <timer_settime+0x63>
			return;
		}
		s = t;
		t = t->next;
	}
	io_store_eflags(e);
  2829c4:	83 ec 0c             	sub    $0xc,%esp
  2829c7:	56                   	push   %esi
  2829c8:	e8 db e1 ff ff       	call   280ba8 <io_store_eflags>
	return;
  2829cd:	83 c4 10             	add    $0x10,%esp
}
  2829d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2829d3:	5b                   	pop    %ebx
  2829d4:	5e                   	pop    %esi
  2829d5:	5f                   	pop    %edi
  2829d6:	5d                   	pop    %ebp
  2829d7:	c3                   	ret    

002829d8 <inthandler20>:

extern struct TIMER *task_timer;

//handler for int 20 (timer interrupts)
void inthandler20(int *esp)
{
  2829d8:	55                   	push   %ebp
  2829d9:	89 e5                	mov    %esp,%ebp
  2829db:	56                   	push   %esi
  2829dc:	53                   	push   %ebx
	char ts = 0;

	io_out8(PIC0_OCW2,0x60); //tell pic continue watch 20 int
  2829dd:	83 ec 08             	sub    $0x8,%esp
  2829e0:	6a 60                	push   $0x60
  2829e2:	6a 20                	push   $0x20
  2829e4:	e8 9d e1 ff ff       	call   280b86 <io_out8>
	timerctl.count ++;
  2829e9:	a1 60 6a 28 00       	mov    0x286a60,%eax
  2829ee:	8d 50 01             	lea    0x1(%eax),%edx
  2829f1:	89 15 60 6a 28 00    	mov    %edx,0x286a60
	
	if(timerctl.count >= timerctl.next)
  2829f7:	83 c4 10             	add    $0x10,%esp
  2829fa:	3b 15 64 6a 28 00    	cmp    0x286a64,%edx
  282a00:	72 6e                	jb     282a70 <inthandler20+0x98>
	{
		struct TIMER *t = timerctl.t0;
  282a02:	8b 1d 78 91 28 00    	mov    0x289178,%ebx
		while(t)
  282a08:	85 db                	test   %ebx,%ebx
  282a0a:	75 4b                	jne    282a57 <inthandler20+0x7f>
  282a0c:	eb 62                	jmp    282a70 <inthandler20+0x98>
		{
			if(t->timeout <= timerctl.count)
  282a0e:	8b 43 04             	mov    0x4(%ebx),%eax
  282a11:	3b 05 60 6a 28 00    	cmp    0x286a60,%eax
  282a17:	77 31                	ja     282a4a <inthandler20+0x72>
			{
				t->flags = TIMER_FLAGS_ALLOC;
  282a19:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
				if(t!=task_timer) fifo32_put(t->fifo,t->data);
  282a20:	39 1d 80 91 28 00    	cmp    %ebx,0x289180
  282a26:	74 15                	je     282a3d <inthandler20+0x65>
  282a28:	83 ec 08             	sub    $0x8,%esp
  282a2b:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  282a2f:	50                   	push   %eax
  282a30:	ff 73 0c             	pushl  0xc(%ebx)
  282a33:	e8 a1 f0 ff ff       	call   281ad9 <fifo32_put>
  282a38:	83 c4 10             	add    $0x10,%esp
  282a3b:	eb 05                	jmp    282a42 <inthandler20+0x6a>
				else ts=1;
  282a3d:	be 01 00 00 00       	mov    $0x1,%esi
				t = t->next;
  282a42:	8b 1b                	mov    (%ebx),%ebx
	timerctl.count ++;
	
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
  282a44:	85 db                	test   %ebx,%ebx
  282a46:	75 c6                	jne    282a0e <inthandler20+0x36>
  282a48:	eb 1b                	jmp    282a65 <inthandler20+0x8d>
				else ts=1;
				t = t->next;
			}
			else
			{
				timerctl.next = t->timeout;
  282a4a:	a3 64 6a 28 00       	mov    %eax,0x286a64
				timerctl.t0 = t;
  282a4f:	89 1d 78 91 28 00    	mov    %ebx,0x289178
				break;
  282a55:	eb 0e                	jmp    282a65 <inthandler20+0x8d>
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
		{
			if(t->timeout <= timerctl.count)
  282a57:	8b 43 04             	mov    0x4(%ebx),%eax
  282a5a:	be 00 00 00 00       	mov    $0x0,%esi
  282a5f:	39 c2                	cmp    %eax,%edx
  282a61:	73 b6                	jae    282a19 <inthandler20+0x41>
  282a63:	eb e5                	jmp    282a4a <inthandler20+0x72>
				break;
			}
		}
	}

	if(ts!=0)task_switch();
  282a65:	89 f0                	mov    %esi,%eax
  282a67:	84 c0                	test   %al,%al
  282a69:	74 05                	je     282a70 <inthandler20+0x98>
  282a6b:	e8 0b 04 00 00       	call   282e7b <task_switch>
	return;
}
  282a70:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282a73:	5b                   	pop    %ebx
  282a74:	5e                   	pop    %esi
  282a75:	5d                   	pop    %ebp
  282a76:	c3                   	ret    
  282a77:	66 90                	xchg   %ax,%ax
  282a79:	66 90                	xchg   %ax,%ax
  282a7b:	66 90                	xchg   %ax,%ax
  282a7d:	66 90                	xchg   %ax,%ax
  282a7f:	90                   	nop

00282a80 <load_tr>:
  282a80:	0f 00 5c 24 04       	ltr    0x4(%esp)
  282a85:	c3                   	ret    

00282a86 <farjmp>:
  282a86:	ff 6c 24 04          	ljmp   *0x4(%esp)
  282a8a:	c3                   	ret    

00282a8b <farcall>:
  282a8b:	ff 5c 24 04          	lcall  *0x4(%esp)
  282a8f:	c3                   	ret    

00282a90 <asm_end_app>:
  282a90:	8b 20                	mov    (%eax),%esp
  282a92:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  282a99:	61                   	popa   
  282a9a:	c3                   	ret    

00282a9b <task_idle>:

struct TASKCTL *taskctl;
struct TIMER *task_timer;

void task_idle(void)
{
  282a9b:	55                   	push   %ebp
  282a9c:	89 e5                	mov    %esp,%ebp
  282a9e:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		io_hlt();
  282aa1:	e8 aa e0 ff ff       	call   280b50 <io_hlt>
  282aa6:	eb f9                	jmp    282aa1 <task_idle+0x6>

00282aa8 <task_alloc>:
	task_run(idle,MAX_TASKLEVELS-1,1);
	return task;
}

struct TASK *task_alloc(void)
{
  282aa8:	55                   	push   %ebp
  282aa9:	89 e5                	mov    %esp,%ebp
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
	{
		if(taskctl->tasks0[i].flags == 0)
  282aab:	8b 0d 7c 91 28 00    	mov    0x28917c,%ecx
  282ab1:	83 b9 fc 0f 00 00 00 	cmpl   $0x0,0xffc(%ecx)
  282ab8:	74 16                	je     282ad0 <task_alloc+0x28>
  282aba:	8d 91 90 10 00 00    	lea    0x1090(%ecx),%edx

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282ac0:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
  282ac5:	83 3a 00             	cmpl   $0x0,(%edx)
  282ac8:	0f 85 b9 00 00 00    	jne    282b87 <task_alloc+0xdf>
  282ace:	eb 05                	jmp    282ad5 <task_alloc+0x2d>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282ad0:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
		{
			task = &taskctl->tasks0[i];
  282ad5:	69 c0 94 00 00 00    	imul   $0x94,%eax,%eax
			task->flags = 1;
  282adb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  282ade:	c7 82 fc 0f 00 00 01 	movl   $0x1,0xffc(%edx)
  282ae5:	00 00 00 
			task->tss.eflags = 0x202;
  282ae8:	c7 82 48 10 00 00 02 	movl   $0x202,0x1048(%edx)
  282aef:	02 00 00 
			task->tss.eax = 0;
  282af2:	c7 82 4c 10 00 00 00 	movl   $0x0,0x104c(%edx)
  282af9:	00 00 00 
			task->tss.ecx = 0;
  282afc:	c7 82 50 10 00 00 00 	movl   $0x0,0x1050(%edx)
  282b03:	00 00 00 
			task->tss.edx = 0;
  282b06:	c7 82 54 10 00 00 00 	movl   $0x0,0x1054(%edx)
  282b0d:	00 00 00 
			task->tss.ebx = 0;
  282b10:	c7 82 58 10 00 00 00 	movl   $0x0,0x1058(%edx)
  282b17:	00 00 00 
			task->tss.ebp = 0;
  282b1a:	c7 82 60 10 00 00 00 	movl   $0x0,0x1060(%edx)
  282b21:	00 00 00 
			task->tss.esi = 0;
  282b24:	c7 82 64 10 00 00 00 	movl   $0x0,0x1064(%edx)
  282b2b:	00 00 00 
			task->tss.edi = 0;
  282b2e:	c7 82 68 10 00 00 00 	movl   $0x0,0x1068(%edx)
  282b35:	00 00 00 
			task->tss.es  = 0;
  282b38:	c7 82 6c 10 00 00 00 	movl   $0x0,0x106c(%edx)
  282b3f:	00 00 00 
			task->tss.ds  = 0;
  282b42:	c7 82 78 10 00 00 00 	movl   $0x0,0x1078(%edx)
  282b49:	00 00 00 
			task->tss.fs  = 0;
  282b4c:	c7 82 7c 10 00 00 00 	movl   $0x0,0x107c(%edx)
  282b53:	00 00 00 
			task->tss.gs  = 0;
  282b56:	c7 82 80 10 00 00 00 	movl   $0x0,0x1080(%edx)
  282b5d:	00 00 00 
			task->tss.ldtr= 0;
  282b60:	c7 82 84 10 00 00 00 	movl   $0x0,0x1084(%edx)
  282b67:	00 00 00 
			task->tss.iomap = 0x40000000;
  282b6a:	c7 82 88 10 00 00 00 	movl   $0x40000000,0x1088(%edx)
  282b71:	00 00 40 
			task->tss.ss0 = 0;
  282b74:	c7 82 2c 10 00 00 00 	movl   $0x0,0x102c(%edx)
  282b7b:	00 00 00 
			return task;
  282b7e:	8d 84 01 f8 0f 00 00 	lea    0xff8(%ecx,%eax,1),%eax
  282b85:	eb 19                	jmp    282ba0 <task_alloc+0xf8>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282b87:	83 c0 01             	add    $0x1,%eax
  282b8a:	81 c2 94 00 00 00    	add    $0x94,%edx
  282b90:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  282b95:	0f 85 2a ff ff ff    	jne    282ac5 <task_alloc+0x1d>
			task->tss.iomap = 0x40000000;
			task->tss.ss0 = 0;
			return task;
		}
	}
	return 0;
  282b9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282ba0:	5d                   	pop    %ebp
  282ba1:	c3                   	ret    

00282ba2 <task_now>:
	}
	return;
}

struct TASK *task_now(void)
{
  282ba2:	55                   	push   %ebp
  282ba3:	89 e5                	mov    %esp,%ebp
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282ba5:	8b 15 7c 91 28 00    	mov    0x28917c,%edx
  282bab:	8b 02                	mov    (%edx),%eax
	return tl->tasks[tl->now];
  282bad:	69 c8 98 01 00 00    	imul   $0x198,%eax,%ecx
  282bb3:	6b c0 66             	imul   $0x66,%eax,%eax
  282bb6:	03 44 0a 0c          	add    0xc(%edx,%ecx,1),%eax
  282bba:	8b 44 82 10          	mov    0x10(%edx,%eax,4),%eax
}
  282bbe:	5d                   	pop    %ebp
  282bbf:	c3                   	ret    

00282bc0 <task_add>:

void task_add(struct TASK *task)
{
  282bc0:	55                   	push   %ebp
  282bc1:	89 e5                	mov    %esp,%ebp
  282bc3:	56                   	push   %esi
  282bc4:	53                   	push   %ebx
  282bc5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  282bc8:	8b 35 7c 91 28 00    	mov    0x28917c,%esi
  282bce:	8b 4b 08             	mov    0x8(%ebx),%ecx
  282bd1:	69 c1 98 01 00 00    	imul   $0x198,%ecx,%eax
  282bd7:	01 f0                	add    %esi,%eax
	if(tl->running == MAX_TASKS_LV) return;
  282bd9:	8b 50 08             	mov    0x8(%eax),%edx
  282bdc:	83 fa 64             	cmp    $0x64,%edx
  282bdf:	74 14                	je     282bf5 <task_add+0x35>
	tl->tasks[tl->running] = task;
  282be1:	6b c9 66             	imul   $0x66,%ecx,%ecx
  282be4:	01 ca                	add    %ecx,%edx
  282be6:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
	tl->running++;
  282bea:	83 40 08 01          	addl   $0x1,0x8(%eax)
	task->flags = 2;	//alive
  282bee:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	return;
}
  282bf5:	5b                   	pop    %ebx
  282bf6:	5e                   	pop    %esi
  282bf7:	5d                   	pop    %ebp
  282bf8:	c3                   	ret    

00282bf9 <task_remove>:

void task_remove(struct TASK *task)
{
  282bf9:	55                   	push   %ebp
  282bfa:	89 e5                	mov    %esp,%ebp
  282bfc:	57                   	push   %edi
  282bfd:	56                   	push   %esi
  282bfe:	53                   	push   %ebx
  282bff:	83 ec 04             	sub    $0x4,%esp
  282c02:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  282c05:	8b 3d 7c 91 28 00    	mov    0x28917c,%edi
  282c0b:	8b 43 08             	mov    0x8(%ebx),%eax
  282c0e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  282c11:	69 d0 98 01 00 00    	imul   $0x198,%eax,%edx
  282c17:	01 fa                	add    %edi,%edx
	int i;
	for(i=0;i<tl->running;i++)
  282c19:	8b 4a 08             	mov    0x8(%edx),%ecx
  282c1c:	85 c9                	test   %ecx,%ecx
  282c1e:	7e 1d                	jle    282c3d <task_remove+0x44>
	{
		if(tl->tasks[i] == task)
  282c20:	3b 5a 10             	cmp    0x10(%edx),%ebx
  282c23:	74 1f                	je     282c44 <task_remove+0x4b>
  282c25:	b8 00 00 00 00       	mov    $0x0,%eax
  282c2a:	eb 06                	jmp    282c32 <task_remove+0x39>
  282c2c:	3b 5c 82 10          	cmp    0x10(%edx,%eax,4),%ebx
  282c30:	74 17                	je     282c49 <task_remove+0x50>

void task_remove(struct TASK *task)
{
	struct TASKLEVEL *tl = &taskctl->level[task->level];
	int i;
	for(i=0;i<tl->running;i++)
  282c32:	83 c0 01             	add    $0x1,%eax
  282c35:	39 c8                	cmp    %ecx,%eax
  282c37:	75 f3                	jne    282c2c <task_remove+0x33>
  282c39:	89 c8                	mov    %ecx,%eax
  282c3b:	eb 0c                	jmp    282c49 <task_remove+0x50>
  282c3d:	b8 00 00 00 00       	mov    $0x0,%eax
  282c42:	eb 05                	jmp    282c49 <task_remove+0x50>
  282c44:	b8 00 00 00 00       	mov    $0x0,%eax
		if(tl->tasks[i] == task)
		{
			break;
		}
	}
	tl->running--;
  282c49:	83 e9 01             	sub    $0x1,%ecx
  282c4c:	89 4a 08             	mov    %ecx,0x8(%edx)
	if(i<tl->now)
  282c4f:	8b 72 0c             	mov    0xc(%edx),%esi
  282c52:	39 c6                	cmp    %eax,%esi
  282c54:	7e 06                	jle    282c5c <task_remove+0x63>
	{
		tl->now--;
  282c56:	83 ee 01             	sub    $0x1,%esi
  282c59:	89 72 0c             	mov    %esi,0xc(%edx)
	}
	if(tl->now >= tl->running)
  282c5c:	3b 4a 0c             	cmp    0xc(%edx),%ecx
  282c5f:	7f 07                	jg     282c68 <task_remove+0x6f>
	{
		tl->now = 0;
  282c61:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	}
	task->flags = 1; //sleep;
  282c68:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	
	for(;i<tl->running;i++)
  282c6f:	39 42 08             	cmp    %eax,0x8(%edx)
  282c72:	7e 1b                	jle    282c8f <task_remove+0x96>
  282c74:	6b 4d f0 66          	imul   $0x66,-0x10(%ebp),%ecx
  282c78:	8d 4c 08 05          	lea    0x5(%eax,%ecx,1),%ecx
  282c7c:	8d 0c 8f             	lea    (%edi,%ecx,4),%ecx
	{
		tl->tasks[i] = tl->tasks[i+1];
  282c7f:	83 c0 01             	add    $0x1,%eax
  282c82:	8b 19                	mov    (%ecx),%ebx
  282c84:	89 59 fc             	mov    %ebx,-0x4(%ecx)
  282c87:	83 c1 04             	add    $0x4,%ecx
	{
		tl->now = 0;
	}
	task->flags = 1; //sleep;
	
	for(;i<tl->running;i++)
  282c8a:	39 42 08             	cmp    %eax,0x8(%edx)
  282c8d:	7f f0                	jg     282c7f <task_remove+0x86>
	{
		tl->tasks[i] = tl->tasks[i+1];
	}
	return;
}
  282c8f:	83 c4 04             	add    $0x4,%esp
  282c92:	5b                   	pop    %ebx
  282c93:	5e                   	pop    %esi
  282c94:	5f                   	pop    %edi
  282c95:	5d                   	pop    %ebp
  282c96:	c3                   	ret    

00282c97 <task_run>:
	}
	return 0;
}

void task_run(struct TASK *task,int level,int priority)
{
  282c97:	55                   	push   %ebp
  282c98:	89 e5                	mov    %esp,%ebp
  282c9a:	56                   	push   %esi
  282c9b:	53                   	push   %ebx
  282c9c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282c9f:	8b 75 0c             	mov    0xc(%ebp),%esi
  282ca2:	8b 45 10             	mov    0x10(%ebp),%eax
	if(level < 0) level = task->level;
  282ca5:	85 f6                	test   %esi,%esi
  282ca7:	79 03                	jns    282cac <task_run+0x15>
  282ca9:	8b 73 08             	mov    0x8(%ebx),%esi
	if(priority > 0) task->priority = priority;
  282cac:	85 c0                	test   %eax,%eax
  282cae:	7e 03                	jle    282cb3 <task_run+0x1c>
  282cb0:	89 43 0c             	mov    %eax,0xc(%ebx)
	if(task->flags == 2 && task->level != level)
  282cb3:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282cb7:	75 14                	jne    282ccd <task_run+0x36>
  282cb9:	3b 73 08             	cmp    0x8(%ebx),%esi
  282cbc:	74 1b                	je     282cd9 <task_run+0x42>
	{
		task_remove(task); //then task->flags = 1;
  282cbe:	53                   	push   %ebx
  282cbf:	e8 35 ff ff ff       	call   282bf9 <task_remove>
	}
	if(task->flags != 2)
  282cc4:	83 c4 04             	add    $0x4,%esp
  282cc7:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282ccb:	74 0c                	je     282cd9 <task_run+0x42>
	{
		task->level = level;
  282ccd:	89 73 08             	mov    %esi,0x8(%ebx)
		task_add(task);
  282cd0:	53                   	push   %ebx
  282cd1:	e8 ea fe ff ff       	call   282bc0 <task_add>
  282cd6:	83 c4 04             	add    $0x4,%esp
	}
	taskctl->lv_change = 1;
  282cd9:	a1 7c 91 28 00       	mov    0x28917c,%eax
  282cde:	c6 40 04 01          	movb   $0x1,0x4(%eax)
	return;
}
  282ce2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282ce5:	5b                   	pop    %ebx
  282ce6:	5e                   	pop    %esi
  282ce7:	5d                   	pop    %ebp
  282ce8:	c3                   	ret    

00282ce9 <task_switchsub>:
	}
	return;
}

void task_switchsub(void)
{
  282ce9:	55                   	push   %ebp
  282cea:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		if(taskctl->level[i].running>0) break;
  282cec:	8b 0d 7c 91 28 00    	mov    0x28917c,%ecx
  282cf2:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  282cf6:	7f 20                	jg     282d18 <task_switchsub+0x2f>
  282cf8:	8d 91 a0 01 00 00    	lea    0x1a0(%ecx),%edx
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282cfe:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->level[i].running>0) break;
  282d03:	83 3a 00             	cmpl   $0x0,(%edx)
  282d06:	7f 15                	jg     282d1d <task_switchsub+0x34>
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282d08:	83 c0 01             	add    $0x1,%eax
  282d0b:	81 c2 98 01 00 00    	add    $0x198,%edx
  282d11:	83 f8 0a             	cmp    $0xa,%eax
  282d14:	75 ed                	jne    282d03 <task_switchsub+0x1a>
  282d16:	eb 05                	jmp    282d1d <task_switchsub+0x34>
  282d18:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->level[i].running>0) break;
	}
	taskctl->now_lv = i;
  282d1d:	89 01                	mov    %eax,(%ecx)
	taskctl->lv_change = 0;
  282d1f:	a1 7c 91 28 00       	mov    0x28917c,%eax
  282d24:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	return;
}
  282d28:	5d                   	pop    %ebp
  282d29:	c3                   	ret    

00282d2a <task_init>:
		io_hlt();
	}
}

struct TASK *task_init(struct MEMMAN *memman)
{
  282d2a:	55                   	push   %ebp
  282d2b:	89 e5                	mov    %esp,%ebp
  282d2d:	57                   	push   %edi
  282d2e:	56                   	push   %esi
  282d2f:	53                   	push   %ebx
  282d30:	83 ec 14             	sub    $0x14,%esp
  282d33:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
  282d36:	68 18 52 02 00       	push   $0x25218
  282d3b:	57                   	push   %edi
  282d3c:	e8 1c f5 ff ff       	call   28225d <memman_alloc_4k>
  282d41:	a3 7c 91 28 00       	mov    %eax,0x28917c
  282d46:	83 c4 10             	add    $0x10,%esp
  282d49:	be 20 00 00 00       	mov    $0x20,%esi
	for(i=0;i<MAX_TASKS;i++)
  282d4e:	bb 00 00 00 00       	mov    $0x0,%ebx
	{
		taskctl->tasks0[i].flags = 0;
  282d53:	8b 15 7c 91 28 00    	mov    0x28917c,%edx
  282d59:	69 c3 94 00 00 00    	imul   $0x94,%ebx,%eax
  282d5f:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282d62:	c7 81 fc 0f 00 00 00 	movl   $0x0,0xffc(%ecx)
  282d69:	00 00 00 
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
  282d6c:	89 b1 f8 0f 00 00    	mov    %esi,0xff8(%ecx)
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
  282d72:	68 89 00 00 00       	push   $0x89
  282d77:	8d 84 02 24 10 00 00 	lea    0x1024(%edx,%eax,1),%eax
  282d7e:	50                   	push   %eax
  282d7f:	6a 67                	push   $0x67
  282d81:	8d 86 00 00 27 00    	lea    0x270000(%esi),%eax
  282d87:	50                   	push   %eax
  282d88:	e8 ea e5 ff ff       	call   281377 <set_segmdesc>
{
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
	for(i=0;i<MAX_TASKS;i++)
  282d8d:	83 c3 01             	add    $0x1,%ebx
  282d90:	83 c6 08             	add    $0x8,%esi
  282d93:	83 c4 10             	add    $0x10,%esp
  282d96:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
  282d9c:	75 b5                	jne    282d53 <task_init+0x29>
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		taskctl->level[i].running = 0;
  282d9e:	8b 15 7c 91 28 00    	mov    0x28917c,%edx
  282da4:	8d 42 08             	lea    0x8(%edx),%eax
  282da7:	81 c2 f8 0f 00 00    	add    $0xff8,%edx
  282dad:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		taskctl->level[i].now = 0;
  282db3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  282dba:	05 98 01 00 00       	add    $0x198,%eax
		taskctl->tasks0[i].flags = 0;
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
  282dbf:	39 d0                	cmp    %edx,%eax
  282dc1:	75 ea                	jne    282dad <task_init+0x83>
	{
		taskctl->level[i].running = 0;
		taskctl->level[i].now = 0;
	}
	task = task_alloc();
  282dc3:	e8 e0 fc ff ff       	call   282aa8 <task_alloc>
  282dc8:	89 c6                	mov    %eax,%esi
	task->flags = 2;
  282dca:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
	task->priority = 2;
  282dd1:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	task->level = 0;
  282dd8:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	task_add(task);
  282ddf:	83 ec 0c             	sub    $0xc,%esp
  282de2:	50                   	push   %eax
  282de3:	e8 d8 fd ff ff       	call   282bc0 <task_add>
	
	task_switchsub();
  282de8:	e8 fc fe ff ff       	call   282ce9 <task_switchsub>
	load_tr(task->sel);
  282ded:	83 c4 04             	add    $0x4,%esp
  282df0:	ff 36                	pushl  (%esi)
  282df2:	e8 89 fc ff ff       	call   282a80 <load_tr>
	task_timer = timer_alloc();
  282df7:	e8 5b fa ff ff       	call   282857 <timer_alloc>
  282dfc:	a3 80 91 28 00       	mov    %eax,0x289180
	timer_settime(task_timer,task->priority);
  282e01:	83 c4 08             	add    $0x8,%esp
  282e04:	ff 76 0c             	pushl  0xc(%esi)
  282e07:	50                   	push   %eax
  282e08:	e8 2f fb ff ff       	call   28293c <timer_settime>

	struct TASK *idle = task_alloc();
  282e0d:	e8 96 fc ff ff       	call   282aa8 <task_alloc>
  282e12:	89 c3                	mov    %eax,%ebx
	idle->tss.esp = memman_alloc(memman,64*1024)+64*1024;
  282e14:	83 c4 08             	add    $0x8,%esp
  282e17:	68 00 00 01 00       	push   $0x10000
  282e1c:	57                   	push   %edi
  282e1d:	e8 ff f0 ff ff       	call   281f21 <memman_alloc>
  282e22:	05 00 00 01 00       	add    $0x10000,%eax
  282e27:	89 43 64             	mov    %eax,0x64(%ebx)
	idle->tss.eip = (int)&task_idle-0x280000;
  282e2a:	c7 43 4c 9b 2a 00 00 	movl   $0x2a9b,0x4c(%ebx)
	idle->tss.es = 1*8;
  282e31:	c7 43 74 08 00 00 00 	movl   $0x8,0x74(%ebx)
	idle->tss.cs = 3*8;
  282e38:	c7 43 78 18 00 00 00 	movl   $0x18,0x78(%ebx)
	idle->tss.ss = 1*8;
  282e3f:	c7 43 7c 08 00 00 00 	movl   $0x8,0x7c(%ebx)
	idle->tss.ds = 1*8;
  282e46:	c7 83 80 00 00 00 08 	movl   $0x8,0x80(%ebx)
  282e4d:	00 00 00 
	idle->tss.fs = 1*8;
  282e50:	c7 83 84 00 00 00 08 	movl   $0x8,0x84(%ebx)
  282e57:	00 00 00 
	idle->tss.gs = 1*8;
  282e5a:	c7 83 88 00 00 00 08 	movl   $0x8,0x88(%ebx)
  282e61:	00 00 00 
	task_run(idle,MAX_TASKLEVELS-1,1);
  282e64:	83 c4 0c             	add    $0xc,%esp
  282e67:	6a 01                	push   $0x1
  282e69:	6a 09                	push   $0x9
  282e6b:	53                   	push   %ebx
  282e6c:	e8 26 fe ff ff       	call   282c97 <task_run>
	return task;
}
  282e71:	89 f0                	mov    %esi,%eax
  282e73:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282e76:	5b                   	pop    %ebx
  282e77:	5e                   	pop    %esi
  282e78:	5f                   	pop    %edi
  282e79:	5d                   	pop    %ebp
  282e7a:	c3                   	ret    

00282e7b <task_switch>:
	taskctl->lv_change = 1;
	return;
}

void task_switch(void)
{
  282e7b:	55                   	push   %ebp
  282e7c:	89 e5                	mov    %esp,%ebp
  282e7e:	56                   	push   %esi
  282e7f:	53                   	push   %ebx
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282e80:	8b 0d 7c 91 28 00    	mov    0x28917c,%ecx
  282e86:	8b 31                	mov    (%ecx),%esi
  282e88:	69 c6 98 01 00 00    	imul   $0x198,%esi,%eax
  282e8e:	01 c8                	add    %ecx,%eax
	struct TASK *new_task,*now_task = tl->tasks[tl->now];
  282e90:	8b 50 0c             	mov    0xc(%eax),%edx
  282e93:	6b de 66             	imul   $0x66,%esi,%ebx
  282e96:	01 d3                	add    %edx,%ebx
  282e98:	8b 5c 99 10          	mov    0x10(%ecx,%ebx,4),%ebx
	tl->now++;
  282e9c:	83 c2 01             	add    $0x1,%edx
  282e9f:	89 50 0c             	mov    %edx,0xc(%eax)
	if(tl->now == tl->running)
  282ea2:	3b 50 08             	cmp    0x8(%eax),%edx
  282ea5:	75 07                	jne    282eae <task_switch+0x33>
	{
		tl->now = 0;
  282ea7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
	if(taskctl->lv_change!=0)
  282eae:	80 79 04 00          	cmpb   $0x0,0x4(%ecx)
  282eb2:	75 0c                	jne    282ec0 <task_switch+0x45>
	return;
}

void task_switch(void)
{
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282eb4:	69 f6 98 01 00 00    	imul   $0x198,%esi,%esi
  282eba:	8d 44 31 08          	lea    0x8(%ecx,%esi,1),%eax
  282ebe:	eb 14                	jmp    282ed4 <task_switch+0x59>
	{
		tl->now = 0;
	}
	if(taskctl->lv_change!=0)
	{
		task_switchsub();
  282ec0:	e8 24 fe ff ff       	call   282ce9 <task_switchsub>
		tl = &taskctl->level[taskctl->now_lv];
  282ec5:	a1 7c 91 28 00       	mov    0x28917c,%eax
  282eca:	69 10 98 01 00 00    	imul   $0x198,(%eax),%edx
  282ed0:	8d 44 10 08          	lea    0x8(%eax,%edx,1),%eax
	}
	new_task = tl->tasks[tl->now];
  282ed4:	8b 50 04             	mov    0x4(%eax),%edx
  282ed7:	8b 74 90 08          	mov    0x8(%eax,%edx,4),%esi
	timer_settime(task_timer,new_task->priority);
  282edb:	83 ec 08             	sub    $0x8,%esp
  282ede:	ff 76 0c             	pushl  0xc(%esi)
  282ee1:	ff 35 80 91 28 00    	pushl  0x289180
  282ee7:	e8 50 fa ff ff       	call   28293c <timer_settime>
	if(new_task != now_task)
  282eec:	83 c4 10             	add    $0x10,%esp
  282eef:	39 f3                	cmp    %esi,%ebx
  282ef1:	74 0f                	je     282f02 <task_switch+0x87>
	{
		farjmp(0,new_task->sel);
  282ef3:	83 ec 08             	sub    $0x8,%esp
  282ef6:	ff 36                	pushl  (%esi)
  282ef8:	6a 00                	push   $0x0
  282efa:	e8 87 fb ff ff       	call   282a86 <farjmp>
  282eff:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  282f02:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282f05:	5b                   	pop    %ebx
  282f06:	5e                   	pop    %esi
  282f07:	5d                   	pop    %ebp
  282f08:	c3                   	ret    

00282f09 <task_sleep>:

void task_sleep(struct TASK *task)
{
  282f09:	55                   	push   %ebp
  282f0a:	89 e5                	mov    %esp,%ebp
  282f0c:	56                   	push   %esi
  282f0d:	53                   	push   %ebx
  282f0e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASK *now_task;
	if(task->flags == 2)
  282f11:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282f15:	75 2d                	jne    282f44 <task_sleep+0x3b>
	{
		now_task = task_now();
  282f17:	e8 86 fc ff ff       	call   282ba2 <task_now>
  282f1c:	89 c6                	mov    %eax,%esi
		task_remove(task);
  282f1e:	53                   	push   %ebx
  282f1f:	e8 d5 fc ff ff       	call   282bf9 <task_remove>
		if(task == now_task)
  282f24:	83 c4 04             	add    $0x4,%esp
  282f27:	39 f3                	cmp    %esi,%ebx
  282f29:	75 19                	jne    282f44 <task_sleep+0x3b>
		{
			task_switchsub();
  282f2b:	e8 b9 fd ff ff       	call   282ce9 <task_switchsub>
			now_task = task_now();
  282f30:	e8 6d fc ff ff       	call   282ba2 <task_now>
			farjmp(0,now_task->sel);
  282f35:	83 ec 08             	sub    $0x8,%esp
  282f38:	ff 30                	pushl  (%eax)
  282f3a:	6a 00                	push   $0x0
  282f3c:	e8 45 fb ff ff       	call   282a86 <farjmp>
  282f41:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  282f44:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282f47:	5b                   	pop    %ebx
  282f48:	5e                   	pop    %esi
  282f49:	5d                   	pop    %ebp
  282f4a:	c3                   	ret    

00282f4b <console_task>:
#include "header.h"
void console_task(struct SHEET *sheet,unsigned int memtotal)
{
  282f4b:	55                   	push   %ebp
  282f4c:	89 e5                	mov    %esp,%ebp
  282f4e:	57                   	push   %edi
  282f4f:	56                   	push   %esi
  282f50:	53                   	push   %ebx
  282f51:	81 ec 4c 02 00 00    	sub    $0x24c,%esp
  282f57:	8b 7d 08             	mov    0x8(%ebp),%edi
	char s[50],cmdline[30];
	struct TIMER *timer;
	struct TASK *task = task_now();
  282f5a:	e8 43 fc ff ff       	call   282ba2 <task_now>
  282f5f:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct CONSOLE cons;
	cons.sht = sheet;
  282f65:	89 7d b8             	mov    %edi,-0x48(%ebp)
	cons.cur_x = 8;
  282f68:	c7 45 bc 08 00 00 00 	movl   $0x8,-0x44(%ebp)
	cons.cur_y = 28;
  282f6f:	c7 45 c0 1c 00 00 00 	movl   $0x1c,-0x40(%ebp)
	cons.cur_c = -1;
  282f76:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,-0x3c(%ebp)
	*((int *)0x0fec) = (int)&cons; //for api
  282f7d:	8d 5d b8             	lea    -0x48(%ebp),%ebx
  282f80:	89 1d ec 0f 00 00    	mov    %ebx,0xfec

	int i,fifobuf[128];
	fifo32_init(&task->fifo,128,fifobuf,task);
  282f86:	8d 70 10             	lea    0x10(%eax),%esi
  282f89:	50                   	push   %eax
  282f8a:	8d 85 b8 fd ff ff    	lea    -0x248(%ebp),%eax
  282f90:	50                   	push   %eax
  282f91:	68 80 00 00 00       	push   $0x80
  282f96:	56                   	push   %esi
  282f97:	e8 0c eb ff ff       	call   281aa8 <fifo32_init>
	timer = timer_alloc();
  282f9c:	e8 b6 f8 ff ff       	call   282857 <timer_alloc>
	timer_init(timer,&task->fifo,1);
  282fa1:	83 c4 0c             	add    $0xc,%esp
  282fa4:	6a 01                	push   $0x1
  282fa6:	56                   	push   %esi
  282fa7:	89 85 b0 fd ff ff    	mov    %eax,-0x250(%ebp)
  282fad:	50                   	push   %eax
  282fae:	e8 75 f9 ff ff       	call   282928 <timer_init>
	timer_settime(timer,50);
  282fb3:	83 c4 08             	add    $0x8,%esp
  282fb6:	6a 32                	push   $0x32
  282fb8:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
  282fbe:	e8 79 f9 ff ff       	call   28293c <timer_settime>
	
	int *fat = (int *)memman_alloc_4k(memman, 4*2880);
  282fc3:	83 c4 08             	add    $0x8,%esp
  282fc6:	68 00 2d 00 00       	push   $0x2d00
  282fcb:	68 00 00 3c 00       	push   $0x3c0000
  282fd0:	e8 88 f2 ff ff       	call   28225d <memman_alloc_4k>
  282fd5:	89 85 ac fd ff ff    	mov    %eax,-0x254(%ebp)
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG+0x000200));
  282fdb:	83 c4 08             	add    $0x8,%esp
  282fde:	68 00 02 10 00       	push   $0x100200
  282fe3:	50                   	push   %eax
  282fe4:	e8 17 02 00 00       	call   283200 <file_readfat>

	//draw prompt char
	cons_putchar(&cons,'>',1);
  282fe9:	83 c4 0c             	add    $0xc,%esp
  282fec:	6a 01                	push   $0x1
  282fee:	6a 3e                	push   $0x3e
  282ff0:	53                   	push   %ebx
  282ff1:	e8 a4 05 00 00       	call   28359a <cons_putchar>
  282ff6:	83 c4 10             	add    $0x10,%esp
	for(;;)
	{
		io_cli();
  282ff9:	e8 54 db ff ff       	call   280b52 <io_cli>
		if(fifo32_status(&task->fifo)==0)
  282ffe:	83 ec 0c             	sub    $0xc,%esp
  283001:	56                   	push   %esi
  283002:	e8 7f eb ff ff       	call   281b86 <fifo32_status>
  283007:	83 c4 10             	add    $0x10,%esp
  28300a:	85 c0                	test   %eax,%eax
  28300c:	75 18                	jne    283026 <console_task+0xdb>
		{
			task_sleep(task);
  28300e:	83 ec 0c             	sub    $0xc,%esp
  283011:	ff b5 b4 fd ff ff    	pushl  -0x24c(%ebp)
  283017:	e8 ed fe ff ff       	call   282f09 <task_sleep>
			io_sti();
  28301c:	e8 33 db ff ff       	call   280b54 <io_sti>
  283021:	83 c4 10             	add    $0x10,%esp
  283024:	eb d3                	jmp    282ff9 <console_task+0xae>
		}
		else
		{
			i=fifo32_get(&task->fifo);
  283026:	83 ec 0c             	sub    $0xc,%esp
  283029:	56                   	push   %esi
  28302a:	e8 1c eb ff ff       	call   281b4b <fifo32_get>
  28302f:	89 c3                	mov    %eax,%ebx
			io_sti();
  283031:	e8 1e db ff ff       	call   280b54 <io_sti>
			if(i<=1) //for cursor
  283036:	83 c4 10             	add    $0x10,%esp
  283039:	83 fb 01             	cmp    $0x1,%ebx
  28303c:	7f 60                	jg     28309e <console_task+0x153>
			{
				if(i!=0)
  28303e:	85 db                	test   %ebx,%ebx
  283040:	74 23                	je     283065 <console_task+0x11a>
				{
					timer_init(timer,&task->fifo,0);
  283042:	83 ec 04             	sub    $0x4,%esp
  283045:	6a 00                	push   $0x0
  283047:	56                   	push   %esi
  283048:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
  28304e:	e8 d5 f8 ff ff       	call   282928 <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_FFFFFF;
  283053:	83 c4 10             	add    $0x10,%esp
  283056:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  28305a:	78 2a                	js     283086 <console_task+0x13b>
  28305c:	c7 45 c4 07 00 00 00 	movl   $0x7,-0x3c(%ebp)
  283063:	eb 21                	jmp    283086 <console_task+0x13b>
				}
				else
				{
					timer_init(timer,&task->fifo,1);
  283065:	83 ec 04             	sub    $0x4,%esp
  283068:	6a 01                	push   $0x1
  28306a:	56                   	push   %esi
  28306b:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
  283071:	e8 b2 f8 ff ff       	call   282928 <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_000000;
  283076:	83 c4 10             	add    $0x10,%esp
  283079:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  28307d:	78 07                	js     283086 <console_task+0x13b>
  28307f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
				}
				timer_settime(timer,50);
  283086:	83 ec 08             	sub    $0x8,%esp
  283089:	6a 32                	push   $0x32
  28308b:	ff b5 b0 fd ff ff    	pushl  -0x250(%ebp)
  283091:	e8 a6 f8 ff ff       	call   28293c <timer_settime>
  283096:	83 c4 10             	add    $0x10,%esp
  283099:	e9 16 01 00 00       	jmp    2831b4 <console_task+0x269>
							
			}
			else if(i == 2) //get show cursor msg
  28309e:	83 fb 02             	cmp    $0x2,%ebx
  2830a1:	75 11                	jne    2830b4 <console_task+0x169>
			{
				cons.cur_c = COL8_FFFFFF;
  2830a3:	c7 45 c4 07 00 00 00 	movl   $0x7,-0x3c(%ebp)
						cmdline[cons.cur_x/8-2] = i-256;
						cons_putchar(&cons,i-256,1);
					}
				}
			}
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  2830aa:	b8 07 00 00 00       	mov    $0x7,%eax
  2830af:	e9 07 01 00 00       	jmp    2831bb <console_task+0x270>
			}
			else if(i == 2) //get show cursor msg
			{
				cons.cur_c = COL8_FFFFFF;
			}
			else if(i == 3) //get hide cursor msg
  2830b4:	83 fb 03             	cmp    $0x3,%ebx
  2830b7:	75 2a                	jne    2830e3 <console_task+0x198>
			{
				cons.cur_c = -1;
  2830b9:	c7 45 c4 ff ff ff ff 	movl   $0xffffffff,-0x3c(%ebp)
				boxfill8(sheet->buf,sheet->bxsize,COL8_000000,cons.cur_x,28,cons.cur_x+7,43);
  2830c0:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2830c3:	83 ec 04             	sub    $0x4,%esp
  2830c6:	6a 2b                	push   $0x2b
  2830c8:	8d 50 07             	lea    0x7(%eax),%edx
  2830cb:	52                   	push   %edx
  2830cc:	6a 1c                	push   $0x1c
  2830ce:	50                   	push   %eax
  2830cf:	6a 00                	push   $0x0
  2830d1:	ff 77 04             	pushl  0x4(%edi)
  2830d4:	ff 37                	pushl  (%edi)
  2830d6:	e8 f9 db ff ff       	call   280cd4 <boxfill8>
  2830db:	83 c4 20             	add    $0x20,%esp
  2830de:	e9 d1 00 00 00       	jmp    2831b4 <console_task+0x269>
			}
			else if(256<=i && i<=511)
  2830e3:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
  2830e9:	3d ff 00 00 00       	cmp    $0xff,%eax
  2830ee:	0f 87 c0 00 00 00    	ja     2831b4 <console_task+0x269>
			{
				if(i == 8+256) //back key
  2830f4:	81 fb 08 01 00 00    	cmp    $0x108,%ebx
  2830fa:	75 26                	jne    283122 <console_task+0x1d7>
				{
					if(cons.cur_x > 16)
  2830fc:	83 7d bc 10          	cmpl   $0x10,-0x44(%ebp)
  283100:	0f 8e ae 00 00 00    	jle    2831b4 <console_task+0x269>
					{
						cons_putchar(&cons,' ',0);
  283106:	83 ec 04             	sub    $0x4,%esp
  283109:	6a 00                	push   $0x0
  28310b:	6a 20                	push   $0x20
  28310d:	8d 45 b8             	lea    -0x48(%ebp),%eax
  283110:	50                   	push   %eax
  283111:	e8 84 04 00 00       	call   28359a <cons_putchar>
						cons.cur_x -= 8;
  283116:	83 6d bc 08          	subl   $0x8,-0x44(%ebp)
  28311a:	83 c4 10             	add    $0x10,%esp
  28311d:	e9 92 00 00 00       	jmp    2831b4 <console_task+0x269>
					}
				}
				else if(i == 10+256) //return key
  283122:	81 fb 0a 01 00 00    	cmp    $0x10a,%ebx
  283128:	75 59                	jne    283183 <console_task+0x238>
				{
					cons_putchar(&cons,' ',0);
  28312a:	83 ec 04             	sub    $0x4,%esp
  28312d:	6a 00                	push   $0x0
  28312f:	6a 20                	push   $0x20
  283131:	8d 45 b8             	lea    -0x48(%ebp),%eax
  283134:	50                   	push   %eax
  283135:	e8 60 04 00 00       	call   28359a <cons_putchar>
					cmdline[cons.cur_x/8-2] = 0;
  28313a:	8b 55 bc             	mov    -0x44(%ebp),%edx
  28313d:	8d 42 07             	lea    0x7(%edx),%eax
  283140:	85 d2                	test   %edx,%edx
  283142:	0f 49 c2             	cmovns %edx,%eax
  283145:	c1 f8 03             	sar    $0x3,%eax
  283148:	c6 44 05 c8 00       	movb   $0x0,-0x38(%ebp,%eax,1)
					cons_newline(&cons);
  28314d:	8d 45 b8             	lea    -0x48(%ebp),%eax
  283150:	89 04 24             	mov    %eax,(%esp)
  283153:	e8 77 03 00 00       	call   2834cf <cons_newline>
					cons_runcmd(cmdline,&cons,fat,memtotal);
  283158:	ff 75 0c             	pushl  0xc(%ebp)
  28315b:	ff b5 ac fd ff ff    	pushl  -0x254(%ebp)
  283161:	8d 45 b8             	lea    -0x48(%ebp),%eax
  283164:	50                   	push   %eax
  283165:	8d 45 ca             	lea    -0x36(%ebp),%eax
  283168:	50                   	push   %eax
  283169:	e8 bd 09 00 00       	call   283b2b <cons_runcmd>
					cons_putchar(&cons,'>',1);
  28316e:	83 c4 1c             	add    $0x1c,%esp
  283171:	6a 01                	push   $0x1
  283173:	6a 3e                	push   $0x3e
  283175:	8d 45 b8             	lea    -0x48(%ebp),%eax
  283178:	50                   	push   %eax
  283179:	e8 1c 04 00 00       	call   28359a <cons_putchar>
  28317e:	83 c4 10             	add    $0x10,%esp
  283181:	eb 31                	jmp    2831b4 <console_task+0x269>
				}
				else
				{
					if(cons.cur_x<240)
  283183:	8b 45 bc             	mov    -0x44(%ebp),%eax
  283186:	3d ef 00 00 00       	cmp    $0xef,%eax
  28318b:	7f 27                	jg     2831b4 <console_task+0x269>
					{
						s[0] = i-256;
						s[1] = 0;
						cmdline[cons.cur_x/8-2] = i-256;
  28318d:	8d 50 07             	lea    0x7(%eax),%edx
  283190:	85 c0                	test   %eax,%eax
  283192:	0f 48 c2             	cmovs  %edx,%eax
  283195:	c1 f8 03             	sar    $0x3,%eax
  283198:	88 5c 05 c8          	mov    %bl,-0x38(%ebp,%eax,1)
						cons_putchar(&cons,i-256,1);
  28319c:	83 ec 04             	sub    $0x4,%esp
  28319f:	6a 01                	push   $0x1
  2831a1:	81 eb 00 01 00 00    	sub    $0x100,%ebx
  2831a7:	53                   	push   %ebx
  2831a8:	8d 45 b8             	lea    -0x48(%ebp),%eax
  2831ab:	50                   	push   %eax
  2831ac:	e8 e9 03 00 00       	call   28359a <cons_putchar>
  2831b1:	83 c4 10             	add    $0x10,%esp
					}
				}
			}
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  2831b4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  2831b7:	85 c0                	test   %eax,%eax
  2831b9:	78 24                	js     2831df <console_task+0x294>
  2831bb:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  2831be:	8b 55 bc             	mov    -0x44(%ebp),%edx
  2831c1:	83 ec 04             	sub    $0x4,%esp
  2831c4:	8d 59 0f             	lea    0xf(%ecx),%ebx
  2831c7:	53                   	push   %ebx
  2831c8:	8d 5a 07             	lea    0x7(%edx),%ebx
  2831cb:	53                   	push   %ebx
  2831cc:	51                   	push   %ecx
  2831cd:	52                   	push   %edx
  2831ce:	0f b6 c0             	movzbl %al,%eax
  2831d1:	50                   	push   %eax
  2831d2:	ff 77 04             	pushl  0x4(%edi)
  2831d5:	ff 37                	pushl  (%edi)
  2831d7:	e8 f8 da ff ff       	call   280cd4 <boxfill8>
  2831dc:	83 c4 20             	add    $0x20,%esp
			sheet_refresh(sheet,cons.cur_x,cons.cur_y,cons.cur_x+8,cons.cur_y+16);
  2831df:	8b 55 c0             	mov    -0x40(%ebp),%edx
  2831e2:	8b 45 bc             	mov    -0x44(%ebp),%eax
  2831e5:	83 ec 0c             	sub    $0xc,%esp
  2831e8:	8d 4a 10             	lea    0x10(%edx),%ecx
  2831eb:	51                   	push   %ecx
  2831ec:	8d 48 08             	lea    0x8(%eax),%ecx
  2831ef:	51                   	push   %ecx
  2831f0:	52                   	push   %edx
  2831f1:	50                   	push   %eax
  2831f2:	57                   	push   %edi
  2831f3:	e8 ba f4 ff ff       	call   2826b2 <sheet_refresh>
  2831f8:	83 c4 20             	add    $0x20,%esp
  2831fb:	e9 f9 fd ff ff       	jmp    282ff9 <console_task+0xae>

00283200 <file_readfat>:
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
  283200:	55                   	push   %ebp
  283201:	89 e5                	mov    %esp,%ebp
  283203:	53                   	push   %ebx
  283204:	83 ec 10             	sub    $0x10,%esp
	int i,j=0;
  283207:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(i=0;i<2880;i+=2)
  28320e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  283215:	e9 87 00 00 00       	jmp    2832a1 <file_readfat+0xa1>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
  28321a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28321d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  283224:	8b 45 08             	mov    0x8(%ebp),%eax
  283227:	01 d0                	add    %edx,%eax
  283229:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28322c:	8b 55 0c             	mov    0xc(%ebp),%edx
  28322f:	01 ca                	add    %ecx,%edx
  283231:	0f b6 12             	movzbl (%edx),%edx
  283234:	0f b6 d2             	movzbl %dl,%edx
  283237:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28323a:	8d 59 01             	lea    0x1(%ecx),%ebx
  28323d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  283240:	01 d9                	add    %ebx,%ecx
  283242:	0f b6 09             	movzbl (%ecx),%ecx
  283245:	0f b6 c9             	movzbl %cl,%ecx
  283248:	c1 e1 08             	shl    $0x8,%ecx
  28324b:	09 ca                	or     %ecx,%edx
  28324d:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  283253:	89 10                	mov    %edx,(%eax)
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
  283255:	8b 45 f8             	mov    -0x8(%ebp),%eax
  283258:	83 c0 01             	add    $0x1,%eax
  28325b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  283262:	8b 45 08             	mov    0x8(%ebp),%eax
  283265:	01 d0                	add    %edx,%eax
  283267:	8b 55 f4             	mov    -0xc(%ebp),%edx
  28326a:	8d 4a 01             	lea    0x1(%edx),%ecx
  28326d:	8b 55 0c             	mov    0xc(%ebp),%edx
  283270:	01 ca                	add    %ecx,%edx
  283272:	0f b6 12             	movzbl (%edx),%edx
  283275:	c0 ea 04             	shr    $0x4,%dl
  283278:	0f b6 d2             	movzbl %dl,%edx
  28327b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  28327e:	8d 59 02             	lea    0x2(%ecx),%ebx
  283281:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  283284:	01 d9                	add    %ebx,%ecx
  283286:	0f b6 09             	movzbl (%ecx),%ecx
  283289:	0f b6 c9             	movzbl %cl,%ecx
  28328c:	c1 e1 04             	shl    $0x4,%ecx
  28328f:	09 ca                	or     %ecx,%edx
  283291:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  283297:	89 10                	mov    %edx,(%eax)
		j+=3;
  283299:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
	int i,j=0;
	for(i=0;i<2880;i+=2)
  28329d:	83 45 f8 02          	addl   $0x2,-0x8(%ebp)
  2832a1:	81 7d f8 3f 0b 00 00 	cmpl   $0xb3f,-0x8(%ebp)
  2832a8:	0f 8e 6c ff ff ff    	jle    28321a <file_readfat+0x1a>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
		j+=3;
	}
	return;
  2832ae:	90                   	nop
}
  2832af:	83 c4 10             	add    $0x10,%esp
  2832b2:	5b                   	pop    %ebx
  2832b3:	5d                   	pop    %ebp
  2832b4:	c3                   	ret    

002832b5 <file_loadfile>:

void file_loadfile(int clustno,int size,char *buf,int *fat,char *img)
{
  2832b5:	55                   	push   %ebp
  2832b6:	89 e5                	mov    %esp,%ebp
  2832b8:	83 ec 10             	sub    $0x10,%esp
	int i;
	for(;;)
	{
		if(size <= 512)
  2832bb:	81 7d 0c 00 02 00 00 	cmpl   $0x200,0xc(%ebp)
  2832c2:	7f 38                	jg     2832fc <file_loadfile+0x47>
		{
			for(i=0;i<size;i++)
  2832c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  2832cb:	eb 25                	jmp    2832f2 <file_loadfile+0x3d>
			{
				buf[i] = img[clustno*512 + i];
  2832cd:	8b 55 fc             	mov    -0x4(%ebp),%edx
  2832d0:	8b 45 10             	mov    0x10(%ebp),%eax
  2832d3:	01 c2                	add    %eax,%edx
  2832d5:	8b 45 08             	mov    0x8(%ebp),%eax
  2832d8:	c1 e0 09             	shl    $0x9,%eax
  2832db:	89 c1                	mov    %eax,%ecx
  2832dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2832e0:	01 c8                	add    %ecx,%eax
  2832e2:	89 c1                	mov    %eax,%ecx
  2832e4:	8b 45 18             	mov    0x18(%ebp),%eax
  2832e7:	01 c8                	add    %ecx,%eax
  2832e9:	0f b6 00             	movzbl (%eax),%eax
  2832ec:	88 02                	mov    %al,(%edx)
	int i;
	for(;;)
	{
		if(size <= 512)
		{
			for(i=0;i<size;i++)
  2832ee:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  2832f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2832f5:	3b 45 0c             	cmp    0xc(%ebp),%eax
  2832f8:	7c d3                	jl     2832cd <file_loadfile+0x18>
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
  2832fa:	eb 5e                	jmp    28335a <file_loadfile+0xa5>
		}
		for(i=0;i<512;i++)
  2832fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  283303:	eb 25                	jmp    28332a <file_loadfile+0x75>
		{
			buf[i] = img[clustno*512 + i];
  283305:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283308:	8b 45 10             	mov    0x10(%ebp),%eax
  28330b:	01 c2                	add    %eax,%edx
  28330d:	8b 45 08             	mov    0x8(%ebp),%eax
  283310:	c1 e0 09             	shl    $0x9,%eax
  283313:	89 c1                	mov    %eax,%ecx
  283315:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283318:	01 c8                	add    %ecx,%eax
  28331a:	89 c1                	mov    %eax,%ecx
  28331c:	8b 45 18             	mov    0x18(%ebp),%eax
  28331f:	01 c8                	add    %ecx,%eax
  283321:	0f b6 00             	movzbl (%eax),%eax
  283324:	88 02                	mov    %al,(%edx)
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
		}
		for(i=0;i<512;i++)
  283326:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  28332a:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%ebp)
  283331:	7e d2                	jle    283305 <file_loadfile+0x50>
		{
			buf[i] = img[clustno*512 + i];
		}
		size -= 512;
  283333:	81 6d 0c 00 02 00 00 	subl   $0x200,0xc(%ebp)
		buf += 512;
  28333a:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
		clustno = fat[clustno];
  283341:	8b 45 08             	mov    0x8(%ebp),%eax
  283344:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  28334b:	8b 45 14             	mov    0x14(%ebp),%eax
  28334e:	01 d0                	add    %edx,%eax
  283350:	8b 00                	mov    (%eax),%eax
  283352:	89 45 08             	mov    %eax,0x8(%ebp)
	}
  283355:	e9 61 ff ff ff       	jmp    2832bb <file_loadfile+0x6>
	return;
}
  28335a:	c9                   	leave  
  28335b:	c3                   	ret    

0028335c <file_search>:

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
  28335c:	55                   	push   %ebp
  28335d:	89 e5                	mov    %esp,%ebp
  28335f:	83 ec 20             	sub    $0x20,%esp
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  283362:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  283369:	eb 0f                	jmp    28337a <file_search+0x1e>
	{
		s[j] = ' ';
  28336b:	8d 55 ec             	lea    -0x14(%ebp),%edx
  28336e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  283371:	01 d0                	add    %edx,%eax
  283373:	c6 00 20             	movb   $0x20,(%eax)

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  283376:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  28337a:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  28337e:	7e eb                	jle    28336b <file_search+0xf>
	{
		s[j] = ' ';
	}
	j=0;
  283380:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;name[i]!=0;i++)
  283387:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  28338e:	e9 83 00 00 00       	jmp    283416 <file_search+0xba>
	{
		if(j>=11) return 0; //length of name is bigger than 11
  283393:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  283397:	7e 0a                	jle    2833a3 <file_search+0x47>
  283399:	b8 00 00 00 00       	mov    $0x0,%eax
  28339e:	e9 2a 01 00 00       	jmp    2834cd <file_search+0x171>
		if(name[i] == '.' && j <= 8)
  2833a3:	8b 55 fc             	mov    -0x4(%ebp),%edx
  2833a6:	8b 45 08             	mov    0x8(%ebp),%eax
  2833a9:	01 d0                	add    %edx,%eax
  2833ab:	0f b6 00             	movzbl (%eax),%eax
  2833ae:	3c 2e                	cmp    $0x2e,%al
  2833b0:	75 0f                	jne    2833c1 <file_search+0x65>
  2833b2:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
  2833b6:	7f 09                	jg     2833c1 <file_search+0x65>
			j = 8;
  2833b8:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)
  2833bf:	eb 51                	jmp    283412 <file_search+0xb6>
		else
		{
			s[j] = name[i];
  2833c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
  2833c4:	8b 45 08             	mov    0x8(%ebp),%eax
  2833c7:	01 d0                	add    %edx,%eax
  2833c9:	0f b6 00             	movzbl (%eax),%eax
  2833cc:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  2833cf:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2833d2:	01 ca                	add    %ecx,%edx
  2833d4:	88 02                	mov    %al,(%edx)
			if('a' <= s[j] && s[j] <= 'z')
  2833d6:	8d 55 ec             	lea    -0x14(%ebp),%edx
  2833d9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2833dc:	01 d0                	add    %edx,%eax
  2833de:	0f b6 00             	movzbl (%eax),%eax
  2833e1:	3c 60                	cmp    $0x60,%al
  2833e3:	7e 29                	jle    28340e <file_search+0xb2>
  2833e5:	8d 55 ec             	lea    -0x14(%ebp),%edx
  2833e8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2833eb:	01 d0                	add    %edx,%eax
  2833ed:	0f b6 00             	movzbl (%eax),%eax
  2833f0:	3c 7a                	cmp    $0x7a,%al
  2833f2:	7f 1a                	jg     28340e <file_search+0xb2>
				s[j] -= 0x20;
  2833f4:	8d 55 ec             	lea    -0x14(%ebp),%edx
  2833f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2833fa:	01 d0                	add    %edx,%eax
  2833fc:	0f b6 00             	movzbl (%eax),%eax
  2833ff:	83 e8 20             	sub    $0x20,%eax
  283402:	89 c1                	mov    %eax,%ecx
  283404:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283407:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28340a:	01 d0                	add    %edx,%eax
  28340c:	88 08                	mov    %cl,(%eax)
			j++;
  28340e:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(j=0;j<11;j++)
	{
		s[j] = ' ';
	}
	j=0;
	for(i=0;name[i]!=0;i++)
  283412:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  283416:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283419:	8b 45 08             	mov    0x8(%ebp),%eax
  28341c:	01 d0                	add    %edx,%eax
  28341e:	0f b6 00             	movzbl (%eax),%eax
  283421:	84 c0                	test   %al,%al
  283423:	0f 85 6a ff ff ff    	jne    283393 <file_search+0x37>
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  283429:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  283430:	e9 84 00 00 00       	jmp    2834b9 <file_search+0x15d>
	{
		if(finfo[i].name[0] == 0) break;
  283435:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283438:	c1 e0 06             	shl    $0x6,%eax
  28343b:	89 c2                	mov    %eax,%edx
  28343d:	8b 45 0c             	mov    0xc(%ebp),%eax
  283440:	01 d0                	add    %edx,%eax
  283442:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  283446:	84 c0                	test   %al,%al
  283448:	74 7d                	je     2834c7 <file_search+0x16b>
		if((finfo[i].type & 0x18) == 0)
  28344a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  28344d:	c1 e0 06             	shl    $0x6,%eax
  283450:	89 c2                	mov    %eax,%edx
  283452:	8b 45 0c             	mov    0xc(%ebp),%eax
  283455:	01 d0                	add    %edx,%eax
  283457:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  28345b:	0f b6 c0             	movzbl %al,%eax
  28345e:	83 e0 18             	and    $0x18,%eax
  283461:	85 c0                	test   %eax,%eax
  283463:	75 50                	jne    2834b5 <file_search+0x159>
		{
			for(j=0;j<11;j++)
  283465:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  28346c:	eb 31                	jmp    28349f <file_search+0x143>
			{
				if(finfo[i].name[j] != s[j])
  28346e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283471:	c1 e0 06             	shl    $0x6,%eax
  283474:	89 c2                	mov    %eax,%edx
  283476:	8b 45 0c             	mov    0xc(%ebp),%eax
  283479:	01 c2                	add    %eax,%edx
  28347b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28347e:	01 d0                	add    %edx,%eax
  283480:	83 c0 20             	add    $0x20,%eax
  283483:	0f b6 00             	movzbl (%eax),%eax
  283486:	0f b6 d0             	movzbl %al,%edx
  283489:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  28348c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28348f:	01 c8                	add    %ecx,%eax
  283491:	0f b6 00             	movzbl (%eax),%eax
  283494:	0f be c0             	movsbl %al,%eax
  283497:	39 c2                	cmp    %eax,%edx
  283499:	75 19                	jne    2834b4 <file_search+0x158>
	for(i=0;i<max;)
	{
		if(finfo[i].name[0] == 0) break;
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
  28349b:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  28349f:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  2834a3:	7e c9                	jle    28346e <file_search+0x112>
			{
				if(finfo[i].name[j] != s[j])
					goto next;
			}
			return finfo+i;
  2834a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2834a8:	c1 e0 06             	shl    $0x6,%eax
  2834ab:	89 c2                	mov    %eax,%edx
  2834ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  2834b0:	01 d0                	add    %edx,%eax
  2834b2:	eb 19                	jmp    2834cd <file_search+0x171>
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
			{
				if(finfo[i].name[j] != s[j])
					goto next;
  2834b4:	90                   	nop
			}
			return finfo+i;
		}
next:
		i++;
  2834b5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  2834b9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2834bc:	3b 45 10             	cmp    0x10(%ebp),%eax
  2834bf:	0f 8c 70 ff ff ff    	jl     283435 <file_search+0xd9>
  2834c5:	eb 01                	jmp    2834c8 <file_search+0x16c>
	{
		if(finfo[i].name[0] == 0) break;
  2834c7:	90                   	nop
			return finfo+i;
		}
next:
		i++;
	}
	return 0;
  2834c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  2834cd:	c9                   	leave  
  2834ce:	c3                   	ret    

002834cf <cons_newline>:
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  2834cf:	55                   	push   %ebp
  2834d0:	89 e5                	mov    %esp,%ebp
  2834d2:	57                   	push   %edi
  2834d3:	56                   	push   %esi
  2834d4:	53                   	push   %ebx
  2834d5:	83 ec 1c             	sub    $0x1c,%esp
	int x,y;
	struct SHEET *sheet = cons->sht;
	if(cons->cur_y<28+112)
  2834d8:	8b 45 08             	mov    0x8(%ebp),%eax
  2834db:	8b 40 08             	mov    0x8(%eax),%eax
  2834de:	3d 8b 00 00 00       	cmp    $0x8b,%eax
  2834e3:	7e 0c                	jle    2834f1 <cons_newline+0x22>
}

void cons_newline(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
  2834e5:	8b 45 08             	mov    0x8(%ebp),%eax
  2834e8:	8b 18                	mov    (%eax),%ebx
  2834ea:	bf 1c 00 00 00       	mov    $0x1c,%edi
  2834ef:	eb 43                	jmp    283534 <cons_newline+0x65>
	if(cons->cur_y<28+112)
	{
		cons->cur_y += 16;
  2834f1:	83 c0 10             	add    $0x10,%eax
  2834f4:	8b 7d 08             	mov    0x8(%ebp),%edi
  2834f7:	89 47 08             	mov    %eax,0x8(%edi)
  2834fa:	e9 89 00 00 00       	jmp    283588 <cons_newline+0xb9>
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  2834ff:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  283502:	8b 43 04             	mov    0x4(%ebx),%eax
  283505:	8b 75 e0             	mov    -0x20(%ebp),%esi
  283508:	0f af f0             	imul   %eax,%esi
  28350b:	89 d1                	mov    %edx,%ecx
  28350d:	03 0b                	add    (%ebx),%ecx
  28350f:	0f b6 34 31          	movzbl (%ecx,%esi,1),%esi
  283513:	0f af c7             	imul   %edi,%eax
  283516:	89 f3                	mov    %esi,%ebx
  283518:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
		cons->cur_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
  28351b:	83 c2 01             	add    $0x1,%edx
  28351e:	81 fa f8 00 00 00    	cmp    $0xf8,%edx
  283524:	75 d9                	jne    2834ff <cons_newline+0x30>
  283526:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	{
		cons->cur_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
  283529:	83 c7 01             	add    $0x1,%edi
  28352c:	81 ff 8c 00 00 00    	cmp    $0x8c,%edi
  283532:	74 33                	je     283567 <cons_newline+0x98>
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  283534:	ba 08 00 00 00       	mov    $0x8,%edx
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  283539:	8d 47 10             	lea    0x10(%edi),%eax
  28353c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  28353f:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  283542:	eb bb                	jmp    2834ff <cons_newline+0x30>
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  283544:	89 fa                	mov    %edi,%edx
  283546:	0f af 53 04          	imul   0x4(%ebx),%edx
  28354a:	89 c1                	mov    %eax,%ecx
  28354c:	03 0b                	add    (%ebx),%ecx
  28354e:	c6 04 11 00          	movb   $0x0,(%ecx,%edx,1)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
  283552:	83 c0 01             	add    $0x1,%eax
  283555:	3d f8 00 00 00       	cmp    $0xf8,%eax
  28355a:	75 e8                	jne    283544 <cons_newline+0x75>
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
  28355c:	83 c7 01             	add    $0x1,%edi
  28355f:	81 ff 9c 00 00 00    	cmp    $0x9c,%edi
  283565:	74 07                	je     28356e <cons_newline+0x9f>
}

void cons_newline(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
  283567:	b8 08 00 00 00       	mov    $0x8,%eax
  28356c:	eb d6                	jmp    283544 <cons_newline+0x75>
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		sheet_refresh(sheet,8,28,8+240,28+128);
  28356e:	83 ec 0c             	sub    $0xc,%esp
  283571:	68 9c 00 00 00       	push   $0x9c
  283576:	68 f8 00 00 00       	push   $0xf8
  28357b:	6a 1c                	push   $0x1c
  28357d:	6a 08                	push   $0x8
  28357f:	53                   	push   %ebx
  283580:	e8 2d f1 ff ff       	call   2826b2 <sheet_refresh>
  283585:	83 c4 20             	add    $0x20,%esp
	}
	cons->cur_x = 8;
  283588:	8b 45 08             	mov    0x8(%ebp),%eax
  28358b:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
}
  283592:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283595:	5b                   	pop    %ebx
  283596:	5e                   	pop    %esi
  283597:	5f                   	pop    %edi
  283598:	5d                   	pop    %ebp
  283599:	c3                   	ret    

0028359a <cons_putchar>:
#include "header.h"
void cons_putchar(struct CONSOLE *cons,int chr,char move)
{
  28359a:	55                   	push   %ebp
  28359b:	89 e5                	mov    %esp,%ebp
  28359d:	56                   	push   %esi
  28359e:	53                   	push   %ebx
  28359f:	83 ec 10             	sub    $0x10,%esp
  2835a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2835a5:	8b 45 0c             	mov    0xc(%ebp),%eax
  2835a8:	8b 75 10             	mov    0x10(%ebp),%esi
	char s[2];
	s[0] = chr;
  2835ab:	88 45 f6             	mov    %al,-0xa(%ebp)
	s[1] = 0;
  2835ae:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	if(s[0] == 0x09)
  2835b2:	3c 09                	cmp    $0x9,%al
  2835b4:	75 46                	jne    2835fc <cons_putchar+0x62>
	{
		//tab
		for(;;)
		{
			putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000," ",1);
  2835b6:	83 ec 04             	sub    $0x4,%esp
  2835b9:	6a 01                	push   $0x1
  2835bb:	68 e3 42 28 00       	push   $0x2842e3
  2835c0:	6a 00                	push   $0x0
  2835c2:	6a 07                	push   $0x7
  2835c4:	ff 73 08             	pushl  0x8(%ebx)
  2835c7:	ff 73 04             	pushl  0x4(%ebx)
  2835ca:	ff 33                	pushl  (%ebx)
  2835cc:	e8 62 db ff ff       	call   281133 <putfonts8_asc_sht>
			cons->cur_x += 8;
  2835d1:	8b 43 04             	mov    0x4(%ebx),%eax
  2835d4:	83 c0 08             	add    $0x8,%eax
  2835d7:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240) {
  2835da:	83 c4 20             	add    $0x20,%esp
  2835dd:	3d f8 00 00 00       	cmp    $0xf8,%eax
  2835e2:	75 0c                	jne    2835f0 <cons_putchar+0x56>
				cons_newline(cons);
  2835e4:	83 ec 0c             	sub    $0xc,%esp
  2835e7:	53                   	push   %ebx
  2835e8:	e8 e2 fe ff ff       	call   2834cf <cons_newline>
  2835ed:	83 c4 10             	add    $0x10,%esp
			}
			if(((cons->cur_x - 8) & 0x1f) == 0)
  2835f0:	8b 43 04             	mov    0x4(%ebx),%eax
  2835f3:	83 e8 08             	sub    $0x8,%eax
  2835f6:	a8 1f                	test   $0x1f,%al
  2835f8:	75 bc                	jne    2835b6 <cons_putchar+0x1c>
  2835fa:	eb 55                	jmp    283651 <cons_putchar+0xb7>
				break;
		}
	}
	else if(s[0] == 0x0a) 
  2835fc:	3c 0a                	cmp    $0xa,%al
  2835fe:	75 0e                	jne    28360e <cons_putchar+0x74>
		cons_newline(cons);
  283600:	83 ec 0c             	sub    $0xc,%esp
  283603:	53                   	push   %ebx
  283604:	e8 c6 fe ff ff       	call   2834cf <cons_newline>
  283609:	83 c4 10             	add    $0x10,%esp
  28360c:	eb 43                	jmp    283651 <cons_putchar+0xb7>
	else if(s[0] == 0x0d) 
  28360e:	3c 0d                	cmp    $0xd,%al
  283610:	74 3f                	je     283651 <cons_putchar+0xb7>
		;//todo
	else
	{
		putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000,s,1);
  283612:	83 ec 04             	sub    $0x4,%esp
  283615:	6a 01                	push   $0x1
  283617:	8d 45 f6             	lea    -0xa(%ebp),%eax
  28361a:	50                   	push   %eax
  28361b:	6a 00                	push   $0x0
  28361d:	6a 07                	push   $0x7
  28361f:	ff 73 08             	pushl  0x8(%ebx)
  283622:	ff 73 04             	pushl  0x4(%ebx)
  283625:	ff 33                	pushl  (%ebx)
  283627:	e8 07 db ff ff       	call   281133 <putfonts8_asc_sht>
		if(move != 0)
  28362c:	83 c4 20             	add    $0x20,%esp
  28362f:	89 f0                	mov    %esi,%eax
  283631:	84 c0                	test   %al,%al
  283633:	74 1c                	je     283651 <cons_putchar+0xb7>
		{
			cons->cur_x += 8;
  283635:	8b 43 04             	mov    0x4(%ebx),%eax
  283638:	83 c0 08             	add    $0x8,%eax
  28363b:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240)
  28363e:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283643:	75 0c                	jne    283651 <cons_putchar+0xb7>
				cons_newline(cons);
  283645:	83 ec 0c             	sub    $0xc,%esp
  283648:	53                   	push   %ebx
  283649:	e8 81 fe ff ff       	call   2834cf <cons_newline>
  28364e:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  283651:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283654:	5b                   	pop    %ebx
  283655:	5e                   	pop    %esi
  283656:	5d                   	pop    %ebp
  283657:	c3                   	ret    

00283658 <cmd_mem>:
	}
	return;
}

void cmd_mem(struct CONSOLE *cons,unsigned int memtotal)
{
  283658:	55                   	push   %ebp
  283659:	89 e5                	mov    %esp,%ebp
  28365b:	56                   	push   %esi
  28365c:	53                   	push   %ebx
  28365d:	83 ec 24             	sub    $0x24,%esp
  283660:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	char s[30];
	sprintf(s,"total %dMB",memtotal/(1024*1024));
  283663:	8b 45 0c             	mov    0xc(%ebp),%eax
  283666:	c1 e8 14             	shr    $0x14,%eax
  283669:	50                   	push   %eax
  28366a:	68 80 42 28 00       	push   $0x284280
  28366f:	8d 75 da             	lea    -0x26(%ebp),%esi
  283672:	56                   	push   %esi
  283673:	e8 75 e2 ff ff       	call   2818ed <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283678:	83 c4 0c             	add    $0xc,%esp
  28367b:	6a 1e                	push   $0x1e
  28367d:	56                   	push   %esi
  28367e:	6a 00                	push   $0x0
  283680:	6a 07                	push   $0x7
  283682:	ff 73 08             	pushl  0x8(%ebx)
  283685:	6a 08                	push   $0x8
  283687:	ff 33                	pushl  (%ebx)
  283689:	e8 a5 da ff ff       	call   281133 <putfonts8_asc_sht>
	cons_newline(cons);
  28368e:	83 c4 14             	add    $0x14,%esp
  283691:	53                   	push   %ebx
  283692:	e8 38 fe ff ff       	call   2834cf <cons_newline>
	sprintf(s,"free %dKB",memman_total(memman)/1024);
  283697:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
  28369e:	e8 45 e8 ff ff       	call   281ee8 <memman_total>
  2836a3:	83 c4 0c             	add    $0xc,%esp
  2836a6:	c1 e8 0a             	shr    $0xa,%eax
  2836a9:	50                   	push   %eax
  2836aa:	68 8b 42 28 00       	push   $0x28428b
  2836af:	56                   	push   %esi
  2836b0:	e8 38 e2 ff ff       	call   2818ed <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  2836b5:	83 c4 0c             	add    $0xc,%esp
  2836b8:	6a 1e                	push   $0x1e
  2836ba:	56                   	push   %esi
  2836bb:	6a 00                	push   $0x0
  2836bd:	6a 07                	push   $0x7
  2836bf:	ff 73 08             	pushl  0x8(%ebx)
  2836c2:	6a 08                	push   $0x8
  2836c4:	ff 33                	pushl  (%ebx)
  2836c6:	e8 68 da ff ff       	call   281133 <putfonts8_asc_sht>
	cons_newline(cons);
  2836cb:	83 c4 14             	add    $0x14,%esp
  2836ce:	53                   	push   %ebx
  2836cf:	e8 fb fd ff ff       	call   2834cf <cons_newline>
	cons_newline(cons);
  2836d4:	89 1c 24             	mov    %ebx,(%esp)
  2836d7:	e8 f3 fd ff ff       	call   2834cf <cons_newline>
	return;
  2836dc:	83 c4 10             	add    $0x10,%esp
}
  2836df:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2836e2:	5b                   	pop    %ebx
  2836e3:	5e                   	pop    %esi
  2836e4:	5d                   	pop    %ebp
  2836e5:	c3                   	ret    

002836e6 <cmd_cls>:

void cmd_cls(struct CONSOLE *cons)
{
  2836e6:	55                   	push   %ebp
  2836e7:	89 e5                	mov    %esp,%ebp
  2836e9:	57                   	push   %edi
  2836ea:	56                   	push   %esi
  2836eb:	53                   	push   %ebx
  2836ec:	83 ec 0c             	sub    $0xc,%esp
  2836ef:	8b 7d 08             	mov    0x8(%ebp),%edi
	int x,y;
	struct SHEET *sheet = cons->sht;
  2836f2:	8b 17                	mov    (%edi),%edx
	for(y=28;y<28+128;y++)
  2836f4:	be 1c 00 00 00       	mov    $0x1c,%esi
  2836f9:	eb 23                	jmp    28371e <cmd_cls+0x38>
	{
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  2836fb:	89 f1                	mov    %esi,%ecx
  2836fd:	0f af 4a 04          	imul   0x4(%edx),%ecx
  283701:	89 c3                	mov    %eax,%ebx
  283703:	03 1a                	add    (%edx),%ebx
  283705:	c6 04 0b 00          	movb   $0x0,(%ebx,%ecx,1)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
	{
		for(x=8;x<8+240;x++)
  283709:	83 c0 01             	add    $0x1,%eax
  28370c:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283711:	75 e8                	jne    2836fb <cmd_cls+0x15>

void cmd_cls(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
  283713:	83 c6 01             	add    $0x1,%esi
  283716:	81 fe 9c 00 00 00    	cmp    $0x9c,%esi
  28371c:	74 07                	je     283725 <cmd_cls+0x3f>
	cons_newline(cons);
	return;
}

void cmd_cls(struct CONSOLE *cons)
{
  28371e:	b8 08 00 00 00       	mov    $0x8,%eax
  283723:	eb d6                	jmp    2836fb <cmd_cls+0x15>
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		}
	}
	sheet_refresh(sheet,8,28,8+240,28+128);
  283725:	83 ec 0c             	sub    $0xc,%esp
  283728:	68 9c 00 00 00       	push   $0x9c
  28372d:	68 f8 00 00 00       	push   $0xf8
  283732:	6a 1c                	push   $0x1c
  283734:	6a 08                	push   $0x8
  283736:	52                   	push   %edx
  283737:	e8 76 ef ff ff       	call   2826b2 <sheet_refresh>
	cons->cur_y = 28;
  28373c:	c7 47 08 1c 00 00 00 	movl   $0x1c,0x8(%edi)
	return;
  283743:	83 c4 20             	add    $0x20,%esp
}
  283746:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283749:	5b                   	pop    %ebx
  28374a:	5e                   	pop    %esi
  28374b:	5f                   	pop    %edi
  28374c:	5d                   	pop    %ebp
  28374d:	c3                   	ret    

0028374e <cmd_dir>:

void cmd_dir(struct CONSOLE *cons)
{
  28374e:	55                   	push   %ebp
  28374f:	89 e5                	mov    %esp,%ebp
  283751:	57                   	push   %edi
  283752:	56                   	push   %esi
  283753:	53                   	push   %ebx
  283754:	83 ec 2c             	sub    $0x2c,%esp
  283757:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  28375a:	0f b6 05 20 26 10 00 	movzbl 0x102620,%eax
  283761:	84 c0                	test   %al,%al
  283763:	0f 84 87 00 00 00    	je     2837f0 <cmd_dir+0xa2>
  283769:	bb 00 26 10 00       	mov    $0x102600,%ebx
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  28376e:	8d 75 ca             	lea    -0x36(%ebp),%esi
  283771:	eb 0b                	jmp    28377e <cmd_dir+0x30>
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  283773:	83 c3 40             	add    $0x40,%ebx
  283776:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  28377a:	84 c0                	test   %al,%al
  28377c:	74 72                	je     2837f0 <cmd_dir+0xa2>
		if(finfo[i].name[0] != 0xe5)
  28377e:	3c e5                	cmp    $0xe5,%al
  283780:	74 66                	je     2837e8 <cmd_dir+0x9a>
		{
			if((finfo[i].type & 0x18) == 0)
  283782:	f6 43 2b 18          	testb  $0x18,0x2b(%ebx)
  283786:	75 60                	jne    2837e8 <cmd_dir+0x9a>
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  283788:	83 ec 04             	sub    $0x4,%esp
  28378b:	ff 73 3c             	pushl  0x3c(%ebx)
  28378e:	68 95 42 28 00       	push   $0x284295
  283793:	56                   	push   %esi
  283794:	e8 54 e1 ff ff       	call   2818ed <sprintf>
  283799:	83 c4 10             	add    $0x10,%esp
				for(j=0;j<8;j++)
  28379c:	b8 00 00 00 00       	mov    $0x0,%eax
				{
					s[j] = finfo[i].name[j];
  2837a1:	0f b6 54 03 20       	movzbl 0x20(%ebx,%eax,1),%edx
  2837a6:	88 14 30             	mov    %dl,(%eax,%esi,1)
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
				for(j=0;j<8;j++)
  2837a9:	83 c0 01             	add    $0x1,%eax
  2837ac:	83 f8 08             	cmp    $0x8,%eax
  2837af:	75 f0                	jne    2837a1 <cmd_dir+0x53>
				{
					s[j] = finfo[i].name[j];
				}
				s[9] = finfo[i].ext[0];
  2837b1:	0f b6 43 28          	movzbl 0x28(%ebx),%eax
  2837b5:	88 45 d3             	mov    %al,-0x2d(%ebp)
				s[10] = finfo[i].ext[1];
  2837b8:	0f b6 43 29          	movzbl 0x29(%ebx),%eax
  2837bc:	88 45 d4             	mov    %al,-0x2c(%ebp)
				s[11] = finfo[i].ext[2];
  2837bf:	0f b6 43 2a          	movzbl 0x2a(%ebx),%eax
  2837c3:	88 45 d5             	mov    %al,-0x2b(%ebp)
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  2837c6:	83 ec 04             	sub    $0x4,%esp
  2837c9:	6a 1e                	push   $0x1e
  2837cb:	56                   	push   %esi
  2837cc:	6a 00                	push   $0x0
  2837ce:	6a 07                	push   $0x7
  2837d0:	ff 77 08             	pushl  0x8(%edi)
  2837d3:	6a 08                	push   $0x8
  2837d5:	ff 37                	pushl  (%edi)
  2837d7:	e8 57 d9 ff ff       	call   281133 <putfonts8_asc_sht>
				cons_newline(cons);
  2837dc:	83 c4 14             	add    $0x14,%esp
  2837df:	57                   	push   %edi
  2837e0:	e8 ea fc ff ff       	call   2834cf <cons_newline>
  2837e5:	83 c4 10             	add    $0x10,%esp
void cmd_dir(struct CONSOLE *cons)
{
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
  2837e8:	81 fb c0 5d 10 00    	cmp    $0x105dc0,%ebx
  2837ee:	75 83                	jne    283773 <cmd_dir+0x25>
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
				cons_newline(cons);
			}
		}
	}
	cons_newline(cons);
  2837f0:	83 ec 0c             	sub    $0xc,%esp
  2837f3:	57                   	push   %edi
  2837f4:	e8 d6 fc ff ff       	call   2834cf <cons_newline>
	return;
  2837f9:	83 c4 10             	add    $0x10,%esp
}
  2837fc:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2837ff:	5b                   	pop    %ebx
  283800:	5e                   	pop    %esi
  283801:	5f                   	pop    %edi
  283802:	5d                   	pop    %ebp
  283803:	c3                   	ret    

00283804 <cmd_type>:

void cmd_type(struct CONSOLE *cons,int *fat,char *cmdline)
{
  283804:	55                   	push   %ebp
  283805:	89 e5                	mov    %esp,%ebp
  283807:	57                   	push   %edi
  283808:	56                   	push   %esi
  283809:	53                   	push   %ebx
  28380a:	83 ec 10             	sub    $0x10,%esp
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo = file_search(cmdline +5,(struct FILEINFO *)(ADR_DISKIMG + 0x002600),224);
  28380d:	68 e0 00 00 00       	push   $0xe0
  283812:	68 00 26 10 00       	push   $0x102600
  283817:	8b 45 10             	mov    0x10(%ebp),%eax
  28381a:	83 c0 05             	add    $0x5,%eax
  28381d:	50                   	push   %eax
  28381e:	e8 39 fb ff ff       	call   28335c <file_search>
	char *p;
	int i;
	if(finfo != 0)
  283823:	83 c4 10             	add    $0x10,%esp
  283826:	85 c0                	test   %eax,%eax
  283828:	74 6e                	je     283898 <cmd_type+0x94>
  28382a:	89 c6                	mov    %eax,%esi
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  28382c:	83 ec 08             	sub    $0x8,%esp
  28382f:	ff 70 3c             	pushl  0x3c(%eax)
  283832:	68 00 00 3c 00       	push   $0x3c0000
  283837:	e8 21 ea ff ff       	call   28225d <memman_alloc_4k>
  28383c:	89 c7                	mov    %eax,%edi
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  28383e:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  283845:	ff 75 0c             	pushl  0xc(%ebp)
  283848:	50                   	push   %eax
  283849:	ff 76 3c             	pushl  0x3c(%esi)
  28384c:	0f b7 46 3a          	movzwl 0x3a(%esi),%eax
  283850:	50                   	push   %eax
  283851:	e8 5f fa ff ff       	call   2832b5 <file_loadfile>
		for(i=0;i<finfo->size;i++)
  283856:	8b 46 3c             	mov    0x3c(%esi),%eax
  283859:	83 c4 20             	add    $0x20,%esp
  28385c:	85 c0                	test   %eax,%eax
  28385e:	74 24                	je     283884 <cmd_type+0x80>
  283860:	bb 00 00 00 00       	mov    $0x0,%ebx
		{
			cons_putchar(cons,p[i],1);
  283865:	83 ec 04             	sub    $0x4,%esp
  283868:	6a 01                	push   $0x1
  28386a:	0f be 04 3b          	movsbl (%ebx,%edi,1),%eax
  28386e:	50                   	push   %eax
  28386f:	ff 75 08             	pushl  0x8(%ebp)
  283872:	e8 23 fd ff ff       	call   28359a <cons_putchar>
	int i;
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		for(i=0;i<finfo->size;i++)
  283877:	83 c3 01             	add    $0x1,%ebx
  28387a:	8b 46 3c             	mov    0x3c(%esi),%eax
  28387d:	83 c4 10             	add    $0x10,%esp
  283880:	39 d8                	cmp    %ebx,%eax
  283882:	77 e1                	ja     283865 <cmd_type+0x61>
		{
			cons_putchar(cons,p[i],1);
		}
		memman_free_4k(memman,(int)p,finfo->size);
  283884:	83 ec 04             	sub    $0x4,%esp
  283887:	50                   	push   %eax
  283888:	57                   	push   %edi
  283889:	68 00 00 3c 00       	push   $0x3c0000
  28388e:	e8 f6 e9 ff ff       	call   282289 <memman_free_4k>
  283893:	83 c4 10             	add    $0x10,%esp
  283896:	eb 2b                	jmp    2838c3 <cmd_type+0xbf>
	}
	else
	{
		putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"File not found.",15);
  283898:	83 ec 04             	sub    $0x4,%esp
  28389b:	6a 0f                	push   $0xf
  28389d:	68 a5 42 28 00       	push   $0x2842a5
  2838a2:	6a 00                	push   $0x0
  2838a4:	6a 07                	push   $0x7
  2838a6:	8b 45 08             	mov    0x8(%ebp),%eax
  2838a9:	ff 70 08             	pushl  0x8(%eax)
  2838ac:	6a 08                	push   $0x8
  2838ae:	ff 30                	pushl  (%eax)
  2838b0:	e8 7e d8 ff ff       	call   281133 <putfonts8_asc_sht>
		cons_newline(cons);
  2838b5:	83 c4 14             	add    $0x14,%esp
  2838b8:	ff 75 08             	pushl  0x8(%ebp)
  2838bb:	e8 0f fc ff ff       	call   2834cf <cons_newline>
  2838c0:	83 c4 10             	add    $0x10,%esp
	}
	cons_newline(cons);
  2838c3:	83 ec 0c             	sub    $0xc,%esp
  2838c6:	ff 75 08             	pushl  0x8(%ebp)
  2838c9:	e8 01 fc ff ff       	call   2834cf <cons_newline>
	return;
  2838ce:	83 c4 10             	add    $0x10,%esp
}
  2838d1:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2838d4:	5b                   	pop    %ebx
  2838d5:	5e                   	pop    %esi
  2838d6:	5f                   	pop    %edi
  2838d7:	5d                   	pop    %ebp
  2838d8:	c3                   	ret    

002838d9 <cons_putstr0>:
	return 0;
}


void cons_putstr0(struct CONSOLE *cons,char *s)
{
  2838d9:	55                   	push   %ebp
  2838da:	89 e5                	mov    %esp,%ebp
  2838dc:	56                   	push   %esi
  2838dd:	53                   	push   %ebx
  2838de:	8b 75 08             	mov    0x8(%ebp),%esi
  2838e1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	for(;*s!=0;s++)
  2838e4:	0f b6 03             	movzbl (%ebx),%eax
  2838e7:	84 c0                	test   %al,%al
  2838e9:	74 1c                	je     283907 <cons_putstr0+0x2e>
	{
		cons_putchar(cons,*s,1);
  2838eb:	83 ec 04             	sub    $0x4,%esp
  2838ee:	6a 01                	push   $0x1
  2838f0:	0f be c0             	movsbl %al,%eax
  2838f3:	50                   	push   %eax
  2838f4:	56                   	push   %esi
  2838f5:	e8 a0 fc ff ff       	call   28359a <cons_putchar>
}


void cons_putstr0(struct CONSOLE *cons,char *s)
{
	for(;*s!=0;s++)
  2838fa:	83 c3 01             	add    $0x1,%ebx
  2838fd:	0f b6 03             	movzbl (%ebx),%eax
  283900:	83 c4 10             	add    $0x10,%esp
  283903:	84 c0                	test   %al,%al
  283905:	75 e4                	jne    2838eb <cons_putstr0+0x12>
	{
		cons_putchar(cons,*s,1);
	}
	return;
}
  283907:	8d 65 f8             	lea    -0x8(%ebp),%esp
  28390a:	5b                   	pop    %ebx
  28390b:	5e                   	pop    %esi
  28390c:	5d                   	pop    %ebp
  28390d:	c3                   	ret    

0028390e <cmd_app>:
}



int cmd_app(struct CONSOLE *cons,int *fat,char *cmdline)
{
  28390e:	55                   	push   %ebp
  28390f:	89 e5                	mov    %esp,%ebp
  283911:	57                   	push   %edi
  283912:	56                   	push   %esi
  283913:	53                   	push   %ebx
  283914:	83 ec 4c             	sub    $0x4c,%esp
  283917:	8b 5d 10             	mov    0x10(%ebp),%ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
  28391a:	e8 83 f2 ff ff       	call   282ba2 <task_now>
  28391f:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
  283922:	0f b6 03             	movzbl (%ebx),%eax
  283925:	3c 20                	cmp    $0x20,%al
  283927:	0f 8f e9 01 00 00    	jg     283b16 <cmd_app+0x208>
  28392d:	eb 16                	jmp    283945 <cmd_app+0x37>
  28392f:	0f b6 04 33          	movzbl (%ebx,%esi,1),%eax
  283933:	3c 20                	cmp    $0x20,%al
  283935:	7e 13                	jle    28394a <cmd_app+0x3c>
			break;
		name[i] = cmdline[i];
  283937:	88 44 35 d6          	mov    %al,-0x2a(%ebp,%esi,1)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  28393b:	83 c6 01             	add    $0x1,%esi
  28393e:	83 fe 0d             	cmp    $0xd,%esi
  283941:	75 ec                	jne    28392f <cmd_app+0x21>
  283943:	eb 05                	jmp    28394a <cmd_app+0x3c>
  283945:	be 00 00 00 00       	mov    $0x0,%esi
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
	}
	name[i] = 0;
  28394a:	c6 44 35 d6 00       	movb   $0x0,-0x2a(%ebp,%esi,1)

	finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  28394f:	83 ec 04             	sub    $0x4,%esp
  283952:	68 e0 00 00 00       	push   $0xe0
  283957:	68 00 26 10 00       	push   $0x102600
  28395c:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  28395f:	50                   	push   %eax
  283960:	e8 f7 f9 ff ff       	call   28335c <file_search>
  283965:	89 c3                	mov    %eax,%ebx
	if(finfo == 0 && name[i-1]!='.')
  283967:	83 c4 10             	add    $0x10,%esp
  28396a:	85 c0                	test   %eax,%eax
  28396c:	75 4c                	jne    2839ba <cmd_app+0xac>
		}
		memman_free_4k(memman,(int)p,finfo->size);
		cons_newline(cons);
		return 1;
	}
	return 0;
  28396e:	b8 00 00 00 00       	mov    $0x0,%eax
		name[i] = cmdline[i];
	}
	name[i] = 0;

	finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
	if(finfo == 0 && name[i-1]!='.')
  283973:	80 7c 35 d5 2e       	cmpb   $0x2e,-0x2b(%ebp,%esi,1)
  283978:	0f 84 a5 01 00 00    	je     283b23 <cmd_app+0x215>
	{
		name[i  ] = '.';
  28397e:	c6 44 35 d6 2e       	movb   $0x2e,-0x2a(%ebp,%esi,1)
		name[i+1] = 'B';
  283983:	c6 44 35 d7 42       	movb   $0x42,-0x29(%ebp,%esi,1)
		name[i+2] = 'I';
  283988:	c6 44 35 d8 49       	movb   $0x49,-0x28(%ebp,%esi,1)
		name[i+3] = 'N';
  28398d:	c6 44 35 d9 4e       	movb   $0x4e,-0x27(%ebp,%esi,1)
		name[i+4] = 0;
  283992:	c6 44 35 da 00       	movb   $0x0,-0x26(%ebp,%esi,1)
		finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  283997:	83 ec 04             	sub    $0x4,%esp
  28399a:	68 e0 00 00 00       	push   $0xe0
  28399f:	68 00 26 10 00       	push   $0x102600
  2839a4:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  2839a7:	50                   	push   %eax
  2839a8:	e8 af f9 ff ff       	call   28335c <file_search>
  2839ad:	89 c3                	mov    %eax,%ebx
	}

	if(finfo != 0)
  2839af:	83 c4 10             	add    $0x10,%esp
  2839b2:	85 c0                	test   %eax,%eax
  2839b4:	0f 84 55 01 00 00    	je     283b0f <cmd_app+0x201>
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  2839ba:	83 ec 08             	sub    $0x8,%esp
  2839bd:	ff 73 3c             	pushl  0x3c(%ebx)
  2839c0:	68 00 00 3c 00       	push   $0x3c0000
  2839c5:	e8 93 e8 ff ff       	call   28225d <memman_alloc_4k>
  2839ca:	89 c6                	mov    %eax,%esi
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  2839cc:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  2839d3:	ff 75 0c             	pushl  0xc(%ebp)
  2839d6:	50                   	push   %eax
  2839d7:	ff 73 3c             	pushl  0x3c(%ebx)
  2839da:	0f b7 43 3a          	movzwl 0x3a(%ebx),%eax
  2839de:	50                   	push   %eax
  2839df:	e8 d1 f8 ff ff       	call   2832b5 <file_loadfile>
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
  2839e4:	83 c4 20             	add    $0x20,%esp
  2839e7:	83 7b 3c 23          	cmpl   $0x23,0x3c(%ebx)
  2839eb:	0f 86 e5 00 00 00    	jbe    283ad6 <cmd_app+0x1c8>
  2839f1:	83 ec 04             	sub    $0x4,%esp
  2839f4:	6a 04                	push   $0x4
  2839f6:	68 b5 42 28 00       	push   $0x2842b5
  2839fb:	8d 46 04             	lea    0x4(%esi),%eax
  2839fe:	50                   	push   %eax
  2839ff:	e8 24 e0 ff ff       	call   281a28 <strncmp>
  283a04:	83 c4 10             	add    $0x10,%esp
  283a07:	85 c0                	test   %eax,%eax
  283a09:	0f 85 c7 00 00 00    	jne    283ad6 <cmd_app+0x1c8>
  283a0f:	80 3e 00             	cmpb   $0x0,(%esi)
  283a12:	0f 85 be 00 00 00    	jne    283ad6 <cmd_app+0x1c8>
		{
			int segsiz	=	*((int *)(p+0x0000));
  283a18:	8b 06                	mov    (%esi),%eax
			int esp		=	*((int *)(p+0x000c));
  283a1a:	8b 7e 0c             	mov    0xc(%esi),%edi
  283a1d:	89 7d b8             	mov    %edi,-0x48(%ebp)
			int datsiz	=	*((int *)(p+0x0010));
  283a20:	8b 7e 10             	mov    0x10(%esi),%edi
			int dathrb	=	*((int *)(p+0x0014));
  283a23:	8b 56 14             	mov    0x14(%esi),%edx
  283a26:	89 55 b4             	mov    %edx,-0x4c(%ebp)

			q = (char *)memman_alloc_4k(memman,segsiz);
  283a29:	83 ec 08             	sub    $0x8,%esp
  283a2c:	89 45 c0             	mov    %eax,-0x40(%ebp)
  283a2f:	50                   	push   %eax
  283a30:	68 00 00 3c 00       	push   $0x3c0000
  283a35:	e8 23 e8 ff ff       	call   28225d <memman_alloc_4k>
			*((int *)0xfe8) = (int) q;
  283a3a:	89 45 bc             	mov    %eax,-0x44(%ebp)
  283a3d:	a3 e8 0f 00 00       	mov    %eax,0xfe8
			set_segmdesc(gdt + 1003,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
  283a42:	68 fa 40 00 00       	push   $0x40fa
  283a47:	56                   	push   %esi
  283a48:	8b 4b 3c             	mov    0x3c(%ebx),%ecx
  283a4b:	8d 41 ff             	lea    -0x1(%ecx),%eax
  283a4e:	50                   	push   %eax
  283a4f:	68 58 1f 27 00       	push   $0x271f58
  283a54:	e8 1e d9 ff ff       	call   281377 <set_segmdesc>
			set_segmdesc(gdt + 1004,segsiz - 1,(int)q,AR_DATA32_RW + 0x60);
  283a59:	83 c4 20             	add    $0x20,%esp
  283a5c:	68 f2 40 00 00       	push   $0x40f2
  283a61:	ff 75 bc             	pushl  -0x44(%ebp)
  283a64:	8b 55 c0             	mov    -0x40(%ebp),%edx
  283a67:	8d 42 ff             	lea    -0x1(%edx),%eax
  283a6a:	50                   	push   %eax
  283a6b:	68 60 1f 27 00       	push   $0x271f60
  283a70:	e8 02 d9 ff ff       	call   281377 <set_segmdesc>
			for(int i = 0;i<datsiz;i++)
  283a75:	83 c4 10             	add    $0x10,%esp
  283a78:	85 ff                	test   %edi,%edi
  283a7a:	7e 24                	jle    283aa0 <cmd_app+0x192>
  283a7c:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				q[esp + i] = p[dathrb + i];
  283a81:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  283a84:	01 f2                	add    %esi,%edx
  283a86:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  283a89:	03 4d b8             	add    -0x48(%ebp),%ecx
  283a8c:	89 5d b4             	mov    %ebx,-0x4c(%ebp)
  283a8f:	0f b6 1c 02          	movzbl (%edx,%eax,1),%ebx
  283a93:	88 1c 01             	mov    %bl,(%ecx,%eax,1)

			q = (char *)memman_alloc_4k(memman,segsiz);
			*((int *)0xfe8) = (int) q;
			set_segmdesc(gdt + 1003,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
			set_segmdesc(gdt + 1004,segsiz - 1,(int)q,AR_DATA32_RW + 0x60);
			for(int i = 0;i<datsiz;i++)
  283a96:	83 c0 01             	add    $0x1,%eax
  283a99:	39 c7                	cmp    %eax,%edi
  283a9b:	75 f2                	jne    283a8f <cmd_app+0x181>
  283a9d:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
			{
				q[esp + i] = p[dathrb + i];
			}
			start_app(0x1b,1003*8,esp,1004*8,&(task->tss.esp0));
  283aa0:	83 ec 0c             	sub    $0xc,%esp
  283aa3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  283aa6:	83 c0 30             	add    $0x30,%eax
  283aa9:	50                   	push   %eax
  283aaa:	68 60 1f 00 00       	push   $0x1f60
  283aaf:	ff 75 b8             	pushl  -0x48(%ebp)
  283ab2:	68 58 1f 00 00       	push   $0x1f58
  283ab7:	6a 1b                	push   $0x1b
  283ab9:	e8 b2 01 00 00       	call   283c70 <start_app>
			memman_free_4k(memman,(int)q,segsiz);
  283abe:	83 c4 1c             	add    $0x1c,%esp
  283ac1:	ff 75 c0             	pushl  -0x40(%ebp)
  283ac4:	ff 75 bc             	pushl  -0x44(%ebp)
  283ac7:	68 00 00 3c 00       	push   $0x3c0000
  283acc:	e8 b8 e7 ff ff       	call   282289 <memman_free_4k>
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
		{
  283ad1:	83 c4 10             	add    $0x10,%esp
  283ad4:	eb 13                	jmp    283ae9 <cmd_app+0x1db>
			start_app(0x1b,1003*8,esp,1004*8,&(task->tss.esp0));
			memman_free_4k(memman,(int)q,segsiz);
		}
		else
		{
			cons_putstr0(cons,".bin file format error.\n");
  283ad6:	83 ec 08             	sub    $0x8,%esp
  283ad9:	68 ba 42 28 00       	push   $0x2842ba
  283ade:	ff 75 08             	pushl  0x8(%ebp)
  283ae1:	e8 f3 fd ff ff       	call   2838d9 <cons_putstr0>
  283ae6:	83 c4 10             	add    $0x10,%esp
		}
		memman_free_4k(memman,(int)p,finfo->size);
  283ae9:	83 ec 04             	sub    $0x4,%esp
  283aec:	ff 73 3c             	pushl  0x3c(%ebx)
  283aef:	56                   	push   %esi
  283af0:	68 00 00 3c 00       	push   $0x3c0000
  283af5:	e8 8f e7 ff ff       	call   282289 <memman_free_4k>
		cons_newline(cons);
  283afa:	83 c4 04             	add    $0x4,%esp
  283afd:	ff 75 08             	pushl  0x8(%ebp)
  283b00:	e8 ca f9 ff ff       	call   2834cf <cons_newline>
		return 1;
  283b05:	83 c4 10             	add    $0x10,%esp
  283b08:	b8 01 00 00 00       	mov    $0x1,%eax
  283b0d:	eb 14                	jmp    283b23 <cmd_app+0x215>
	}
	return 0;
  283b0f:	b8 00 00 00 00       	mov    $0x0,%eax
  283b14:	eb 0d                	jmp    283b23 <cmd_app+0x215>

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
  283b16:	88 45 d6             	mov    %al,-0x2a(%ebp)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  283b19:	be 01 00 00 00       	mov    $0x1,%esi
  283b1e:	e9 0c fe ff ff       	jmp    28392f <cmd_app+0x21>
		memman_free_4k(memman,(int)p,finfo->size);
		cons_newline(cons);
		return 1;
	}
	return 0;
}
  283b23:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283b26:	5b                   	pop    %ebx
  283b27:	5e                   	pop    %esi
  283b28:	5f                   	pop    %edi
  283b29:	5d                   	pop    %ebp
  283b2a:	c3                   	ret    

00283b2b <cons_runcmd>:
	cons->cur_x = 8;
}

#include "string.h"
void cons_runcmd(char *cmdline,struct CONSOLE *cons,int *fat,unsigned int memtotal)
{
  283b2b:	55                   	push   %ebp
  283b2c:	89 e5                	mov    %esp,%ebp
  283b2e:	53                   	push   %ebx
  283b2f:	83 ec 0c             	sub    $0xc,%esp
  283b32:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(strcmp(cmdline,"mem") == 0)
  283b35:	68 d3 42 28 00       	push   $0x2842d3
  283b3a:	53                   	push   %ebx
  283b3b:	e8 82 de ff ff       	call   2819c2 <strcmp>
  283b40:	83 c4 10             	add    $0x10,%esp
  283b43:	85 c0                	test   %eax,%eax
  283b45:	75 16                	jne    283b5d <cons_runcmd+0x32>
		cmd_mem(cons,memtotal);
  283b47:	83 ec 08             	sub    $0x8,%esp
  283b4a:	ff 75 14             	pushl  0x14(%ebp)
  283b4d:	ff 75 0c             	pushl  0xc(%ebp)
  283b50:	e8 03 fb ff ff       	call   283658 <cmd_mem>
  283b55:	83 c4 10             	add    $0x10,%esp
  283b58:	e9 c9 00 00 00       	jmp    283c26 <cons_runcmd+0xfb>
	else if(strcmp(cmdline,"cls") == 0)
  283b5d:	83 ec 08             	sub    $0x8,%esp
  283b60:	68 d7 42 28 00       	push   $0x2842d7
  283b65:	53                   	push   %ebx
  283b66:	e8 57 de ff ff       	call   2819c2 <strcmp>
  283b6b:	83 c4 10             	add    $0x10,%esp
  283b6e:	85 c0                	test   %eax,%eax
  283b70:	75 13                	jne    283b85 <cons_runcmd+0x5a>
		cmd_cls(cons);
  283b72:	83 ec 0c             	sub    $0xc,%esp
  283b75:	ff 75 0c             	pushl  0xc(%ebp)
  283b78:	e8 69 fb ff ff       	call   2836e6 <cmd_cls>
  283b7d:	83 c4 10             	add    $0x10,%esp
  283b80:	e9 a1 00 00 00       	jmp    283c26 <cons_runcmd+0xfb>
	else if(strcmp(cmdline,"dir") == 0)
  283b85:	83 ec 08             	sub    $0x8,%esp
  283b88:	68 db 42 28 00       	push   $0x2842db
  283b8d:	53                   	push   %ebx
  283b8e:	e8 2f de ff ff       	call   2819c2 <strcmp>
  283b93:	83 c4 10             	add    $0x10,%esp
  283b96:	85 c0                	test   %eax,%eax
  283b98:	75 10                	jne    283baa <cons_runcmd+0x7f>
		cmd_dir(cons);
  283b9a:	83 ec 0c             	sub    $0xc,%esp
  283b9d:	ff 75 0c             	pushl  0xc(%ebp)
  283ba0:	e8 a9 fb ff ff       	call   28374e <cmd_dir>
  283ba5:	83 c4 10             	add    $0x10,%esp
  283ba8:	eb 7c                	jmp    283c26 <cons_runcmd+0xfb>
	else if(strncmp(cmdline,"type ",5) == 0)
  283baa:	83 ec 04             	sub    $0x4,%esp
  283bad:	6a 05                	push   $0x5
  283baf:	68 df 42 28 00       	push   $0x2842df
  283bb4:	53                   	push   %ebx
  283bb5:	e8 6e de ff ff       	call   281a28 <strncmp>
  283bba:	83 c4 10             	add    $0x10,%esp
  283bbd:	85 c0                	test   %eax,%eax
  283bbf:	75 14                	jne    283bd5 <cons_runcmd+0xaa>
		cmd_type(cons,fat,cmdline);
  283bc1:	83 ec 04             	sub    $0x4,%esp
  283bc4:	53                   	push   %ebx
  283bc5:	ff 75 10             	pushl  0x10(%ebp)
  283bc8:	ff 75 0c             	pushl  0xc(%ebp)
  283bcb:	e8 34 fc ff ff       	call   283804 <cmd_type>
  283bd0:	83 c4 10             	add    $0x10,%esp
  283bd3:	eb 51                	jmp    283c26 <cons_runcmd+0xfb>
	else if(cmdline[0] != 0)
  283bd5:	80 3b 00             	cmpb   $0x0,(%ebx)
  283bd8:	74 4c                	je     283c26 <cons_runcmd+0xfb>
	{
		if(cmd_app(cons,fat,cmdline) == 0)
  283bda:	83 ec 04             	sub    $0x4,%esp
  283bdd:	53                   	push   %ebx
  283bde:	ff 75 10             	pushl  0x10(%ebp)
  283be1:	ff 75 0c             	pushl  0xc(%ebp)
  283be4:	e8 25 fd ff ff       	call   28390e <cmd_app>
  283be9:	83 c4 10             	add    $0x10,%esp
  283bec:	85 c0                	test   %eax,%eax
  283bee:	75 36                	jne    283c26 <cons_runcmd+0xfb>
		{
			putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"Bad command.",12);
  283bf0:	83 ec 04             	sub    $0x4,%esp
  283bf3:	6a 0c                	push   $0xc
  283bf5:	68 e5 42 28 00       	push   $0x2842e5
  283bfa:	6a 00                	push   $0x0
  283bfc:	6a 07                	push   $0x7
  283bfe:	8b 45 0c             	mov    0xc(%ebp),%eax
  283c01:	ff 70 08             	pushl  0x8(%eax)
  283c04:	6a 08                	push   $0x8
  283c06:	ff 30                	pushl  (%eax)
  283c08:	e8 26 d5 ff ff       	call   281133 <putfonts8_asc_sht>
			cons_newline(cons);
  283c0d:	83 c4 14             	add    $0x14,%esp
  283c10:	ff 75 0c             	pushl  0xc(%ebp)
  283c13:	e8 b7 f8 ff ff       	call   2834cf <cons_newline>
			cons_newline(cons);
  283c18:	83 c4 04             	add    $0x4,%esp
  283c1b:	ff 75 0c             	pushl  0xc(%ebp)
  283c1e:	e8 ac f8 ff ff       	call   2834cf <cons_newline>
  283c23:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  283c26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  283c29:	c9                   	leave  
  283c2a:	c3                   	ret    

00283c2b <cons_putstr1>:
	}
	return;
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
  283c2b:	55                   	push   %ebp
  283c2c:	89 e5                	mov    %esp,%ebp
  283c2e:	57                   	push   %edi
  283c2f:	56                   	push   %esi
  283c30:	53                   	push   %ebx
  283c31:	83 ec 0c             	sub    $0xc,%esp
  283c34:	8b 7d 08             	mov    0x8(%ebp),%edi
  283c37:	8b 75 0c             	mov    0xc(%ebp),%esi
  283c3a:	8b 45 10             	mov    0x10(%ebp),%eax
	int i;
	for(i=0;i<l;i++)
  283c3d:	85 c0                	test   %eax,%eax
  283c3f:	7e 1d                	jle    283c5e <cons_putstr1+0x33>
  283c41:	89 f3                	mov    %esi,%ebx
  283c43:	01 c6                	add    %eax,%esi
	{
		cons_putchar(cons,s[i],1);
  283c45:	83 ec 04             	sub    $0x4,%esp
  283c48:	6a 01                	push   $0x1
  283c4a:	0f be 03             	movsbl (%ebx),%eax
  283c4d:	50                   	push   %eax
  283c4e:	57                   	push   %edi
  283c4f:	e8 46 f9 ff ff       	call   28359a <cons_putchar>
  283c54:	83 c3 01             	add    $0x1,%ebx
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
	int i;
	for(i=0;i<l;i++)
  283c57:	83 c4 10             	add    $0x10,%esp
  283c5a:	39 f3                	cmp    %esi,%ebx
  283c5c:	75 e7                	jne    283c45 <cons_putstr1+0x1a>
	{
		cons_putchar(cons,s[i],1);
	}
	return;
}
  283c5e:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283c61:	5b                   	pop    %ebx
  283c62:	5e                   	pop    %esi
  283c63:	5f                   	pop    %edi
  283c64:	5d                   	pop    %ebp
  283c65:	c3                   	ret    
  283c66:	66 90                	xchg   %ax,%ax
  283c68:	66 90                	xchg   %ax,%ax
  283c6a:	66 90                	xchg   %ax,%ax
  283c6c:	66 90                	xchg   %ax,%ax
  283c6e:	66 90                	xchg   %ax,%ax

00283c70 <start_app>:
  283c70:	60                   	pusha  
  283c71:	8b 44 24 24          	mov    0x24(%esp),%eax
  283c75:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  283c79:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  283c7d:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  283c81:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  283c85:	89 65 00             	mov    %esp,0x0(%ebp)
  283c88:	8c 55 04             	mov    %ss,0x4(%ebp)
  283c8b:	8e c3                	mov    %ebx,%es
  283c8d:	8e db                	mov    %ebx,%ds
  283c8f:	8e e3                	mov    %ebx,%fs
  283c91:	8e eb                	mov    %ebx,%gs
  283c93:	83 c9 03             	or     $0x3,%ecx
  283c96:	83 cb 03             	or     $0x3,%ebx
  283c99:	53                   	push   %ebx
  283c9a:	52                   	push   %edx
  283c9b:	51                   	push   %ecx
  283c9c:	50                   	push   %eax
  283c9d:	cb                   	lret   

00283c9e <sys_api>:
#include "console.h"
#include "task.h"
#include "map_sheet.h"
int *sys_api(int edi,int esi,int ebp,int esp,int ebx,int edx,int ecx,int eax)
{
  283c9e:	55                   	push   %ebp
  283c9f:	89 e5                	mov    %esp,%ebp
  283ca1:	57                   	push   %edi
  283ca2:	56                   	push   %esi
  283ca3:	53                   	push   %ebx
  283ca4:	83 ec 0c             	sub    $0xc,%esp
  283ca7:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
  283caa:	8b 3d ec 0f 00 00    	mov    0xfec,%edi
	int ds_base = *((int *)0xfe8);
  283cb0:	8b 35 e8 0f 00 00    	mov    0xfe8,%esi
	struct TASK *task = task_now();
  283cb6:	e8 e7 ee ff ff       	call   282ba2 <task_now>
	   reg[0] = 1st_edi; reg[1] = 1st_esi ... reg[7] = 1st_eax
	   and the parameters:
	   edi = 2nd_edi; esi = 2nd_esi ... eax = 2nd_eax
	 */

	if(edx == 1) cons_putchar(cons,eax & 0xff,1);
  283cbb:	83 fb 01             	cmp    $0x1,%ebx
  283cbe:	75 1d                	jne    283cdd <sys_api+0x3f>
  283cc0:	83 ec 04             	sub    $0x4,%esp
  283cc3:	6a 01                	push   $0x1
  283cc5:	0f b6 45 24          	movzbl 0x24(%ebp),%eax
  283cc9:	50                   	push   %eax
  283cca:	57                   	push   %edi
  283ccb:	e8 ca f8 ff ff       	call   28359a <cons_putchar>
  283cd0:	83 c4 10             	add    $0x10,%esp
	{
		sht = (struct SHEET *)ebx;
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
		sheet_refresh(sht,eax,ecx,esi+1,edi+1);
	}
	return 0;
  283cd3:	b8 00 00 00 00       	mov    $0x0,%eax
  283cd8:	e9 52 01 00 00       	jmp    283e2f <sys_api+0x191>
	   and the parameters:
	   edi = 2nd_edi; esi = 2nd_esi ... eax = 2nd_eax
	 */

	if(edx == 1) cons_putchar(cons,eax & 0xff,1);
	else if(edx == 2) cons_putstr0(cons,(char *)ebx+ds_base);
  283cdd:	83 fb 02             	cmp    $0x2,%ebx
  283ce0:	75 1a                	jne    283cfc <sys_api+0x5e>
  283ce2:	83 ec 08             	sub    $0x8,%esp
  283ce5:	03 75 18             	add    0x18(%ebp),%esi
  283ce8:	56                   	push   %esi
  283ce9:	57                   	push   %edi
  283cea:	e8 ea fb ff ff       	call   2838d9 <cons_putstr0>
  283cef:	83 c4 10             	add    $0x10,%esp
	{
		sht = (struct SHEET *)ebx;
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
		sheet_refresh(sht,eax,ecx,esi+1,edi+1);
	}
	return 0;
  283cf2:	b8 00 00 00 00       	mov    $0x0,%eax
  283cf7:	e9 33 01 00 00       	jmp    283e2f <sys_api+0x191>
	   edi = 2nd_edi; esi = 2nd_esi ... eax = 2nd_eax
	 */

	if(edx == 1) cons_putchar(cons,eax & 0xff,1);
	else if(edx == 2) cons_putstr0(cons,(char *)ebx+ds_base);
	else if(edx == 3) cons_putstr1(cons,(char *)ebx+ds_base,ecx);
  283cfc:	83 fb 03             	cmp    $0x3,%ebx
  283cff:	75 1d                	jne    283d1e <sys_api+0x80>
  283d01:	83 ec 04             	sub    $0x4,%esp
  283d04:	ff 75 20             	pushl  0x20(%ebp)
  283d07:	03 75 18             	add    0x18(%ebp),%esi
  283d0a:	56                   	push   %esi
  283d0b:	57                   	push   %edi
  283d0c:	e8 1a ff ff ff       	call   283c2b <cons_putstr1>
  283d11:	83 c4 10             	add    $0x10,%esp
	{
		sht = (struct SHEET *)ebx;
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
		sheet_refresh(sht,eax,ecx,esi+1,edi+1);
	}
	return 0;
  283d14:	b8 00 00 00 00       	mov    $0x0,%eax
  283d19:	e9 11 01 00 00       	jmp    283e2f <sys_api+0x191>
	else if(edx == 2) cons_putstr0(cons,(char *)ebx+ds_base);
	else if(edx == 3) cons_putstr1(cons,(char *)ebx+ds_base,ecx);
	else if(edx == 4)
	{
		//exit app
		return &(task->tss.esp0);
  283d1e:	83 c0 30             	add    $0x30,%eax
	 */

	if(edx == 1) cons_putchar(cons,eax & 0xff,1);
	else if(edx == 2) cons_putstr0(cons,(char *)ebx+ds_base);
	else if(edx == 3) cons_putstr1(cons,(char *)ebx+ds_base,ecx);
	else if(edx == 4)
  283d21:	83 fb 04             	cmp    $0x4,%ebx
  283d24:	0f 84 05 01 00 00    	je     283e2f <sys_api+0x191>
	{
		//exit app
		return &(task->tss.esp0);
	}
	else if(edx == 5)
  283d2a:	83 fb 05             	cmp    $0x5,%ebx
  283d2d:	75 62                	jne    283d91 <sys_api+0xf3>
	{
		sht = sheet_alloc(shtctl);
  283d2f:	83 ec 0c             	sub    $0xc,%esp
  283d32:	ff 35 e4 0f 00 00    	pushl  0xfe4
  283d38:	e8 0f e6 ff ff       	call   28234c <sheet_alloc>
  283d3d:	89 c7                	mov    %eax,%edi
		sheet_setbuf(sht,(char *)ebx+ds_base,esi,edi,eax);
  283d3f:	89 f3                	mov    %esi,%ebx
  283d41:	03 5d 18             	add    0x18(%ebp),%ebx
  283d44:	83 c4 04             	add    $0x4,%esp
  283d47:	ff 75 24             	pushl  0x24(%ebp)
  283d4a:	ff 75 08             	pushl  0x8(%ebp)
  283d4d:	ff 75 0c             	pushl  0xc(%ebp)
  283d50:	53                   	push   %ebx
  283d51:	50                   	push   %eax
  283d52:	e8 5c e6 ff ff       	call   2823b3 <sheet_setbuf>
		make_window8((char *)ebx+ds_base,esi,edi,(char *)ecx+ds_base,0);
  283d57:	83 c4 14             	add    $0x14,%esp
  283d5a:	6a 00                	push   $0x0
  283d5c:	03 75 20             	add    0x20(%ebp),%esi
  283d5f:	56                   	push   %esi
  283d60:	ff 75 08             	pushl  0x8(%ebp)
  283d63:	ff 75 0c             	pushl  0xc(%ebp)
  283d66:	53                   	push   %ebx
  283d67:	e8 69 d2 ff ff       	call   280fd5 <make_window8>
		sheet_slide(sht,100,50);
  283d6c:	83 c4 1c             	add    $0x1c,%esp
  283d6f:	6a 32                	push   $0x32
  283d71:	6a 64                	push   $0x64
  283d73:	57                   	push   %edi
  283d74:	e8 5b ea ff ff       	call   2827d4 <sheet_slide>
		sheet_updown(sht,3);	//above task_a
  283d79:	83 c4 08             	add    $0x8,%esp
  283d7c:	6a 03                	push   $0x3
  283d7e:	57                   	push   %edi
  283d7f:	e8 67 e9 ff ff       	call   2826eb <sheet_updown>
  283d84:	83 c4 10             	add    $0x10,%esp
	{
		sht = (struct SHEET *)ebx;
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
		sheet_refresh(sht,eax,ecx,esi+1,edi+1);
	}
	return 0;
  283d87:	b8 00 00 00 00       	mov    $0x0,%eax
  283d8c:	e9 9e 00 00 00       	jmp    283e2f <sys_api+0x191>
		make_window8((char *)ebx+ds_base,esi,edi,(char *)ecx+ds_base,0);
		sheet_slide(sht,100,50);
		sheet_updown(sht,3);	//above task_a
		reg[7] = (int)sht;		//after sys_api ret and popad the eax will be sht
	}
	else if(edx == 6)
  283d91:	83 fb 06             	cmp    $0x6,%ebx
  283d94:	75 49                	jne    283ddf <sys_api+0x141>
	{
		sht = (struct SHEET *)ebx;
		putfonts8_asc(sht->buf,sht->bxsize,esi,edi,eax,(char *)ebp + ds_base);
  283d96:	83 ec 08             	sub    $0x8,%esp
  283d99:	03 75 10             	add    0x10(%ebp),%esi
  283d9c:	56                   	push   %esi
  283d9d:	ff 75 24             	pushl  0x24(%ebp)
  283da0:	ff 75 08             	pushl  0x8(%ebp)
  283da3:	ff 75 0c             	pushl  0xc(%ebp)
  283da6:	8b 45 18             	mov    0x18(%ebp),%eax
  283da9:	ff 70 04             	pushl  0x4(%eax)
  283dac:	ff 30                	pushl  (%eax)
  283dae:	e8 76 d5 ff ff       	call   281329 <putfonts8_asc>
		sheet_refresh(sht,esi,edi,esi+ecx*8,edi+16);
  283db3:	83 c4 14             	add    $0x14,%esp
  283db6:	8b 45 08             	mov    0x8(%ebp),%eax
  283db9:	83 c0 10             	add    $0x10,%eax
  283dbc:	50                   	push   %eax
  283dbd:	8b 45 0c             	mov    0xc(%ebp),%eax
  283dc0:	8b 55 20             	mov    0x20(%ebp),%edx
  283dc3:	8d 04 d0             	lea    (%eax,%edx,8),%eax
  283dc6:	50                   	push   %eax
  283dc7:	ff 75 08             	pushl  0x8(%ebp)
  283dca:	ff 75 0c             	pushl  0xc(%ebp)
  283dcd:	ff 75 18             	pushl  0x18(%ebp)
  283dd0:	e8 dd e8 ff ff       	call   2826b2 <sheet_refresh>
  283dd5:	83 c4 20             	add    $0x20,%esp
	{
		sht = (struct SHEET *)ebx;
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
		sheet_refresh(sht,eax,ecx,esi+1,edi+1);
	}
	return 0;
  283dd8:	b8 00 00 00 00       	mov    $0x0,%eax
  283ddd:	eb 50                	jmp    283e2f <sys_api+0x191>
  283ddf:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		sht = (struct SHEET *)ebx;
		putfonts8_asc(sht->buf,sht->bxsize,esi,edi,eax,(char *)ebp + ds_base);
		sheet_refresh(sht,esi,edi,esi+ecx*8,edi+16);
	}
	else if(edx == 7)
  283de4:	83 fb 07             	cmp    $0x7,%ebx
  283de7:	75 46                	jne    283e2f <sys_api+0x191>
	{
		sht = (struct SHEET *)ebx;
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
  283de9:	83 ec 04             	sub    $0x4,%esp
  283dec:	ff 75 08             	pushl  0x8(%ebp)
  283def:	ff 75 0c             	pushl  0xc(%ebp)
  283df2:	ff 75 20             	pushl  0x20(%ebp)
  283df5:	ff 75 24             	pushl  0x24(%ebp)
  283df8:	ff 75 10             	pushl  0x10(%ebp)
  283dfb:	8b 45 18             	mov    0x18(%ebp),%eax
  283dfe:	ff 70 04             	pushl  0x4(%eax)
  283e01:	ff 30                	pushl  (%eax)
  283e03:	e8 cc ce ff ff       	call   280cd4 <boxfill8>
		sheet_refresh(sht,eax,ecx,esi+1,edi+1);
  283e08:	83 c4 14             	add    $0x14,%esp
  283e0b:	8b 45 08             	mov    0x8(%ebp),%eax
  283e0e:	83 c0 01             	add    $0x1,%eax
  283e11:	50                   	push   %eax
  283e12:	8b 45 0c             	mov    0xc(%ebp),%eax
  283e15:	83 c0 01             	add    $0x1,%eax
  283e18:	50                   	push   %eax
  283e19:	ff 75 20             	pushl  0x20(%ebp)
  283e1c:	ff 75 24             	pushl  0x24(%ebp)
  283e1f:	ff 75 18             	pushl  0x18(%ebp)
  283e22:	e8 8b e8 ff ff       	call   2826b2 <sheet_refresh>
  283e27:	83 c4 20             	add    $0x20,%esp
	}
	return 0;
  283e2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  283e2f:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283e32:	5b                   	pop    %ebx
  283e33:	5e                   	pop    %esi
  283e34:	5f                   	pop    %edi
  283e35:	5d                   	pop    %ebp
  283e36:	c3                   	ret    
  283e37:	66 90                	xchg   %ax,%ax
  283e39:	66 90                	xchg   %ax,%ax
  283e3b:	66 90                	xchg   %ax,%ax
  283e3d:	66 90                	xchg   %ax,%ax
  283e3f:	90                   	nop

00283e40 <api_putchar>:
  283e40:	ba 01 00 00 00       	mov    $0x1,%edx
  283e45:	8a 44 24 04          	mov    0x4(%esp),%al
  283e49:	cd 40                	int    $0x40
  283e4b:	c3                   	ret    

00283e4c <api_putstr>:
  283e4c:	ba 02 00 00 00       	mov    $0x2,%edx
  283e51:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  283e55:	cd 40                	int    $0x40
  283e57:	c3                   	ret    

00283e58 <api_end>:
  283e58:	ba 04 00 00 00       	mov    $0x4,%edx
  283e5d:	cd 40                	int    $0x40

00283e5f <api_test>:
  283e5f:	05 80 00 00 00       	add    $0x80,%eax
  283e64:	c3                   	ret    

00283e65 <api_openwin>:
  283e65:	57                   	push   %edi
  283e66:	56                   	push   %esi
  283e67:	53                   	push   %ebx
  283e68:	ba 05 00 00 00       	mov    $0x5,%edx
  283e6d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  283e71:	8b 74 24 14          	mov    0x14(%esp),%esi
  283e75:	8b 7c 24 18          	mov    0x18(%esp),%edi
  283e79:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  283e7d:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  283e81:	cd 40                	int    $0x40
  283e83:	5b                   	pop    %ebx
  283e84:	5e                   	pop    %esi
  283e85:	5f                   	pop    %edi
  283e86:	c3                   	ret    

00283e87 <api_putstrwin>:
  283e87:	57                   	push   %edi
  283e88:	56                   	push   %esi
  283e89:	55                   	push   %ebp
  283e8a:	53                   	push   %ebx
  283e8b:	ba 06 00 00 00       	mov    $0x6,%edx
  283e90:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  283e94:	8b 74 24 18          	mov    0x18(%esp),%esi
  283e98:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  283e9c:	8b 44 24 20          	mov    0x20(%esp),%eax
  283ea0:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  283ea4:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  283ea8:	cd 40                	int    $0x40
  283eaa:	5b                   	pop    %ebx
  283eab:	5d                   	pop    %ebp
  283eac:	5e                   	pop    %esi
  283ead:	5f                   	pop    %edi
  283eae:	c3                   	ret    

00283eaf <api_boxfilwin>:
  283eaf:	57                   	push   %edi
  283eb0:	56                   	push   %esi
  283eb1:	55                   	push   %ebp
  283eb2:	53                   	push   %ebx
  283eb3:	ba 07 00 00 00       	mov    $0x7,%edx
  283eb8:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  283ebc:	8b 44 24 18          	mov    0x18(%esp),%eax
  283ec0:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  283ec4:	8b 74 24 20          	mov    0x20(%esp),%esi
  283ec8:	8b 7c 24 24          	mov    0x24(%esp),%edi
  283ecc:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  283ed0:	cd 40                	int    $0x40
  283ed2:	5b                   	pop    %ebx
  283ed3:	5d                   	pop    %ebp
  283ed4:	5e                   	pop    %esi
  283ed5:	5f                   	pop    %edi
  283ed6:	c3                   	ret    

00283ed7 <test>:
#include "test.h"
int test(int screenx, int screeny)
{
  283ed7:	55                   	push   %ebp
  283ed8:	89 e5                	mov    %esp,%ebp
	return screenx*screeny;
  283eda:	8b 45 0c             	mov    0xc(%ebp),%eax
  283edd:	0f af 45 08          	imul   0x8(%ebp),%eax
}
  283ee1:	5d                   	pop    %ebp
  283ee2:	c3                   	ret    
