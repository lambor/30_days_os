
main.out.o:     file format elf32-i386


Disassembly of section .text:

00280000 <bootmain>:
#include "header.h"


int bootmain()
{
  280000:	55                   	push   %ebp
	//the buf for all strings.
	char s[50] = {0};
  280001:	31 c0                	xor    %eax,%eax
  280003:	b9 32 00 00 00       	mov    $0x32,%ecx
#include "header.h"


int bootmain()
{
  280008:	89 e5                	mov    %esp,%ebp
  28000a:	57                   	push   %edi
  28000b:	56                   	push   %esi
	//the buf for all strings.
	char s[50] = {0};
  28000c:	8d bd 36 fc ff ff    	lea    -0x3ca(%ebp),%edi
#include "header.h"


int bootmain()
{
  280012:	53                   	push   %ebx
  280013:	81 ec 6c 04 00 00    	sub    $0x46c,%esp
	//the buf for all strings.
	char s[50] = {0};
  280019:	f3 aa                	rep stos %al,%es:(%edi)
	struct BOOTINFO *binfo = (struct BOOTINFO *)0xff0;

	//init fifo and keycmd fifo
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
  28001b:	8d 85 e8 fd ff ff    	lea    -0x218(%ebp),%eax
  280021:	6a 00                	push   $0x0
  280023:	50                   	push   %eax
  280024:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  28002a:	68 80 00 00 00       	push   $0x80
  28002f:	50                   	push   %eax
  280030:	e8 03 1d 00 00       	call   281d38 <fifo32_init>
	fifo32_init(&keycmd,32,keycmd_buf,0);
  280035:	8d 85 68 fc ff ff    	lea    -0x398(%ebp),%eax
  28003b:	6a 00                	push   $0x0
  28003d:	50                   	push   %eax
  28003e:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  280044:	6a 20                	push   $0x20
  280046:	50                   	push   %eax
  280047:	e8 ec 1c 00 00       	call   281d38 <fifo32_init>

	int key_leds = (binfo->leds>>4)&7;
  28004c:	a0 f1 0f 00 00       	mov    0xff1,%al

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280051:	83 c4 18             	add    $0x18,%esp
  280054:	68 ed 00 00 00       	push   $0xed
	struct FIFO32 fifo,keycmd;
	int fifobuf[128], keycmd_buf[32];
	fifo32_init(&fifo,128,fifobuf,0);
	fifo32_init(&keycmd,32,keycmd_buf,0);

	int key_leds = (binfo->leds>>4)&7;
  280059:	c0 f8 04             	sar    $0x4,%al
  28005c:	83 e0 07             	and    $0x7,%eax
  28005f:	89 85 c8 fb ff ff    	mov    %eax,-0x438(%ebp)

	//init with the keyboard led status
	fifo32_put(&keycmd,KEYCMD_LED);
  280065:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  28006b:	50                   	push   %eax
  28006c:	e8 f8 1c 00 00       	call   281d69 <fifo32_put>
	fifo32_put(&keycmd,key_leds);
  280071:	58                   	pop    %eax
  280072:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
  280078:	5a                   	pop    %edx
  280079:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  28007f:	50                   	push   %eax
  280080:	e8 e4 1c 00 00       	call   281d69 <fifo32_put>

	//init gdt idt pic and enable cpu interrupt
	init_gdtidt();
  280085:	e8 fe 15 00 00       	call   281688 <init_gdtidt>
	init_pic();
  28008a:	e8 bd 17 00 00       	call   28184c <init_pic>
	io_sti();
  28008f:	e8 40 0c 00 00       	call   280cd4 <io_sti>

	//init keyboard and mouse
	init_keyboard(&fifo,256);
  280094:	59                   	pop    %ecx
  280095:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  28009b:	5b                   	pop    %ebx
  28009c:	68 00 01 00 00       	push   $0x100
  2800a1:	50                   	push   %eax
  2800a2:	e8 cb 1e 00 00       	call   281f72 <init_keyboard>
	struct MOUSE_DEC mdec;
	enable_mouse(&fifo,512,&mdec);
  2800a7:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  2800ad:	83 c4 0c             	add    $0xc,%esp
  2800b0:	50                   	push   %eax
  2800b1:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  2800b7:	68 00 02 00 00       	push   $0x200
  2800bc:	50                   	push   %eax
  2800bd:	e8 62 1d 00 00       	call   281e24 <enable_mouse>

	//init timer
	init_pit();
  2800c2:	e8 7b 2a 00 00       	call   282b42 <init_pit>

	io_out8(PIC0_IMR,0xf8);
  2800c7:	5e                   	pop    %esi
  2800c8:	5f                   	pop    %edi
  2800c9:	68 f8 00 00 00       	push   $0xf8
  2800ce:	6a 21                	push   $0x21
  2800d0:	e8 31 0c 00 00       	call   280d06 <io_out8>
	io_out8(PIC1_IMR,0xef);
  2800d5:	58                   	pop    %eax
  2800d6:	5a                   	pop    %edx
  2800d7:	68 ef 00 00 00       	push   $0xef
  2800dc:	68 a1 00 00 00       	push   $0xa1
  2800e1:	e8 20 0c 00 00       	call   280d06 <io_out8>

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800e6:	59                   	pop    %ecx
  2800e7:	5b                   	pop    %ebx
  2800e8:	68 ff ff ff bf       	push   $0xbfffffff
  2800ed:	68 00 00 40 00       	push   $0x400000
  2800f2:	e8 15 1f 00 00       	call   28200c <memtest>
	memman_init(memman);
  2800f7:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
	io_out8(PIC1_IMR,0xef);

	//init memory manager
	unsigned int memtotal,count = 0;
	struct MEMMAN *memman  = (struct MEMMAN *)MEMMAN_ADDR;
	memtotal = memtest(0x00400000,0xbfffffff);
  2800fe:	89 c6                	mov    %eax,%esi
	memman_init(memman);
  280100:	e8 46 20 00 00       	call   28214b <memman_init>
	//init memman with two mem block:0x00001000-0x0009efff and 0x00400000-memtotal
	memman_free(memman,0x00001000,0x0009e000);
  280105:	83 c4 0c             	add    $0xc,%esp
  280108:	68 00 e0 09 00       	push   $0x9e000
  28010d:	68 00 10 00 00       	push   $0x1000
  280112:	68 00 00 3c 00       	push   $0x3c0000
  280117:	e8 7e 21 00 00       	call   28229a <memman_free>
	memman_free(memman,0x00400000,memtotal-0x00400000);
  28011c:	8d 86 00 00 c0 ff    	lea    -0x400000(%esi),%eax
  280122:	83 c4 0c             	add    $0xc,%esp
  280125:	50                   	push   %eax
  280126:	68 00 00 40 00       	push   $0x400000
  28012b:	68 00 00 3c 00       	push   $0x3c0000
  280130:	e8 65 21 00 00       	call   28229a <memman_free>
	struct SHTCTL *shtctl;
	struct SHEET *sht_bg, *sht_mouse, *sht_window, *sht_console;
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;

	init_palette();
  280135:	e8 01 0d 00 00       	call   280e3b <init_palette>
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  28013a:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  280141:	50                   	push   %eax
  280142:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280149:	50                   	push   %eax
  28014a:	ff 35 f8 0f 00 00    	pushl  0xff8
  280150:	68 00 00 3c 00       	push   $0x3c0000
  280155:	e8 ee 23 00 00       	call   282548 <shtctl_init>
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  28015a:	83 c4 14             	add    $0x14,%esp
	struct SHEET *sht_bg, *sht_mouse, *sht_window, *sht_console;
	unsigned char *buf_bg,buf_mouse[256],*buf_window,*buf_console;
	struct TASK *task_a, *task_console;

	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
  28015d:	89 85 d4 fb ff ff    	mov    %eax,-0x42c(%ebp)
	*((int *)0x0fe4) = (int)shtctl;
  280163:	a3 e4 0f 00 00       	mov    %eax,0xfe4
	task_a = task_init(memman); //main task
  280168:	68 00 00 3c 00       	push   $0x3c0000
  28016d:	e8 48 2e 00 00       	call   282fba <task_init>
	fifo.task = task_a;
	task_run(task_a,1,0);
  280172:	83 c4 0c             	add    $0xc,%esp
	struct TASK *task_a, *task_console;

	init_palette();
	shtctl = shtctl_init(memman,binfo->vram,binfo->scrnx,binfo->scrny);
	*((int *)0x0fe4) = (int)shtctl;
	task_a = task_init(memman); //main task
  280175:	89 85 9c fb ff ff    	mov    %eax,-0x464(%ebp)
	fifo.task = task_a;
  28017b:	89 85 14 fc ff ff    	mov    %eax,-0x3ec(%ebp)
	task_run(task_a,1,0);
  280181:	6a 00                	push   $0x0
  280183:	6a 01                	push   $0x1
  280185:	50                   	push   %eax
  280186:	e8 9c 2d 00 00       	call   282f27 <task_run>

	//desktop sheet
	sht_bg = sheet_alloc(shtctl);
  28018b:	5f                   	pop    %edi
  28018c:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280192:	e8 45 24 00 00       	call   2825dc <sheet_alloc>
  280197:	89 85 b0 fb ff ff    	mov    %eax,-0x450(%ebp)
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
  28019d:	58                   	pop    %eax
  28019e:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801a5:	5a                   	pop    %edx
  2801a6:	0f bf 15 f4 0f 00 00 	movswl 0xff4,%edx
  2801ad:	0f af c2             	imul   %edx,%eax
  2801b0:	50                   	push   %eax
  2801b1:	68 00 00 3c 00       	push   $0x3c0000
  2801b6:	e8 32 23 00 00       	call   2824ed <memman_alloc_4k>
  2801bb:	89 c3                	mov    %eax,%ebx
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
  2801bd:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801c4:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  2801cb:	50                   	push   %eax
  2801cc:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801d3:	50                   	push   %eax
  2801d4:	53                   	push   %ebx
  2801d5:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  2801db:	e8 6f 24 00 00       	call   28264f <sheet_setbuf>
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);
  2801e0:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
  2801e7:	83 c4 1c             	add    $0x1c,%esp
  2801ea:	50                   	push   %eax
  2801eb:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2801f2:	50                   	push   %eax
  2801f3:	53                   	push   %ebx
  2801f4:	e8 cb 0c 00 00       	call   280ec4 <init_screen8>

	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
  2801f9:	59                   	pop    %ecx
  2801fa:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  280200:	e8 d7 23 00 00       	call   2825dc <sheet_alloc>
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  280205:	5b                   	pop    %ebx
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);

	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
  280206:	89 c7                	mov    %eax,%edi
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  280208:	58                   	pop    %eax
  280209:	68 80 20 00 00       	push   $0x2080
  28020e:	68 00 00 3c 00       	push   $0x3c0000
  280213:	e8 d5 22 00 00       	call   2824ed <memman_alloc_4k>
	sheet_setbuf(sht_window,buf_window,144,52,-1);
  280218:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  28021f:	6a 34                	push   $0x34
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);

	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
  280221:	89 c3                	mov    %eax,%ebx
	sheet_setbuf(sht_window,buf_window,144,52,-1);
  280223:	68 90 00 00 00       	push   $0x90
  280228:	50                   	push   %eax
  280229:	57                   	push   %edi
  28022a:	e8 20 24 00 00       	call   28264f <sheet_setbuf>
	make_window8(buf_window,144,52,"task_a",1);
  28022f:	83 c4 14             	add    $0x14,%esp
  280232:	6a 01                	push   $0x1
  280234:	68 60 47 28 00       	push   $0x284760
  280239:	6a 34                	push   $0x34
  28023b:	68 90 00 00 00       	push   $0x90
  280240:	53                   	push   %ebx
	timer_init(timer,&fifo,1);
	timer_settime(timer,50);

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  280241:	8d 9d e8 fc ff ff    	lea    -0x318(%ebp),%ebx

	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
	buf_window = (unsigned char *)memman_alloc_4k(memman,160*52);
	sheet_setbuf(sht_window,buf_window,144,52,-1);
	make_window8(buf_window,144,52,"task_a",1);
  280247:	e8 09 0f 00 00       	call   281155 <make_window8>
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
  28024c:	83 c4 18             	add    $0x18,%esp
  28024f:	6a 07                	push   $0x7
  280251:	6a 10                	push   $0x10
  280253:	68 80 00 00 00       	push   $0x80
  280258:	6a 1c                	push   $0x1c
  28025a:	6a 08                	push   $0x8
  28025c:	57                   	push   %edi
  28025d:	e8 b6 10 00 00       	call   281318 <make_textbox8>
	cursor_x = 8;
	cursor_c = COL8_FFFFFF;
	//timer for cursor.
	struct TIMER *timer;
	timer = timer_alloc();
  280262:	83 c4 20             	add    $0x20,%esp
  280265:	e8 84 28 00 00       	call   282aee <timer_alloc>
  28026a:	89 85 ac fb ff ff    	mov    %eax,-0x454(%ebp)
	timer_init(timer,&fifo,1);
  280270:	50                   	push   %eax
  280271:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
  280277:	6a 01                	push   $0x1
  280279:	50                   	push   %eax
  28027a:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280280:	e8 3a 29 00 00       	call   282bbf <timer_init>
	timer_settime(timer,50);
  280285:	58                   	pop    %eax
  280286:	5a                   	pop    %edx
  280287:	6a 32                	push   $0x32
  280289:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  28028f:	e8 3f 29 00 00       	call   282bd3 <timer_settime>

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  280294:	59                   	pop    %ecx
  280295:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
  28029b:	e8 3c 23 00 00       	call   2825dc <sheet_alloc>
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  2802a0:	c7 04 24 63 00 00 00 	movl   $0x63,(%esp)
  2802a7:	6a 10                	push   $0x10
  2802a9:	6a 10                	push   $0x10
  2802ab:	53                   	push   %ebx
  2802ac:	50                   	push   %eax
	timer = timer_alloc();
	timer_init(timer,&fifo,1);
	timer_settime(timer,50);

	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
  2802ad:	89 85 a4 fb ff ff    	mov    %eax,-0x45c(%ebp)
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
  2802b3:	e8 97 23 00 00       	call   28264f <sheet_setbuf>
	init_mouse_cursor8(buf_mouse,99);
  2802b8:	83 c4 18             	add    $0x18,%esp
  2802bb:	6a 63                	push   $0x63
  2802bd:	53                   	push   %ebx
  2802be:	e8 70 0d 00 00       	call   281033 <init_mouse_cursor8>
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  2802c3:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  2802ca:	b9 02 00 00 00       	mov    $0x2,%ecx
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1;

	//console sheet
	sht_console = sheet_alloc(shtctl);
  2802cf:	5b                   	pop    %ebx
	//mouse sheet
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
  2802d0:	83 e8 10             	sub    $0x10,%eax
  2802d3:	99                   	cltd   
  2802d4:	f7 f9                	idiv   %ecx
  2802d6:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
	int my = (binfo->scrny-28-16)/2;
  2802dc:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
	int x,y,mmx = -1,mmy = -1;

	//console sheet
	sht_console = sheet_alloc(shtctl);
  2802e3:	ff b5 d4 fb ff ff    	pushl  -0x42c(%ebp)
	sht_mouse = sheet_alloc(shtctl);
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
  2802e9:	83 e8 2c             	sub    $0x2c,%eax
  2802ec:	99                   	cltd   
  2802ed:	f7 f9                	idiv   %ecx
  2802ef:	89 85 cc fb ff ff    	mov    %eax,-0x434(%ebp)
	int x,y,mmx = -1,mmy = -1;

	//console sheet
	sht_console = sheet_alloc(shtctl);
  2802f5:	e8 e2 22 00 00       	call   2825dc <sheet_alloc>
  2802fa:	89 c3                	mov    %eax,%ebx
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
  2802fc:	58                   	pop    %eax
  2802fd:	5a                   	pop    %edx
  2802fe:	68 00 a5 00 00       	push   $0xa500
  280303:	68 00 00 3c 00       	push   $0x3c0000
  280308:	e8 e0 21 00 00       	call   2824ed <memman_alloc_4k>
	sheet_setbuf(sht_console,buf_console,256,165,-1);
  28030d:	c7 04 24 ff ff ff ff 	movl   $0xffffffff,(%esp)
  280314:	68 a5 00 00 00       	push   $0xa5
  280319:	68 00 01 00 00       	push   $0x100
  28031e:	50                   	push   %eax
  28031f:	53                   	push   %ebx
  280320:	89 85 e4 fb ff ff    	mov    %eax,-0x41c(%ebp)
  280326:	e8 24 23 00 00       	call   28264f <sheet_setbuf>
	make_window8(buf_console,256,165,"console",0);
  28032b:	8b 85 e4 fb ff ff    	mov    -0x41c(%ebp),%eax
  280331:	83 c4 14             	add    $0x14,%esp
  280334:	6a 00                	push   $0x0
  280336:	68 67 47 28 00       	push   $0x284767
  28033b:	68 a5 00 00 00       	push   $0xa5
  280340:	68 00 01 00 00       	push   $0x100
  280345:	50                   	push   %eax
  280346:	e8 0a 0e 00 00       	call   281155 <make_window8>
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
  28034b:	83 c4 18             	add    $0x18,%esp
  28034e:	6a 00                	push   $0x0
  280350:	68 80 00 00 00       	push   $0x80
  280355:	68 f0 00 00 00       	push   $0xf0
  28035a:	6a 1c                	push   $0x1c
  28035c:	6a 08                	push   $0x8
  28035e:	53                   	push   %ebx
  28035f:	e8 b4 0f 00 00       	call   281318 <make_textbox8>
	task_console = task_alloc();
  280364:	83 c4 20             	add    $0x20,%esp
  280367:	e8 cc 29 00 00       	call   282d38 <task_alloc>
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  28036c:	51                   	push   %ecx
  28036d:	51                   	push   %ecx
  28036e:	68 00 00 01 00       	push   $0x10000
  280373:	68 00 00 3c 00       	push   $0x3c0000
	sht_console = sheet_alloc(shtctl);
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
	sheet_setbuf(sht_console,buf_console,256,165,-1);
	make_window8(buf_console,256,165,"console",0);
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
	task_console = task_alloc();
  280378:	89 85 e0 fb ff ff    	mov    %eax,-0x420(%ebp)
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  28037e:	e8 6a 21 00 00       	call   2824ed <memman_alloc_4k>
  280383:	8b 8d e0 fb ff ff    	mov    -0x420(%ebp),%ecx
  280389:	8d 90 f4 ff 00 00    	lea    0xfff4(%eax),%edx
	task_console->tss.ds = 1*8;
	task_console->tss.fs = 1*8;
	task_console->tss.gs = 1*8;
	*((int *)(task_console->tss.esp + 4)) = sht_console;
	*((int *)(task_console->tss.esp + 8)) = memtotal;
	task_run(task_console,2,2);
  28038f:	83 c4 0c             	add    $0xc,%esp
	buf_console = (unsigned char *)memman_alloc_4k(memman,256*165);
	sheet_setbuf(sht_console,buf_console,256,165,-1);
	make_window8(buf_console,256,165,"console",0);
	make_textbox8(sht_console,8,28,240,128,COL8_000000);
	task_console = task_alloc();
	task_console->tss.esp = memman_alloc_4k(memman,64*1024)+64*1024-12;
  280392:	89 51 64             	mov    %edx,0x64(%ecx)
	task_console->tss.eip = (int)&console_task - 0x280000;
  280395:	c7 41 4c db 31 00 00 	movl   $0x31db,0x4c(%ecx)
	task_console->tss.es = 1*8;
  28039c:	c7 41 74 08 00 00 00 	movl   $0x8,0x74(%ecx)
	task_console->tss.cs = 3*8;
  2803a3:	c7 41 78 18 00 00 00 	movl   $0x18,0x78(%ecx)
	task_console->tss.ss = 1*8;
  2803aa:	c7 41 7c 08 00 00 00 	movl   $0x8,0x7c(%ecx)
	task_console->tss.ds = 1*8;
  2803b1:	c7 81 80 00 00 00 08 	movl   $0x8,0x80(%ecx)
  2803b8:	00 00 00 
	task_console->tss.fs = 1*8;
  2803bb:	c7 81 84 00 00 00 08 	movl   $0x8,0x84(%ecx)
  2803c2:	00 00 00 
	task_console->tss.gs = 1*8;
  2803c5:	c7 81 88 00 00 00 08 	movl   $0x8,0x88(%ecx)
  2803cc:	00 00 00 
	*((int *)(task_console->tss.esp + 4)) = sht_console;
  2803cf:	89 98 f8 ff 00 00    	mov    %ebx,0xfff8(%eax)
	*((int *)(task_console->tss.esp + 8)) = memtotal;
  2803d5:	8b 41 64             	mov    0x64(%ecx),%eax
  2803d8:	89 70 08             	mov    %esi,0x8(%eax)
	task_run(task_console,2,2);
  2803db:	6a 02                	push   $0x2
  2803dd:	6a 02                	push   $0x2
  2803df:	51                   	push   %ecx
  2803e0:	e8 42 2b 00 00       	call   282f27 <task_run>


	sheet_slide(sht_bg,0,0);
  2803e5:	83 c4 0c             	add    $0xc,%esp
  2803e8:	6a 00                	push   $0x0
  2803ea:	6a 00                	push   $0x0
  2803ec:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  2803f2:	e8 74 26 00 00       	call   282a6b <sheet_slide>
	sheet_slide(sht_console,32,4);
  2803f7:	83 c4 0c             	add    $0xc,%esp
  2803fa:	6a 04                	push   $0x4
  2803fc:	6a 20                	push   $0x20
  2803fe:	53                   	push   %ebx
  2803ff:	e8 67 26 00 00       	call   282a6b <sheet_slide>
	sheet_slide(sht_window,	64, 56);
  280404:	83 c4 0c             	add    $0xc,%esp
  280407:	6a 38                	push   $0x38
  280409:	6a 40                	push   $0x40
  28040b:	57                   	push   %edi
  28040c:	e8 5a 26 00 00       	call   282a6b <sheet_slide>
	sheet_slide(sht_mouse,mx,my);
  280411:	83 c4 0c             	add    $0xc,%esp
  280414:	ff b5 cc fb ff ff    	pushl  -0x434(%ebp)
  28041a:	ff b5 d0 fb ff ff    	pushl  -0x430(%ebp)
  280420:	ff b5 a4 fb ff ff    	pushl  -0x45c(%ebp)
  280426:	e8 40 26 00 00       	call   282a6b <sheet_slide>
	sheet_updown(sht_bg,0);
  28042b:	5e                   	pop    %esi
  28042c:	58                   	pop    %eax
  28042d:	6a 00                	push   $0x0
  28042f:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  280435:	e8 48 25 00 00       	call   282982 <sheet_updown>
	sheet_updown(sht_console,1);
  28043a:	58                   	pop    %eax
  28043b:	5a                   	pop    %edx
  28043c:	6a 01                	push   $0x1
  28043e:	53                   	push   %ebx
  28043f:	e8 3e 25 00 00       	call   282982 <sheet_updown>
	sheet_updown(sht_window,2);
  280444:	59                   	pop    %ecx
  280445:	5e                   	pop    %esi
  280446:	6a 02                	push   $0x2
  280448:	57                   	push   %edi
	buf_bg = (unsigned char *)memman_alloc_4k(memman,binfo->scrnx*binfo->scrny);
	sheet_setbuf(sht_bg,buf_bg,binfo->scrnx,binfo->scrny,-1);
	init_screen8(buf_bg,binfo->scrnx,binfo->scrny);

	//task_a window sheet
	sht_window = sheet_alloc(shtctl);
  280449:	89 fe                	mov    %edi,%esi
	sheet_slide(sht_console,32,4);
	sheet_slide(sht_window,	64, 56);
	sheet_slide(sht_mouse,mx,my);
	sheet_updown(sht_bg,0);
	sheet_updown(sht_console,1);
	sheet_updown(sht_window,2);
  28044b:	e8 32 25 00 00       	call   282982 <sheet_updown>
	sheet_updown(sht_mouse,3);
  280450:	58                   	pop    %eax
  280451:	5a                   	pop    %edx
  280452:	6a 03                	push   $0x3
  280454:	ff b5 a4 fb ff ff    	pushl  -0x45c(%ebp)
  28045a:	e8 23 25 00 00       	call   282982 <sheet_updown>
	extern struct TIMERCTL timerctl;
	struct SHEET *key_win,*sht = 0;

	//init window focus
	key_win = sht_window;
	sht_console->task = task_console;
  28045f:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
	sht_console->flags |= 0x20;
  280465:	83 4b 1c 20          	orl    $0x20,0x1c(%ebx)
  280469:	83 c4 10             	add    $0x10,%esp

	int key_shift = 0,keycmd_wait = -1;
  28046c:	c7 85 b4 fb ff ff ff 	movl   $0xffffffff,-0x44c(%ebp)
  280473:	ff ff ff 
  280476:	c7 85 c4 fb ff ff 00 	movl   $0x0,-0x43c(%ebp)
  28047d:	00 00 00 
	sheet_updown(sht_console,1);
	sheet_updown(sht_window,2);
	sheet_updown(sht_mouse,3);

	extern struct TIMERCTL timerctl;
	struct SHEET *key_win,*sht = 0;
  280480:	c7 85 e4 fb ff ff 00 	movl   $0x0,-0x41c(%ebp)
  280487:	00 00 00 
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1;
  28048a:	c7 85 a8 fb ff ff ff 	movl   $0xffffffff,-0x458(%ebp)
  280491:	ff ff ff 
	extern struct TIMERCTL timerctl;
	struct SHEET *key_win,*sht = 0;

	//init window focus
	key_win = sht_window;
	sht_console->task = task_console;
  280494:	89 43 24             	mov    %eax,0x24(%ebx)

	int key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  280497:	8d 85 18 fc ff ff    	lea    -0x3e8(%ebp),%eax
	sheet_setbuf(sht_mouse,buf_mouse,16,16,99);
	init_mouse_cursor8(buf_mouse,99);
	//mouse pos
	int mx = (binfo->scrnx-16)/2;
	int my = (binfo->scrny-28-16)/2;
	int x,y,mmx = -1,mmy = -1;
  28049d:	c7 85 bc fb ff ff ff 	movl   $0xffffffff,-0x444(%ebp)
  2804a4:	ff ff ff 

	int key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  2804a7:	89 85 c0 fb ff ff    	mov    %eax,-0x440(%ebp)
			keycmd_wait = fifo32_get(&keycmd);
			wait_KBC_sendready();
			io_out8(PORT_KEYDAT,keycmd_wait);
		}
		io_cli();
		if(fifo32_status(&fifo) == 0)
  2804ad:	8d 85 fc fb ff ff    	lea    -0x404(%ebp),%eax
	make_window8(buf_window,144,52,"task_a",1);
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
	cursor_x = 8;
	cursor_c = COL8_FFFFFF;
  2804b3:	c7 85 d8 fb ff ff 07 	movl   $0x7,-0x428(%ebp)
  2804ba:	00 00 00 
	sheet_setbuf(sht_window,buf_window,144,52,-1);
	make_window8(buf_window,144,52,"task_a",1);
	//text box in task_a window
	int cursor_x,cursor_c;
	make_textbox8(sht_window,8,28,128,16,COL8_FFFFFF);
	cursor_x = 8;
  2804bd:	c7 85 dc fb ff ff 08 	movl   $0x8,-0x424(%ebp)
  2804c4:	00 00 00 
			keycmd_wait = fifo32_get(&keycmd);
			wait_KBC_sendready();
			io_out8(PORT_KEYDAT,keycmd_wait);
		}
		io_cli();
		if(fifo32_status(&fifo) == 0)
  2804c7:	89 85 a0 fb ff ff    	mov    %eax,-0x460(%ebp)

	int key_shift = 0,keycmd_wait = -1;

	for(;;)
	{
		if(fifo32_status(&keycmd) > 0 && keycmd_wait < 0)
  2804cd:	83 ec 0c             	sub    $0xc,%esp
  2804d0:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2804d6:	e8 3b 19 00 00       	call   281e16 <fifo32_status>
  2804db:	8b 95 b4 fb ff ff    	mov    -0x44c(%ebp),%edx
  2804e1:	83 c4 10             	add    $0x10,%esp
  2804e4:	c1 ea 1f             	shr    $0x1f,%edx
  2804e7:	74 2f                	je     280518 <bootmain+0x518>
  2804e9:	85 c0                	test   %eax,%eax
  2804eb:	7e 2b                	jle    280518 <bootmain+0x518>
		{
			keycmd_wait = fifo32_get(&keycmd);
  2804ed:	83 ec 0c             	sub    $0xc,%esp
  2804f0:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2804f6:	e8 e0 18 00 00       	call   281ddb <fifo32_get>
  2804fb:	89 85 b4 fb ff ff    	mov    %eax,-0x44c(%ebp)
			wait_KBC_sendready();
  280501:	e8 53 1a 00 00       	call   281f59 <wait_KBC_sendready>
			io_out8(PORT_KEYDAT,keycmd_wait);
  280506:	5b                   	pop    %ebx
  280507:	58                   	pop    %eax
  280508:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  28050e:	6a 60                	push   $0x60
  280510:	e8 f1 07 00 00       	call   280d06 <io_out8>
  280515:	83 c4 10             	add    $0x10,%esp
		}
		io_cli();
  280518:	e8 b5 07 00 00       	call   280cd2 <io_cli>
		if(fifo32_status(&fifo) == 0)
  28051d:	83 ec 0c             	sub    $0xc,%esp
  280520:	ff b5 a0 fb ff ff    	pushl  -0x460(%ebp)
  280526:	e8 eb 18 00 00       	call   281e16 <fifo32_status>
  28052b:	83 c4 10             	add    $0x10,%esp
  28052e:	85 c0                	test   %eax,%eax
  280530:	75 18                	jne    28054a <bootmain+0x54a>
		{	
			task_sleep(task_a);
  280532:	83 ec 0c             	sub    $0xc,%esp
  280535:	ff b5 9c fb ff ff    	pushl  -0x464(%ebp)
  28053b:	e8 59 2c 00 00       	call   283199 <task_sleep>
			io_sti();
  280540:	e8 8f 07 00 00       	call   280cd4 <io_sti>
  280545:	e9 16 07 00 00       	jmp    280c60 <bootmain+0xc60>
		}
		else
		{
			int i = fifo32_get(&fifo);
  28054a:	83 ec 0c             	sub    $0xc,%esp
  28054d:	ff b5 a0 fb ff ff    	pushl  -0x460(%ebp)
  280553:	e8 83 18 00 00       	call   281ddb <fifo32_get>
  280558:	89 c3                	mov    %eax,%ebx
			io_sti();
  28055a:	e8 75 07 00 00       	call   280cd4 <io_sti>
			if(key_win->flags == 0) //key_win already closed
  28055f:	83 c4 10             	add    $0x10,%esp
  280562:	83 7e 1c 00          	cmpl   $0x0,0x1c(%esi)
  280566:	75 2a                	jne    280592 <bootmain+0x592>
			{
				key_win = shtctl->sheets[shtctl->top - 1];
  280568:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  28056e:	8b b5 d4 fb ff ff    	mov    -0x42c(%ebp),%esi
  280574:	8b 40 10             	mov    0x10(%eax),%eax
  280577:	8b 74 86 10          	mov    0x10(%esi,%eax,4),%esi
				cursor_c = keywin_on(key_win,sht_window,cursor_c);
  28057b:	51                   	push   %ecx
  28057c:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280582:	57                   	push   %edi
  280583:	56                   	push   %esi
  280584:	e8 7a 41 00 00       	call   284703 <keywin_on>
  280589:	83 c4 10             	add    $0x10,%esp
  28058c:	89 85 d8 fb ff ff    	mov    %eax,-0x428(%ebp)
			}
			if(256<=i && i<=511)
  280592:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
  280598:	3d ff 00 00 00       	cmp    $0xff,%eax
  28059d:	0f 87 93 03 00 00    	ja     280936 <bootmain+0x936>
			{
				xtoa(i-256,s);
  2805a3:	52                   	push   %edx
  2805a4:	52                   	push   %edx
  2805a5:	8d 95 36 fc ff ff    	lea    -0x3ca(%ebp),%edx
  2805ab:	89 85 b8 fb ff ff    	mov    %eax,-0x448(%ebp)
  2805b1:	52                   	push   %edx
  2805b2:	50                   	push   %eax
  2805b3:	89 95 98 fb ff ff    	mov    %edx,-0x468(%ebp)
  2805b9:	e8 28 15 00 00       	call   281ae6 <xtoa>
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);
  2805be:	8b 95 98 fb ff ff    	mov    -0x468(%ebp),%edx
  2805c4:	83 c4 0c             	add    $0xc,%esp
  2805c7:	6a 04                	push   $0x4
  2805c9:	52                   	push   %edx
  2805ca:	6a 00                	push   $0x0
  2805cc:	6a 07                	push   $0x7
  2805ce:	6a 10                	push   $0x10
  2805d0:	6a 00                	push   $0x0
  2805d2:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  2805d8:	e8 d6 0c 00 00       	call   2812b3 <putfonts8_asc_sht>

				s[0] = key_char(i-256,key_shift);
  2805dd:	8b 85 b8 fb ff ff    	mov    -0x448(%ebp),%eax
  2805e3:	83 c4 18             	add    $0x18,%esp
  2805e6:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  2805ec:	50                   	push   %eax
  2805ed:	e8 f2 19 00 00       	call   281fe4 <key_char>
				s[1] = 0;

				if('A' <= s[0] && s[0] <= 'Z')
  2805f2:	8d 50 bf             	lea    -0x41(%eax),%edx
  2805f5:	83 c4 10             	add    $0x10,%esp
			if(256<=i && i<=511)
			{
				xtoa(i-256,s);
				putfonts8_asc_sht(sht_bg,0,16,COL8_FFFFFF,COL8_000000,s,4);

				s[0] = key_char(i-256,key_shift);
  2805f8:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				s[1] = 0;
  2805fe:	c6 85 37 fc ff ff 00 	movb   $0x0,-0x3c9(%ebp)

				if('A' <= s[0] && s[0] <= 'Z')
  280605:	80 fa 19             	cmp    $0x19,%dl
  280608:	77 26                	ja     280630 <bootmain+0x630>
				{
					if((key_leds&4) == 0 && key_shift != 0 ||	//keyboard led off and shift on
  28060a:	f6 85 c8 fb ff ff 04 	testb  $0x4,-0x438(%ebp)
  280611:	75 0b                	jne    28061e <bootmain+0x61e>
  280613:	83 bd c4 fb ff ff 00 	cmpl   $0x0,-0x43c(%ebp)
  28061a:	75 0b                	jne    280627 <bootmain+0x627>
  28061c:	eb 12                	jmp    280630 <bootmain+0x630>
							(key_leds&4) != 0 && key_shift == 0)			//keyboard led on and shift off
  28061e:	83 bd c4 fb ff ff 00 	cmpl   $0x0,-0x43c(%ebp)
  280625:	75 09                	jne    280630 <bootmain+0x630>
						s[0] += 0x20;		//uppercase 2 lowercases					
  280627:	83 c0 20             	add    $0x20,%eax
  28062a:	88 85 36 fc ff ff    	mov    %al,-0x3ca(%ebp)
				}
				if(s[0]!=0)//visible char
  280630:	0f be 85 36 fc ff ff 	movsbl -0x3ca(%ebp),%eax
  280637:	84 c0                	test   %al,%al
  280639:	74 4c                	je     280687 <bootmain+0x687>
				{
					if(key_win == sht_window && cursor_x <128)
  28063b:	39 fe                	cmp    %edi,%esi
  28063d:	75 31                	jne    280670 <bootmain+0x670>
  28063f:	83 bd dc fb ff ff 7f 	cmpl   $0x7f,-0x424(%ebp)
  280646:	7f 28                	jg     280670 <bootmain+0x670>
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF,s,1);
  280648:	50                   	push   %eax
  280649:	8d 85 36 fc ff ff    	lea    -0x3ca(%ebp),%eax
  28064f:	6a 01                	push   $0x1
  280651:	50                   	push   %eax
  280652:	6a 07                	push   $0x7
  280654:	6a 00                	push   $0x0
  280656:	6a 1c                	push   $0x1c
  280658:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  28065e:	57                   	push   %edi
  28065f:	e8 4f 0c 00 00       	call   2812b3 <putfonts8_asc_sht>
						cursor_x += 8;
  280664:	83 85 dc fb ff ff 08 	addl   $0x8,-0x424(%ebp)
  28066b:	83 c4 20             	add    $0x20,%esp
  28066e:	eb 17                	jmp    280687 <bootmain+0x687>
					}
					else
					{
						fifo32_put(&key_win->task->fifo,s[0]+256); //send key to console fifo
  280670:	05 00 01 00 00       	add    $0x100,%eax
  280675:	51                   	push   %ecx
  280676:	51                   	push   %ecx
  280677:	50                   	push   %eax
  280678:	8b 46 24             	mov    0x24(%esi),%eax
  28067b:	83 c0 10             	add    $0x10,%eax
  28067e:	50                   	push   %eax
  28067f:	e8 e5 16 00 00       	call   281d69 <fifo32_put>
  280684:	83 c4 10             	add    $0x10,%esp
					}

				}
				if(i == 256 + 0x0f) //tab key
  280687:	81 fb 0f 01 00 00    	cmp    $0x10f,%ebx
  28068d:	75 4c                	jne    2806db <bootmain+0x6db>
				{
					cursor_c = keywin_off(key_win,sht_window,cursor_c,cursor_x);
  28068f:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280695:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  28069b:	57                   	push   %edi
  28069c:	56                   	push   %esi
  28069d:	e8 fc 3f 00 00       	call   28469e <keywin_off>
					int j=key_win->height - 1;
  2806a2:	8b 56 18             	mov    0x18(%esi),%edx
					if(j==0)
  2806a5:	83 c4 10             	add    $0x10,%esp
  2806a8:	4a                   	dec    %edx
  2806a9:	75 12                	jne    2806bd <bootmain+0x6bd>
					{
						j = shtctl->top-1;
  2806ab:	8b b5 d4 fb ff ff    	mov    -0x42c(%ebp),%esi
  2806b1:	8b 76 10             	mov    0x10(%esi),%esi
  2806b4:	8d 56 ff             	lea    -0x1(%esi),%edx
  2806b7:	89 b5 d8 fb ff ff    	mov    %esi,-0x428(%ebp)
					}
					key_win = shtctl->sheets[j];
  2806bd:	8b b5 d4 fb ff ff    	mov    -0x42c(%ebp),%esi
  2806c3:	8b 74 96 14          	mov    0x14(%esi,%edx,4),%esi
					cursor_c = keywin_on(key_win,sht_window,cursor_c);
  2806c7:	52                   	push   %edx
  2806c8:	50                   	push   %eax
  2806c9:	57                   	push   %edi
  2806ca:	56                   	push   %esi
  2806cb:	e8 33 40 00 00       	call   284703 <keywin_on>
  2806d0:	89 85 d8 fb ff ff    	mov    %eax,-0x428(%ebp)
  2806d6:	e9 bb 01 00 00       	jmp    280896 <bootmain+0x896>
				}
				else if(i == 256 + 0x0e) //back key
  2806db:	81 fb 0e 01 00 00    	cmp    $0x10e,%ebx
  2806e1:	75 3f                	jne    280722 <bootmain+0x722>
				{
					if(key_win == sht_window && cursor_x >8)
  2806e3:	39 fe                	cmp    %edi,%esi
  2806e5:	75 32                	jne    280719 <bootmain+0x719>
  2806e7:	83 bd dc fb ff ff 08 	cmpl   $0x8,-0x424(%ebp)
  2806ee:	7e 29                	jle    280719 <bootmain+0x719>
					{
						putfonts8_asc_sht(sht_window,cursor_x,28,COL8_000000,COL8_FFFFFF," ",1);
  2806f0:	50                   	push   %eax
  2806f1:	6a 01                	push   $0x1
  2806f3:	68 43 4b 28 00       	push   $0x284b43
  2806f8:	6a 07                	push   $0x7
  2806fa:	6a 00                	push   $0x0
  2806fc:	6a 1c                	push   $0x1c
  2806fe:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280704:	57                   	push   %edi
  280705:	e8 a9 0b 00 00       	call   2812b3 <putfonts8_asc_sht>
						cursor_x -= 8;
  28070a:	83 ad dc fb ff ff 08 	subl   $0x8,-0x424(%ebp)
  280711:	83 c4 20             	add    $0x20,%esp
  280714:	e9 8c 01 00 00       	jmp    2808a5 <bootmain+0x8a5>
					}
					else
					{
						fifo32_put(&key_win->task->fifo,8+256);
  280719:	53                   	push   %ebx
  28071a:	53                   	push   %ebx
  28071b:	68 08 01 00 00       	push   $0x108
  280720:	eb 17                	jmp    280739 <bootmain+0x739>
					}
				}
				else if(i == 256 + 0x1c)  //return key
  280722:	81 fb 1c 01 00 00    	cmp    $0x11c,%ebx
  280728:	75 20                	jne    28074a <bootmain+0x74a>
				{
					if(key_win != sht_window) //forcus on task_console window
  28072a:	39 fe                	cmp    %edi,%esi
  28072c:	0f 84 73 01 00 00    	je     2808a5 <bootmain+0x8a5>
					{
						fifo32_put(&key_win->task->fifo,10+256);
  280732:	51                   	push   %ecx
  280733:	51                   	push   %ecx
  280734:	68 0a 01 00 00       	push   $0x10a
  280739:	8b 46 24             	mov    0x24(%esi),%eax
  28073c:	83 c0 10             	add    $0x10,%eax
  28073f:	50                   	push   %eax
  280740:	e8 24 16 00 00       	call   281d69 <fifo32_put>
  280745:	e9 4c 01 00 00       	jmp    280896 <bootmain+0x896>
					}
				}
				else if(i == 256 + 0x2a)  //left shift on
  28074a:	81 fb 2a 01 00 00    	cmp    $0x12a,%ebx
  280750:	75 0c                	jne    28075e <bootmain+0x75e>
				{
					key_shift |= 1;
  280752:	83 8d c4 fb ff ff 01 	orl    $0x1,-0x43c(%ebp)
  280759:	e9 47 01 00 00       	jmp    2808a5 <bootmain+0x8a5>
				} 
				else if(i == 256 + 0x36) //right shift on
  28075e:	81 fb 36 01 00 00    	cmp    $0x136,%ebx
  280764:	75 0c                	jne    280772 <bootmain+0x772>
				{
					key_shift |= 2;
  280766:	83 8d c4 fb ff ff 02 	orl    $0x2,-0x43c(%ebp)
  28076d:	e9 33 01 00 00       	jmp    2808a5 <bootmain+0x8a5>
				}
				else if(i == 256 + 0xaa)  //left shift off
  280772:	81 fb aa 01 00 00    	cmp    $0x1aa,%ebx
  280778:	75 0c                	jne    280786 <bootmain+0x786>
				{
					key_shift &= ~1;
  28077a:	83 a5 c4 fb ff ff fe 	andl   $0xfffffffe,-0x43c(%ebp)
  280781:	e9 1f 01 00 00       	jmp    2808a5 <bootmain+0x8a5>
				} 
				else if(i == 256 + 0xb6) //right shift off
  280786:	81 fb b6 01 00 00    	cmp    $0x1b6,%ebx
  28078c:	75 0c                	jne    28079a <bootmain+0x79a>
				{
					key_shift &= ~2;
  28078e:	83 a5 c4 fb ff ff fd 	andl   $0xfffffffd,-0x43c(%ebp)
  280795:	e9 0b 01 00 00       	jmp    2808a5 <bootmain+0x8a5>
				}
				else if(i == 256 + 0x3a) //CapsLock
  28079a:	81 fb 3a 01 00 00    	cmp    $0x13a,%ebx
  2807a0:	75 09                	jne    2807ab <bootmain+0x7ab>
				{
					key_leds ^= 4;
  2807a2:	83 b5 c8 fb ff ff 04 	xorl   $0x4,-0x438(%ebp)
  2807a9:	eb 20                	jmp    2807cb <bootmain+0x7cb>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x45) //NumLock
  2807ab:	81 fb 45 01 00 00    	cmp    $0x145,%ebx
  2807b1:	75 09                	jne    2807bc <bootmain+0x7bc>
				{
					key_leds ^= 2;
  2807b3:	83 b5 c8 fb ff ff 02 	xorl   $0x2,-0x438(%ebp)
  2807ba:	eb 0f                	jmp    2807cb <bootmain+0x7cb>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0x46) //ScrollLock
  2807bc:	81 fb 46 01 00 00    	cmp    $0x146,%ebx
  2807c2:	75 2c                	jne    2807f0 <bootmain+0x7f0>
				{
					key_leds ^= 1;
  2807c4:	83 b5 c8 fb ff ff 01 	xorl   $0x1,-0x438(%ebp)
					fifo32_put(&keycmd,KEYCMD_LED);
  2807cb:	50                   	push   %eax
  2807cc:	50                   	push   %eax
  2807cd:	68 ed 00 00 00       	push   $0xed
  2807d2:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2807d8:	e8 8c 15 00 00       	call   281d69 <fifo32_put>
					fifo32_put(&keycmd,key_leds);
  2807dd:	58                   	pop    %eax
  2807de:	5a                   	pop    %edx
  2807df:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  2807e5:	ff b5 c0 fb ff ff    	pushl  -0x440(%ebp)
  2807eb:	e9 50 ff ff ff       	jmp    280740 <bootmain+0x740>
				}
				else if(i == 256 + 0xfa)
  2807f0:	81 fb fa 01 00 00    	cmp    $0x1fa,%ebx
  2807f6:	0f 84 9f 00 00 00    	je     28089b <bootmain+0x89b>
				{
					keycmd_wait = -1;
				}
				else if(i == 256 + 0xfe)
  2807fc:	81 fb fe 01 00 00    	cmp    $0x1fe,%ebx
  280802:	75 16                	jne    28081a <bootmain+0x81a>
				{
					wait_KBC_sendready();
  280804:	e8 50 17 00 00       	call   281f59 <wait_KBC_sendready>
					io_out8(PORT_KEYDAT,keycmd_wait);
  280809:	53                   	push   %ebx
  28080a:	53                   	push   %ebx
  28080b:	ff b5 b4 fb ff ff    	pushl  -0x44c(%ebp)
  280811:	6a 60                	push   $0x60
  280813:	e8 ee 04 00 00       	call   280d06 <io_out8>
  280818:	eb 7c                	jmp    280896 <bootmain+0x896>
				}
				else if(i == 256 + 0x3b && key_shift != 0 && task_console->tss.esp0 != 0)	//shift + F1
  28081a:	81 fb 3b 01 00 00    	cmp    $0x13b,%ebx
  280820:	75 4c                	jne    28086e <bootmain+0x86e>
  280822:	83 bd c4 fb ff ff 00 	cmpl   $0x0,-0x43c(%ebp)
  280829:	74 43                	je     28086e <bootmain+0x86e>
  28082b:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
  280831:	83 78 30 00          	cmpl   $0x0,0x30(%eax)
  280835:	74 6e                	je     2808a5 <bootmain+0x8a5>
				{
					struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
					extern void asm_end_app();
					cons_putstr0(cons,"\nBreak(key):\n");
  280837:	51                   	push   %ecx
  280838:	51                   	push   %ecx
  280839:	68 6f 47 28 00       	push   $0x28476f
  28083e:	ff 35 ec 0f 00 00    	pushl  0xfec
  280844:	e8 11 33 00 00       	call   283b5a <cons_putstr0>
					io_cli();
  280849:	e8 84 04 00 00       	call   280cd2 <io_cli>
					task_console->tss.eax = (int)&(task_console->tss.esp0);
  28084e:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
  280854:	8b 8d e0 fb ff ff    	mov    -0x420(%ebp),%ecx
  28085a:	83 c0 30             	add    $0x30,%eax
					task_console->tss.eip = (int)asm_end_app - 0x280000;
  28085d:	c7 41 4c 20 2d 00 00 	movl   $0x2d20,0x4c(%ecx)
				{
					struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
					extern void asm_end_app();
					cons_putstr0(cons,"\nBreak(key):\n");
					io_cli();
					task_console->tss.eax = (int)&(task_console->tss.esp0);
  280864:	89 41 54             	mov    %eax,0x54(%ecx)
					task_console->tss.eip = (int)asm_end_app - 0x280000;
					io_sti();
  280867:	e8 68 04 00 00       	call   280cd4 <io_sti>
  28086c:	eb 28                	jmp    280896 <bootmain+0x896>
				}
				else if(i == 256 + 0x57 && shtctl->top > 2)
  28086e:	81 fb 57 01 00 00    	cmp    $0x157,%ebx
  280874:	75 2f                	jne    2808a5 <bootmain+0x8a5>
  280876:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  28087c:	8b 40 10             	mov    0x10(%eax),%eax
  28087f:	83 f8 02             	cmp    $0x2,%eax
  280882:	7e 21                	jle    2808a5 <bootmain+0x8a5>
				{
					//F11 to pop the bottom window
					sheet_updown(shtctl->sheets[1],shtctl->top - 1);
  280884:	48                   	dec    %eax
  280885:	52                   	push   %edx
  280886:	52                   	push   %edx
  280887:	50                   	push   %eax
  280888:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  28088e:	ff 70 18             	pushl  0x18(%eax)
  280891:	e8 ec 20 00 00       	call   282982 <sheet_updown>
  280896:	83 c4 10             	add    $0x10,%esp
  280899:	eb 0a                	jmp    2808a5 <bootmain+0x8a5>
					fifo32_put(&keycmd,KEYCMD_LED);
					fifo32_put(&keycmd,key_leds);
				}
				else if(i == 256 + 0xfa)
				{
					keycmd_wait = -1;
  28089b:	c7 85 b4 fb ff ff ff 	movl   $0xffffffff,-0x44c(%ebp)
  2808a2:	ff ff ff 
				else if(i == 256 + 0x57 && shtctl->top > 2)
				{
					//F11 to pop the bottom window
					sheet_updown(shtctl->sheets[1],shtctl->top - 1);
				}
				if(cursor_c >= 0)
  2808a5:	83 bd d8 fb ff ff 00 	cmpl   $0x0,-0x428(%ebp)
  2808ac:	78 2a                	js     2808d8 <bootmain+0x8d8>
				{
					//show cursor after show character
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
  2808ae:	50                   	push   %eax
  2808af:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  2808b5:	6a 2b                	push   $0x2b
  2808b7:	83 c0 07             	add    $0x7,%eax
  2808ba:	50                   	push   %eax
  2808bb:	0f b6 85 d8 fb ff ff 	movzbl -0x428(%ebp),%eax
  2808c2:	6a 1c                	push   $0x1c
  2808c4:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  2808ca:	50                   	push   %eax
  2808cb:	ff 77 04             	pushl  0x4(%edi)
  2808ce:	ff 37                	pushl  (%edi)
  2808d0:	e8 7f 05 00 00       	call   280e54 <boxfill8>
  2808d5:	83 c4 20             	add    $0x20,%esp
				}
				sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
  2808d8:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  2808de:	83 ec 0c             	sub    $0xc,%esp
				sprintf(s,"%d,%d",key_leds,key_shift);
  2808e1:	8d 9d 36 fc ff ff    	lea    -0x3ca(%ebp),%ebx
				if(cursor_c >= 0)
				{
					//show cursor after show character
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
				}
				sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
  2808e7:	6a 2c                	push   $0x2c
  2808e9:	83 c0 08             	add    $0x8,%eax
  2808ec:	50                   	push   %eax
  2808ed:	6a 1c                	push   $0x1c
  2808ef:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  2808f5:	57                   	push   %edi
  2808f6:	e8 53 20 00 00       	call   28294e <sheet_refresh>
				sprintf(s,"%d,%d",key_leds,key_shift);
  2808fb:	83 c4 20             	add    $0x20,%esp
  2808fe:	ff b5 c4 fb ff ff    	pushl  -0x43c(%ebp)
  280904:	ff b5 c8 fb ff ff    	pushl  -0x438(%ebp)
  28090a:	68 7d 47 28 00       	push   $0x28477d
  28090f:	53                   	push   %ebx
  280910:	e8 68 12 00 00       	call   281b7d <sprintf>
				putfonts8_asc_sht(sht_bg,0,32,COL8_FFFFFF,COL8_000000,s,4);
  280915:	83 c4 0c             	add    $0xc,%esp
  280918:	6a 04                	push   $0x4
  28091a:	53                   	push   %ebx
  28091b:	6a 00                	push   $0x0
  28091d:	6a 07                	push   $0x7
  28091f:	6a 20                	push   $0x20
  280921:	6a 00                	push   $0x0
  280923:	ff b5 b0 fb ff ff    	pushl  -0x450(%ebp)
  280929:	e8 85 09 00 00       	call   2812b3 <putfonts8_asc_sht>
  28092e:	83 c4 20             	add    $0x20,%esp
  280931:	e9 97 fb ff ff       	jmp    2804cd <bootmain+0x4cd>

			}
			else if(512<=i && i<=767)
  280936:	8d 83 00 fe ff ff    	lea    -0x200(%ebx),%eax
  28093c:	3d ff 00 00 00       	cmp    $0xff,%eax
  280941:	0f 87 bb 02 00 00    	ja     280c02 <bootmain+0xc02>
			{
				if(mouse_decode(&mdec,i-512)!=0)
  280947:	50                   	push   %eax
  280948:	50                   	push   %eax
  280949:	8d 85 ec fb ff ff    	lea    -0x414(%ebp),%eax
  28094f:	0f b6 db             	movzbl %bl,%ebx
  280952:	53                   	push   %ebx
  280953:	50                   	push   %eax
  280954:	e8 15 15 00 00       	call   281e6e <mouse_decode>
  280959:	83 c4 10             	add    $0x10,%esp
  28095c:	85 c0                	test   %eax,%eax
  28095e:	0f 84 69 fb ff ff    	je     2804cd <bootmain+0x4cd>
  280964:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  28096a:	31 c9                	xor    %ecx,%ecx
  28096c:	03 85 f0 fb ff ff    	add    -0x410(%ebp),%eax
  280972:	0f 48 c1             	cmovs  %ecx,%eax
  280975:	89 85 d0 fb ff ff    	mov    %eax,-0x430(%ebp)
  28097b:	8b 85 cc fb ff ff    	mov    -0x434(%ebp),%eax
  280981:	03 85 f4 fb ff ff    	add    -0x40c(%ebp),%eax
  280987:	0f 49 c8             	cmovns %eax,%ecx
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  28098a:	0f bf 05 f4 0f 00 00 	movswl 0xff4,%eax
  280991:	3b 85 d0 fb ff ff    	cmp    -0x430(%ebp),%eax
  280997:	8d 50 ff             	lea    -0x1(%eax),%edx
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  28099a:	0f bf 05 f6 0f 00 00 	movswl 0xff6,%eax
				{
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
  2809a1:	0f 4f 95 d0 fb ff ff 	cmovg  -0x430(%ebp),%edx
  2809a8:	89 95 d0 fb ff ff    	mov    %edx,-0x430(%ebp)
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2809ae:	8d 50 ff             	lea    -0x1(%eax),%edx
  2809b1:	39 c1                	cmp    %eax,%ecx
					sheet_slide(sht_mouse,mx,my);
  2809b3:	50                   	push   %eax
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2809b4:	0f 4c d1             	cmovl  %ecx,%edx
					sheet_slide(sht_mouse,mx,my);
  2809b7:	52                   	push   %edx
  2809b8:	ff b5 d0 fb ff ff    	pushl  -0x430(%ebp)
  2809be:	ff b5 a4 fb ff ff    	pushl  -0x45c(%ebp)
					mx += mdec.x;
					my += mdec.y;
					if(mx<0) mx=0;
					if(my<0) my=0;
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
  2809c4:	89 95 cc fb ff ff    	mov    %edx,-0x434(%ebp)
					sheet_slide(sht_mouse,mx,my);
  2809ca:	e8 9c 20 00 00       	call   282a6b <sheet_slide>
					if(mdec.btn & 0x01)
  2809cf:	83 c4 10             	add    $0x10,%esp
  2809d2:	f6 85 f8 fb ff ff 01 	testb  $0x1,-0x408(%ebp)
  2809d9:	75 0f                	jne    2809ea <bootmain+0x9ea>
							mmy = my;
						}
					}
					else
					{
						mmx = -1;
  2809db:	c7 85 bc fb ff ff ff 	movl   $0xffffffff,-0x444(%ebp)
  2809e2:	ff ff ff 
  2809e5:	e9 e3 fa ff ff       	jmp    2804cd <bootmain+0x4cd>
					if(mx>binfo->scrnx - 1) mx=binfo->scrnx-1;
					if(my>binfo->scrny - 1) my=binfo->scrny-1;
					sheet_slide(sht_mouse,mx,my);
					if(mdec.btn & 0x01)
					{
						if(mmx < 0) 
  2809ea:	83 bd bc fb ff ff 00 	cmpl   $0x0,-0x444(%ebp)
  2809f1:	0f 89 be 01 00 00    	jns    280bb5 <bootmain+0xbb5>
						{
							for(int j=shtctl->top-1;j>0;j--)
  2809f7:	8b 85 d4 fb ff ff    	mov    -0x42c(%ebp),%eax
  2809fd:	8b 40 10             	mov    0x10(%eax),%eax
  280a00:	89 85 b8 fb ff ff    	mov    %eax,-0x448(%ebp)
  280a06:	48                   	dec    %eax
  280a07:	89 85 98 fb ff ff    	mov    %eax,-0x468(%ebp)
  280a0d:	85 c0                	test   %eax,%eax
  280a0f:	0f 8e b8 fa ff ff    	jle    2804cd <bootmain+0x4cd>
							{
								sht = shtctl->sheets[j];
  280a15:	8b 95 d4 fb ff ff    	mov    -0x42c(%ebp),%edx
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280a1b:	8b 8d d0 fb ff ff    	mov    -0x430(%ebp),%ecx
					{
						if(mmx < 0) 
						{
							for(int j=shtctl->top-1;j>0;j--)
							{
								sht = shtctl->sheets[j];
  280a21:	8b 54 82 14          	mov    0x14(%edx,%eax,4),%edx
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280a25:	2b 4a 0c             	sub    0xc(%edx),%ecx
					{
						if(mmx < 0) 
						{
							for(int j=shtctl->top-1;j>0;j--)
							{
								sht = shtctl->sheets[j];
  280a28:	89 95 e4 fb ff ff    	mov    %edx,-0x41c(%ebp)
								x = mx - sht->vx0;
								y = my - sht->vy0;
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280a2e:	89 8d b8 fb ff ff    	mov    %ecx,-0x448(%ebp)
  280a34:	0f 88 75 01 00 00    	js     280baf <bootmain+0xbaf>
						{
							for(int j=shtctl->top-1;j>0;j--)
							{
								sht = shtctl->sheets[j];
								x = mx - sht->vx0;
								y = my - sht->vy0;
  280a3a:	8b 9d cc fb ff ff    	mov    -0x434(%ebp),%ebx
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280a40:	8b 4a 04             	mov    0x4(%edx),%ecx
						{
							for(int j=shtctl->top-1;j>0;j--)
							{
								sht = shtctl->sheets[j];
								x = mx - sht->vx0;
								y = my - sht->vy0;
  280a43:	2b 5a 10             	sub    0x10(%edx),%ebx
								if(x>=0 && x<sht->bxsize && y>=0 && y<sht->bysize)
  280a46:	39 8d b8 fb ff ff    	cmp    %ecx,-0x448(%ebp)
  280a4c:	0f 8d 5d 01 00 00    	jge    280baf <bootmain+0xbaf>
  280a52:	89 da                	mov    %ebx,%edx
  280a54:	83 ea 00             	sub    $0x0,%edx
  280a57:	0f 88 52 01 00 00    	js     280baf <bootmain+0xbaf>
  280a5d:	8b 95 e4 fb ff ff    	mov    -0x41c(%ebp),%edx
  280a63:	3b 5a 08             	cmp    0x8(%edx),%ebx
  280a66:	0f 8d 43 01 00 00    	jge    280baf <bootmain+0xbaf>
								{
									if(sht->buf[y*sht->bxsize+x] != sht->col_inv )
  280a6c:	0f af cb             	imul   %ebx,%ecx
  280a6f:	89 8d 94 fb ff ff    	mov    %ecx,-0x46c(%ebp)
  280a75:	89 d1                	mov    %edx,%ecx
  280a77:	8b 95 b8 fb ff ff    	mov    -0x448(%ebp),%edx
  280a7d:	03 11                	add    (%ecx),%edx
  280a7f:	89 d1                	mov    %edx,%ecx
  280a81:	8b 95 94 fb ff ff    	mov    -0x46c(%ebp),%edx
  280a87:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  280a8b:	8b 95 e4 fb ff ff    	mov    -0x41c(%ebp),%edx
  280a91:	3b 4a 14             	cmp    0x14(%edx),%ecx
  280a94:	0f 84 15 01 00 00    	je     280baf <bootmain+0xbaf>
									{
										sheet_updown(sht,shtctl->top-1);
  280a9a:	50                   	push   %eax
  280a9b:	50                   	push   %eax
  280a9c:	ff b5 98 fb ff ff    	pushl  -0x468(%ebp)
  280aa2:	52                   	push   %edx
  280aa3:	e8 da 1e 00 00       	call   282982 <sheet_updown>
										if(sht!=key_win)
  280aa8:	83 c4 10             	add    $0x10,%esp
  280aab:	3b b5 e4 fb ff ff    	cmp    -0x41c(%ebp),%esi
  280ab1:	74 2c                	je     280adf <bootmain+0xadf>
										{
											cursor_c = keywin_off(key_win,sht_window,cursor_c,cursor_x);
  280ab3:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280ab9:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280abf:	57                   	push   %edi
  280ac0:	56                   	push   %esi
  280ac1:	e8 d8 3b 00 00       	call   28469e <keywin_off>
											key_win = sht;
											cursor_c = keywin_on(key_win,sht_window,cursor_c);
  280ac6:	83 c4 0c             	add    $0xc,%esp
  280ac9:	50                   	push   %eax
  280aca:	57                   	push   %edi
  280acb:	ff b5 e4 fb ff ff    	pushl  -0x41c(%ebp)
  280ad1:	e8 2d 3c 00 00       	call   284703 <keywin_on>
  280ad6:	83 c4 10             	add    $0x10,%esp
  280ad9:	89 85 d8 fb ff ff    	mov    %eax,-0x428(%ebp)
										}
										if(x>=3 && x<sht->bxsize-3 && y>=3 && y<21)
  280adf:	83 bd b8 fb ff ff 02 	cmpl   $0x2,-0x448(%ebp)
  280ae6:	8b 85 e4 fb ff ff    	mov    -0x41c(%ebp),%eax
  280aec:	8b 40 04             	mov    0x4(%eax),%eax
  280aef:	7e 37                	jle    280b28 <bootmain+0xb28>
  280af1:	8d 50 fd             	lea    -0x3(%eax),%edx
  280af4:	39 95 b8 fb ff ff    	cmp    %edx,-0x448(%ebp)
  280afa:	7d 2c                	jge    280b28 <bootmain+0xb28>
  280afc:	8d 53 fd             	lea    -0x3(%ebx),%edx
										{
											mmx = mx;
											mmy = my;
  280aff:	8b 8d a8 fb ff ff    	mov    -0x458(%ebp),%ecx
  280b05:	83 fa 11             	cmp    $0x11,%edx
  280b08:	0f 46 8d cc fb ff ff 	cmovbe -0x434(%ebp),%ecx
  280b0f:	89 8d a8 fb ff ff    	mov    %ecx,-0x458(%ebp)
  280b15:	8b 8d bc fb ff ff    	mov    -0x444(%ebp),%ecx
  280b1b:	0f 46 8d d0 fb ff ff 	cmovbe -0x430(%ebp),%ecx
  280b22:	89 8d bc fb ff ff    	mov    %ecx,-0x444(%ebp)
										}
										if(sht->bxsize - 21 <= x && x<sht->bxsize - 5 && y>=5 && y<19)
  280b28:	8d 50 eb             	lea    -0x15(%eax),%edx
  280b2b:	39 95 b8 fb ff ff    	cmp    %edx,-0x448(%ebp)
  280b31:	8b b5 e4 fb ff ff    	mov    -0x41c(%ebp),%esi
  280b37:	0f 8c 90 f9 ff ff    	jl     2804cd <bootmain+0x4cd>
  280b3d:	83 e8 05             	sub    $0x5,%eax
  280b40:	39 85 b8 fb ff ff    	cmp    %eax,-0x448(%ebp)
  280b46:	0f 8d 81 f9 ff ff    	jge    2804cd <bootmain+0x4cd>
  280b4c:	83 eb 05             	sub    $0x5,%ebx
  280b4f:	83 fb 0d             	cmp    $0xd,%ebx
  280b52:	0f 87 75 f9 ff ff    	ja     2804cd <bootmain+0x4cd>
										{
											if(sht->flags & 0x10)
  280b58:	f6 46 1c 10          	testb  $0x10,0x1c(%esi)
  280b5c:	0f 84 6b f9 ff ff    	je     2804cd <bootmain+0x4cd>
											{
												if(sht->task != 0)
  280b62:	83 7e 24 00          	cmpl   $0x0,0x24(%esi)
  280b66:	0f 84 61 f9 ff ff    	je     2804cd <bootmain+0x4cd>
												{
													struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
													cons_putstr0(cons,"\nBreak(mouse) :\n");
  280b6c:	50                   	push   %eax
  280b6d:	50                   	push   %eax
  280b6e:	68 83 47 28 00       	push   $0x284783
  280b73:	ff 35 ec 0f 00 00    	pushl  0xfec
  280b79:	e8 dc 2f 00 00       	call   283b5a <cons_putstr0>
													io_cli();
  280b7e:	e8 4f 01 00 00       	call   280cd2 <io_cli>
													task_console->tss.eax = (int)&(task_console->tss.esp0);
  280b83:	8b 85 e0 fb ff ff    	mov    -0x420(%ebp),%eax
  280b89:	8b b5 e0 fb ff ff    	mov    -0x420(%ebp),%esi
  280b8f:	83 c0 30             	add    $0x30,%eax
													extern void asm_end_app();
													task_console->tss.eip = (int)&asm_end_app - 0x280000;
  280b92:	c7 46 4c 20 2d 00 00 	movl   $0x2d20,0x4c(%esi)
												if(sht->task != 0)
												{
													struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
													cons_putstr0(cons,"\nBreak(mouse) :\n");
													io_cli();
													task_console->tss.eax = (int)&(task_console->tss.esp0);
  280b99:	89 46 54             	mov    %eax,0x54(%esi)
													extern void asm_end_app();
													task_console->tss.eip = (int)&asm_end_app - 0x280000;
													io_sti();
  280b9c:	e8 33 01 00 00       	call   280cd4 <io_sti>
  280ba1:	83 c4 10             	add    $0x10,%esp
  280ba4:	8b b5 e4 fb ff ff    	mov    -0x41c(%ebp),%esi
  280baa:	e9 1e f9 ff ff       	jmp    2804cd <bootmain+0x4cd>
					sheet_slide(sht_mouse,mx,my);
					if(mdec.btn & 0x01)
					{
						if(mmx < 0) 
						{
							for(int j=shtctl->top-1;j>0;j--)
  280baf:	48                   	dec    %eax
  280bb0:	e9 58 fe ff ff       	jmp    280a0d <bootmain+0xa0d>
						}
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							sheet_slide(sht,sht->vx0+x,sht->vy0+y);
  280bb5:	8b 9d e4 fb ff ff    	mov    -0x41c(%ebp),%ebx
  280bbb:	50                   	push   %eax
  280bbc:	8b 85 cc fb ff ff    	mov    -0x434(%ebp),%eax
  280bc2:	2b 85 a8 fb ff ff    	sub    -0x458(%ebp),%eax
  280bc8:	03 43 10             	add    0x10(%ebx),%eax
  280bcb:	50                   	push   %eax
  280bcc:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  280bd2:	2b 85 bc fb ff ff    	sub    -0x444(%ebp),%eax
  280bd8:	03 43 0c             	add    0xc(%ebx),%eax
  280bdb:	50                   	push   %eax
  280bdc:	53                   	push   %ebx
  280bdd:	e8 89 1e 00 00       	call   282a6b <sheet_slide>
							mmx = mx;
							mmy = my;
  280be2:	8b 85 cc fb ff ff    	mov    -0x434(%ebp),%eax
						}
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							sheet_slide(sht,sht->vx0+x,sht->vy0+y);
  280be8:	83 c4 10             	add    $0x10,%esp
							mmx = mx;
							mmy = my;
  280beb:	89 85 a8 fb ff ff    	mov    %eax,-0x458(%ebp)
						else 
						{
							x = mx - mmx;
							y = my - mmy;
							sheet_slide(sht,sht->vx0+x,sht->vy0+y);
							mmx = mx;
  280bf1:	8b 85 d0 fb ff ff    	mov    -0x430(%ebp),%eax
  280bf7:	89 85 bc fb ff ff    	mov    %eax,-0x444(%ebp)
  280bfd:	e9 cb f8 ff ff       	jmp    2804cd <bootmain+0x4cd>
					{
						mmx = -1;
					}
				}
			}
			else if(i<=1)
  280c02:	83 fb 01             	cmp    $0x1,%ebx
  280c05:	0f 8f c2 f8 ff ff    	jg     2804cd <bootmain+0x4cd>
			{
				if(i != 0)
  280c0b:	85 db                	test   %ebx,%ebx
  280c0d:	74 22                	je     280c31 <bootmain+0xc31>
				{
					timer_init(timer,&fifo,0);
  280c0f:	53                   	push   %ebx
  280c10:	6a 00                	push   $0x0
  280c12:	ff b5 a0 fb ff ff    	pushl  -0x460(%ebp)
  280c18:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280c1e:	e8 9c 1f 00 00       	call   282bbf <timer_init>
					if(cursor_c>=0) cursor_c = COL8_000000;
  280c23:	83 c4 10             	add    $0x10,%esp
  280c26:	83 bd d8 fb ff ff 00 	cmpl   $0x0,-0x428(%ebp)
  280c2d:	79 39                	jns    280c68 <bootmain+0xc68>
  280c2f:	eb 20                	jmp    280c51 <bootmain+0xc51>
				}
				else
				{
					timer_init(timer,&fifo,1);
  280c31:	51                   	push   %ecx
  280c32:	6a 01                	push   $0x1
  280c34:	ff b5 a0 fb ff ff    	pushl  -0x460(%ebp)
  280c3a:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280c40:	e8 7a 1f 00 00       	call   282bbf <timer_init>
					if(cursor_c>=0) cursor_c = COL8_FFFFFF;
  280c45:	83 c4 10             	add    $0x10,%esp
  280c48:	83 bd d8 fb ff ff 00 	cmpl   $0x0,-0x428(%ebp)
  280c4f:	79 23                	jns    280c74 <bootmain+0xc74>
				if(cursor_c >= 0) // check if the color invalid
				{
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
					sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
				}
				timer_settime(timer,50);
  280c51:	52                   	push   %edx
  280c52:	52                   	push   %edx
  280c53:	6a 32                	push   $0x32
  280c55:	ff b5 ac fb ff ff    	pushl  -0x454(%ebp)
  280c5b:	e8 73 1f 00 00       	call   282bd3 <timer_settime>
  280c60:	83 c4 10             	add    $0x10,%esp
  280c63:	e9 65 f8 ff ff       	jmp    2804cd <bootmain+0x4cd>
			else if(i<=1)
			{
				if(i != 0)
				{
					timer_init(timer,&fifo,0);
					if(cursor_c>=0) cursor_c = COL8_000000;
  280c68:	c7 85 d8 fb ff ff 00 	movl   $0x0,-0x428(%ebp)
  280c6f:	00 00 00 
  280c72:	eb 0a                	jmp    280c7e <bootmain+0xc7e>
				}
				else
				{
					timer_init(timer,&fifo,1);
					if(cursor_c>=0) cursor_c = COL8_FFFFFF;
  280c74:	c7 85 d8 fb ff ff 07 	movl   $0x7,-0x428(%ebp)
  280c7b:	00 00 00 
				}
				if(cursor_c >= 0) // check if the color invalid
				{
					boxfill8(sht_window->buf,sht_window->bxsize,cursor_c,cursor_x,28,cursor_x+7,43);
  280c7e:	50                   	push   %eax
  280c7f:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  280c85:	6a 2b                	push   $0x2b
  280c87:	83 c0 07             	add    $0x7,%eax
  280c8a:	50                   	push   %eax
  280c8b:	6a 1c                	push   $0x1c
  280c8d:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280c93:	ff b5 d8 fb ff ff    	pushl  -0x428(%ebp)
  280c99:	ff 77 04             	pushl  0x4(%edi)
  280c9c:	ff 37                	pushl  (%edi)
  280c9e:	e8 b1 01 00 00       	call   280e54 <boxfill8>
					sheet_refresh(sht_window,cursor_x,28,cursor_x+8,44);
  280ca3:	8b 85 dc fb ff ff    	mov    -0x424(%ebp),%eax
  280ca9:	83 c4 14             	add    $0x14,%esp
  280cac:	6a 2c                	push   $0x2c
  280cae:	83 c0 08             	add    $0x8,%eax
  280cb1:	50                   	push   %eax
  280cb2:	6a 1c                	push   $0x1c
  280cb4:	ff b5 dc fb ff ff    	pushl  -0x424(%ebp)
  280cba:	57                   	push   %edi
  280cbb:	e8 8e 1c 00 00       	call   28294e <sheet_refresh>
  280cc0:	83 c4 20             	add    $0x20,%esp
  280cc3:	eb 8c                	jmp    280c51 <bootmain+0xc51>
  280cc5:	66 90                	xchg   %ax,%ax
  280cc7:	66 90                	xchg   %ax,%ax
  280cc9:	66 90                	xchg   %ax,%ax
  280ccb:	66 90                	xchg   %ax,%ax
  280ccd:	66 90                	xchg   %ax,%ax
  280ccf:	90                   	nop

00280cd0 <io_hlt>:
  280cd0:	f4                   	hlt    
  280cd1:	c3                   	ret    

00280cd2 <io_cli>:
  280cd2:	fa                   	cli    
  280cd3:	c3                   	ret    

00280cd4 <io_sti>:
  280cd4:	fb                   	sti    
  280cd5:	c3                   	ret    

00280cd6 <io_stihlt>:
  280cd6:	fb                   	sti    
  280cd7:	f4                   	hlt    
  280cd8:	c3                   	ret    

00280cd9 <write_mem8>:
  280cd9:	8b 4c 24 04          	mov    0x4(%esp),%ecx
  280cdd:	8a 44 24 08          	mov    0x8(%esp),%al
  280ce1:	88 01                	mov    %al,(%ecx)
  280ce3:	c3                   	ret    

00280ce4 <io_in8>:
  280ce4:	8b 54 24 04          	mov    0x4(%esp),%edx
  280ce8:	b8 00 00 00 00       	mov    $0x0,%eax
  280ced:	ec                   	in     (%dx),%al
  280cee:	c3                   	ret    

00280cef <io_in16>:
  280cef:	8b 54 24 04          	mov    0x4(%esp),%edx
  280cf3:	b8 00 00 00 00       	mov    $0x0,%eax
  280cf8:	66 ed                	in     (%dx),%ax
  280cfa:	c3                   	ret    

00280cfb <io_in32>:
  280cfb:	8b 54 24 04          	mov    0x4(%esp),%edx
  280cff:	b8 00 00 00 00       	mov    $0x0,%eax
  280d04:	ed                   	in     (%dx),%eax
  280d05:	c3                   	ret    

00280d06 <io_out8>:
  280d06:	8b 54 24 04          	mov    0x4(%esp),%edx
  280d0a:	8b 44 24 08          	mov    0x8(%esp),%eax
  280d0e:	ee                   	out    %al,(%dx)
  280d0f:	c3                   	ret    

00280d10 <io_out16>:
  280d10:	8b 54 24 04          	mov    0x4(%esp),%edx
  280d14:	8b 44 24 08          	mov    0x8(%esp),%eax
  280d18:	66 ef                	out    %ax,(%dx)
  280d1a:	c3                   	ret    

00280d1b <io_out32>:
  280d1b:	8b 54 24 04          	mov    0x4(%esp),%edx
  280d1f:	8b 44 24 08          	mov    0x8(%esp),%eax
  280d23:	ef                   	out    %eax,(%dx)
  280d24:	c3                   	ret    

00280d25 <io_load_eflags>:
  280d25:	9c                   	pushf  
  280d26:	58                   	pop    %eax
  280d27:	c3                   	ret    

00280d28 <io_store_eflags>:
  280d28:	8b 44 24 04          	mov    0x4(%esp),%eax
  280d2c:	50                   	push   %eax
  280d2d:	9d                   	popf   
  280d2e:	c3                   	ret    

00280d2f <load_gdtr>:
  280d2f:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280d34:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280d39:	0f 01 54 24 06       	lgdtl  0x6(%esp)
  280d3e:	c3                   	ret    

00280d3f <load_idtr>:
  280d3f:	66 8b 44 24 04       	mov    0x4(%esp),%ax
  280d44:	66 89 44 24 06       	mov    %ax,0x6(%esp)
  280d49:	0f 01 5c 24 06       	lidtl  0x6(%esp)
  280d4e:	c3                   	ret    

00280d4f <load_cr0>:
  280d4f:	0f 20 c0             	mov    %cr0,%eax
  280d52:	c3                   	ret    

00280d53 <store_cr0>:
  280d53:	8b 44 24 04          	mov    0x4(%esp),%eax
  280d57:	0f 22 c0             	mov    %eax,%cr0
  280d5a:	c3                   	ret    

00280d5b <_memtest_sub>:
  280d5b:	57                   	push   %edi
  280d5c:	56                   	push   %esi
  280d5d:	53                   	push   %ebx
  280d5e:	be 55 aa 55 aa       	mov    $0xaa55aa55,%esi
  280d63:	bf aa 55 aa 55       	mov    $0x55aa55aa,%edi
  280d68:	8b 44 24 10          	mov    0x10(%esp),%eax

00280d6c <mts_loop>:
  280d6c:	89 c3                	mov    %eax,%ebx
  280d6e:	81 c3 fc 0f 00 00    	add    $0xffc,%ebx
  280d74:	8b 13                	mov    (%ebx),%edx
  280d76:	89 33                	mov    %esi,(%ebx)
  280d78:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280d7b:	3b 3b                	cmp    (%ebx),%edi
  280d7d:	75 18                	jne    280d97 <mts_qit>
  280d7f:	83 33 ff             	xorl   $0xffffffff,(%ebx)
  280d82:	3b 33                	cmp    (%ebx),%esi
  280d84:	75 11                	jne    280d97 <mts_qit>
  280d86:	89 13                	mov    %edx,(%ebx)
  280d88:	05 00 10 00 00       	add    $0x1000,%eax
  280d8d:	3b 44 24 14          	cmp    0x14(%esp),%eax
  280d91:	76 d9                	jbe    280d6c <mts_loop>

00280d93 <mts_ret>:
  280d93:	5b                   	pop    %ebx
  280d94:	5e                   	pop    %esi
  280d95:	5f                   	pop    %edi
  280d96:	c3                   	ret    

00280d97 <mts_qit>:
  280d97:	89 13                	mov    %edx,(%ebx)
  280d99:	5b                   	pop    %ebx
  280d9a:	5e                   	pop    %esi
  280d9b:	5f                   	pop    %edi
  280d9c:	c3                   	ret    

00280d9d <set_palette>:
	set_palette(0,15,table_rgb);
	return;	
}

void set_palette(int start, int end, unsigned char *rgb)
{
  280d9d:	55                   	push   %ebp
  280d9e:	89 e5                	mov    %esp,%ebp
  280da0:	57                   	push   %edi
  280da1:	56                   	push   %esi
  280da2:	53                   	push   %ebx
  280da3:	83 ec 1c             	sub    $0x1c,%esp
  280da6:	8b 75 08             	mov    0x8(%ebp),%esi
  280da9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  280dac:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int i,eflags;
	eflags = io_load_eflags();
  280daf:	e8 71 ff ff ff       	call   280d25 <io_load_eflags>
  280db4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	io_cli();
  280db7:	e8 16 ff ff ff       	call   280cd2 <io_cli>
	io_out8(0x03c8,start);
  280dbc:	83 ec 08             	sub    $0x8,%esp
  280dbf:	56                   	push   %esi
  280dc0:	68 c8 03 00 00       	push   $0x3c8
  280dc5:	e8 3c ff ff ff       	call   280d06 <io_out8>
	for(i=start;i<=end;i++)
  280dca:	83 c4 10             	add    $0x10,%esp
  280dcd:	39 fe                	cmp    %edi,%esi
  280dcf:	7f 54                	jg     280e25 <set_palette+0x88>
	{
		io_out8(0x03c9,rgb[0]/4);
  280dd1:	83 ec 08             	sub    $0x8,%esp
  280dd4:	0f b6 03             	movzbl (%ebx),%eax
  280dd7:	c0 e8 02             	shr    $0x2,%al
  280dda:	0f b6 c0             	movzbl %al,%eax
  280ddd:	50                   	push   %eax
  280dde:	68 c9 03 00 00       	push   $0x3c9
  280de3:	e8 1e ff ff ff       	call   280d06 <io_out8>
		io_out8(0x03c9,rgb[1]/4);
  280de8:	83 c4 08             	add    $0x8,%esp
  280deb:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  280def:	c0 e8 02             	shr    $0x2,%al
  280df2:	0f b6 c0             	movzbl %al,%eax
  280df5:	50                   	push   %eax
  280df6:	68 c9 03 00 00       	push   $0x3c9
  280dfb:	e8 06 ff ff ff       	call   280d06 <io_out8>
		io_out8(0x03c9,rgb[2]/4);
  280e00:	83 c4 08             	add    $0x8,%esp
  280e03:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
  280e07:	c0 e8 02             	shr    $0x2,%al
  280e0a:	0f b6 c0             	movzbl %al,%eax
  280e0d:	50                   	push   %eax
  280e0e:	68 c9 03 00 00       	push   $0x3c9
  280e13:	e8 ee fe ff ff       	call   280d06 <io_out8>
		rgb+=3;
  280e18:	83 c3 03             	add    $0x3,%ebx
{
	int i,eflags;
	eflags = io_load_eflags();
	io_cli();
	io_out8(0x03c8,start);
	for(i=start;i<=end;i++)
  280e1b:	83 c6 01             	add    $0x1,%esi
  280e1e:	83 c4 10             	add    $0x10,%esp
  280e21:	39 f7                	cmp    %esi,%edi
  280e23:	7d ac                	jge    280dd1 <set_palette+0x34>
		io_out8(0x03c9,rgb[0]/4);
		io_out8(0x03c9,rgb[1]/4);
		io_out8(0x03c9,rgb[2]/4);
		rgb+=3;
	}
	io_store_eflags(eflags);
  280e25:	83 ec 0c             	sub    $0xc,%esp
  280e28:	ff 75 e4             	pushl  -0x1c(%ebp)
  280e2b:	e8 f8 fe ff ff       	call   280d28 <io_store_eflags>
	return;
  280e30:	83 c4 10             	add    $0x10,%esp
}
  280e33:	8d 65 f4             	lea    -0xc(%ebp),%esp
  280e36:	5b                   	pop    %ebx
  280e37:	5e                   	pop    %esi
  280e38:	5f                   	pop    %edi
  280e39:	5d                   	pop    %ebp
  280e3a:	c3                   	ret    

00280e3b <init_palette>:
#include "graphics.h"

void init_palette(void)
{
  280e3b:	55                   	push   %ebp
  280e3c:	89 e5                	mov    %esp,%ebp
  280e3e:	83 ec 0c             	sub    $0xc,%esp
		0x00, 0x00, 0x84,	//dark blue
		0x84, 0x00, 0x84,	//dark purple
		0x00, 0x84, 0x84,	//dark light blue
		0x84, 0x84, 0x84,	//dark gray
	};
	set_palette(0,15,table_rgb);
  280e41:	68 20 59 28 00       	push   $0x285920
  280e46:	6a 0f                	push   $0xf
  280e48:	6a 00                	push   $0x0
  280e4a:	e8 4e ff ff ff       	call   280d9d <set_palette>
	return;	
  280e4f:	83 c4 10             	add    $0x10,%esp
}
  280e52:	c9                   	leave  
  280e53:	c3                   	ret    

00280e54 <boxfill8>:
	io_store_eflags(eflags);
	return;
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
  280e54:	55                   	push   %ebp
  280e55:	89 e5                	mov    %esp,%ebp
  280e57:	57                   	push   %edi
  280e58:	56                   	push   %esi
  280e59:	53                   	push   %ebx
  280e5a:	83 ec 04             	sub    $0x4,%esp
  280e5d:	8b 55 0c             	mov    0xc(%ebp),%edx
  280e60:	8b 7d 14             	mov    0x14(%ebp),%edi
  280e63:	8b 75 18             	mov    0x18(%ebp),%esi
  280e66:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  280e69:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
	int x,y;
	for(y=y0;y<=y1;y++)
  280e6d:	3b 75 20             	cmp    0x20(%ebp),%esi
  280e70:	7f 28                	jg     280e9a <boxfill8+0x46>
  280e72:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280e75:	0f af d6             	imul   %esi,%edx
  280e78:	03 55 08             	add    0x8(%ebp),%edx
  280e7b:	eb 15                	jmp    280e92 <boxfill8+0x3e>
	{
		for(x=x0;x<=x1;x++)
			vram[y*xsize+x]=c;
  280e7d:	88 1c 02             	mov    %bl,(%edx,%eax,1)
void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
	{
		for(x=x0;x<=x1;x++)
  280e80:	83 c0 01             	add    $0x1,%eax
  280e83:	39 c1                	cmp    %eax,%ecx
  280e85:	7d f6                	jge    280e7d <boxfill8+0x29>
}

void  boxfill8(unsigned char *vram,int xsize,unsigned char c,int x0,int y0,int x1,int y1)
{
	int x,y;
	for(y=y0;y<=y1;y++)
  280e87:	83 c6 01             	add    $0x1,%esi
  280e8a:	03 55 f0             	add    -0x10(%ebp),%edx
  280e8d:	39 75 20             	cmp    %esi,0x20(%ebp)
  280e90:	7c 08                	jl     280e9a <boxfill8+0x46>
	{
		for(x=x0;x<=x1;x++)
  280e92:	89 f8                	mov    %edi,%eax
  280e94:	39 cf                	cmp    %ecx,%edi
  280e96:	7e e5                	jle    280e7d <boxfill8+0x29>
  280e98:	eb ed                	jmp    280e87 <boxfill8+0x33>
			vram[y*xsize+x]=c;
	}
		
	return;
}
  280e9a:	83 c4 04             	add    $0x4,%esp
  280e9d:	5b                   	pop    %ebx
  280e9e:	5e                   	pop    %esi
  280e9f:	5f                   	pop    %edi
  280ea0:	5d                   	pop    %ebp
  280ea1:	c3                   	ret    

00280ea2 <boxfill8_test>:

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
  280ea2:	55                   	push   %ebp
  280ea3:	89 e5                	mov    %esp,%ebp
  280ea5:	53                   	push   %ebx
  280ea6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  280ea9:	8b 55 10             	mov    0x10(%ebp),%edx
  280eac:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	int i;
	for(i=0;i<size;i++)
  280eb0:	85 d2                	test   %edx,%edx
  280eb2:	7e 0d                	jle    280ec1 <boxfill8_test+0x1f>
  280eb4:	89 d8                	mov    %ebx,%eax
  280eb6:	01 da                	add    %ebx,%edx
	{
		vram[i] = c;
  280eb8:	88 08                	mov    %cl,(%eax)
  280eba:	83 c0 01             	add    $0x1,%eax
}

void boxfill8_test(unsigned char *vram,unsigned char c,int size)
{
	int i;
	for(i=0;i<size;i++)
  280ebd:	39 d0                	cmp    %edx,%eax
  280ebf:	75 f7                	jne    280eb8 <boxfill8_test+0x16>
	{
		vram[i] = c;
	}
	//vram[TRY_BG_SIZE-1] = c;
}
  280ec1:	5b                   	pop    %ebx
  280ec2:	5d                   	pop    %ebp
  280ec3:	c3                   	ret    

00280ec4 <init_screen8>:

void init_screen8(unsigned char *vram, int xsize, int ysize)
{
  280ec4:	55                   	push   %ebp
  280ec5:	89 e5                	mov    %esp,%ebp
  280ec7:	57                   	push   %edi
  280ec8:	56                   	push   %esi
  280ec9:	53                   	push   %ebx
  280eca:	83 ec 14             	sub    $0x14,%esp
  280ecd:	8b 7d 08             	mov    0x8(%ebp),%edi
  280ed0:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  280ed3:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(vram,310,COL8_008484,0,0,310,190);
  280ed6:	68 be 00 00 00       	push   $0xbe
  280edb:	68 36 01 00 00       	push   $0x136
  280ee0:	6a 00                	push   $0x0
  280ee2:	6a 00                	push   $0x0
  280ee4:	6a 0e                	push   $0xe
  280ee6:	68 36 01 00 00       	push   $0x136
  280eeb:	57                   	push   %edi
  280eec:	e8 63 ff ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_008484,0,      0,          xsize-1,    ysize-29);
  280ef1:	8d 43 ff             	lea    -0x1(%ebx),%eax
  280ef4:	89 c2                	mov    %eax,%edx
  280ef6:	8d 46 e3             	lea    -0x1d(%esi),%eax
  280ef9:	50                   	push   %eax
  280efa:	89 55 f0             	mov    %edx,-0x10(%ebp)
  280efd:	52                   	push   %edx
  280efe:	6a 00                	push   $0x0
  280f00:	6a 00                	push   $0x0
  280f02:	6a 0e                	push   $0xe
  280f04:	53                   	push   %ebx
  280f05:	57                   	push   %edi
  280f06:	e8 49 ff ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-28,   xsize-1,    ysize-28);
  280f0b:	8d 46 e4             	lea    -0x1c(%esi),%eax
  280f0e:	83 c4 38             	add    $0x38,%esp
  280f11:	50                   	push   %eax
  280f12:	ff 75 f0             	pushl  -0x10(%ebp)
  280f15:	50                   	push   %eax
  280f16:	6a 00                	push   $0x0
  280f18:	6a 08                	push   $0x8
  280f1a:	53                   	push   %ebx
  280f1b:	57                   	push   %edi
  280f1c:	e8 33 ff ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,0,      ysize-27,   xsize-1,    ysize-27);
  280f21:	8d 46 e5             	lea    -0x1b(%esi),%eax
  280f24:	50                   	push   %eax
  280f25:	ff 75 f0             	pushl  -0x10(%ebp)
  280f28:	50                   	push   %eax
  280f29:	6a 00                	push   $0x0
  280f2b:	6a 07                	push   $0x7
  280f2d:	53                   	push   %ebx
  280f2e:	57                   	push   %edi
  280f2f:	e8 20 ff ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_C6C6C6,0,      ysize-26,   xsize-1,    ysize- 1);
  280f34:	83 c4 38             	add    $0x38,%esp
  280f37:	8d 46 ff             	lea    -0x1(%esi),%eax
  280f3a:	50                   	push   %eax
  280f3b:	ff 75 f0             	pushl  -0x10(%ebp)
  280f3e:	8d 46 e6             	lea    -0x1a(%esi),%eax
  280f41:	50                   	push   %eax
  280f42:	6a 00                	push   $0x0
  280f44:	6a 08                	push   $0x8
  280f46:	53                   	push   %ebx
  280f47:	57                   	push   %edi
  280f48:	e8 07 ff ff ff       	call   280e54 <boxfill8>
	
	
	boxfill8(vram,xsize,COL8_FFFFFF,3,      ysize-24,   59,         ysize-24);
  280f4d:	8d 46 e8             	lea    -0x18(%esi),%eax
  280f50:	50                   	push   %eax
  280f51:	6a 3b                	push   $0x3b
  280f53:	89 45 f0             	mov    %eax,-0x10(%ebp)
  280f56:	50                   	push   %eax
  280f57:	6a 03                	push   $0x3
  280f59:	6a 07                	push   $0x7
  280f5b:	53                   	push   %ebx
  280f5c:	57                   	push   %edi
  280f5d:	e8 f2 fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,2,      ysize-24,    2,         ysize- 4);
  280f62:	8d 4e fc             	lea    -0x4(%esi),%ecx
  280f65:	83 c4 38             	add    $0x38,%esp
  280f68:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  280f6b:	51                   	push   %ecx
  280f6c:	6a 02                	push   $0x2
  280f6e:	ff 75 f0             	pushl  -0x10(%ebp)
  280f71:	6a 02                	push   $0x2
  280f73:	6a 07                	push   $0x7
  280f75:	53                   	push   %ebx
  280f76:	57                   	push   %edi
  280f77:	e8 d8 fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,3,      ysize- 4,   59,         ysize- 4);
  280f7c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  280f7f:	51                   	push   %ecx
  280f80:	6a 3b                	push   $0x3b
  280f82:	51                   	push   %ecx
  280f83:	6a 03                	push   $0x3
  280f85:	6a 0f                	push   $0xf
  280f87:	53                   	push   %ebx
  280f88:	57                   	push   %edi
  280f89:	e8 c6 fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,59,     ysize-23,   59,         ysize- 5);
  280f8e:	8d 56 e9             	lea    -0x17(%esi),%edx
  280f91:	83 c4 38             	add    $0x38,%esp
  280f94:	8d 46 fb             	lea    -0x5(%esi),%eax
  280f97:	50                   	push   %eax
  280f98:	6a 3b                	push   $0x3b
  280f9a:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  280f9d:	52                   	push   %edx
  280f9e:	6a 3b                	push   $0x3b
  280fa0:	6a 0f                	push   $0xf
  280fa2:	53                   	push   %ebx
  280fa3:	57                   	push   %edi
  280fa4:	e8 ab fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,2,      ysize- 3,   59,         ysize- 3);
  280fa9:	83 ee 03             	sub    $0x3,%esi
  280fac:	56                   	push   %esi
  280fad:	6a 3b                	push   $0x3b
  280faf:	56                   	push   %esi
  280fb0:	6a 02                	push   $0x2
  280fb2:	6a 00                	push   $0x0
  280fb4:	53                   	push   %ebx
  280fb5:	57                   	push   %edi
  280fb6:	e8 99 fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_000000,60,     ysize-24,   60,         ysize- 3);
  280fbb:	83 c4 38             	add    $0x38,%esp
  280fbe:	56                   	push   %esi
  280fbf:	6a 3c                	push   $0x3c
  280fc1:	ff 75 f0             	pushl  -0x10(%ebp)
  280fc4:	6a 3c                	push   $0x3c
  280fc6:	6a 00                	push   $0x0
  280fc8:	53                   	push   %ebx
  280fc9:	57                   	push   %edi
  280fca:	e8 85 fe ff ff       	call   280e54 <boxfill8>
	
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-24,   xsize- 4,   ysize-24);
  280fcf:	8d 4b fc             	lea    -0x4(%ebx),%ecx
  280fd2:	8d 53 d1             	lea    -0x2f(%ebx),%edx
  280fd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  280fd8:	50                   	push   %eax
  280fd9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  280fdc:	51                   	push   %ecx
  280fdd:	50                   	push   %eax
  280fde:	89 55 e8             	mov    %edx,-0x18(%ebp)
  280fe1:	52                   	push   %edx
  280fe2:	6a 0f                	push   $0xf
  280fe4:	53                   	push   %ebx
  280fe5:	57                   	push   %edi
  280fe6:	e8 69 fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_848484,xsize-47,       ysize-23,   xsize-47,   ysize- 4);
  280feb:	83 c4 38             	add    $0x38,%esp
  280fee:	ff 75 ec             	pushl  -0x14(%ebp)
  280ff1:	8b 55 e8             	mov    -0x18(%ebp),%edx
  280ff4:	52                   	push   %edx
  280ff5:	ff 75 e4             	pushl  -0x1c(%ebp)
  280ff8:	52                   	push   %edx
  280ff9:	6a 0f                	push   $0xf
  280ffb:	53                   	push   %ebx
  280ffc:	57                   	push   %edi
  280ffd:	e8 52 fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize-47,       ysize- 3,   xsize- 4,   ysize- 3);
  281002:	56                   	push   %esi
  281003:	ff 75 e0             	pushl  -0x20(%ebp)
  281006:	56                   	push   %esi
  281007:	ff 75 e8             	pushl  -0x18(%ebp)
  28100a:	6a 07                	push   $0x7
  28100c:	53                   	push   %ebx
  28100d:	57                   	push   %edi
  28100e:	e8 41 fe ff ff       	call   280e54 <boxfill8>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
  281013:	8d 43 fd             	lea    -0x3(%ebx),%eax
  281016:	83 c4 38             	add    $0x38,%esp
  281019:	56                   	push   %esi
  28101a:	50                   	push   %eax
  28101b:	ff 75 f0             	pushl  -0x10(%ebp)
  28101e:	50                   	push   %eax
  28101f:	6a 07                	push   $0x7
  281021:	53                   	push   %ebx
  281022:	57                   	push   %edi
  281023:	e8 2c fe ff ff       	call   280e54 <boxfill8>
}
  281028:	83 c4 1c             	add    $0x1c,%esp
  28102b:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28102e:	5b                   	pop    %ebx
  28102f:	5e                   	pop    %esi
  281030:	5f                   	pop    %edi
  281031:	5d                   	pop    %ebp
  281032:	c3                   	ret    

00281033 <init_mouse_cursor8>:


void init_mouse_cursor8(char *mouse, char bc)
{
  281033:	55                   	push   %ebp
  281034:	89 e5                	mov    %esp,%ebp
  281036:	57                   	push   %edi
  281037:	56                   	push   %esi
  281038:	53                   	push   %ebx
  281039:	83 ec 08             	sub    $0x8,%esp
  28103c:	8b 75 08             	mov    0x8(%ebp),%esi
  28103f:	0f b6 7d 0c          	movzbl 0xc(%ebp),%edi
  281043:	89 75 f0             	mov    %esi,-0x10(%ebp)
  281046:	8d 86 00 01 00 00    	lea    0x100(%esi),%eax
  28104c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  28104f:	eb 38                	jmp    281089 <init_mouse_cursor8+0x56>
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  281051:	0f b6 94 03 80 48 28 	movzbl 0x284880(%ebx,%eax,1),%edx
  281058:	00 
  281059:	80 fa 2a             	cmp    $0x2a,%dl
  28105c:	75 06                	jne    281064 <init_mouse_cursor8+0x31>
				mouse[y*16+x] = COL8_000000;
  28105e:	c6 04 06 00          	movb   $0x0,(%esi,%eax,1)
  281062:	eb 15                	jmp    281079 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == 'O')
  281064:	80 fa 4f             	cmp    $0x4f,%dl
  281067:	75 06                	jne    28106f <init_mouse_cursor8+0x3c>
				mouse[y*16+x] = COL8_FFFFFF;
  281069:	c6 04 06 07          	movb   $0x7,(%esi,%eax,1)
  28106d:	eb 0a                	jmp    281079 <init_mouse_cursor8+0x46>
			else if(cursor[y][x] == '.')
  28106f:	80 fa 2e             	cmp    $0x2e,%dl
  281072:	75 05                	jne    281079 <init_mouse_cursor8+0x46>
				mouse[y*16+x] = bc;
  281074:	89 fa                	mov    %edi,%edx
  281076:	88 14 06             	mov    %dl,(%esi,%eax,1)
	};
	int x,y;
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
  281079:	83 c0 01             	add    $0x1,%eax
  28107c:	83 f8 10             	cmp    $0x10,%eax
  28107f:	75 d0                	jne    281051 <init_mouse_cursor8+0x1e>
  281081:	83 c6 10             	add    $0x10,%esi
        "............*OO*",
        ".............***"
	};
	int x,y;
	
	for(y=0;y<16;y++)
  281084:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  281087:	74 0c                	je     281095 <init_mouse_cursor8+0x62>
	boxfill8(vram,xsize,COL8_FFFFFF,xsize- 3,       ysize-24,   xsize- 3,   ysize- 3);
}


void init_mouse_cursor8(char *mouse, char bc)
{
  281089:	b8 00 00 00 00       	mov    $0x0,%eax
	
	for(y=0;y<16;y++)
	{
		for(x=0;x<16;x++)
		{
			if(cursor[y][x] == '*')
  28108e:	89 f3                	mov    %esi,%ebx
  281090:	2b 5d f0             	sub    -0x10(%ebp),%ebx
  281093:	eb bc                	jmp    281051 <init_mouse_cursor8+0x1e>
			else if(cursor[y][x] == '.')
				mouse[y*16+x] = bc;
		}
	}
	return;
}
  281095:	83 c4 08             	add    $0x8,%esp
  281098:	5b                   	pop    %ebx
  281099:	5e                   	pop    %esi
  28109a:	5f                   	pop    %edi
  28109b:	5d                   	pop    %ebp
  28109c:	c3                   	ret    

0028109d <make_wtitle8>:
	make_wtitle8(buf,xsize,title,act);
	return;
}

void make_wtitle8(unsigned char *buf,int xsize,char *title,char act)
{
  28109d:	55                   	push   %ebp
  28109e:	89 e5                	mov    %esp,%ebp
  2810a0:	57                   	push   %edi
  2810a1:	56                   	push   %esi
  2810a2:	53                   	push   %ebx
  2810a3:	83 ec 1c             	sub    $0x1c,%esp
  2810a6:	8b 75 08             	mov    0x8(%ebp),%esi
  2810a9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  2810ac:	8b 55 14             	mov    0x14(%ebp),%edx
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
		tbc= COL8_848484;
  2810af:	80 fa 01             	cmp    $0x1,%dl
  2810b2:	19 c0                	sbb    %eax,%eax
  2810b4:	83 e0 03             	and    $0x3,%eax
  2810b7:	83 c0 0c             	add    $0xc,%eax
  2810ba:	80 fa 01             	cmp    $0x1,%dl
  2810bd:	19 ff                	sbb    %edi,%edi
  2810bf:	f7 d7                	not    %edi
  2810c1:	83 c7 08             	add    $0x8,%edi
	}
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
  2810c4:	6a 14                	push   $0x14
  2810c6:	8d 53 fc             	lea    -0x4(%ebx),%edx
  2810c9:	52                   	push   %edx
  2810ca:	6a 03                	push   $0x3
  2810cc:	6a 03                	push   $0x3
  2810ce:	0f b6 c0             	movzbl %al,%eax
  2810d1:	50                   	push   %eax
  2810d2:	53                   	push   %ebx
  2810d3:	56                   	push   %esi
  2810d4:	e8 7b fd ff ff       	call   280e54 <boxfill8>
	putfonts8_asc(buf,xsize,24,4,tc,title);
  2810d9:	83 c4 04             	add    $0x4,%esp
  2810dc:	ff 75 10             	pushl  0x10(%ebp)
  2810df:	89 f8                	mov    %edi,%eax
  2810e1:	0f be f8             	movsbl %al,%edi
  2810e4:	57                   	push   %edi
  2810e5:	6a 04                	push   $0x4
  2810e7:	6a 18                	push   $0x18
  2810e9:	53                   	push   %ebx
  2810ea:	56                   	push   %esi
  2810eb:	e8 c7 04 00 00       	call   2815b7 <putfonts8_asc>
  2810f0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  2810f3:	8d 3c 9b             	lea    (%ebx,%ebx,4),%edi
  2810f6:	01 fb                	add    %edi,%ebx
  2810f8:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
  2810fb:	83 c4 30             	add    $0x30,%esp
  2810fe:	be 00 00 00 00       	mov    $0x0,%esi
  281103:	eb 41                	jmp    281146 <make_wtitle8+0xa9>
  281105:	89 c1                	mov    %eax,%ecx
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
		{
			c=closebtn[y][x];
  281107:	0f b6 9c 06 a0 47 28 	movzbl 0x2847a0(%esi,%eax,1),%ebx
  28110e:	00 
			if(c == '@') c=COL8_000000;
  28110f:	ba 00 00 00 00       	mov    $0x0,%edx
  281114:	80 fb 40             	cmp    $0x40,%bl
  281117:	74 13                	je     28112c <make_wtitle8+0x8f>
			else if(c == '$') c=COL8_848484;
  281119:	ba 0f 00 00 00       	mov    $0xf,%edx
  28111e:	80 fb 24             	cmp    $0x24,%bl
  281121:	74 09                	je     28112c <make_wtitle8+0x8f>
			else if(c == 'Q') c=COL8_C6C6C6;
			else c=COL8_FFFFFF;
  281123:	80 fb 51             	cmp    $0x51,%bl
  281126:	0f 94 c2             	sete   %dl
  281129:	83 c2 07             	add    $0x7,%edx
			buf[(5+y)*xsize+(xsize-21+x)] = c;
  28112c:	88 54 0f eb          	mov    %dl,-0x15(%edi,%ecx,1)
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
	{
		for(x=0;x<16;x++)
  281130:	83 c0 01             	add    $0x1,%eax
  281133:	83 f8 10             	cmp    $0x10,%eax
  281136:	75 cd                	jne    281105 <make_wtitle8+0x68>
  281138:	03 7d e4             	add    -0x1c(%ebp),%edi
  28113b:	83 c6 10             	add    $0x10,%esi
	//draw title bar
    boxfill8(buf, xsize, tbc		, 3     , 3     , xsize-4,20    );
	putfonts8_asc(buf,xsize,24,4,tc,title);
	
	//draw close button
	for(y=0;y<14;y++)
  28113e:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
  281144:	74 07                	je     28114d <make_wtitle8+0xb0>
		tc = COL8_FFFFFF;
		tbc= COL8_000084;
	}
	else
	{
		tc = COL8_C6C6C6;
  281146:	b8 00 00 00 00       	mov    $0x0,%eax
  28114b:	eb b8                	jmp    281105 <make_wtitle8+0x68>
			else c=COL8_FFFFFF;
			buf[(5+y)*xsize+(xsize-21+x)] = c;
		}
	}
	return;
}
  28114d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281150:	5b                   	pop    %ebx
  281151:	5e                   	pop    %esi
  281152:	5f                   	pop    %edi
  281153:	5d                   	pop    %ebp
  281154:	c3                   	ret    

00281155 <make_window8>:
	}
	return;
}

void make_window8(unsigned char *buf,int xsize,int ysize,char *title,char act)
{
  281155:	55                   	push   %ebp
  281156:	89 e5                	mov    %esp,%ebp
  281158:	57                   	push   %edi
  281159:	56                   	push   %esi
  28115a:	53                   	push   %ebx
  28115b:	83 ec 1c             	sub    $0x1c,%esp
  28115e:	8b 75 08             	mov    0x8(%ebp),%esi
  281161:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281164:	8b 45 18             	mov    0x18(%ebp),%eax
  281167:	89 45 d8             	mov    %eax,-0x28(%ebp)
	boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , xsize - 1, 0  );
  28116a:	8d 43 ff             	lea    -0x1(%ebx),%eax
  28116d:	6a 00                	push   $0x0
  28116f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  281172:	50                   	push   %eax
  281173:	6a 00                	push   $0x0
  281175:	6a 00                	push   $0x0
  281177:	6a 08                	push   $0x8
  281179:	53                   	push   %ebx
  28117a:	56                   	push   %esi
  28117b:	e8 d4 fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , xsize - 2, 1  );
  281180:	8d 53 fe             	lea    -0x2(%ebx),%edx
  281183:	6a 01                	push   $0x1
  281185:	89 55 e0             	mov    %edx,-0x20(%ebp)
  281188:	52                   	push   %edx
  281189:	6a 01                	push   $0x1
  28118b:	6a 01                	push   $0x1
  28118d:	6a 07                	push   $0x7
  28118f:	53                   	push   %ebx
  281190:	56                   	push   %esi
  281191:	e8 be fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 0     , 0     , 0     , ysize-1);
  281196:	8b 7d 10             	mov    0x10(%ebp),%edi
  281199:	8d 4f ff             	lea    -0x1(%edi),%ecx
  28119c:	83 c4 38             	add    $0x38,%esp
  28119f:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  2811a2:	51                   	push   %ecx
  2811a3:	6a 00                	push   $0x0
  2811a5:	6a 00                	push   $0x0
  2811a7:	6a 00                	push   $0x0
  2811a9:	6a 08                	push   $0x8
  2811ab:	53                   	push   %ebx
  2811ac:	56                   	push   %esi
  2811ad:	e8 a2 fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_FFFFFF, 1     , 1     , 1     , ysize-2);
  2811b2:	8b 7d 10             	mov    0x10(%ebp),%edi
  2811b5:	83 ef 02             	sub    $0x2,%edi
  2811b8:	57                   	push   %edi
  2811b9:	6a 01                	push   $0x1
  2811bb:	6a 01                	push   $0x1
  2811bd:	6a 01                	push   $0x1
  2811bf:	6a 07                	push   $0x7
  2811c1:	53                   	push   %ebx
  2811c2:	56                   	push   %esi
  2811c3:	e8 8c fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, xsize-2,1     , xsize-2,ysize-2);
  2811c8:	83 c4 38             	add    $0x38,%esp
  2811cb:	57                   	push   %edi
  2811cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  2811cf:	52                   	push   %edx
  2811d0:	6a 01                	push   $0x1
  2811d2:	52                   	push   %edx
  2811d3:	6a 0f                	push   $0xf
  2811d5:	53                   	push   %ebx
  2811d6:	56                   	push   %esi
  2811d7:	e8 78 fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, xsize-1,0     , xsize-1,ysize-1);
  2811dc:	ff 75 dc             	pushl  -0x24(%ebp)
  2811df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  2811e2:	50                   	push   %eax
  2811e3:	6a 00                	push   $0x0
  2811e5:	50                   	push   %eax
  2811e6:	6a 00                	push   $0x0
  2811e8:	53                   	push   %ebx
  2811e9:	56                   	push   %esi
  2811ea:	e8 65 fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_C6C6C6, 2     , 2     , xsize-3,ysize-3);
  2811ef:	83 c4 38             	add    $0x38,%esp
  2811f2:	8b 55 10             	mov    0x10(%ebp),%edx
  2811f5:	8d 42 fd             	lea    -0x3(%edx),%eax
  2811f8:	50                   	push   %eax
  2811f9:	8d 43 fd             	lea    -0x3(%ebx),%eax
  2811fc:	50                   	push   %eax
  2811fd:	6a 02                	push   $0x2
  2811ff:	6a 02                	push   $0x2
  281201:	6a 08                	push   $0x8
  281203:	53                   	push   %ebx
  281204:	56                   	push   %esi
  281205:	e8 4a fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_848484, 1     , ysize-2,xsize-2,ysize-2);
  28120a:	57                   	push   %edi
  28120b:	ff 75 e0             	pushl  -0x20(%ebp)
  28120e:	57                   	push   %edi
  28120f:	6a 01                	push   $0x1
  281211:	6a 0f                	push   $0xf
  281213:	53                   	push   %ebx
  281214:	56                   	push   %esi
  281215:	e8 3a fc ff ff       	call   280e54 <boxfill8>
    boxfill8(buf, xsize, COL8_000000, 0     , ysize-1,xsize-1,ysize-1);
  28121a:	83 c4 38             	add    $0x38,%esp
  28121d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  281220:	51                   	push   %ecx
  281221:	ff 75 e4             	pushl  -0x1c(%ebp)
  281224:	51                   	push   %ecx
  281225:	6a 00                	push   $0x0
  281227:	6a 00                	push   $0x0
  281229:	53                   	push   %ebx
  28122a:	56                   	push   %esi
  28122b:	e8 24 fc ff ff       	call   280e54 <boxfill8>
	make_wtitle8(buf,xsize,title,act);
  281230:	83 c4 1c             	add    $0x1c,%esp
  281233:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  281237:	50                   	push   %eax
  281238:	ff 75 14             	pushl  0x14(%ebp)
  28123b:	53                   	push   %ebx
  28123c:	56                   	push   %esi
  28123d:	e8 5b fe ff ff       	call   28109d <make_wtitle8>
	return;
  281242:	83 c4 10             	add    $0x10,%esp
}
  281245:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281248:	5b                   	pop    %ebx
  281249:	5e                   	pop    %esi
  28124a:	5f                   	pop    %edi
  28124b:	5d                   	pop    %ebp
  28124c:	c3                   	ret    

0028124d <putblock8_8>:
	}
	return;
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
  28124d:	55                   	push   %ebp
  28124e:	89 e5                	mov    %esp,%ebp
  281250:	57                   	push   %edi
  281251:	56                   	push   %esi
  281252:	53                   	push   %ebx
  281253:	83 ec 04             	sub    $0x4,%esp
  281256:	8b 45 0c             	mov    0xc(%ebp),%eax
  281259:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int x,y;
	for(y=0;y<pysize;y++)
  28125c:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  281260:	7e 49                	jle    2812ab <putblock8_8+0x5e>
  281262:	8b 7d 24             	mov    0x24(%ebp),%edi
  281265:	8b 4d 20             	mov    0x20(%ebp),%ecx
  281268:	89 45 f0             	mov    %eax,-0x10(%ebp)
  28126b:	0f af 45 1c          	imul   0x1c(%ebp),%eax
  28126f:	03 45 18             	add    0x18(%ebp),%eax
  281272:	89 c2                	mov    %eax,%edx
  281274:	03 55 08             	add    0x8(%ebp),%edx
  281277:	be 00 00 00 00       	mov    $0x0,%esi
  28127c:	eb 22                	jmp    2812a0 <putblock8_8+0x53>
  28127e:	89 5d 10             	mov    %ebx,0x10(%ebp)
		for(x=0;x<pxsize;x++)
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];
  281281:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
  281285:	88 1c 02             	mov    %bl,(%edx,%eax,1)

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
		for(x=0;x<pxsize;x++)
  281288:	83 c0 01             	add    $0x1,%eax
  28128b:	39 45 10             	cmp    %eax,0x10(%ebp)
  28128e:	75 f1                	jne    281281 <putblock8_8+0x34>
  281290:	8b 5d 10             	mov    0x10(%ebp),%ebx
}

void putblock8_8(char *vram,int vxsize,int pxsize,int pysize,int px0,int py0,char *buf,int bxsize)
{
	int x,y;
	for(y=0;y<pysize;y++)
  281293:	83 c6 01             	add    $0x1,%esi
  281296:	01 f9                	add    %edi,%ecx
  281298:	03 55 f0             	add    -0x10(%ebp),%edx
  28129b:	39 75 14             	cmp    %esi,0x14(%ebp)
  28129e:	74 0b                	je     2812ab <putblock8_8+0x5e>
		for(x=0;x<pxsize;x++)
  2812a0:	b8 00 00 00 00       	mov    $0x0,%eax
  2812a5:	85 db                	test   %ebx,%ebx
  2812a7:	7f d5                	jg     28127e <putblock8_8+0x31>
  2812a9:	eb e8                	jmp    281293 <putblock8_8+0x46>
			vram[(py0+y)*vxsize+(px0+x)]=buf[y*bxsize+x];

	return;
}
  2812ab:	83 c4 04             	add    $0x4,%esp
  2812ae:	5b                   	pop    %ebx
  2812af:	5e                   	pop    %esi
  2812b0:	5f                   	pop    %edi
  2812b1:	5d                   	pop    %ebp
  2812b2:	c3                   	ret    

002812b3 <putfonts8_asc_sht>:
//b background color
//c font color
void putfonts8_asc_sht(struct SHEET *sht,int x,int y,int c,int b,char *s,int l)
{
  2812b3:	55                   	push   %ebp
  2812b4:	89 e5                	mov    %esp,%ebp
  2812b6:	57                   	push   %edi
  2812b7:	56                   	push   %esi
  2812b8:	53                   	push   %ebx
  2812b9:	83 ec 0c             	sub    $0xc,%esp
  2812bc:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2812bf:	8b 75 10             	mov    0x10(%ebp),%esi
	boxfill8(sht->buf,sht->bxsize,b,x,y,x+l*8-1,y+15);
  2812c2:	8b 45 20             	mov    0x20(%ebp),%eax
  2812c5:	8b 55 0c             	mov    0xc(%ebp),%edx
  2812c8:	8d 3c c2             	lea    (%edx,%eax,8),%edi
  2812cb:	8d 46 0f             	lea    0xf(%esi),%eax
  2812ce:	50                   	push   %eax
  2812cf:	8d 47 ff             	lea    -0x1(%edi),%eax
  2812d2:	50                   	push   %eax
  2812d3:	56                   	push   %esi
  2812d4:	52                   	push   %edx
  2812d5:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  2812d9:	50                   	push   %eax
  2812da:	ff 73 04             	pushl  0x4(%ebx)
  2812dd:	ff 33                	pushl  (%ebx)
  2812df:	e8 70 fb ff ff       	call   280e54 <boxfill8>
	putfonts8_asc(sht->buf,sht->bxsize,x,y,c,s);
  2812e4:	83 c4 04             	add    $0x4,%esp
  2812e7:	ff 75 1c             	pushl  0x1c(%ebp)
  2812ea:	ff 75 14             	pushl  0x14(%ebp)
  2812ed:	56                   	push   %esi
  2812ee:	ff 75 0c             	pushl  0xc(%ebp)
  2812f1:	ff 73 04             	pushl  0x4(%ebx)
  2812f4:	ff 33                	pushl  (%ebx)
  2812f6:	e8 bc 02 00 00       	call   2815b7 <putfonts8_asc>
	sheet_refresh(sht,x,y,x+l*8,y+16);
  2812fb:	83 c4 24             	add    $0x24,%esp
  2812fe:	8d 46 10             	lea    0x10(%esi),%eax
  281301:	50                   	push   %eax
  281302:	57                   	push   %edi
  281303:	56                   	push   %esi
  281304:	ff 75 0c             	pushl  0xc(%ebp)
  281307:	53                   	push   %ebx
  281308:	e8 41 16 00 00       	call   28294e <sheet_refresh>
}
  28130d:	83 c4 20             	add    $0x20,%esp
  281310:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281313:	5b                   	pop    %ebx
  281314:	5e                   	pop    %esi
  281315:	5f                   	pop    %edi
  281316:	5d                   	pop    %ebp
  281317:	c3                   	ret    

00281318 <make_textbox8>:

void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c)
{
  281318:	55                   	push   %ebp
  281319:	89 e5                	mov    %esp,%ebp
  28131b:	57                   	push   %edi
  28131c:	56                   	push   %esi
  28131d:	53                   	push   %ebx
  28131e:	83 ec 18             	sub    $0x18,%esp
  281321:	8b 5d 08             	mov    0x8(%ebp),%ebx
    int x1 = x0 + sx, y1 = y0 + sy;
  281324:	8b 45 0c             	mov    0xc(%ebp),%eax
  281327:	03 45 14             	add    0x14(%ebp),%eax
  28132a:	8b 55 10             	mov    0x10(%ebp),%edx
  28132d:	03 55 18             	add    0x18(%ebp),%edx
  281330:	89 d7                	mov    %edx,%edi
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 2, y0 - 3, x1 + 1, y0 - 3);
  281332:	89 45 e8             	mov    %eax,-0x18(%ebp)
  281335:	8d 48 01             	lea    0x1(%eax),%ecx
  281338:	8b 75 10             	mov    0x10(%ebp),%esi
  28133b:	83 ee 03             	sub    $0x3,%esi
  28133e:	8b 55 0c             	mov    0xc(%ebp),%edx
  281341:	83 ea 02             	sub    $0x2,%edx
  281344:	56                   	push   %esi
  281345:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  281348:	51                   	push   %ecx
  281349:	56                   	push   %esi
  28134a:	89 55 f0             	mov    %edx,-0x10(%ebp)
  28134d:	52                   	push   %edx
  28134e:	6a 0f                	push   $0xf
  281350:	ff 73 04             	pushl  0x4(%ebx)
  281353:	ff 33                	pushl  (%ebx)
  281355:	e8 fa fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_848484, x0 - 3, y0 - 3, x0 - 3, y1 + 1);
  28135a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  28135d:	8d 7f 01             	lea    0x1(%edi),%edi
  281360:	89 f9                	mov    %edi,%ecx
  281362:	8b 7d 0c             	mov    0xc(%ebp),%edi
  281365:	83 ef 03             	sub    $0x3,%edi
  281368:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  28136b:	51                   	push   %ecx
  28136c:	57                   	push   %edi
  28136d:	56                   	push   %esi
  28136e:	57                   	push   %edi
  28136f:	6a 0f                	push   $0xf
  281371:	ff 73 04             	pushl  0x4(%ebx)
  281374:	ff 33                	pushl  (%ebx)
  281376:	e8 d9 fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x0 - 3, y1 + 2, x1 + 1, y1 + 2);
  28137b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  28137e:	8d 4a 02             	lea    0x2(%edx),%ecx
  281381:	83 c4 38             	add    $0x38,%esp
  281384:	51                   	push   %ecx
  281385:	ff 75 e0             	pushl  -0x20(%ebp)
  281388:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  28138b:	51                   	push   %ecx
  28138c:	57                   	push   %edi
  28138d:	6a 07                	push   $0x7
  28138f:	ff 73 04             	pushl  0x4(%ebx)
  281392:	ff 33                	pushl  (%ebx)
  281394:	e8 bb fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_FFFFFF, x1 + 2, y0 - 3, x1 + 2, y1 + 2);
  281399:	8b 45 e8             	mov    -0x18(%ebp),%eax
  28139c:	83 c0 02             	add    $0x2,%eax
  28139f:	ff 75 dc             	pushl  -0x24(%ebp)
  2813a2:	50                   	push   %eax
  2813a3:	56                   	push   %esi
  2813a4:	50                   	push   %eax
  2813a5:	6a 07                	push   $0x7
  2813a7:	ff 73 04             	pushl  0x4(%ebx)
  2813aa:	ff 33                	pushl  (%ebx)
  2813ac:	e8 a3 fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 1, y0 - 2, x1 + 0, y0 - 2);
  2813b1:	8b 75 10             	mov    0x10(%ebp),%esi
  2813b4:	8d 7e fe             	lea    -0x2(%esi),%edi
  2813b7:	8b 75 0c             	mov    0xc(%ebp),%esi
  2813ba:	83 ee 01             	sub    $0x1,%esi
  2813bd:	83 c4 38             	add    $0x38,%esp
  2813c0:	57                   	push   %edi
  2813c1:	ff 75 e8             	pushl  -0x18(%ebp)
  2813c4:	57                   	push   %edi
  2813c5:	56                   	push   %esi
  2813c6:	6a 00                	push   $0x0
  2813c8:	ff 73 04             	pushl  0x4(%ebx)
  2813cb:	ff 33                	pushl  (%ebx)
  2813cd:	e8 82 fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_000000, x0 - 2, y0 - 2, x0 - 2, y1 + 0);
  2813d2:	ff 75 e4             	pushl  -0x1c(%ebp)
  2813d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  2813d8:	52                   	push   %edx
  2813d9:	57                   	push   %edi
  2813da:	52                   	push   %edx
  2813db:	6a 00                	push   $0x0
  2813dd:	ff 73 04             	pushl  0x4(%ebx)
  2813e0:	ff 33                	pushl  (%ebx)
  2813e2:	e8 6d fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x0 - 2, y1 + 1, x1 + 0, y1 + 1);
  2813e7:	83 c4 38             	add    $0x38,%esp
  2813ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
  2813ed:	50                   	push   %eax
  2813ee:	ff 75 e8             	pushl  -0x18(%ebp)
  2813f1:	50                   	push   %eax
  2813f2:	ff 75 f0             	pushl  -0x10(%ebp)
  2813f5:	6a 08                	push   $0x8
  2813f7:	ff 73 04             	pushl  0x4(%ebx)
  2813fa:	ff 33                	pushl  (%ebx)
  2813fc:	e8 53 fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, COL8_C6C6C6, x1 + 1, y0 - 2, x1 + 1, y1 + 1);
  281401:	ff 75 ec             	pushl  -0x14(%ebp)
  281404:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  281407:	51                   	push   %ecx
  281408:	57                   	push   %edi
  281409:	51                   	push   %ecx
  28140a:	6a 08                	push   $0x8
  28140c:	ff 73 04             	pushl  0x4(%ebx)
  28140f:	ff 33                	pushl  (%ebx)
  281411:	e8 3e fa ff ff       	call   280e54 <boxfill8>
    boxfill8(sht->buf, sht->bxsize, c,           x0 - 1, y0 - 1, x1 + 0, y1 + 0);
  281416:	83 c4 38             	add    $0x38,%esp
  281419:	ff 75 e4             	pushl  -0x1c(%ebp)
  28141c:	ff 75 e8             	pushl  -0x18(%ebp)
  28141f:	8b 45 10             	mov    0x10(%ebp),%eax
  281422:	83 e8 01             	sub    $0x1,%eax
  281425:	50                   	push   %eax
  281426:	56                   	push   %esi
  281427:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  28142b:	50                   	push   %eax
  28142c:	ff 73 04             	pushl  0x4(%ebx)
  28142f:	ff 33                	pushl  (%ebx)
  281431:	e8 1e fa ff ff       	call   280e54 <boxfill8>
    return;
  281436:	83 c4 1c             	add    $0x1c,%esp
}
  281439:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28143c:	5b                   	pop    %ebx
  28143d:	5e                   	pop    %esi
  28143e:	5f                   	pop    %edi
  28143f:	5d                   	pop    %ebp
  281440:	c3                   	ret    

00281441 <drawline8_sht>:

void drawline8_sht(struct SHEET *sht,int x0,int y0,int x1,int y1,int col)
{
  281441:	55                   	push   %ebp
  281442:	89 e5                	mov    %esp,%ebp
  281444:	57                   	push   %edi
  281445:	56                   	push   %esi
  281446:	53                   	push   %ebx
  281447:	83 ec 10             	sub    $0x10,%esp
  28144a:	8b 75 08             	mov    0x8(%ebp),%esi
	int i,x,y,len,dx,dy;
	dx = x1-x0;
  28144d:	8b 7d 14             	mov    0x14(%ebp),%edi
  281450:	2b 7d 0c             	sub    0xc(%ebp),%edi
	dy = y1-y0;
  281453:	8b 45 18             	mov    0x18(%ebp),%eax
  281456:	2b 45 10             	sub    0x10(%ebp),%eax
  281459:	89 45 f0             	mov    %eax,-0x10(%ebp)
	x = x0 << 10;
  28145c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  28145f:	c1 e1 0a             	shl    $0xa,%ecx
	y = y0 << 10;
  281462:	8b 5d 10             	mov    0x10(%ebp),%ebx
  281465:	c1 e3 0a             	shl    $0xa,%ebx
  281468:	89 fa                	mov    %edi,%edx
  28146a:	c1 fa 1f             	sar    $0x1f,%edx
  28146d:	89 d0                	mov    %edx,%eax
  28146f:	31 fa                	xor    %edi,%edx
  281471:	29 c2                	sub    %eax,%edx
  281473:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281476:	c1 f8 1f             	sar    $0x1f,%eax
  281479:	89 45 ec             	mov    %eax,-0x14(%ebp)
  28147c:	33 45 f0             	xor    -0x10(%ebp),%eax
  28147f:	2b 45 ec             	sub    -0x14(%ebp),%eax
	}
	if (dy<0) 
	{
		dy = -dy;
	}
	if(dx >= dy)
  281482:	39 c2                	cmp    %eax,%edx
  281484:	7c 4a                	jl     2814d0 <drawline8_sht+0x8f>
	{
		len=dx+1;
  281486:	83 c2 01             	add    $0x1,%edx
  281489:	89 55 ec             	mov    %edx,-0x14(%ebp)
		if(x0 >x1)
			dx = -1024;
		else
			dx = 1024;
  28148c:	8b 7d 0c             	mov    0xc(%ebp),%edi
  28148f:	39 7d 14             	cmp    %edi,0x14(%ebp)
  281492:	b8 00 04 00 00       	mov    $0x400,%eax
  281497:	ba 00 fc ff ff       	mov    $0xfffffc00,%edx
  28149c:	89 c7                	mov    %eax,%edi
  28149e:	0f 4c fa             	cmovl  %edx,%edi
  2814a1:	89 7d e8             	mov    %edi,-0x18(%ebp)
		if(y0<=y1)
  2814a4:	8b 7d 10             	mov    0x10(%ebp),%edi
  2814a7:	39 7d 18             	cmp    %edi,0x18(%ebp)
  2814aa:	7c 12                	jl     2814be <drawline8_sht+0x7d>
			dy = ((y1 - y0 + 1)<<10)/len;
  2814ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2814af:	83 c0 01             	add    $0x1,%eax
  2814b2:	c1 e0 0a             	shl    $0xa,%eax
  2814b5:	99                   	cltd   
  2814b6:	f7 7d ec             	idivl  -0x14(%ebp)
  2814b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  2814bc:	eb 52                	jmp    281510 <drawline8_sht+0xcf>
		else
			dy = ((y1 - y0 - 1)<<10)/len;
  2814be:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2814c1:	83 e8 01             	sub    $0x1,%eax
  2814c4:	c1 e0 0a             	shl    $0xa,%eax
  2814c7:	99                   	cltd   
  2814c8:	f7 7d ec             	idivl  -0x14(%ebp)
  2814cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  2814ce:	eb 40                	jmp    281510 <drawline8_sht+0xcf>
	}
	else
	{
		len=dy+1;
  2814d0:	83 c0 01             	add    $0x1,%eax
  2814d3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if(y0>y1)
			dy = -1024;
		else
			dy = 1024;
  2814d6:	8b 55 10             	mov    0x10(%ebp),%edx
  2814d9:	39 55 18             	cmp    %edx,0x18(%ebp)
  2814dc:	b8 00 04 00 00       	mov    $0x400,%eax
  2814e1:	ba 00 fc ff ff       	mov    $0xfffffc00,%edx
  2814e6:	0f 4c c2             	cmovl  %edx,%eax
  2814e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if(x0<=x1)
  2814ec:	8b 55 0c             	mov    0xc(%ebp),%edx
  2814ef:	39 55 14             	cmp    %edx,0x14(%ebp)
  2814f2:	7c 0f                	jl     281503 <drawline8_sht+0xc2>
			dx = ((x1 - x0 + 1)<<10)/len;
  2814f4:	8d 47 01             	lea    0x1(%edi),%eax
  2814f7:	c1 e0 0a             	shl    $0xa,%eax
  2814fa:	99                   	cltd   
  2814fb:	f7 7d ec             	idivl  -0x14(%ebp)
  2814fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
  281501:	eb 0d                	jmp    281510 <drawline8_sht+0xcf>
		else
			dx = ((x1 - x0 - 1)<<10)/len;
  281503:	8d 47 ff             	lea    -0x1(%edi),%eax
  281506:	c1 e0 0a             	shl    $0xa,%eax
  281509:	99                   	cltd   
  28150a:	f7 7d ec             	idivl  -0x14(%ebp)
  28150d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	}
	for(i=0;i<len;i++)
  281510:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
  281514:	7e 31                	jle    281547 <drawline8_sht+0x106>
  281516:	ba 00 00 00 00       	mov    $0x0,%edx
  28151b:	89 55 f0             	mov    %edx,-0x10(%ebp)
	{
		sht->buf[(y>>10)*sht->bxsize+(x>>10)] = col;
  28151e:	89 d8                	mov    %ebx,%eax
  281520:	c1 f8 0a             	sar    $0xa,%eax
  281523:	0f af 46 04          	imul   0x4(%esi),%eax
  281527:	89 cf                	mov    %ecx,%edi
  281529:	c1 ff 0a             	sar    $0xa,%edi
  28152c:	03 06                	add    (%esi),%eax
  28152e:	0f b6 55 1c          	movzbl 0x1c(%ebp),%edx
  281532:	88 14 38             	mov    %dl,(%eax,%edi,1)
		x += dx;
  281535:	03 4d e8             	add    -0x18(%ebp),%ecx
		y += dy;
  281538:	03 5d e4             	add    -0x1c(%ebp),%ebx
		if(x0<=x1)
			dx = ((x1 - x0 + 1)<<10)/len;
		else
			dx = ((x1 - x0 - 1)<<10)/len;
	}
	for(i=0;i<len;i++)
  28153b:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  28153f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  281542:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  281545:	75 d7                	jne    28151e <drawline8_sht+0xdd>
		sht->buf[(y>>10)*sht->bxsize+(x>>10)] = col;
		x += dx;
		y += dy;
	}
	return;
}
  281547:	83 c4 10             	add    $0x10,%esp
  28154a:	5b                   	pop    %ebx
  28154b:	5e                   	pop    %esi
  28154c:	5f                   	pop    %edi
  28154d:	5d                   	pop    %ebp
  28154e:	c3                   	ret    

0028154f <putfont8>:
#include "fontascii.h"
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
  28154f:	55                   	push   %ebp
  281550:	89 e5                	mov    %esp,%ebp
  281552:	57                   	push   %edi
  281553:	56                   	push   %esi
  281554:	53                   	push   %ebx
  281555:	83 ec 08             	sub    $0x8,%esp
  281558:	8b 45 0c             	mov    0xc(%ebp),%eax
  28155b:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  28155e:	0f b6 75 18          	movzbl 0x18(%ebp),%esi
  281562:	89 fb                	mov    %edi,%ebx
  281564:	89 45 ec             	mov    %eax,-0x14(%ebp)
  281567:	0f af 45 14          	imul   0x14(%ebp),%eax
  28156b:	03 45 10             	add    0x10(%ebp),%eax
  28156e:	89 c1                	mov    %eax,%ecx
  281570:	03 4d 08             	add    0x8(%ebp),%ecx
  281573:	83 c7 10             	add    $0x10,%edi
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
  281576:	0f b6 13             	movzbl (%ebx),%edx
		int col = HKK_TABLE_COL-1;
  281579:	b8 07 00 00 00       	mov    $0x7,%eax
  28157e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  281581:	89 f1                	mov    %esi,%ecx
  281583:	89 de                	mov    %ebx,%esi
  281585:	89 cb                	mov    %ecx,%ebx
		for(;col>=0;col--)
		{
			if(d&0x1) p[col] = c;
  281587:	f6 c2 01             	test   $0x1,%dl
  28158a:	74 06                	je     281592 <putfont8+0x43>
  28158c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  28158f:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
			d=d>>1;
  281592:	d0 ea                	shr    %dl
	for(i=0;i<HKK_TABLE_ROW;i++)
	{
		p = vram + (y+i)*xsize+x;
		d = font[i];
		int col = HKK_TABLE_COL-1;
		for(;col>=0;col--)
  281594:	83 e8 01             	sub    $0x1,%eax
  281597:	83 f8 ff             	cmp    $0xffffffff,%eax
  28159a:	75 eb                	jne    281587 <putfont8+0x38>
  28159c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  28159f:	89 d8                	mov    %ebx,%eax
  2815a1:	89 f3                	mov    %esi,%ebx
  2815a3:	89 c6                	mov    %eax,%esi
  2815a5:	83 c3 01             	add    $0x1,%ebx
  2815a8:	03 4d ec             	add    -0x14(%ebp),%ecx
void putfont8(char *vram, int xsize,int x,int y,char c,unsigned char *font)
{
	int i;
	char *p;
	unsigned char d;
	for(i=0;i<HKK_TABLE_ROW;i++)
  2815ab:	39 fb                	cmp    %edi,%ebx
  2815ad:	75 c7                	jne    281576 <putfont8+0x27>
			if(d&0x1) p[col] = c;
			d=d>>1;
		}
	}

}
  2815af:	83 c4 08             	add    $0x8,%esp
  2815b2:	5b                   	pop    %ebx
  2815b3:	5e                   	pop    %esi
  2815b4:	5f                   	pop    %edi
  2815b5:	5d                   	pop    %ebp
  2815b6:	c3                   	ret    

002815b7 <putfonts8_asc>:

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
  2815b7:	55                   	push   %ebp
  2815b8:	89 e5                	mov    %esp,%ebp
  2815ba:	57                   	push   %edi
  2815bb:	56                   	push   %esi
  2815bc:	53                   	push   %ebx
  2815bd:	8b 75 10             	mov    0x10(%ebp),%esi
  2815c0:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
  2815c3:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
	extern char hankaku[];
	for(;*s !=0x00;s++)
  2815c7:	0f b6 03             	movzbl (%ebx),%eax
  2815ca:	84 c0                	test   %al,%al
  2815cc:	74 2f                	je     2815fd <putfonts8_asc+0x46>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
  2815ce:	0f be fa             	movsbl %dl,%edi
  2815d1:	0f b6 c0             	movzbl %al,%eax
  2815d4:	c1 e0 04             	shl    $0x4,%eax
  2815d7:	05 60 59 28 00       	add    $0x285960,%eax
  2815dc:	50                   	push   %eax
  2815dd:	57                   	push   %edi
  2815de:	ff 75 14             	pushl  0x14(%ebp)
  2815e1:	56                   	push   %esi
  2815e2:	ff 75 0c             	pushl  0xc(%ebp)
  2815e5:	ff 75 08             	pushl  0x8(%ebp)
  2815e8:	e8 62 ff ff ff       	call   28154f <putfont8>
		x+=HKK_TABLE_COL;
  2815ed:	83 c6 08             	add    $0x8,%esi
}

void putfonts8_asc(char *vram,int xsize,int x,int y,char c,unsigned char *s)
{
	extern char hankaku[];
	for(;*s !=0x00;s++)
  2815f0:	83 c3 01             	add    $0x1,%ebx
  2815f3:	0f b6 03             	movzbl (%ebx),%eax
  2815f6:	83 c4 18             	add    $0x18,%esp
  2815f9:	84 c0                	test   %al,%al
  2815fb:	75 d4                	jne    2815d1 <putfonts8_asc+0x1a>
	{
		putfont8(vram,xsize,x,y,c,hankaku+*s*HKK_TABLE_ROW);
		x+=HKK_TABLE_COL;
	}
	return; 
}
  2815fd:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281600:	5b                   	pop    %ebx
  281601:	5e                   	pop    %esi
  281602:	5f                   	pop    %edi
  281603:	5d                   	pop    %ebp
  281604:	c3                   	ret    

00281605 <set_segmdesc>:
#include "dsctbl.h"
#include "io.h"

void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit,int base,int ar)
{
  281605:	55                   	push   %ebp
  281606:	89 e5                	mov    %esp,%ebp
  281608:	57                   	push   %edi
  281609:	56                   	push   %esi
  28160a:	53                   	push   %ebx
  28160b:	8b 55 08             	mov    0x8(%ebp),%edx
  28160e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281611:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281614:	8b 7d 14             	mov    0x14(%ebp),%edi
	if(limit>0xfffff)
  281617:	81 fb ff ff 0f 00    	cmp    $0xfffff,%ebx
  28161d:	76 09                	jbe    281628 <set_segmdesc+0x23>
	{
		ar |= 0x8000;
  28161f:	81 cf 00 80 00 00    	or     $0x8000,%edi
		limit /= 0x1000;
  281625:	c1 eb 0c             	shr    $0xc,%ebx
	}
	sd->limit_low = limit&0xffff;
  281628:	66 89 1a             	mov    %bx,(%edx)
	sd->base_low = base&0xffff;
  28162b:	66 89 4a 02          	mov    %cx,0x2(%edx)
	sd->base_mid = (base>>16) & 0xff;
  28162f:	89 ce                	mov    %ecx,%esi
  281631:	c1 fe 10             	sar    $0x10,%esi
  281634:	89 f0                	mov    %esi,%eax
  281636:	88 42 04             	mov    %al,0x4(%edx)
	sd->access_right = ar & 0xff;
  281639:	89 f8                	mov    %edi,%eax
  28163b:	88 42 05             	mov    %al,0x5(%edx)
	sd->limit_high = ((limit>>16)&0x0f) | ((ar>>8)&0xf0);
  28163e:	c1 eb 10             	shr    $0x10,%ebx
  281641:	83 e3 0f             	and    $0xf,%ebx
  281644:	89 f8                	mov    %edi,%eax
  281646:	c1 f8 08             	sar    $0x8,%eax
  281649:	83 e0 f0             	and    $0xfffffff0,%eax
  28164c:	09 d8                	or     %ebx,%eax
  28164e:	88 42 06             	mov    %al,0x6(%edx)
	sd->base_high = (base>>24)&0xff;
  281651:	c1 e9 18             	shr    $0x18,%ecx
  281654:	88 4a 07             	mov    %cl,0x7(%edx)
	return;
}
  281657:	5b                   	pop    %ebx
  281658:	5e                   	pop    %esi
  281659:	5f                   	pop    %edi
  28165a:	5d                   	pop    %ebp
  28165b:	c3                   	ret    

0028165c <set_gatedesc>:

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
  28165c:	55                   	push   %ebp
  28165d:	89 e5                	mov    %esp,%ebp
  28165f:	53                   	push   %ebx
  281660:	8b 45 08             	mov    0x8(%ebp),%eax
  281663:	8b 55 0c             	mov    0xc(%ebp),%edx
  281666:	8b 4d 14             	mov    0x14(%ebp),%ecx
	gd->offset_low = offset & 0xffff;
  281669:	66 89 10             	mov    %dx,(%eax)
	gd->selector = selector;
  28166c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  28166f:	66 89 58 02          	mov    %bx,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  281673:	89 cb                	mov    %ecx,%ebx
  281675:	c1 fb 08             	sar    $0x8,%ebx
  281678:	88 58 04             	mov    %bl,0x4(%eax)
	gd->access_right = ar&0xff;
  28167b:	88 48 05             	mov    %cl,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  28167e:	c1 ea 10             	shr    $0x10,%edx
  281681:	66 89 50 06          	mov    %dx,0x6(%eax)
	return;
}
  281685:	5b                   	pop    %ebx
  281686:	5d                   	pop    %ebp
  281687:	c3                   	ret    

00281688 <init_gdtidt>:

void init_gdtidt(void)
{
  281688:	55                   	push   %ebp
  281689:	89 e5                	mov    %esp,%ebp
  28168b:	53                   	push   %ebx
  28168c:	83 ec 04             	sub    $0x4,%esp
  28168f:	bb 00 00 27 00       	mov    $0x270000,%ebx
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
	{
		set_segmdesc(gdt+i,0,0,0);
  281694:	6a 00                	push   $0x0
  281696:	6a 00                	push   $0x0
  281698:	6a 00                	push   $0x0
  28169a:	53                   	push   %ebx
  28169b:	e8 65 ff ff ff       	call   281605 <set_segmdesc>
  2816a0:	83 c3 08             	add    $0x8,%ebx
{
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *) ADR_GDT;
	struct GATE_DESCRIPTOR *idt = (struct GATE_DESCRIPTOR *) ADR_IDT;
	int i;

	for(i=0;i<8192;i++)
  2816a3:	83 c4 10             	add    $0x10,%esp
  2816a6:	81 fb 00 00 28 00    	cmp    $0x280000,%ebx
  2816ac:	75 e6                	jne    281694 <init_gdtidt+0xc>
	{
		set_segmdesc(gdt+i,0,0,0);
	}
	//must be similiar with bootstrap gdt.
	//otherwise the code will run with different segment descriptor.
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
  2816ae:	68 92 40 00 00       	push   $0x4092
  2816b3:	6a 00                	push   $0x0
  2816b5:	6a ff                	push   $0xffffffff
  2816b7:	68 08 00 27 00       	push   $0x270008
  2816bc:	e8 44 ff ff ff       	call   281605 <set_segmdesc>
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
  2816c1:	68 9a 40 00 00       	push   $0x409a
  2816c6:	6a 00                	push   $0x0
  2816c8:	68 ff ff 0f 00       	push   $0xfffff
  2816cd:	68 10 00 27 00       	push   $0x270010
  2816d2:	e8 2e ff ff ff       	call   281605 <set_segmdesc>
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
  2816d7:	83 c4 20             	add    $0x20,%esp
  2816da:	68 9a 40 00 00       	push   $0x409a
  2816df:	68 00 00 28 00       	push   $0x280000
  2816e4:	68 ff ff 07 00       	push   $0x7ffff
  2816e9:	68 18 00 27 00       	push   $0x270018
  2816ee:	e8 12 ff ff ff       	call   281605 <set_segmdesc>
	load_gdtr(LIMIT_GDT,ADR_GDT);
  2816f3:	83 c4 08             	add    $0x8,%esp
  2816f6:	68 00 00 27 00       	push   $0x270000
  2816fb:	68 ff ff 00 00       	push   $0xffff
  281700:	e8 2a f6 ff ff       	call   280d2f <load_gdtr>
  281705:	83 c4 10             	add    $0x10,%esp
  281708:	b8 00 f8 26 00       	mov    $0x26f800,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28170d:	66 c7 00 00 00       	movw   $0x0,(%eax)
	gd->selector = selector;
  281712:	66 c7 40 02 00 00    	movw   $0x0,0x2(%eax)
	gd->dw_count = (ar>>8) & 0xff;
  281718:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	gd->access_right = ar&0xff;
  28171c:	c6 40 05 00          	movb   $0x0,0x5(%eax)
	gd->offset_high = (offset>>16)&0xffff;
  281720:	66 c7 40 06 00 00    	movw   $0x0,0x6(%eax)
  281726:	83 c0 08             	add    $0x8,%eax
	set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
	set_segmdesc(gdt+2,0x000fffff,0x00000000,AR_CODE32_ER);
	set_segmdesc(gdt+3,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
	load_gdtr(LIMIT_GDT,ADR_GDT);

	for(i=0;i<256;i++)
  281729:	3d 00 00 27 00       	cmp    $0x270000,%eax
  28172e:	75 dd                	jne    28170d <init_gdtidt+0x85>
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
  281730:	b8 de 19 00 00       	mov    $0x19de,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281735:	66 a3 00 f9 26 00    	mov    %ax,0x26f900
	gd->selector = selector;
  28173b:	66 c7 05 02 f9 26 00 	movw   $0x18,0x26f902
  281742:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  281744:	c6 05 04 f9 26 00 00 	movb   $0x0,0x26f904
	gd->access_right = ar&0xff;
  28174b:	c6 05 05 f9 26 00 8e 	movb   $0x8e,0x26f905
	gd->offset_high = (offset>>16)&0xffff;
  281752:	c1 e8 10             	shr    $0x10,%eax
  281755:	66 a3 06 f9 26 00    	mov    %ax,0x26f906
	for(i=0;i<256;i++)
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
  28175b:	b8 b0 19 00 00       	mov    $0x19b0,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  281760:	66 a3 08 f9 26 00    	mov    %ax,0x26f908
	gd->selector = selector;
  281766:	66 c7 05 0a f9 26 00 	movw   $0x18,0x26f90a
  28176d:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  28176f:	c6 05 0c f9 26 00 00 	movb   $0x0,0x26f90c
	gd->access_right = ar&0xff;
  281776:	c6 05 0d f9 26 00 8e 	movb   $0x8e,0x26f90d
	gd->offset_high = (offset>>16)&0xffff;
  28177d:	c1 e8 10             	shr    $0x10,%eax
  281780:	66 a3 0e f9 26 00    	mov    %ax,0x26f90e
	{
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
  281786:	b8 c7 19 00 00       	mov    $0x19c7,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28178b:	66 a3 60 f9 26 00    	mov    %ax,0x26f960
	gd->selector = selector;
  281791:	66 c7 05 62 f9 26 00 	movw   $0x18,0x26f962
  281798:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  28179a:	c6 05 64 f9 26 00 00 	movb   $0x0,0x26f964
	gd->access_right = ar&0xff;
  2817a1:	c6 05 65 f9 26 00 8e 	movb   $0x8e,0x26f965
	gd->offset_high = (offset>>16)&0xffff;
  2817a8:	c1 e8 10             	shr    $0x10,%eax
  2817ab:	66 a3 66 f9 26 00    	mov    %ax,0x26f966
		set_gatedesc(idt+i,0,0,0);
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
  2817b1:	b8 f5 19 00 00       	mov    $0x19f5,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2817b6:	66 a3 00 fa 26 00    	mov    %ax,0x26fa00
	gd->selector = selector;
  2817bc:	66 c7 05 02 fa 26 00 	movw   $0x18,0x26fa02
  2817c3:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2817c5:	c6 05 04 fa 26 00 00 	movb   $0x0,0x26fa04
	gd->access_right = ar&0xff;
  2817cc:	c6 05 05 fa 26 00 ee 	movb   $0xee,0x26fa05
	gd->offset_high = (offset>>16)&0xffff;
  2817d3:	c1 e8 10             	shr    $0x10,%eax
  2817d6:	66 a3 06 fa 26 00    	mov    %ax,0x26fa06
	}
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
  2817dc:	b8 16 1a 00 00       	mov    $0x1a16,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  2817e1:	66 a3 68 f8 26 00    	mov    %ax,0x26f868
	gd->selector = selector;
  2817e7:	66 c7 05 6a f8 26 00 	movw   $0x18,0x26f86a
  2817ee:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  2817f0:	c6 05 6c f8 26 00 00 	movb   $0x0,0x26f86c
	gd->access_right = ar&0xff;
  2817f7:	c6 05 6d f8 26 00 8e 	movb   $0x8e,0x26f86d
	gd->offset_high = (offset>>16)&0xffff;
  2817fe:	c1 e8 10             	shr    $0x10,%eax
  281801:	66 a3 6e f8 26 00    	mov    %ax,0x26f86e
	set_gatedesc(idt+0x20,(int)asm_inthandler20 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
  281807:	b8 36 1a 00 00       	mov    $0x1a36,%eax
	return;
}

void set_gatedesc(struct GATE_DESCRIPTOR *gd,int offset,int selector,int ar)
{
	gd->offset_low = offset & 0xffff;
  28180c:	66 a3 60 f8 26 00    	mov    %ax,0x26f860
	gd->selector = selector;
  281812:	66 c7 05 62 f8 26 00 	movw   $0x18,0x26f862
  281819:	18 00 
	gd->dw_count = (ar>>8) & 0xff;
  28181b:	c6 05 64 f8 26 00 00 	movb   $0x0,0x26f864
	gd->access_right = ar&0xff;
  281822:	c6 05 65 f8 26 00 8e 	movb   $0x8e,0x26f865
	gd->offset_high = (offset>>16)&0xffff;
  281829:	c1 e8 10             	shr    $0x10,%eax
  28182c:	66 a3 66 f8 26 00    	mov    %ax,0x26f866
	set_gatedesc(idt+0x21,(int)asm_inthandler21 - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x2c,(int)asm_inthandler2c - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x40,(int)asm_sys_api - 0x280000,3*8,AR_INTGATE32+0x60);
	set_gatedesc(idt+0x0d,(int)asm_inthandler0d - 0x280000,3*8,AR_INTGATE32);
	set_gatedesc(idt+0x0c,(int)asm_inthandler0c - 0x280000,3*8,AR_INTGATE32);
	load_idtr(LIMIT_IDT,ADR_IDT);
  281832:	83 ec 08             	sub    $0x8,%esp
  281835:	68 00 f8 26 00       	push   $0x26f800
  28183a:	68 ff 07 00 00       	push   $0x7ff
  28183f:	e8 fb f4 ff ff       	call   280d3f <load_idtr>

	return;
  281844:	83 c4 10             	add    $0x10,%esp
}
  281847:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  28184a:	c9                   	leave  
  28184b:	c3                   	ret    

0028184c <init_pic>:
#include "const.h"
#include "fifo.h"
#include "timer.h"
#include "string.h"
void init_pic(void)
{
  28184c:	55                   	push   %ebp
  28184d:	89 e5                	mov    %esp,%ebp
  28184f:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIC0_IMR, 0xff);	//disable all pic0 int
  281852:	68 ff 00 00 00       	push   $0xff
  281857:	6a 21                	push   $0x21
  281859:	e8 a8 f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC1_IMR, 0xff);	//disable all pic1 int
  28185e:	83 c4 08             	add    $0x8,%esp
  281861:	68 ff 00 00 00       	push   $0xff
  281866:	68 a1 00 00 00       	push   $0xa1
  28186b:	e8 96 f4 ff ff       	call   280d06 <io_out8>

	io_out8(PIC0_ICW1, 0x11);	
  281870:	83 c4 08             	add    $0x8,%esp
  281873:	6a 11                	push   $0x11
  281875:	6a 20                	push   $0x20
  281877:	e8 8a f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC0_ICW2, 0x20);
  28187c:	83 c4 08             	add    $0x8,%esp
  28187f:	6a 20                	push   $0x20
  281881:	6a 21                	push   $0x21
  281883:	e8 7e f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC0_ICW3, 1 << 2);
  281888:	83 c4 08             	add    $0x8,%esp
  28188b:	6a 04                	push   $0x4
  28188d:	6a 21                	push   $0x21
  28188f:	e8 72 f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC0_ICW4, 0x01);
  281894:	83 c4 08             	add    $0x8,%esp
  281897:	6a 01                	push   $0x1
  281899:	6a 21                	push   $0x21
  28189b:	e8 66 f4 ff ff       	call   280d06 <io_out8>

	io_out8(PIC1_ICW1, 0x11);
  2818a0:	83 c4 08             	add    $0x8,%esp
  2818a3:	6a 11                	push   $0x11
  2818a5:	68 a0 00 00 00       	push   $0xa0
  2818aa:	e8 57 f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC1_ICW2, 0x28);
  2818af:	83 c4 08             	add    $0x8,%esp
  2818b2:	6a 28                	push   $0x28
  2818b4:	68 a1 00 00 00       	push   $0xa1
  2818b9:	e8 48 f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC1_ICW3, 2);
  2818be:	83 c4 08             	add    $0x8,%esp
  2818c1:	6a 02                	push   $0x2
  2818c3:	68 a1 00 00 00       	push   $0xa1
  2818c8:	e8 39 f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC1_ICW4, 0x01);
  2818cd:	83 c4 08             	add    $0x8,%esp
  2818d0:	6a 01                	push   $0x1
  2818d2:	68 a1 00 00 00       	push   $0xa1
  2818d7:	e8 2a f4 ff ff       	call   280d06 <io_out8>

	io_out8(PIC0_IMR, 0xfb);
  2818dc:	83 c4 08             	add    $0x8,%esp
  2818df:	68 fb 00 00 00       	push   $0xfb
  2818e4:	6a 21                	push   $0x21
  2818e6:	e8 1b f4 ff ff       	call   280d06 <io_out8>
	io_out8(PIC1_IMR, 0xff);
  2818eb:	83 c4 08             	add    $0x8,%esp
  2818ee:	68 ff 00 00 00       	push   $0xff
  2818f3:	68 a1 00 00 00       	push   $0xa1
  2818f8:	e8 09 f4 ff ff       	call   280d06 <io_out8>
}
  2818fd:	83 c4 10             	add    $0x10,%esp
  281900:	c9                   	leave  
  281901:	c3                   	ret    

00281902 <inthandler0d>:

//when app code execute or access sys code or mem
int *inthandler0d(int *esp)
{
  281902:	55                   	push   %ebp
  281903:	89 e5                	mov    %esp,%ebp
  281905:	57                   	push   %edi
  281906:	56                   	push   %esi
  281907:	53                   	push   %ebx
  281908:	83 ec 2c             	sub    $0x2c,%esp
	struct CONSOLE *cons = (struct CONSOLE *)*((int *)0x0fec);
  28190b:	8b 35 ec 0f 00 00    	mov    0xfec,%esi
	struct TASK *task = task_now();
  281911:	e8 1c 15 00 00       	call   282e32 <task_now>
  281916:	89 c3                	mov    %eax,%ebx
	cons_putstr0(cons,"\nINT 0D:\n General Protected Exception.\n");
  281918:	83 ec 08             	sub    $0x8,%esp
  28191b:	68 80 49 28 00       	push   $0x284980
  281920:	56                   	push   %esi
  281921:	e8 34 22 00 00       	call   283b5a <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  281926:	83 c4 0c             	add    $0xc,%esp
  281929:	8b 45 08             	mov    0x8(%ebp),%eax
  28192c:	ff 70 2c             	pushl  0x2c(%eax)
  28192f:	68 a8 49 28 00       	push   $0x2849a8
  281934:	8d 7d ca             	lea    -0x36(%ebp),%edi
  281937:	57                   	push   %edi
  281938:	e8 40 02 00 00       	call   281b7d <sprintf>
	cons_putstr0(cons,s);
  28193d:	83 c4 08             	add    $0x8,%esp
  281940:	57                   	push   %edi
  281941:	56                   	push   %esi
  281942:	e8 13 22 00 00       	call   283b5a <cons_putstr0>
	return &(task->tss.esp0);
  281947:	8d 43 30             	lea    0x30(%ebx),%eax
}
  28194a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28194d:	5b                   	pop    %ebx
  28194e:	5e                   	pop    %esi
  28194f:	5f                   	pop    %edi
  281950:	5d                   	pop    %ebp
  281951:	c3                   	ret    

00281952 <inthandler0c>:


//when code write beyond stack too much
int *inthandler0c(int *esp)
{
  281952:	55                   	push   %ebp
  281953:	89 e5                	mov    %esp,%ebp
  281955:	57                   	push   %edi
  281956:	56                   	push   %esi
  281957:	53                   	push   %ebx
  281958:	83 ec 2c             	sub    $0x2c,%esp
	struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
  28195b:	8b 35 ec 0f 00 00    	mov    0xfec,%esi
	struct TASK *task = task_now();
  281961:	e8 cc 14 00 00       	call   282e32 <task_now>
  281966:	89 c3                	mov    %eax,%ebx
	cons_putstr0(cons,"\nINT 0C:\n Stack Exception.\n");
  281968:	83 ec 08             	sub    $0x8,%esp
  28196b:	68 b0 49 28 00       	push   $0x2849b0
  281970:	56                   	push   %esi
  281971:	e8 e4 21 00 00       	call   283b5a <cons_putstr0>
	char s[30];
	sprintf(s,"EIP=%x\n",esp[11]);
  281976:	83 c4 0c             	add    $0xc,%esp
  281979:	8b 45 08             	mov    0x8(%ebp),%eax
  28197c:	ff 70 2c             	pushl  0x2c(%eax)
  28197f:	68 a8 49 28 00       	push   $0x2849a8
  281984:	8d 7d ca             	lea    -0x36(%ebp),%edi
  281987:	57                   	push   %edi
  281988:	e8 f0 01 00 00       	call   281b7d <sprintf>
	cons_putstr0(cons,s);
  28198d:	83 c4 08             	add    $0x8,%esp
  281990:	57                   	push   %edi
  281991:	56                   	push   %esi
  281992:	e8 c3 21 00 00       	call   283b5a <cons_putstr0>
	return &(task->tss.esp0);
  281997:	8d 43 30             	lea    0x30(%ebx),%eax
}
  28199a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  28199d:	5b                   	pop    %ebx
  28199e:	5e                   	pop    %esi
  28199f:	5f                   	pop    %edi
  2819a0:	5d                   	pop    %ebp
  2819a1:	c3                   	ret    
  2819a2:	66 90                	xchg   %ax,%ax
  2819a4:	66 90                	xchg   %ax,%ax
  2819a6:	66 90                	xchg   %ax,%ax
  2819a8:	66 90                	xchg   %ax,%ax
  2819aa:	66 90                	xchg   %ax,%ax
  2819ac:	66 90                	xchg   %ax,%ax
  2819ae:	66 90                	xchg   %ax,%ax

002819b0 <asm_inthandler21>:
  2819b0:	06                   	push   %es
  2819b1:	1e                   	push   %ds
  2819b2:	60                   	pusha  
  2819b3:	89 e0                	mov    %esp,%eax
  2819b5:	50                   	push   %eax
  2819b6:	66 8c d0             	mov    %ss,%ax
  2819b9:	8e d8                	mov    %eax,%ds
  2819bb:	8e c0                	mov    %eax,%es
  2819bd:	e8 ed 05 00 00       	call   281faf <inthandler21>
  2819c2:	58                   	pop    %eax
  2819c3:	61                   	popa   
  2819c4:	1f                   	pop    %ds
  2819c5:	07                   	pop    %es
  2819c6:	cf                   	iret   

002819c7 <asm_inthandler2c>:
  2819c7:	06                   	push   %es
  2819c8:	1e                   	push   %ds
  2819c9:	60                   	pusha  
  2819ca:	89 e0                	mov    %esp,%eax
  2819cc:	50                   	push   %eax
  2819cd:	66 8c d0             	mov    %ss,%ax
  2819d0:	8e d8                	mov    %eax,%ds
  2819d2:	8e c0                	mov    %eax,%es
  2819d4:	e8 3c 05 00 00       	call   281f15 <inthandler2c>
  2819d9:	58                   	pop    %eax
  2819da:	61                   	popa   
  2819db:	1f                   	pop    %ds
  2819dc:	07                   	pop    %es
  2819dd:	cf                   	iret   

002819de <asm_inthandler20>:
  2819de:	06                   	push   %es
  2819df:	1e                   	push   %ds
  2819e0:	60                   	pusha  
  2819e1:	89 e0                	mov    %esp,%eax
  2819e3:	50                   	push   %eax
  2819e4:	66 8c d0             	mov    %ss,%ax
  2819e7:	8e d8                	mov    %eax,%ds
  2819e9:	8e c0                	mov    %eax,%es
  2819eb:	e8 7f 12 00 00       	call   282c6f <inthandler20>
  2819f0:	58                   	pop    %eax
  2819f1:	61                   	popa   
  2819f2:	1f                   	pop    %ds
  2819f3:	07                   	pop    %es
  2819f4:	cf                   	iret   

002819f5 <asm_sys_api>:
  2819f5:	fb                   	sti    
  2819f6:	1e                   	push   %ds
  2819f7:	06                   	push   %es
  2819f8:	60                   	pusha  
  2819f9:	60                   	pusha  
  2819fa:	66 8c d0             	mov    %ss,%ax
  2819fd:	8e d8                	mov    %eax,%ds
  2819ff:	8e c0                	mov    %eax,%es
  281a01:	e8 58 25 00 00       	call   283f5e <sys_api>
  281a06:	83 f8 00             	cmp    $0x0,%eax
  281a09:	75 07                	jne    281a12 <end_app>
  281a0b:	83 c4 20             	add    $0x20,%esp
  281a0e:	61                   	popa   
  281a0f:	07                   	pop    %es
  281a10:	1f                   	pop    %ds
  281a11:	cf                   	iret   

00281a12 <end_app>:
  281a12:	8b 20                	mov    (%eax),%esp
  281a14:	61                   	popa   
  281a15:	c3                   	ret    

00281a16 <asm_inthandler0d>:
  281a16:	fb                   	sti    
  281a17:	06                   	push   %es
  281a18:	1e                   	push   %ds
  281a19:	60                   	pusha  
  281a1a:	89 e0                	mov    %esp,%eax
  281a1c:	50                   	push   %eax
  281a1d:	66 8c d0             	mov    %ss,%ax
  281a20:	8e d8                	mov    %eax,%ds
  281a22:	8e c0                	mov    %eax,%es
  281a24:	e8 d9 fe ff ff       	call   281902 <inthandler0d>
  281a29:	83 f8 00             	cmp    $0x0,%eax
  281a2c:	75 e4                	jne    281a12 <end_app>
  281a2e:	58                   	pop    %eax
  281a2f:	61                   	popa   
  281a30:	1f                   	pop    %ds
  281a31:	07                   	pop    %es
  281a32:	83 c4 04             	add    $0x4,%esp
  281a35:	cf                   	iret   

00281a36 <asm_inthandler0c>:
  281a36:	fb                   	sti    
  281a37:	06                   	push   %es
  281a38:	1e                   	push   %ds
  281a39:	60                   	pusha  
  281a3a:	89 e0                	mov    %esp,%eax
  281a3c:	50                   	push   %eax
  281a3d:	66 8c d0             	mov    %ss,%ax
  281a40:	8e d8                	mov    %eax,%ds
  281a42:	8e c0                	mov    %eax,%es
  281a44:	e8 09 ff ff ff       	call   281952 <inthandler0c>
  281a49:	83 f8 00             	cmp    $0x0,%eax
  281a4c:	75 c4                	jne    281a12 <end_app>
  281a4e:	58                   	pop    %eax
  281a4f:	61                   	popa   
  281a50:	1f                   	pop    %ds
  281a51:	07                   	pop    %es
  281a52:	83 c4 04             	add    $0x4,%esp
  281a55:	cf                   	iret   

00281a56 <itoa>:
#include"string.h"
void itoa(int value,char *buf){
  281a56:	55                   	push   %ebp
  281a57:	89 e5                	mov    %esp,%ebp
  281a59:	57                   	push   %edi
  281a5a:	56                   	push   %esi
  281a5b:	53                   	push   %ebx
  281a5c:	83 ec 10             	sub    $0x10,%esp
  281a5f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  281a62:	8b 7d 0c             	mov    0xc(%ebp),%edi
	char tmp_buf[10] = {0};
  281a65:	c7 45 ea 00 00 00 00 	movl   $0x0,-0x16(%ebp)
  281a6c:	c7 45 ee 00 00 00 00 	movl   $0x0,-0x12(%ebp)
  281a73:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%ebp)
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
  281a79:	85 c9                	test   %ecx,%ecx
  281a7b:	79 08                	jns    281a85 <itoa+0x2f>
		*buf++ = '-';
  281a7d:	c6 07 2d             	movb   $0x2d,(%edi)
		value = ~value + 1; 
  281a80:	f7 d9                	neg    %ecx
#include"string.h"
void itoa(int value,char *buf){
	char tmp_buf[10] = {0};
	char *tbp = tmp_buf;
	if((value >> 31) & 0x1){ // neg num 
		*buf++ = '-';
  281a82:	8d 7f 01             	lea    0x1(%edi),%edi
  281a85:	8d 5d ea             	lea    -0x16(%ebp),%ebx
		value = ~value + 1; 
	}

	do{
		*tbp++ = ('0' + (char)(value % 10));
  281a88:	be 67 66 66 66       	mov    $0x66666667,%esi
  281a8d:	83 c3 01             	add    $0x1,%ebx
  281a90:	89 c8                	mov    %ecx,%eax
  281a92:	f7 ee                	imul   %esi
  281a94:	c1 fa 02             	sar    $0x2,%edx
  281a97:	89 c8                	mov    %ecx,%eax
  281a99:	c1 f8 1f             	sar    $0x1f,%eax
  281a9c:	29 c2                	sub    %eax,%edx
  281a9e:	8d 04 92             	lea    (%edx,%edx,4),%eax
  281aa1:	01 c0                	add    %eax,%eax
  281aa3:	29 c1                	sub    %eax,%ecx
  281aa5:	83 c1 30             	add    $0x30,%ecx
  281aa8:	88 4b ff             	mov    %cl,-0x1(%ebx)
		value /= 10;
  281aab:	89 d1                	mov    %edx,%ecx
	}while(value);
  281aad:	85 d2                	test   %edx,%edx
  281aaf:	75 dc                	jne    281a8d <itoa+0x37>
	while(tmp_buf != tbp--)
  281ab1:	8d 73 ff             	lea    -0x1(%ebx),%esi
  281ab4:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281ab7:	39 c3                	cmp    %eax,%ebx
  281ab9:	74 20                	je     281adb <itoa+0x85>
  281abb:	89 f0                	mov    %esi,%eax
  281abd:	89 fa                	mov    %edi,%edx
  281abf:	8d 5d e9             	lea    -0x17(%ebp),%ebx
		*buf++ = *tbp;
  281ac2:	83 c2 01             	add    $0x1,%edx
  281ac5:	0f b6 08             	movzbl (%eax),%ecx
  281ac8:	88 4a ff             	mov    %cl,-0x1(%edx)

	do{
		*tbp++ = ('0' + (char)(value % 10));
		value /= 10;
	}while(value);
	while(tmp_buf != tbp--)
  281acb:	83 e8 01             	sub    $0x1,%eax
  281ace:	39 d8                	cmp    %ebx,%eax
  281ad0:	75 f0                	jne    281ac2 <itoa+0x6c>
  281ad2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  281ad5:	29 c6                	sub    %eax,%esi
  281ad7:	8d 7c 37 0b          	lea    0xb(%edi,%esi,1),%edi
		*buf++ = *tbp;
	*buf='\0';
  281adb:	c6 07 00             	movb   $0x0,(%edi)
}
  281ade:	83 c4 10             	add    $0x10,%esp
  281ae1:	5b                   	pop    %ebx
  281ae2:	5e                   	pop    %esi
  281ae3:	5f                   	pop    %edi
  281ae4:	5d                   	pop    %ebp
  281ae5:	c3                   	ret    

00281ae6 <xtoa>:
    else
        value = value + 48;
    return value;
}

void xtoa(unsigned int value,char *buf){
  281ae6:	55                   	push   %ebp
  281ae7:	89 e5                	mov    %esp,%ebp
  281ae9:	57                   	push   %edi
  281aea:	56                   	push   %esi
  281aeb:	53                   	push   %ebx
  281aec:	83 ec 20             	sub    $0x20,%esp
  281aef:	8b 45 08             	mov    0x8(%ebp),%eax
    char tmp_buf[30] = {0};
  281af2:	bb 00 00 00 00       	mov    $0x0,%ebx
  281af7:	c7 45 d6 00 00 00 00 	movl   $0x0,-0x2a(%ebp)
  281afe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  281b05:	b9 1c 00 00 00       	mov    $0x1c,%ecx
  281b0a:	ba 00 00 00 00       	mov    $0x0,%edx
  281b0f:	89 5c 15 d8          	mov    %ebx,-0x28(%ebp,%edx,1)
  281b13:	83 c2 04             	add    $0x4,%edx
  281b16:	39 ca                	cmp    %ecx,%edx
  281b18:	72 f5                	jb     281b0f <xtoa+0x29>
    char *tbp = tmp_buf;

    *buf++='0';
  281b1a:	8b 75 0c             	mov    0xc(%ebp),%esi
  281b1d:	c6 06 30             	movb   $0x30,(%esi)
    *buf++='x';
  281b20:	83 c6 02             	add    $0x2,%esi
  281b23:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281b26:	c6 43 01 78          	movb   $0x78,0x1(%ebx)
    return value;
}

void xtoa(unsigned int value,char *buf){
    char tmp_buf[30] = {0};
    char *tbp = tmp_buf;
  281b2a:	8d 5d d6             	lea    -0x2a(%ebp),%ebx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//
		*tbp++=fourbtoc(value&0x0000000f);
  281b2d:	83 c3 01             	add    $0x1,%ebx
  281b30:	89 c1                	mov    %eax,%ecx
  281b32:	83 e1 0f             	and    $0xf,%ecx
	*str='\0';
}

static  inline char fourbtoc(int value){
    if(value >= 10)
        value = value - 10 + 65;
  281b35:	8d 79 37             	lea    0x37(%ecx),%edi
  281b38:	8d 51 30             	lea    0x30(%ecx),%edx
  281b3b:	83 f9 0a             	cmp    $0xa,%ecx
  281b3e:	0f 4d d7             	cmovge %edi,%edx

    *buf++='0';
    *buf++='x';
    do{
        // *tbp++ = ('0' + (char)(value % 16));//
		*tbp++=fourbtoc(value&0x0000000f);
  281b41:	88 53 ff             	mov    %dl,-0x1(%ebx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//
		value >>= 4;
  281b44:	c1 e8 04             	shr    $0x4,%eax
    }while(value);
  281b47:	85 c0                	test   %eax,%eax
  281b49:	75 e2                	jne    281b2d <xtoa+0x47>
    
    while(tmp_buf != tbp){
  281b4b:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  281b4e:	39 c3                	cmp    %eax,%ebx
  281b50:	74 20                	je     281b72 <xtoa+0x8c>
  281b52:	89 d8                	mov    %ebx,%eax
  281b54:	89 f1                	mov    %esi,%ecx
  281b56:	8d 7d d6             	lea    -0x2a(%ebp),%edi
      tbp--;
  281b59:	83 e8 01             	sub    $0x1,%eax
      *buf++ = *tbp;
  281b5c:	83 c1 01             	add    $0x1,%ecx
  281b5f:	0f b6 10             	movzbl (%eax),%edx
  281b62:	88 51 ff             	mov    %dl,-0x1(%ecx)
        
        //*tbp++ = ((value % 16)>9)?('A' + (char)(value % 16-10)):('0' + (char)(value % 16));//
		value >>= 4;
    }while(value);
    
    while(tmp_buf != tbp){
  281b65:	39 f8                	cmp    %edi,%eax
  281b67:	75 f0                	jne    281b59 <xtoa+0x73>
  281b69:	8d 45 f4             	lea    -0xc(%ebp),%eax
  281b6c:	29 c3                	sub    %eax,%ebx
  281b6e:	8d 74 1e 1e          	lea    0x1e(%esi,%ebx,1),%esi
      tbp--;
      *buf++ = *tbp;
    }
    *buf='\0';
  281b72:	c6 06 00             	movb   $0x0,(%esi)
}
  281b75:	83 c4 20             	add    $0x20,%esp
  281b78:	5b                   	pop    %ebx
  281b79:	5e                   	pop    %esi
  281b7a:	5f                   	pop    %edi
  281b7b:	5d                   	pop    %ebp
  281b7c:	c3                   	ret    

00281b7d <sprintf>:
	while(tmp_buf != tbp--)
		*buf++ = *tbp;
	*buf='\0';
}

void sprintf(char *str,char *format ,...){
  281b7d:	55                   	push   %ebp
  281b7e:	89 e5                	mov    %esp,%ebp
  281b80:	57                   	push   %edi
  281b81:	56                   	push   %esi
  281b82:	53                   	push   %ebx
  281b83:	83 ec 10             	sub    $0x10,%esp
  281b86:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int *var=(int *)(&format)+1; //
  281b89:	8d 7d 10             	lea    0x10(%ebp),%edi
	char buffer[10];
	char *buf=buffer;
	while(*format){
  281b8c:	e9 a8 00 00 00       	jmp    281c39 <sprintf+0xbc>
		if(*format!='%'){
  281b91:	3c 25                	cmp    $0x25,%al
  281b93:	74 10                	je     281ba5 <sprintf+0x28>
			*str++=*format++;
  281b95:	83 c6 01             	add    $0x1,%esi
  281b98:	89 75 0c             	mov    %esi,0xc(%ebp)
  281b9b:	88 03                	mov    %al,(%ebx)
  281b9d:	8d 5b 01             	lea    0x1(%ebx),%ebx
			continue;
  281ba0:	e9 94 00 00 00       	jmp    281c39 <sprintf+0xbc>
		}
		else{
			format++;
  281ba5:	8d 46 01             	lea    0x1(%esi),%eax
  281ba8:	89 45 0c             	mov    %eax,0xc(%ebp)
			switch (*format){
  281bab:	0f b6 46 01          	movzbl 0x1(%esi),%eax
  281baf:	3c 73                	cmp    $0x73,%al
  281bb1:	74 5e                	je     281c11 <sprintf+0x94>
  281bb3:	3c 78                	cmp    $0x78,%al
  281bb5:	74 2f                	je     281be6 <sprintf+0x69>
  281bb7:	3c 64                	cmp    $0x64,%al
  281bb9:	75 75                	jne    281c30 <sprintf+0xb3>
				case 'd':itoa(*var,buf);while(*buf){*str++=*buf++;};break;
  281bbb:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281bbe:	50                   	push   %eax
  281bbf:	ff 37                	pushl  (%edi)
  281bc1:	e8 90 fe ff ff       	call   281a56 <itoa>
  281bc6:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281bca:	83 c4 08             	add    $0x8,%esp
  281bcd:	84 c0                	test   %al,%al
  281bcf:	74 5f                	je     281c30 <sprintf+0xb3>
  281bd1:	8d 55 ea             	lea    -0x16(%ebp),%edx
  281bd4:	83 c3 01             	add    $0x1,%ebx
  281bd7:	83 c2 01             	add    $0x1,%edx
  281bda:	88 43 ff             	mov    %al,-0x1(%ebx)
  281bdd:	0f b6 02             	movzbl (%edx),%eax
  281be0:	84 c0                	test   %al,%al
  281be2:	75 f0                	jne    281bd4 <sprintf+0x57>
  281be4:	eb 4a                	jmp    281c30 <sprintf+0xb3>
				case 'x':xtoa(*var,buf);while(*buf){*str++=*buf++;};break;
  281be6:	8d 45 ea             	lea    -0x16(%ebp),%eax
  281be9:	50                   	push   %eax
  281bea:	ff 37                	pushl  (%edi)
  281bec:	e8 f5 fe ff ff       	call   281ae6 <xtoa>
  281bf1:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
  281bf5:	83 c4 08             	add    $0x8,%esp
  281bf8:	84 c0                	test   %al,%al
  281bfa:	74 34                	je     281c30 <sprintf+0xb3>
  281bfc:	8d 55 ea             	lea    -0x16(%ebp),%edx
  281bff:	83 c3 01             	add    $0x1,%ebx
  281c02:	83 c2 01             	add    $0x1,%edx
  281c05:	88 43 ff             	mov    %al,-0x1(%ebx)
  281c08:	0f b6 02             	movzbl (%edx),%eax
  281c0b:	84 c0                	test   %al,%al
  281c0d:	75 f0                	jne    281bff <sprintf+0x82>
  281c0f:	eb 1f                	jmp    281c30 <sprintf+0xb3>
				case 's':buf=(char*)(*var);while(*buf){*str++=*buf++;};break;
  281c11:	8b 0f                	mov    (%edi),%ecx
  281c13:	0f b6 11             	movzbl (%ecx),%edx
  281c16:	84 d2                	test   %dl,%dl
  281c18:	74 16                	je     281c30 <sprintf+0xb3>
  281c1a:	89 d8                	mov    %ebx,%eax
  281c1c:	83 c0 01             	add    $0x1,%eax
  281c1f:	88 50 ff             	mov    %dl,-0x1(%eax)
  281c22:	89 c2                	mov    %eax,%edx
  281c24:	29 da                	sub    %ebx,%edx
  281c26:	0f b6 14 0a          	movzbl (%edx,%ecx,1),%edx
  281c2a:	84 d2                	test   %dl,%dl
  281c2c:	75 ee                	jne    281c1c <sprintf+0x9f>
  281c2e:	89 c3                	mov    %eax,%ebx
			}
			buf=buffer;
			var++;
  281c30:	83 c7 04             	add    $0x4,%edi
			format++;
  281c33:	83 c6 02             	add    $0x2,%esi
  281c36:	89 75 0c             	mov    %esi,0xc(%ebp)

void sprintf(char *str,char *format ,...){
	int *var=(int *)(&format)+1; //
	char buffer[10];
	char *buf=buffer;
	while(*format){
  281c39:	8b 75 0c             	mov    0xc(%ebp),%esi
  281c3c:	0f b6 06             	movzbl (%esi),%eax
  281c3f:	84 c0                	test   %al,%al
  281c41:	0f 85 4a ff ff ff    	jne    281b91 <sprintf+0x14>
			buf=buffer;
			var++;
			format++;
		}
	}
	*str='\0';
  281c47:	c6 03 00             	movb   $0x0,(%ebx)
}
  281c4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
  281c4d:	5b                   	pop    %ebx
  281c4e:	5e                   	pop    %esi
  281c4f:	5f                   	pop    %edi
  281c50:	5d                   	pop    %ebp
  281c51:	c3                   	ret    

00281c52 <strcmp>:
    }
    *buf='\0';
}

int strcmp(const char *str1,const char *str2)
{
  281c52:	55                   	push   %ebp
  281c53:	89 e5                	mov    %esp,%ebp
  281c55:	57                   	push   %edi
  281c56:	56                   	push   %esi
  281c57:	53                   	push   %ebx
  281c58:	8b 7d 08             	mov    0x8(%ebp),%edi
  281c5b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281c5e:	0f b6 17             	movzbl (%edi),%edx
  281c61:	be 00 00 00 00       	mov    $0x0,%esi
  281c66:	84 d2                	test   %dl,%dl
  281c68:	74 40                	je     281caa <strcmp+0x58>
  281c6a:	eb 1d                	jmp    281c89 <strcmp+0x37>
	{
		if(c1==c2) i++;
  281c6c:	38 ca                	cmp    %cl,%dl
  281c6e:	75 0f                	jne    281c7f <strcmp+0x2d>
  281c70:	83 c0 01             	add    $0x1,%eax

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281c73:	89 c6                	mov    %eax,%esi
  281c75:	0f b6 14 07          	movzbl (%edi,%eax,1),%edx
  281c79:	84 d2                	test   %dl,%dl
  281c7b:	75 1e                	jne    281c9b <strcmp+0x49>
  281c7d:	eb 2b                	jmp    281caa <strcmp+0x58>
	{
		if(c1==c2) i++;
		else return c1-c2;
  281c7f:	0f be c2             	movsbl %dl,%eax
  281c82:	0f be c9             	movsbl %cl,%ecx
  281c85:	29 c8                	sub    %ecx,%eax
  281c87:	eb 2a                	jmp    281cb3 <strcmp+0x61>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281c89:	0f b6 0b             	movzbl (%ebx),%ecx
  281c8c:	84 c9                	test   %cl,%cl
  281c8e:	74 15                	je     281ca5 <strcmp+0x53>
	{
		if(c1==c2) i++;
  281c90:	b8 00 00 00 00       	mov    $0x0,%eax
  281c95:	38 ca                	cmp    %cl,%dl
  281c97:	74 d7                	je     281c70 <strcmp+0x1e>
  281c99:	eb e4                	jmp    281c7f <strcmp+0x2d>

int strcmp(const char *str1,const char *str2)
{
	int i = 0;
	char c1,c2;
	while((c1 = str1[i]) && (c2 = str2[i]))
  281c9b:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  281c9f:	84 c9                	test   %cl,%cl
  281ca1:	75 c9                	jne    281c6c <strcmp+0x1a>
  281ca3:	eb 05                	jmp    281caa <strcmp+0x58>
  281ca5:	be 00 00 00 00       	mov    $0x0,%esi
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281caa:	0f be c2             	movsbl %dl,%eax
  281cad:	0f be 14 33          	movsbl (%ebx,%esi,1),%edx
  281cb1:	29 d0                	sub    %edx,%eax
}
  281cb3:	5b                   	pop    %ebx
  281cb4:	5e                   	pop    %esi
  281cb5:	5f                   	pop    %edi
  281cb6:	5d                   	pop    %ebp
  281cb7:	c3                   	ret    

00281cb8 <strncmp>:

int strncmp(const char *str1,const char *str2,unsigned int n)
{
  281cb8:	55                   	push   %ebp
  281cb9:	89 e5                	mov    %esp,%ebp
  281cbb:	57                   	push   %edi
  281cbc:	56                   	push   %esi
  281cbd:	53                   	push   %ebx
  281cbe:	8b 75 08             	mov    0x8(%ebp),%esi
  281cc1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281cc4:	8b 7d 10             	mov    0x10(%ebp),%edi
	if(n == 0) return 0;
  281cc7:	b8 00 00 00 00       	mov    $0x0,%eax
  281ccc:	85 ff                	test   %edi,%edi
  281cce:	74 63                	je     281d33 <strncmp+0x7b>
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281cd0:	83 ef 01             	sub    $0x1,%edi
  281cd3:	89 fa                	mov    %edi,%edx
  281cd5:	74 52                	je     281d29 <strncmp+0x71>
  281cd7:	eb 19                	jmp    281cf2 <strncmp+0x3a>
	{
		if(c1==c2) i++;
  281cd9:	38 c8                	cmp    %cl,%al
  281cdb:	75 0b                	jne    281ce8 <strncmp+0x30>
  281cdd:	83 c2 01             	add    $0x1,%edx
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281ce0:	39 fa                	cmp    %edi,%edx
  281ce2:	75 27                	jne    281d0b <strncmp+0x53>
	{
		if(c1==c2) i++;
  281ce4:	89 fa                	mov    %edi,%edx
  281ce6:	eb 41                	jmp    281d29 <strncmp+0x71>
		else return c1-c2;
  281ce8:	0f be c0             	movsbl %al,%eax
  281ceb:	0f be c9             	movsbl %cl,%ecx
  281cee:	29 c8                	sub    %ecx,%eax
  281cf0:	eb 41                	jmp    281d33 <strncmp+0x7b>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281cf2:	0f b6 06             	movzbl (%esi),%eax
  281cf5:	84 c0                	test   %al,%al
  281cf7:	74 24                	je     281d1d <strncmp+0x65>
  281cf9:	0f b6 0b             	movzbl (%ebx),%ecx
  281cfc:	84 c9                	test   %cl,%cl
  281cfe:	74 24                	je     281d24 <strncmp+0x6c>
	{
		if(c1==c2) i++;
  281d00:	ba 00 00 00 00       	mov    $0x0,%edx
  281d05:	38 c8                	cmp    %cl,%al
  281d07:	74 d4                	je     281cdd <strncmp+0x25>
  281d09:	eb dd                	jmp    281ce8 <strncmp+0x30>
int strncmp(const char *str1,const char *str2,unsigned int n)
{
	if(n == 0) return 0;
	unsigned int i = 0;
	char c1,c2;
	while(i<n-1 && (c1 = str1[i]) && (c2 = str2[i]))
  281d0b:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
  281d0f:	84 c0                	test   %al,%al
  281d11:	74 16                	je     281d29 <strncmp+0x71>
  281d13:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  281d17:	84 c9                	test   %cl,%cl
  281d19:	75 be                	jne    281cd9 <strncmp+0x21>
  281d1b:	eb 0c                	jmp    281d29 <strncmp+0x71>
  281d1d:	ba 00 00 00 00       	mov    $0x0,%edx
  281d22:	eb 05                	jmp    281d29 <strncmp+0x71>
  281d24:	ba 00 00 00 00       	mov    $0x0,%edx
	{
		if(c1==c2) i++;
		else return c1-c2;
	}
	return str1[i] - str2[i];
  281d29:	0f be 04 16          	movsbl (%esi,%edx,1),%eax
  281d2d:	0f be 14 13          	movsbl (%ebx,%edx,1),%edx
  281d31:	29 d0                	sub    %edx,%eax
}
  281d33:	5b                   	pop    %ebx
  281d34:	5e                   	pop    %esi
  281d35:	5f                   	pop    %edi
  281d36:	5d                   	pop    %ebp
  281d37:	c3                   	ret    

00281d38 <fifo32_init>:
#include "fifo.h"
#include "task.h"
void fifo32_init(struct FIFO32 *fifo,int size,int *buf,struct TASK *task)
{
  281d38:	55                   	push   %ebp
  281d39:	89 e5                	mov    %esp,%ebp
  281d3b:	8b 45 08             	mov    0x8(%ebp),%eax
  281d3e:	8b 55 0c             	mov    0xc(%ebp),%edx
	fifo->size=size;
  281d41:	89 50 0c             	mov    %edx,0xc(%eax)
	fifo->buf=buf;
  281d44:	8b 4d 10             	mov    0x10(%ebp),%ecx
  281d47:	89 08                	mov    %ecx,(%eax)
	fifo->free = size;
  281d49:	89 50 10             	mov    %edx,0x10(%eax)
	fifo->flags = 0;
  281d4c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
	fifo->p = 0;
  281d53:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->q = 0;
  281d5a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	fifo->task = task;
  281d61:	8b 55 14             	mov    0x14(%ebp),%edx
  281d64:	89 50 18             	mov    %edx,0x18(%eax)
	return;
}
  281d67:	5d                   	pop    %ebp
  281d68:	c3                   	ret    

00281d69 <fifo32_put>:
#define FLAGS_OVERRUN 0x0001
#include "timer.h"
extern struct TIMERCTL timerctl;

int fifo32_put(struct FIFO32 *fifo,int data)
{
  281d69:	55                   	push   %ebp
  281d6a:	89 e5                	mov    %esp,%ebp
  281d6c:	53                   	push   %ebx
  281d6d:	83 ec 04             	sub    $0x4,%esp
  281d70:	8b 45 08             	mov    0x8(%ebp),%eax
	if(fifo->free == 0)
  281d73:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  281d77:	75 0b                	jne    281d84 <fifo32_put+0x1b>
	{
		fifo->flags |= FLAGS_OVERRUN;
  281d79:	83 48 14 01          	orl    $0x1,0x14(%eax)
		return -1;
  281d7d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  281d82:	eb 52                	jmp    281dd6 <fifo32_put+0x6d>
	}
	fifo->buf[fifo->p] = data;
  281d84:	8b 48 04             	mov    0x4(%eax),%ecx
  281d87:	8b 10                	mov    (%eax),%edx
  281d89:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  281d8c:	89 1c 8a             	mov    %ebx,(%edx,%ecx,4)
	fifo->p++;
  281d8f:	8b 48 04             	mov    0x4(%eax),%ecx
  281d92:	8d 51 01             	lea    0x1(%ecx),%edx
  281d95:	89 50 04             	mov    %edx,0x4(%eax)
	if(fifo->p == fifo->size)
  281d98:	3b 50 0c             	cmp    0xc(%eax),%edx
  281d9b:	75 07                	jne    281da4 <fifo32_put+0x3b>
		fifo->p = 0;
  281d9d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	fifo->free--;
  281da4:	83 68 10 01          	subl   $0x1,0x10(%eax)

	//wake up task
	if(fifo->task!=0)
  281da8:	8b 50 18             	mov    0x18(%eax),%edx
  281dab:	85 d2                	test   %edx,%edx
  281dad:	74 22                	je     281dd1 <fifo32_put+0x68>
		if(fifo->task->flags!=2)
		{
			task_run(fifo->task,-1,0);
		}
	}
	return 0;
  281daf:	b8 00 00 00 00       	mov    $0x0,%eax
	fifo->free--;

	//wake up task
	if(fifo->task!=0)
	{
		if(fifo->task->flags!=2)
  281db4:	83 7a 04 02          	cmpl   $0x2,0x4(%edx)
  281db8:	74 1c                	je     281dd6 <fifo32_put+0x6d>
		{
			task_run(fifo->task,-1,0);
  281dba:	83 ec 04             	sub    $0x4,%esp
  281dbd:	6a 00                	push   $0x0
  281dbf:	6a ff                	push   $0xffffffff
  281dc1:	52                   	push   %edx
  281dc2:	e8 60 11 00 00       	call   282f27 <task_run>
  281dc7:	83 c4 10             	add    $0x10,%esp
		}
	}
	return 0;
  281dca:	b8 00 00 00 00       	mov    $0x0,%eax
  281dcf:	eb 05                	jmp    281dd6 <fifo32_put+0x6d>
  281dd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  281dd6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  281dd9:	c9                   	leave  
  281dda:	c3                   	ret    

00281ddb <fifo32_get>:

int fifo32_get(struct FIFO32 *fifo)
{
  281ddb:	55                   	push   %ebp
  281ddc:	89 e5                	mov    %esp,%ebp
  281dde:	56                   	push   %esi
  281ddf:	53                   	push   %ebx
  281de0:	8b 4d 08             	mov    0x8(%ebp),%ecx
	if(fifo->free == fifo->size)
  281de3:	8b 59 10             	mov    0x10(%ecx),%ebx
  281de6:	8b 71 0c             	mov    0xc(%ecx),%esi
  281de9:	39 f3                	cmp    %esi,%ebx
  281deb:	74 20                	je     281e0d <fifo32_get+0x32>
		return -1;
	int data = fifo->buf[fifo->q];
  281ded:	8b 51 08             	mov    0x8(%ecx),%edx
  281df0:	8b 01                	mov    (%ecx),%eax
  281df2:	8b 04 90             	mov    (%eax,%edx,4),%eax
	fifo->q++;
  281df5:	83 c2 01             	add    $0x1,%edx
	if(fifo->q == fifo->size)
  281df8:	39 d6                	cmp    %edx,%esi
int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
	int data = fifo->buf[fifo->q];
	fifo->q++;
  281dfa:	be 00 00 00 00       	mov    $0x0,%esi
  281dff:	0f 44 d6             	cmove  %esi,%edx
  281e02:	89 51 08             	mov    %edx,0x8(%ecx)
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
  281e05:	83 c3 01             	add    $0x1,%ebx
  281e08:	89 59 10             	mov    %ebx,0x10(%ecx)
	return data;
  281e0b:	eb 05                	jmp    281e12 <fifo32_get+0x37>
}

int fifo32_get(struct FIFO32 *fifo)
{
	if(fifo->free == fifo->size)
		return -1;
  281e0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	fifo->q++;
	if(fifo->q == fifo->size)
		fifo->q = 0;
	fifo->free++;
	return data;
}
  281e12:	5b                   	pop    %ebx
  281e13:	5e                   	pop    %esi
  281e14:	5d                   	pop    %ebp
  281e15:	c3                   	ret    

00281e16 <fifo32_status>:

int fifo32_status(struct FIFO32 *fifo)
{
  281e16:	55                   	push   %ebp
  281e17:	89 e5                	mov    %esp,%ebp
  281e19:	8b 55 08             	mov    0x8(%ebp),%edx
	return fifo->size - fifo->free;
  281e1c:	8b 42 0c             	mov    0xc(%edx),%eax
  281e1f:	2b 42 10             	sub    0x10(%edx),%eax
}
  281e22:	5d                   	pop    %ebp
  281e23:	c3                   	ret    

00281e24 <enable_mouse>:
#include "mouse.h"
struct FIFO32 *mousefifo;
int mousedata0;
void enable_mouse(struct FIFO32 *fifo,int data0,struct MOUSE_DEC *mdec)
{
  281e24:	55                   	push   %ebp
  281e25:	89 e5                	mov    %esp,%ebp
  281e27:	83 ec 08             	sub    $0x8,%esp
	mousefifo = fifo;
  281e2a:	8b 45 08             	mov    0x8(%ebp),%eax
  281e2d:	a3 44 73 28 00       	mov    %eax,0x287344
	mousedata0 = data0;
  281e32:	8b 45 0c             	mov    0xc(%ebp),%eax
  281e35:	a3 40 73 28 00       	mov    %eax,0x287340

	wait_KBC_sendready();
  281e3a:	e8 1a 01 00 00       	call   281f59 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_SENDTO_MOUSE);
  281e3f:	83 ec 08             	sub    $0x8,%esp
  281e42:	68 d4 00 00 00       	push   $0xd4
  281e47:	6a 64                	push   $0x64
  281e49:	e8 b8 ee ff ff       	call   280d06 <io_out8>
	wait_KBC_sendready();
  281e4e:	e8 06 01 00 00       	call   281f59 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,MOUSECMD_ENABLE);
  281e53:	83 c4 08             	add    $0x8,%esp
  281e56:	68 f4 00 00 00       	push   $0xf4
  281e5b:	6a 60                	push   $0x60
  281e5d:	e8 a4 ee ff ff       	call   280d06 <io_out8>
	mdec->phase = 0;
  281e62:	8b 45 10             	mov    0x10(%ebp),%eax
  281e65:	c6 40 03 00          	movb   $0x0,0x3(%eax)
	return;
  281e69:	83 c4 10             	add    $0x10,%esp
}
  281e6c:	c9                   	leave  
  281e6d:	c3                   	ret    

00281e6e <mouse_decode>:

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
  281e6e:	55                   	push   %ebp
  281e6f:	89 e5                	mov    %esp,%ebp
  281e71:	56                   	push   %esi
  281e72:	53                   	push   %ebx
  281e73:	8b 55 08             	mov    0x8(%ebp),%edx
  281e76:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	if(mdec->phase == 0)
  281e79:	0f b6 42 03          	movzbl 0x3(%edx),%eax
  281e7d:	84 c0                	test   %al,%al
  281e7f:	75 14                	jne    281e95 <mouse_decode+0x27>
	{
		if(dat == 0xfa)
			mdec->phase = 1;
		return 0;
  281e81:	b8 00 00 00 00       	mov    $0x0,%eax

int mouse_decode(struct MOUSE_DEC *mdec,unsigned char dat)
{
	if(mdec->phase == 0)
	{
		if(dat == 0xfa)
  281e86:	80 f9 fa             	cmp    $0xfa,%cl
  281e89:	0f 85 82 00 00 00    	jne    281f11 <mouse_decode+0xa3>
			mdec->phase = 1;
  281e8f:	c6 42 03 01          	movb   $0x1,0x3(%edx)
  281e93:	eb 7c                	jmp    281f11 <mouse_decode+0xa3>
		return 0;
	}
	if(mdec->phase == 1)
  281e95:	3c 01                	cmp    $0x1,%al
  281e97:	75 17                	jne    281eb0 <mouse_decode+0x42>
	{
		if((dat&0xc8) == 0x08)
  281e99:	89 cb                	mov    %ecx,%ebx
  281e9b:	83 e3 c8             	and    $0xffffffc8,%ebx
		{
			mdec->buf[0] = dat;
			mdec->phase = 2;
		}
		return 0;
  281e9e:	b8 00 00 00 00       	mov    $0x0,%eax
			mdec->phase = 1;
		return 0;
	}
	if(mdec->phase == 1)
	{
		if((dat&0xc8) == 0x08)
  281ea3:	80 fb 08             	cmp    $0x8,%bl
  281ea6:	75 69                	jne    281f11 <mouse_decode+0xa3>
		{
			mdec->buf[0] = dat;
  281ea8:	88 0a                	mov    %cl,(%edx)
			mdec->phase = 2;
  281eaa:	c6 42 03 02          	movb   $0x2,0x3(%edx)
  281eae:	eb 61                	jmp    281f11 <mouse_decode+0xa3>
		}
		return 0;
	}
	if(mdec->phase == 2)
  281eb0:	3c 02                	cmp    $0x2,%al
  281eb2:	75 0e                	jne    281ec2 <mouse_decode+0x54>
	{
		mdec->buf[1] = dat;
  281eb4:	88 4a 01             	mov    %cl,0x1(%edx)
		mdec->phase = 3;
  281eb7:	c6 42 03 03          	movb   $0x3,0x3(%edx)
		return 0;
  281ebb:	b8 00 00 00 00       	mov    $0x0,%eax
  281ec0:	eb 4f                	jmp    281f11 <mouse_decode+0xa3>
	}
	if(mdec->phase == 3)
  281ec2:	3c 03                	cmp    $0x3,%al
  281ec4:	75 46                	jne    281f0c <mouse_decode+0x9e>
	{
		mdec->buf[2] = dat;
  281ec6:	88 4a 02             	mov    %cl,0x2(%edx)
		mdec->phase = 1;
  281ec9:	c6 42 03 01          	movb   $0x1,0x3(%edx)
		mdec->btn = mdec->buf[0] & 0x07;
  281ecd:	0f b6 02             	movzbl (%edx),%eax
  281ed0:	89 c3                	mov    %eax,%ebx
  281ed2:	83 e3 07             	and    $0x7,%ebx
  281ed5:	89 5a 0c             	mov    %ebx,0xc(%edx)
		mdec->x = mdec->buf[1];
  281ed8:	0f b6 5a 01          	movzbl 0x1(%edx),%ebx
  281edc:	0f b6 f3             	movzbl %bl,%esi
  281edf:	89 72 04             	mov    %esi,0x4(%edx)
		
		mdec->y = mdec->buf[2];
  281ee2:	0f b6 f1             	movzbl %cl,%esi
  281ee5:	89 72 08             	mov    %esi,0x8(%edx)
		if((mdec->buf[0] & 0x10)!=0)
  281ee8:	a8 10                	test   $0x10,%al
  281eea:	74 09                	je     281ef5 <mouse_decode+0x87>
		{
			mdec->x |= 0xffffff00;
  281eec:	81 cb 00 ff ff ff    	or     $0xffffff00,%ebx
  281ef2:	89 5a 04             	mov    %ebx,0x4(%edx)
		}
		if((mdec->buf[0] & 0x20)!=0)
  281ef5:	a8 20                	test   $0x20,%al
  281ef7:	74 09                	je     281f02 <mouse_decode+0x94>
		{
			mdec->y |= 0xffffff00;
  281ef9:	81 c9 00 ff ff ff    	or     $0xffffff00,%ecx
  281eff:	89 4a 08             	mov    %ecx,0x8(%edx)
		}
		mdec->y = -mdec->y;
  281f02:	f7 5a 08             	negl   0x8(%edx)
		return 1;
  281f05:	b8 01 00 00 00       	mov    $0x1,%eax
  281f0a:	eb 05                	jmp    281f11 <mouse_decode+0xa3>
	}
	return -1;
  281f0c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  281f11:	5b                   	pop    %ebx
  281f12:	5e                   	pop    %esi
  281f13:	5d                   	pop    %ebp
  281f14:	c3                   	ret    

00281f15 <inthandler2c>:
#include "fifo.h"


//hanlder for int 2c (mouse interrupts)
void inthandler2c(int *esp)
{
  281f15:	55                   	push   %ebp
  281f16:	89 e5                	mov    %esp,%ebp
  281f18:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic continue watch 2c int
	io_out8(PIC1_OCW2,0X64);
  281f1b:	6a 64                	push   $0x64
  281f1d:	68 a0 00 00 00       	push   $0xa0
  281f22:	e8 df ed ff ff       	call   280d06 <io_out8>
	io_out8(PIC0_OCW2,0x62);
  281f27:	83 c4 08             	add    $0x8,%esp
  281f2a:	6a 62                	push   $0x62
  281f2c:	6a 20                	push   $0x20
  281f2e:	e8 d3 ed ff ff       	call   280d06 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281f33:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281f3a:	e8 a5 ed ff ff       	call   280ce4 <io_in8>
	fifo32_put(mousefifo,data+mousedata0);
  281f3f:	83 c4 08             	add    $0x8,%esp
  281f42:	03 05 40 73 28 00    	add    0x287340,%eax
  281f48:	50                   	push   %eax
  281f49:	ff 35 44 73 28 00    	pushl  0x287344
  281f4f:	e8 15 fe ff ff       	call   281d69 <fifo32_put>
	return;
  281f54:	83 c4 10             	add    $0x10,%esp
}
  281f57:	c9                   	leave  
  281f58:	c3                   	ret    

00281f59 <wait_KBC_sendready>:

struct FIFO32 *keyfifo;
int keydata0;

void wait_KBC_sendready(void)
{
  281f59:	55                   	push   %ebp
  281f5a:	89 e5                	mov    %esp,%ebp
  281f5c:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		if((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) == 0)
  281f5f:	83 ec 0c             	sub    $0xc,%esp
  281f62:	6a 64                	push   $0x64
  281f64:	e8 7b ed ff ff       	call   280ce4 <io_in8>
  281f69:	83 c4 10             	add    $0x10,%esp
  281f6c:	a8 02                	test   $0x2,%al
  281f6e:	75 ef                	jne    281f5f <wait_KBC_sendready+0x6>
			break;
	}
	return;
}
  281f70:	c9                   	leave  
  281f71:	c3                   	ret    

00281f72 <init_keyboard>:

void init_keyboard(struct FIFO32 *fifo,int data0)
{
  281f72:	55                   	push   %ebp
  281f73:	89 e5                	mov    %esp,%ebp
  281f75:	83 ec 08             	sub    $0x8,%esp
	keyfifo = fifo;
  281f78:	8b 45 08             	mov    0x8(%ebp),%eax
  281f7b:	a3 48 73 28 00       	mov    %eax,0x287348
	keydata0 = data0;
  281f80:	8b 45 0c             	mov    0xc(%ebp),%eax
  281f83:	a3 4c 73 28 00       	mov    %eax,0x28734c
	wait_KBC_sendready();
  281f88:	e8 cc ff ff ff       	call   281f59 <wait_KBC_sendready>
	io_out8(PORT_KEYCMD,KEYCMD_WRITE_MODE);
  281f8d:	83 ec 08             	sub    $0x8,%esp
  281f90:	6a 60                	push   $0x60
  281f92:	6a 64                	push   $0x64
  281f94:	e8 6d ed ff ff       	call   280d06 <io_out8>
	wait_KBC_sendready();
  281f99:	e8 bb ff ff ff       	call   281f59 <wait_KBC_sendready>
	io_out8(PORT_KEYDAT,KBC_MODE);
  281f9e:	83 c4 08             	add    $0x8,%esp
  281fa1:	6a 47                	push   $0x47
  281fa3:	6a 60                	push   $0x60
  281fa5:	e8 5c ed ff ff       	call   280d06 <io_out8>
	return;
  281faa:	83 c4 10             	add    $0x10,%esp
}
  281fad:	c9                   	leave  
  281fae:	c3                   	ret    

00281faf <inthandler21>:
#include "fifo.h"


//handler for int 21 (keyboard interrupts)
void inthandler21(int *esp)
{
  281faf:	55                   	push   %ebp
  281fb0:	89 e5                	mov    %esp,%ebp
  281fb2:	83 ec 10             	sub    $0x10,%esp
	int data;
	//tell pic contine watch 21 int
	io_out8(PIC0_OCW2,0x61);
  281fb5:	6a 61                	push   $0x61
  281fb7:	6a 20                	push   $0x20
  281fb9:	e8 48 ed ff ff       	call   280d06 <io_out8>
	data = io_in8(PORT_KEYDAT);
  281fbe:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  281fc5:	e8 1a ed ff ff       	call   280ce4 <io_in8>
	fifo32_put(keyfifo,data + keydata0);
  281fca:	83 c4 08             	add    $0x8,%esp
  281fcd:	03 05 4c 73 28 00    	add    0x28734c,%eax
  281fd3:	50                   	push   %eax
  281fd4:	ff 35 48 73 28 00    	pushl  0x287348
  281fda:	e8 8a fd ff ff       	call   281d69 <fifo32_put>
	return;
  281fdf:	83 c4 10             	add    $0x10,%esp
}
  281fe2:	c9                   	leave  
  281fe3:	c3                   	ret    

00281fe4 <key_char>:
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
  281fe4:	55                   	push   %ebp
  281fe5:	89 e5                	mov    %esp,%ebp
  281fe7:	8b 55 08             	mov    0x8(%ebp),%edx
	if(key>=0 && key<0x80)
	{
		if(key_shift==0) return keytable0[key];
		else return keytable1[key];
	}
	else return 0;
  281fea:	b8 00 00 00 00       	mov    $0x0,%eax
    0,   0,   0,   '_', 0,   0,   0,   0,   0,   0,   0,   0,   0,   '|', 0,   0
};

char key_char(int key, int key_shift)
{
	if(key>=0 && key<0x80)
  281fef:	83 fa 7f             	cmp    $0x7f,%edx
  281ff2:	77 16                	ja     28200a <key_char+0x26>
	{
		if(key_shift==0) return keytable0[key];
  281ff4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  281ff8:	75 09                	jne    282003 <key_char+0x1f>
  281ffa:	0f b6 82 60 4a 28 00 	movzbl 0x284a60(%edx),%eax
  282001:	eb 07                	jmp    28200a <key_char+0x26>
		else return keytable1[key];
  282003:	0f b6 82 e0 49 28 00 	movzbl 0x2849e0(%edx),%eax
	}
	else return 0;
}
  28200a:	5d                   	pop    %ebp
  28200b:	c3                   	ret    

0028200c <memtest>:
#include "memory.h"
#include "io.h"

extern unsigned int _memtest_sub(unsigned int start,unsigned int end);
unsigned int memtest(unsigned int start,unsigned int end)
{
  28200c:	55                   	push   %ebp
  28200d:	89 e5                	mov    %esp,%ebp
  28200f:	83 ec 18             	sub    $0x18,%esp
	char flg486 = 0;
  282012:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	unsigned int eflg,cr0,i;
	
	//check cpu type
	eflg = io_load_eflags();
  282016:	e8 0a ed ff ff       	call   280d25 <io_load_eflags>
  28201b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	eflg != EFLAGS_AC_BIT;
	io_store_eflags(eflg);
  28201e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282021:	83 ec 0c             	sub    $0xc,%esp
  282024:	50                   	push   %eax
  282025:	e8 fe ec ff ff       	call   280d28 <io_store_eflags>
  28202a:	83 c4 10             	add    $0x10,%esp
	eflg = io_load_eflags();
  28202d:	e8 f3 ec ff ff       	call   280d25 <io_load_eflags>
  282032:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if((eflg & EFLAGS_AC_BIT) !=0)
  282035:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282038:	25 00 00 04 00       	and    $0x40000,%eax
  28203d:	85 c0                	test   %eax,%eax
  28203f:	74 04                	je     282045 <memtest+0x39>
		flg486 = 1;
  282041:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
	eflg &= ~EFLAGS_AC_BIT;
  282045:	81 65 f0 ff ff fb ff 	andl   $0xfffbffff,-0x10(%ebp)
	io_store_eflags(eflg);
  28204c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28204f:	83 ec 0c             	sub    $0xc,%esp
  282052:	50                   	push   %eax
  282053:	e8 d0 ec ff ff       	call   280d28 <io_store_eflags>
  282058:	83 c4 10             	add    $0x10,%esp
	
	//disable cpu cache
	if(flg486)
  28205b:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  28205f:	74 1d                	je     28207e <memtest+0x72>
	{
		cr0 = load_cr0;
  282061:	c7 45 ec 4f 0d 28 00 	movl   $0x280d4f,-0x14(%ebp)
		cr0 |= CR0_CACHE_DISABLE;
  282068:	81 4d ec 00 00 00 60 	orl    $0x60000000,-0x14(%ebp)
		store_cr0(cr0);
  28206f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  282072:	83 ec 0c             	sub    $0xc,%esp
  282075:	50                   	push   %eax
  282076:	e8 d8 ec ff ff       	call   280d53 <store_cr0>
  28207b:	83 c4 10             	add    $0x10,%esp
	}
	
	//i = memtest_sub(start,end);
	i = _memtest_sub(start,end);
  28207e:	83 ec 08             	sub    $0x8,%esp
  282081:	ff 75 0c             	pushl  0xc(%ebp)
  282084:	ff 75 08             	pushl  0x8(%ebp)
  282087:	e8 cf ec ff ff       	call   280d5b <_memtest_sub>
  28208c:	83 c4 10             	add    $0x10,%esp
  28208f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	
	//enable cpu cache
	if(flg486)
  282092:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
  282096:	74 1e                	je     2820b6 <memtest+0xaa>
	{
		cr0 = load_cr0();
  282098:	e8 b2 ec ff ff       	call   280d4f <load_cr0>
  28209d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cr0 &= ~CR0_CACHE_DISABLE;
  2820a0:	81 65 ec ff ff ff 9f 	andl   $0x9fffffff,-0x14(%ebp)
		store_cr0(cr0);
  2820a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  2820aa:	83 ec 0c             	sub    $0xc,%esp
  2820ad:	50                   	push   %eax
  2820ae:	e8 a0 ec ff ff       	call   280d53 <store_cr0>
  2820b3:	83 c4 10             	add    $0x10,%esp
	}

	return i;
  2820b6:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
  2820b9:	c9                   	leave  
  2820ba:	c3                   	ret    

002820bb <memtest_sub>:

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
  2820bb:	55                   	push   %ebp
  2820bc:	89 e5                	mov    %esp,%ebp
  2820be:	83 ec 20             	sub    $0x20,%esp
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
  2820c1:	c7 45 f8 55 aa 55 aa 	movl   $0xaa55aa55,-0x8(%ebp)
  2820c8:	c7 45 f4 aa 55 aa 55 	movl   $0x55aa55aa,-0xc(%ebp)
	for(i=start;i<=end;i+=0x1000)
  2820cf:	8b 45 08             	mov    0x8(%ebp),%eax
  2820d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  2820d5:	eb 67                	jmp    28213e <memtest_sub+0x83>
	{
		p = (unsigned int *) (i+0xffc);
  2820d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2820da:	05 fc 0f 00 00       	add    $0xffc,%eax
  2820df:	89 45 f0             	mov    %eax,-0x10(%ebp)
		old = *p;
  2820e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820e5:	8b 00                	mov    (%eax),%eax
  2820e7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*p = pat0;
  2820ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820ed:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2820f0:	89 10                	mov    %edx,(%eax)
		*p ^= 0xffffffff;
  2820f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820f5:	8b 00                	mov    (%eax),%eax
  2820f7:	f7 d0                	not    %eax
  2820f9:	89 c2                	mov    %eax,%edx
  2820fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2820fe:	89 10                	mov    %edx,(%eax)
		if(*p != pat1)
  282100:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282103:	8b 00                	mov    (%eax),%eax
  282105:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  282108:	74 0d                	je     282117 <memtest_sub+0x5c>
  28210a:	eb 01                	jmp    28210d <memtest_sub+0x52>
			break;
		}
		*p ^= 0xffffffff;
		if(*p != pat0)
		{
			goto not_memory;
  28210c:	90                   	nop
		*p = pat0;
		*p ^= 0xffffffff;
		if(*p != pat1)
		{
not_memory:
			*p = old;
  28210d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282110:	8b 55 ec             	mov    -0x14(%ebp),%edx
  282113:	89 10                	mov    %edx,(%eax)
			break;
  282115:	eb 2f                	jmp    282146 <memtest_sub+0x8b>
		}
		*p ^= 0xffffffff;
  282117:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28211a:	8b 00                	mov    (%eax),%eax
  28211c:	f7 d0                	not    %eax
  28211e:	89 c2                	mov    %eax,%edx
  282120:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282123:	89 10                	mov    %edx,(%eax)
		if(*p != pat0)
  282125:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282128:	8b 00                	mov    (%eax),%eax
  28212a:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28212d:	75 dd                	jne    28210c <memtest_sub+0x51>
		{
			goto not_memory;
		}
		*p = old;
  28212f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  282132:	8b 55 ec             	mov    -0x14(%ebp),%edx
  282135:	89 10                	mov    %edx,(%eax)

//the compiler will op memtest_sub,make it not work expected
unsigned int memtest_sub(unsigned int start, unsigned int end)
{
	unsigned int i,*p,old,pat0 = 0xaa55aa55, pat1 = 0x55aa55aa;
	for(i=start;i<=end;i+=0x1000)
  282137:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%ebp)
  28213e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  282141:	3b 45 0c             	cmp    0xc(%ebp),%eax
  282144:	76 91                	jbe    2820d7 <memtest_sub+0x1c>
		{
			goto not_memory;
		}
		*p = old;
	}
	return i;
  282146:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  282149:	c9                   	leave  
  28214a:	c3                   	ret    

0028214b <memman_init>:

void memman_init(struct MEMMAN *man)
{
  28214b:	55                   	push   %ebp
  28214c:	89 e5                	mov    %esp,%ebp
	man->frees = 0;
  28214e:	8b 45 08             	mov    0x8(%ebp),%eax
  282151:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	man->maxfrees = 0;
  282157:	8b 45 08             	mov    0x8(%ebp),%eax
  28215a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	man->lostsize = 0;
  282161:	8b 45 08             	mov    0x8(%ebp),%eax
  282164:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	man->losts = 0;
  28216b:	8b 45 08             	mov    0x8(%ebp),%eax
  28216e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	return;
  282175:	90                   	nop
}
  282176:	5d                   	pop    %ebp
  282177:	c3                   	ret    

00282178 <memman_total>:

unsigned int memman_total(struct MEMMAN *man)
{
  282178:	55                   	push   %ebp
  282179:	89 e5                	mov    %esp,%ebp
  28217b:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,t = 0;
  28217e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;i<man->frees;i++)
  282185:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  28218c:	eb 14                	jmp    2821a2 <memman_total+0x2a>
	{
		t+=man->free[i].size;
  28218e:	8b 45 08             	mov    0x8(%ebp),%eax
  282191:	8b 55 fc             	mov    -0x4(%ebp),%edx
  282194:	83 c2 02             	add    $0x2,%edx
  282197:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  28219b:	01 45 f8             	add    %eax,-0x8(%ebp)
}

unsigned int memman_total(struct MEMMAN *man)
{
	unsigned int i,t = 0;
	for(i=0;i<man->frees;i++)
  28219e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  2821a2:	8b 45 08             	mov    0x8(%ebp),%eax
  2821a5:	8b 00                	mov    (%eax),%eax
  2821a7:	3b 45 fc             	cmp    -0x4(%ebp),%eax
  2821aa:	77 e2                	ja     28218e <memman_total+0x16>
	{
		t+=man->free[i].size;
	}
	return t;
  2821ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
  2821af:	c9                   	leave  
  2821b0:	c3                   	ret    

002821b1 <memman_alloc>:

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
  2821b1:	55                   	push   %ebp
  2821b2:	89 e5                	mov    %esp,%ebp
  2821b4:	53                   	push   %ebx
  2821b5:	83 ec 10             	sub    $0x10,%esp
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  2821b8:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  2821bf:	e9 bd 00 00 00       	jmp    282281 <memman_alloc+0xd0>
	{
		if(man->free[i].size >= size)
  2821c4:	8b 45 08             	mov    0x8(%ebp),%eax
  2821c7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821ca:	83 c2 02             	add    $0x2,%edx
  2821cd:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  2821d1:	3b 45 0c             	cmp    0xc(%ebp),%eax
  2821d4:	0f 82 a3 00 00 00    	jb     28227d <memman_alloc+0xcc>
		{
			a = man->free[i].addr;
  2821da:	8b 45 08             	mov    0x8(%ebp),%eax
  2821dd:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821e0:	83 c2 02             	add    $0x2,%edx
  2821e3:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  2821e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
			man->free[i].addr+=size;
  2821e9:	8b 45 08             	mov    0x8(%ebp),%eax
  2821ec:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2821ef:	83 c2 02             	add    $0x2,%edx
  2821f2:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  2821f5:	8b 45 0c             	mov    0xc(%ebp),%eax
  2821f8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2821fb:	8b 45 08             	mov    0x8(%ebp),%eax
  2821fe:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282201:	83 c2 02             	add    $0x2,%edx
  282204:	89 0c d0             	mov    %ecx,(%eax,%edx,8)
			man->free[i].size-=size;
  282207:	8b 45 08             	mov    0x8(%ebp),%eax
  28220a:	8b 55 f8             	mov    -0x8(%ebp),%edx
  28220d:	83 c2 02             	add    $0x2,%edx
  282210:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  282214:	2b 45 0c             	sub    0xc(%ebp),%eax
  282217:	89 c2                	mov    %eax,%edx
  282219:	8b 45 08             	mov    0x8(%ebp),%eax
  28221c:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  28221f:	83 c1 02             	add    $0x2,%ecx
  282222:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
			if(man->free[i].size == 0)
  282226:	8b 45 08             	mov    0x8(%ebp),%eax
  282229:	8b 55 f8             	mov    -0x8(%ebp),%edx
  28222c:	83 c2 02             	add    $0x2,%edx
  28222f:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
  282233:	85 c0                	test   %eax,%eax
  282235:	75 41                	jne    282278 <memman_alloc+0xc7>
			{
				man->frees--;
  282237:	8b 45 08             	mov    0x8(%ebp),%eax
  28223a:	8b 00                	mov    (%eax),%eax
  28223c:	8d 50 ff             	lea    -0x1(%eax),%edx
  28223f:	8b 45 08             	mov    0x8(%ebp),%eax
  282242:	89 10                	mov    %edx,(%eax)
				for(;i<man->frees;i++)
  282244:	eb 28                	jmp    28226e <memman_alloc+0xbd>
				{
					man->free[i] = man->free[i+1];
  282246:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282249:	8d 50 01             	lea    0x1(%eax),%edx
  28224c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  28224f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282252:	8d 58 02             	lea    0x2(%eax),%ebx
  282255:	8b 45 08             	mov    0x8(%ebp),%eax
  282258:	83 c2 02             	add    $0x2,%edx
  28225b:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  28225e:	8b 02                	mov    (%edx),%eax
  282260:	8b 52 04             	mov    0x4(%edx),%edx
  282263:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  282266:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
			man->free[i].addr+=size;
			man->free[i].size-=size;
			if(man->free[i].size == 0)
			{
				man->frees--;
				for(;i<man->frees;i++)
  28226a:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  28226e:	8b 45 08             	mov    0x8(%ebp),%eax
  282271:	8b 00                	mov    (%eax),%eax
  282273:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282276:	77 ce                	ja     282246 <memman_alloc+0x95>
				{
					man->free[i] = man->free[i+1];
				}
			}
			return a;
  282278:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28227b:	eb 17                	jmp    282294 <memman_alloc+0xe3>
}

unsigned int memman_alloc(struct MEMMAN *man,unsigned int size)
{
	unsigned int i,a;
	for(i=0;i<man->frees;i++)
  28227d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  282281:	8b 45 08             	mov    0x8(%ebp),%eax
  282284:	8b 00                	mov    (%eax),%eax
  282286:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  282289:	0f 87 35 ff ff ff    	ja     2821c4 <memman_alloc+0x13>
				}
			}
			return a;
		}
	}
	return 0;
  28228f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282294:	83 c4 10             	add    $0x10,%esp
  282297:	5b                   	pop    %ebx
  282298:	5d                   	pop    %ebp
  282299:	c3                   	ret    

0028229a <memman_free>:

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  28229a:	55                   	push   %ebp
  28229b:	89 e5                	mov    %esp,%ebp
  28229d:	53                   	push   %ebx
  28229e:	83 ec 10             	sub    $0x10,%esp
	int i,j;
	
	for(i=0;i<man->frees;i++)
  2822a1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  2822a8:	eb 15                	jmp    2822bf <memman_free+0x25>
	{
		if(man->free[i].addr>addr) break;
  2822aa:	8b 45 08             	mov    0x8(%ebp),%eax
  2822ad:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2822b0:	83 c2 02             	add    $0x2,%edx
  2822b3:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  2822b6:	3b 45 0c             	cmp    0xc(%ebp),%eax
  2822b9:	77 10                	ja     2822cb <memman_free+0x31>

int memman_free(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
	int i,j;
	
	for(i=0;i<man->frees;i++)
  2822bb:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  2822bf:	8b 45 08             	mov    0x8(%ebp),%eax
  2822c2:	8b 00                	mov    (%eax),%eax
  2822c4:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  2822c7:	7f e1                	jg     2822aa <memman_free+0x10>
  2822c9:	eb 01                	jmp    2822cc <memman_free+0x32>
	{
		if(man->free[i].addr>addr) break;
  2822cb:	90                   	nop
	}

	//if prev combinable.
	if(i>0 && (man->free[i-1].addr+man->free[i-1].size == addr))
  2822cc:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
  2822d0:	0f 8e f2 00 00 00    	jle    2823c8 <memman_free+0x12e>
  2822d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2822d9:	8d 50 ff             	lea    -0x1(%eax),%edx
  2822dc:	8b 45 08             	mov    0x8(%ebp),%eax
  2822df:	83 c2 02             	add    $0x2,%edx
  2822e2:	8b 14 d0             	mov    (%eax,%edx,8),%edx
  2822e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2822e8:	8d 48 ff             	lea    -0x1(%eax),%ecx
  2822eb:	8b 45 08             	mov    0x8(%ebp),%eax
  2822ee:	83 c1 02             	add    $0x2,%ecx
  2822f1:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  2822f5:	01 d0                	add    %edx,%eax
  2822f7:	3b 45 0c             	cmp    0xc(%ebp),%eax
  2822fa:	0f 85 c8 00 00 00    	jne    2823c8 <memman_free+0x12e>
	{
		//combine with prev
		man->free[i-1].size += size;
  282300:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282303:	8d 58 ff             	lea    -0x1(%eax),%ebx
  282306:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282309:	8d 50 ff             	lea    -0x1(%eax),%edx
  28230c:	8b 45 08             	mov    0x8(%ebp),%eax
  28230f:	83 c2 02             	add    $0x2,%edx
  282312:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282316:	8b 45 10             	mov    0x10(%ebp),%eax
  282319:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28231c:	8b 45 08             	mov    0x8(%ebp),%eax
  28231f:	8d 53 02             	lea    0x2(%ebx),%edx
  282322:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)

		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
  282326:	8b 45 08             	mov    0x8(%ebp),%eax
  282329:	8b 00                	mov    (%eax),%eax
  28232b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28232e:	0f 8e 8a 00 00 00    	jle    2823be <memman_free+0x124>
  282334:	8b 55 0c             	mov    0xc(%ebp),%edx
  282337:	8b 45 10             	mov    0x10(%ebp),%eax
  28233a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28233d:	8b 45 08             	mov    0x8(%ebp),%eax
  282340:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282343:	83 c2 02             	add    $0x2,%edx
  282346:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  282349:	39 c1                	cmp    %eax,%ecx
  28234b:	75 71                	jne    2823be <memman_free+0x124>
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
  28234d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282350:	8d 58 ff             	lea    -0x1(%eax),%ebx
  282353:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282356:	8d 50 ff             	lea    -0x1(%eax),%edx
  282359:	8b 45 08             	mov    0x8(%ebp),%eax
  28235c:	83 c2 02             	add    $0x2,%edx
  28235f:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282363:	8b 45 08             	mov    0x8(%ebp),%eax
  282366:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  282369:	83 c1 02             	add    $0x2,%ecx
  28236c:	8b 44 c8 04          	mov    0x4(%eax,%ecx,8),%eax
  282370:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282373:	8b 45 08             	mov    0x8(%ebp),%eax
  282376:	8d 53 02             	lea    0x2(%ebx),%edx
  282379:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
			for(;i<man->frees;i++)
  28237d:	eb 28                	jmp    2823a7 <memman_free+0x10d>
				man->free[i] = man->free[i+1];
  28237f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  282382:	8d 50 01             	lea    0x1(%eax),%edx
  282385:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282388:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28238b:	8d 58 02             	lea    0x2(%eax),%ebx
  28238e:	8b 45 08             	mov    0x8(%ebp),%eax
  282391:	83 c2 02             	add    $0x2,%edx
  282394:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  282397:	8b 02                	mov    (%edx),%eax
  282399:	8b 52 04             	mov    0x4(%edx),%edx
  28239c:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  28239f:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
		//and if next combinable.
		if(i<man->frees && addr + size == man->free[i].addr)
		{
			//combine next.
			man->free[i-1].size += man->free[i].size;
			for(;i<man->frees;i++)
  2823a3:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  2823a7:	8b 45 08             	mov    0x8(%ebp),%eax
  2823aa:	8b 00                	mov    (%eax),%eax
  2823ac:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  2823af:	7f ce                	jg     28237f <memman_free+0xe5>
				man->free[i] = man->free[i+1];
			man->frees--;
  2823b1:	8b 45 08             	mov    0x8(%ebp),%eax
  2823b4:	8b 00                	mov    (%eax),%eax
  2823b6:	8d 50 ff             	lea    -0x1(%eax),%edx
  2823b9:	8b 45 08             	mov    0x8(%ebp),%eax
  2823bc:	89 10                	mov    %edx,(%eax)
		}
		
		return 0;
  2823be:	b8 00 00 00 00       	mov    $0x0,%eax
  2823c3:	e9 1f 01 00 00       	jmp    2824e7 <memman_free+0x24d>
	}

	//if next combinable
	if(i<man->frees && (addr + size == man->free[i].addr))
  2823c8:	8b 45 08             	mov    0x8(%ebp),%eax
  2823cb:	8b 00                	mov    (%eax),%eax
  2823cd:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  2823d0:	7e 52                	jle    282424 <memman_free+0x18a>
  2823d2:	8b 55 0c             	mov    0xc(%ebp),%edx
  2823d5:	8b 45 10             	mov    0x10(%ebp),%eax
  2823d8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  2823db:	8b 45 08             	mov    0x8(%ebp),%eax
  2823de:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2823e1:	83 c2 02             	add    $0x2,%edx
  2823e4:	8b 04 d0             	mov    (%eax,%edx,8),%eax
  2823e7:	39 c1                	cmp    %eax,%ecx
  2823e9:	75 39                	jne    282424 <memman_free+0x18a>
	{
		man->free[i].addr = addr;
  2823eb:	8b 45 08             	mov    0x8(%ebp),%eax
  2823ee:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2823f1:	8d 4a 02             	lea    0x2(%edx),%ecx
  2823f4:	8b 55 0c             	mov    0xc(%ebp),%edx
  2823f7:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size += size;
  2823fa:	8b 45 08             	mov    0x8(%ebp),%eax
  2823fd:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282400:	83 c2 02             	add    $0x2,%edx
  282403:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
  282407:	8b 45 10             	mov    0x10(%ebp),%eax
  28240a:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  28240d:	8b 45 08             	mov    0x8(%ebp),%eax
  282410:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282413:	83 c2 02             	add    $0x2,%edx
  282416:	89 4c d0 04          	mov    %ecx,0x4(%eax,%edx,8)
		return 0;
  28241a:	b8 00 00 00 00       	mov    $0x0,%eax
  28241f:	e9 c3 00 00 00       	jmp    2824e7 <memman_free+0x24d>
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
  282424:	8b 45 08             	mov    0x8(%ebp),%eax
  282427:	8b 00                	mov    (%eax),%eax
  282429:	3d f9 0f 00 00       	cmp    $0xff9,%eax
  28242e:	0f 8f 8a 00 00 00    	jg     2824be <memman_free+0x224>
	{
		for(j=man->frees-1;j>=i;j--)
  282434:	8b 45 08             	mov    0x8(%ebp),%eax
  282437:	8b 00                	mov    (%eax),%eax
  282439:	83 e8 01             	sub    $0x1,%eax
  28243c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  28243f:	eb 28                	jmp    282469 <memman_free+0x1cf>
			man->free[j+1] = man->free[j];
  282441:	8b 45 f4             	mov    -0xc(%ebp),%eax
  282444:	83 c0 01             	add    $0x1,%eax
  282447:	8b 4d 08             	mov    0x8(%ebp),%ecx
  28244a:	8d 58 02             	lea    0x2(%eax),%ebx
  28244d:	8b 45 08             	mov    0x8(%ebp),%eax
  282450:	8b 55 f4             	mov    -0xc(%ebp),%edx
  282453:	83 c2 02             	add    $0x2,%edx
  282456:	8d 14 d0             	lea    (%eax,%edx,8),%edx
  282459:	8b 02                	mov    (%edx),%eax
  28245b:	8b 52 04             	mov    0x4(%edx),%edx
  28245e:	89 04 d9             	mov    %eax,(%ecx,%ebx,8)
  282461:	89 54 d9 04          	mov    %edx,0x4(%ecx,%ebx,8)
	}
	
	//insert a new free into man->free[]
	if(man->frees < MEMMAN_FREES)
	{
		for(j=man->frees-1;j>=i;j--)
  282465:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
  282469:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28246c:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  28246f:	7d d0                	jge    282441 <memman_free+0x1a7>
			man->free[j+1] = man->free[j];
		if(man->maxfrees < man->frees) man->maxfrees = man->frees;
  282471:	8b 45 08             	mov    0x8(%ebp),%eax
  282474:	8b 50 04             	mov    0x4(%eax),%edx
  282477:	8b 45 08             	mov    0x8(%ebp),%eax
  28247a:	8b 00                	mov    (%eax),%eax
  28247c:	39 c2                	cmp    %eax,%edx
  28247e:	7d 0b                	jge    28248b <memman_free+0x1f1>
  282480:	8b 45 08             	mov    0x8(%ebp),%eax
  282483:	8b 10                	mov    (%eax),%edx
  282485:	8b 45 08             	mov    0x8(%ebp),%eax
  282488:	89 50 04             	mov    %edx,0x4(%eax)
		man->free[i].addr = addr;
  28248b:	8b 45 08             	mov    0x8(%ebp),%eax
  28248e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  282491:	8d 4a 02             	lea    0x2(%edx),%ecx
  282494:	8b 55 0c             	mov    0xc(%ebp),%edx
  282497:	89 14 c8             	mov    %edx,(%eax,%ecx,8)
		man->free[i].size = size;
  28249a:	8b 45 08             	mov    0x8(%ebp),%eax
  28249d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  2824a0:	8d 4a 02             	lea    0x2(%edx),%ecx
  2824a3:	8b 55 10             	mov    0x10(%ebp),%edx
  2824a6:	89 54 c8 04          	mov    %edx,0x4(%eax,%ecx,8)
		man->frees++;
  2824aa:	8b 45 08             	mov    0x8(%ebp),%eax
  2824ad:	8b 00                	mov    (%eax),%eax
  2824af:	8d 50 01             	lea    0x1(%eax),%edx
  2824b2:	8b 45 08             	mov    0x8(%ebp),%eax
  2824b5:	89 10                	mov    %edx,(%eax)
		return 0;
  2824b7:	b8 00 00 00 00       	mov    $0x0,%eax
  2824bc:	eb 29                	jmp    2824e7 <memman_free+0x24d>
	}

	//no room for new free
	man->losts++;
  2824be:	8b 45 08             	mov    0x8(%ebp),%eax
  2824c1:	8b 40 0c             	mov    0xc(%eax),%eax
  2824c4:	8d 50 01             	lea    0x1(%eax),%edx
  2824c7:	8b 45 08             	mov    0x8(%ebp),%eax
  2824ca:	89 50 0c             	mov    %edx,0xc(%eax)
	man->lostsize += size;
  2824cd:	8b 45 08             	mov    0x8(%ebp),%eax
  2824d0:	8b 40 08             	mov    0x8(%eax),%eax
  2824d3:	89 c2                	mov    %eax,%edx
  2824d5:	8b 45 10             	mov    0x10(%ebp),%eax
  2824d8:	01 d0                	add    %edx,%eax
  2824da:	89 c2                	mov    %eax,%edx
  2824dc:	8b 45 08             	mov    0x8(%ebp),%eax
  2824df:	89 50 08             	mov    %edx,0x8(%eax)
	return -1;
  2824e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  2824e7:	83 c4 10             	add    $0x10,%esp
  2824ea:	5b                   	pop    %ebx
  2824eb:	5d                   	pop    %ebp
  2824ec:	c3                   	ret    

002824ed <memman_alloc_4k>:

unsigned int memman_alloc_4k(struct MEMMAN *man,unsigned int size)
{
  2824ed:	55                   	push   %ebp
  2824ee:	89 e5                	mov    %esp,%ebp
  2824f0:	83 ec 10             	sub    $0x10,%esp
	unsigned int a;
	size = (size+0xfff) & 0xfffff000;
  2824f3:	8b 45 0c             	mov    0xc(%ebp),%eax
  2824f6:	05 ff 0f 00 00       	add    $0xfff,%eax
  2824fb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  282500:	89 45 0c             	mov    %eax,0xc(%ebp)
	a = memman_alloc(man,size);
  282503:	ff 75 0c             	pushl  0xc(%ebp)
  282506:	ff 75 08             	pushl  0x8(%ebp)
  282509:	e8 a3 fc ff ff       	call   2821b1 <memman_alloc>
  28250e:	83 c4 08             	add    $0x8,%esp
  282511:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return a;
  282514:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  282517:	c9                   	leave  
  282518:	c3                   	ret    

00282519 <memman_free_4k>:

int memman_free_4k(struct MEMMAN *man,unsigned int addr,unsigned int size)
{
  282519:	55                   	push   %ebp
  28251a:	89 e5                	mov    %esp,%ebp
  28251c:	83 ec 10             	sub    $0x10,%esp
	int i;
	size = (size+0xfff) & 0xfffff000;
  28251f:	8b 45 10             	mov    0x10(%ebp),%eax
  282522:	05 ff 0f 00 00       	add    $0xfff,%eax
  282527:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  28252c:	89 45 10             	mov    %eax,0x10(%ebp)
	i = memman_free(man,addr,size);
  28252f:	ff 75 10             	pushl  0x10(%ebp)
  282532:	ff 75 0c             	pushl  0xc(%ebp)
  282535:	ff 75 08             	pushl  0x8(%ebp)
  282538:	e8 5d fd ff ff       	call   28229a <memman_free>
  28253d:	83 c4 0c             	add    $0xc,%esp
  282540:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return i;
  282543:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
  282546:	c9                   	leave  
  282547:	c3                   	ret    

00282548 <shtctl_init>:
#include "map_sheet.h"

struct SHTCTL* shtctl_init(struct MEMMAN *man,unsigned char *vram,int xsize,int ysize)
{
  282548:	55                   	push   %ebp
  282549:	89 e5                	mov    %esp,%ebp
  28254b:	57                   	push   %edi
  28254c:	56                   	push   %esi
  28254d:	53                   	push   %ebx
  28254e:	83 ec 14             	sub    $0x14,%esp
  282551:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct SHTCTL *ctl;
	int i;
	ctl = (struct SHTCTL *)memman_alloc_4k(man,sizeof(struct SHTCTL));
  282554:	68 14 2c 00 00       	push   $0x2c14
  282559:	57                   	push   %edi
  28255a:	e8 8e ff ff ff       	call   2824ed <memman_alloc_4k>
  28255f:	89 c6                	mov    %eax,%esi
	if(ctl == 0)
  282561:	83 c4 10             	add    $0x10,%esp
  282564:	85 c0                	test   %eax,%eax
  282566:	74 6a                	je     2825d2 <shtctl_init+0x8a>
  282568:	89 c3                	mov    %eax,%ebx
		goto err;
	ctl->vram = vram;
  28256a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28256d:	89 06                	mov    %eax,(%esi)
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
  28256f:	83 ec 08             	sub    $0x8,%esp
  282572:	8b 45 10             	mov    0x10(%ebp),%eax
  282575:	0f af 45 14          	imul   0x14(%ebp),%eax
  282579:	50                   	push   %eax
  28257a:	57                   	push   %edi
  28257b:	e8 6d ff ff ff       	call   2824ed <memman_alloc_4k>
  282580:	89 46 04             	mov    %eax,0x4(%esi)
	if(ctl->map == 0)
  282583:	83 c4 10             	add    $0x10,%esp
  282586:	85 c0                	test   %eax,%eax
  282588:	75 19                	jne    2825a3 <shtctl_init+0x5b>
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
  28258a:	83 ec 04             	sub    $0x4,%esp
  28258d:	68 14 2c 00 00       	push   $0x2c14
  282592:	56                   	push   %esi
  282593:	57                   	push   %edi
  282594:	e8 80 ff ff ff       	call   282519 <memman_free_4k>
		ctl = 0;
		goto err;
  282599:	83 c4 10             	add    $0x10,%esp
	ctl->vram = vram;
	ctl->map = (unsigned char *)memman_alloc_4k(man,xsize*ysize);
	if(ctl->map == 0)
	{
		memman_free_4k(man,(int)ctl,sizeof(struct SHTCTL));
		ctl = 0;
  28259c:	be 00 00 00 00       	mov    $0x0,%esi
		goto err;
  2825a1:	eb 2f                	jmp    2825d2 <shtctl_init+0x8a>
	}
	ctl->xsize= xsize;
  2825a3:	8b 45 10             	mov    0x10(%ebp),%eax
  2825a6:	89 46 08             	mov    %eax,0x8(%esi)
	ctl->ysize= ysize;
  2825a9:	8b 45 14             	mov    0x14(%ebp),%eax
  2825ac:	89 46 0c             	mov    %eax,0xc(%esi)
	ctl->top = -1;
  2825af:	c7 46 10 ff ff ff ff 	movl   $0xffffffff,0x10(%esi)
  2825b6:	8d 86 30 04 00 00    	lea    0x430(%esi),%eax
  2825bc:	81 c3 30 2c 00 00    	add    $0x2c30,%ebx
	for(i=0;i<MAX_SHEETS;i++)
	{
		ctl->sheets0[i].flags = 0;
  2825c2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ctl->sheets0[i].ctl = ctl;
  2825c8:	89 70 04             	mov    %esi,0x4(%eax)
  2825cb:	83 c0 28             	add    $0x28,%eax
		goto err;
	}
	ctl->xsize= xsize;
	ctl->ysize= ysize;
	ctl->top = -1;
	for(i=0;i<MAX_SHEETS;i++)
  2825ce:	39 d8                	cmp    %ebx,%eax
  2825d0:	75 f0                	jne    2825c2 <shtctl_init+0x7a>
		ctl->sheets0[i].flags = 0;
		ctl->sheets0[i].ctl = ctl;
	}
	err:
		return ctl;
}
  2825d2:	89 f0                	mov    %esi,%eax
  2825d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2825d7:	5b                   	pop    %ebx
  2825d8:	5e                   	pop    %esi
  2825d9:	5f                   	pop    %edi
  2825da:	5d                   	pop    %ebp
  2825db:	c3                   	ret    

002825dc <sheet_alloc>:

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
  2825dc:	55                   	push   %ebp
  2825dd:	89 e5                	mov    %esp,%ebp
  2825df:	56                   	push   %esi
  2825e0:	53                   	push   %ebx
  2825e1:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
	{
		if(ctl->sheets0[i].flags == 0)
  2825e4:	83 b9 30 04 00 00 00 	cmpl   $0x0,0x430(%ecx)
  2825eb:	74 12                	je     2825ff <sheet_alloc+0x23>
  2825ed:	8d 91 58 04 00 00    	lea    0x458(%ecx),%edx

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  2825f3:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(ctl->sheets0[i].flags == 0)
  2825f8:	83 3a 00             	cmpl   $0x0,(%edx)
  2825fb:	75 3c                	jne    282639 <sheet_alloc+0x5d>
  2825fd:	eb 05                	jmp    282604 <sheet_alloc+0x28>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  2825ff:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(ctl->sheets0[i].flags == 0)
		{
			sht = &ctl->sheets0[i];
  282604:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  28260b:	8d 34 02             	lea    (%edx,%eax,1),%esi
			sht->flags = SHEET_USE;
  28260e:	8d 1c f1             	lea    (%ecx,%esi,8),%ebx
  282611:	c7 83 30 04 00 00 01 	movl   $0x1,0x430(%ebx)
  282618:	00 00 00 
			sht->height = -1;
  28261b:	c7 83 2c 04 00 00 ff 	movl   $0xffffffff,0x42c(%ebx)
  282622:	ff ff ff 
			sht->task = 0;
  282625:	c7 84 f1 38 04 00 00 	movl   $0x0,0x438(%ecx,%esi,8)
  28262c:	00 00 00 00 
			return sht;
  282630:	8d 84 f1 14 04 00 00 	lea    0x414(%ecx,%esi,8),%eax
  282637:	eb 12                	jmp    28264b <sheet_alloc+0x6f>

struct SHEET *sheet_alloc(struct SHTCTL *ctl)
{
	struct SHEET *sht;
	int i;
	for(i=0;i<MAX_SHEETS;i++)
  282639:	83 c0 01             	add    $0x1,%eax
  28263c:	83 c2 28             	add    $0x28,%edx
  28263f:	3d 00 01 00 00       	cmp    $0x100,%eax
  282644:	75 b2                	jne    2825f8 <sheet_alloc+0x1c>
			sht->height = -1;
			sht->task = 0;
			return sht;
		}
	}
	return 0;
  282646:	b8 00 00 00 00       	mov    $0x0,%eax
}
  28264b:	5b                   	pop    %ebx
  28264c:	5e                   	pop    %esi
  28264d:	5d                   	pop    %ebp
  28264e:	c3                   	ret    

0028264f <sheet_setbuf>:

void sheet_setbuf(struct SHEET *sht,unsigned char *buf,int xsize,int ysize,int col_inv)
{
  28264f:	55                   	push   %ebp
  282650:	89 e5                	mov    %esp,%ebp
  282652:	8b 45 08             	mov    0x8(%ebp),%eax
	sht->buf = buf;
  282655:	8b 55 0c             	mov    0xc(%ebp),%edx
  282658:	89 10                	mov    %edx,(%eax)
	sht->bxsize = xsize;
  28265a:	8b 55 10             	mov    0x10(%ebp),%edx
  28265d:	89 50 04             	mov    %edx,0x4(%eax)
	sht->bysize = ysize;
  282660:	8b 55 14             	mov    0x14(%ebp),%edx
  282663:	89 50 08             	mov    %edx,0x8(%eax)
	sht->col_inv = col_inv;
  282666:	8b 55 18             	mov    0x18(%ebp),%edx
  282669:	89 50 14             	mov    %edx,0x14(%eax)
	return;
}
  28266c:	5d                   	pop    %ebp
  28266d:	c3                   	ret    

0028266e <sheet_refresh_ob>:
}

//not good refresh
//obsolete
void sheet_refresh_ob(struct SHTCTL *ctl)
{
  28266e:	55                   	push   %ebp
  28266f:	89 e5                	mov    %esp,%ebp
  282671:	57                   	push   %edi
  282672:	56                   	push   %esi
  282673:	53                   	push   %ebx
  282674:	83 ec 10             	sub    $0x10,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
  282677:	8b 45 08             	mov    0x8(%ebp),%eax
  28267a:	8b 00                	mov    (%eax),%eax
  28267c:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  28267f:	8b 45 08             	mov    0x8(%ebp),%eax
  282682:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  282686:	0f 88 80 00 00 00    	js     28270c <sheet_refresh_ob+0x9e>
  28268c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	{
		sht = ctl->sheets[h];
  282693:	8b 45 08             	mov    0x8(%ebp),%eax
  282696:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  282699:	8b 54 b8 14          	mov    0x14(%eax,%edi,4),%edx
		buf = sht->buf;
  28269d:	8b 02                	mov    (%edx),%eax
  28269f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		for(by=0;by<sht->bysize;by++)
  2826a2:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  2826a6:	7e 55                	jle    2826fd <sheet_refresh_ob+0x8f>
  2826a8:	bf 00 00 00 00       	mov    $0x0,%edi
		{
			vy = sht->vy0+by;
  2826ad:	89 f8                	mov    %edi,%eax
  2826af:	03 42 10             	add    0x10(%edx),%eax
  2826b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
			for(bx=0;bx<sht->bxsize;bx++)
  2826b5:	8b 4a 04             	mov    0x4(%edx),%ecx
  2826b8:	85 c9                	test   %ecx,%ecx
  2826ba:	7e 39                	jle    2826f5 <sheet_refresh_ob+0x87>
  2826bc:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				vx = sht->vx0+bx;
				c=buf[by*sht->bxsize+bx];
  2826c1:	0f af cf             	imul   %edi,%ecx
  2826c4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  2826c7:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  2826ca:	0f b6 1c 0b          	movzbl (%ebx,%ecx,1),%ebx
				if(c!=sht->col_inv)
  2826ce:	0f b6 cb             	movzbl %bl,%ecx
  2826d1:	3b 4a 14             	cmp    0x14(%edx),%ecx
  2826d4:	74 15                	je     2826eb <sheet_refresh_ob+0x7d>
					vram[vy*ctl->xsize+vx] = c;
  2826d6:	8b 4d 08             	mov    0x8(%ebp),%ecx
  2826d9:	8b 75 ec             	mov    -0x14(%ebp),%esi
  2826dc:	0f af 71 08          	imul   0x8(%ecx),%esi
  2826e0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  2826e3:	01 c1                	add    %eax,%ecx
  2826e5:	03 4a 0c             	add    0xc(%edx),%ecx
  2826e8:	88 1c 31             	mov    %bl,(%ecx,%esi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0+by;
			for(bx=0;bx<sht->bxsize;bx++)
  2826eb:	83 c0 01             	add    $0x1,%eax
  2826ee:	8b 4a 04             	mov    0x4(%edx),%ecx
  2826f1:	39 c1                	cmp    %eax,%ecx
  2826f3:	7f cc                	jg     2826c1 <sheet_refresh_ob+0x53>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  2826f5:	83 c7 01             	add    $0x1,%edi
  2826f8:	39 7a 08             	cmp    %edi,0x8(%edx)
  2826fb:	7f b0                	jg     2826ad <sheet_refresh_ob+0x3f>
void sheet_refresh_ob(struct SHTCTL *ctl)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram=ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  2826fd:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  282701:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  282704:	8b 7d 08             	mov    0x8(%ebp),%edi
  282707:	39 47 10             	cmp    %eax,0x10(%edi)
  28270a:	7d 87                	jge    282693 <sheet_refresh_ob+0x25>
					vram[vy*ctl->xsize+vx] = c;
			}
		}
	}
	return;
}
  28270c:	83 c4 10             	add    $0x10,%esp
  28270f:	5b                   	pop    %ebx
  282710:	5e                   	pop    %esi
  282711:	5f                   	pop    %edi
  282712:	5d                   	pop    %ebp
  282713:	c3                   	ret    

00282714 <sheet_refreshsub1>:



void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
  282714:	55                   	push   %ebp
  282715:	89 e5                	mov    %esp,%ebp
  282717:	57                   	push   %edi
  282718:	56                   	push   %esi
  282719:	53                   	push   %ebx
  28271a:	83 ec 14             	sub    $0x14,%esp
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
  28271d:	8b 45 08             	mov    0x8(%ebp),%eax
  282720:	8b 00                	mov    (%eax),%eax
  282722:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  282725:	8b 45 08             	mov    0x8(%ebp),%eax
  282728:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
  28272c:	0f 88 a7 00 00 00    	js     2827d9 <sheet_refreshsub1+0xc5>
  282732:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	{
		sht = ctl->sheets[h];
  282739:	8b 45 08             	mov    0x8(%ebp),%eax
  28273c:	8b 7d e0             	mov    -0x20(%ebp),%edi
  28273f:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  282743:	8b 01                	mov    (%ecx),%eax
  282745:	89 45 e8             	mov    %eax,-0x18(%ebp)
		for(by=0;by<sht->bysize;by++)
  282748:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  28274c:	7e 78                	jle    2827c6 <sheet_refreshsub1+0xb2>
  28274e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		{
			vy = sht->vy0 + by;
  282755:	8b 5d ec             	mov    -0x14(%ebp),%ebx
  282758:	03 59 10             	add    0x10(%ecx),%ebx
			for(bx=0;bx<sht->bxsize;bx++)
  28275b:	8b 71 04             	mov    0x4(%ecx),%esi
  28275e:	85 f6                	test   %esi,%esi
  282760:	7e 58                	jle    2827ba <sheet_refreshsub1+0xa6>
  282762:	b8 00 00 00 00       	mov    $0x0,%eax
  282767:	89 5d f0             	mov    %ebx,-0x10(%ebp)
			{
				vx = sht->vx0 + bx;
  28276a:	89 c2                	mov    %eax,%edx
  28276c:	03 51 0c             	add    0xc(%ecx),%edx
				if(vx0<=vx && vx<vx1 && vy0<=vy && vy<vy1)
  28276f:	3b 55 0c             	cmp    0xc(%ebp),%edx
  282772:	7c 3c                	jl     2827b0 <sheet_refreshsub1+0x9c>
  282774:	3b 55 14             	cmp    0x14(%ebp),%edx
  282777:	7d 37                	jge    2827b0 <sheet_refreshsub1+0x9c>
  282779:	8b 7d f0             	mov    -0x10(%ebp),%edi
  28277c:	3b 7d 10             	cmp    0x10(%ebp),%edi
  28277f:	7c 2f                	jl     2827b0 <sheet_refreshsub1+0x9c>
  282781:	3b 7d 18             	cmp    0x18(%ebp),%edi
  282784:	7d 2a                	jge    2827b0 <sheet_refreshsub1+0x9c>
				{
					c = buf[by*sht->bxsize+bx];
  282786:	0f af 75 ec          	imul   -0x14(%ebp),%esi
  28278a:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  28278d:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
  282790:	0f b6 34 37          	movzbl (%edi,%esi,1),%esi
					if(c!=sht->col_inv)
  282794:	89 f3                	mov    %esi,%ebx
  282796:	0f b6 fb             	movzbl %bl,%edi
  282799:	3b 79 14             	cmp    0x14(%ecx),%edi
  28279c:	74 12                	je     2827b0 <sheet_refreshsub1+0x9c>
						vram[vy*ctl->xsize+vx] = c;
  28279e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  2827a1:	8b 7d f0             	mov    -0x10(%ebp),%edi
  2827a4:	0f af 7b 08          	imul   0x8(%ebx),%edi
  2827a8:	03 55 e4             	add    -0x1c(%ebp),%edx
  2827ab:	89 f3                	mov    %esi,%ebx
  2827ad:	88 1c 3a             	mov    %bl,(%edx,%edi,1)
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
		{
			vy = sht->vy0 + by;
			for(bx=0;bx<sht->bxsize;bx++)
  2827b0:	83 c0 01             	add    $0x1,%eax
  2827b3:	8b 71 04             	mov    0x4(%ecx),%esi
  2827b6:	39 c6                	cmp    %eax,%esi
  2827b8:	7f b0                	jg     28276a <sheet_refreshsub1+0x56>
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
	{
		sht = ctl->sheets[h];
		buf = sht->buf;
		for(by=0;by<sht->bysize;by++)
  2827ba:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
  2827be:	8b 45 ec             	mov    -0x14(%ebp),%eax
  2827c1:	39 41 08             	cmp    %eax,0x8(%ecx)
  2827c4:	7f 8f                	jg     282755 <sheet_refreshsub1+0x41>
void sheet_refreshsub1(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1)
{
	int h,bx,by,vx,vy;
	unsigned char *buf,c,*vram = ctl->vram;
	struct SHEET *sht;
	for(h=0;h<=ctl->top;h++)
  2827c6:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  2827ca:	8b 45 e0             	mov    -0x20(%ebp),%eax
  2827cd:	8b 7d 08             	mov    0x8(%ebp),%edi
  2827d0:	39 47 10             	cmp    %eax,0x10(%edi)
  2827d3:	0f 8d 60 ff ff ff    	jge    282739 <sheet_refreshsub1+0x25>
						vram[vy*ctl->xsize+vx] = c;
				}
			}
		}
	}
}
  2827d9:	83 c4 14             	add    $0x14,%esp
  2827dc:	5b                   	pop    %ebx
  2827dd:	5e                   	pop    %esi
  2827de:	5f                   	pop    %edi
  2827df:	5d                   	pop    %ebp
  2827e0:	c3                   	ret    

002827e1 <sheet_refreshsub2>:

void sheet_refreshsub2(struct SHTCTL *ctl,int vx0,int vy0,int vx1,int vy1,int h0)
{
  2827e1:	55                   	push   %ebp
  2827e2:	89 e5                	mov    %esp,%ebp
  2827e4:	57                   	push   %edi
  2827e5:	56                   	push   %esi
  2827e6:	53                   	push   %ebx
  2827e7:	83 ec 30             	sub    $0x30,%esp
  2827ea:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  2827ed:	8b 55 10             	mov    0x10(%ebp),%edx
  2827f0:	8b 75 14             	mov    0x14(%ebp),%esi
  2827f3:	8b 7d 18             	mov    0x18(%ebp),%edi
  2827f6:	8b 5d 1c             	mov    0x1c(%ebp),%ebx
	int h,bx,by,vx,vy,bx0,by0,bx1,by1;
	unsigned char *buf,c,*vram = ctl->vram,*map = ctl->map;
  2827f9:	8b 45 08             	mov    0x8(%ebp),%eax
  2827fc:	8b 00                	mov    (%eax),%eax
  2827fe:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  282801:	8b 45 08             	mov    0x8(%ebp),%eax
  282804:	8b 40 04             	mov    0x4(%eax),%eax
  282807:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  28280a:	b8 00 00 00 00       	mov    $0x0,%eax
  28280f:	85 c9                	test   %ecx,%ecx
  282811:	0f 48 c8             	cmovs  %eax,%ecx
  282814:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  282817:	85 d2                	test   %edx,%edx
  282819:	0f 48 d0             	cmovs  %eax,%edx
  28281c:	89 55 d0             	mov    %edx,-0x30(%ebp)
	struct SHEET *sht;
	
	//limit the refresh rect in the visible rect.
	if(vx0<0) vx0 = 0;
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
  28281f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  282822:	8b 51 08             	mov    0x8(%ecx),%edx
  282825:	39 f2                	cmp    %esi,%edx
  282827:	0f 4e f2             	cmovle %edx,%esi
  28282a:	89 75 d4             	mov    %esi,-0x2c(%ebp)
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
  28282d:	8b 51 0c             	mov    0xc(%ecx),%edx
  282830:	39 fa                	cmp    %edi,%edx
  282832:	0f 4e fa             	cmovle %edx,%edi
  282835:	89 7d cc             	mov    %edi,-0x34(%ebp)
  282838:	85 db                	test   %ebx,%ebx
  28283a:	0f 49 c3             	cmovns %ebx,%eax
  28283d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  282840:	39 41 10             	cmp    %eax,0x10(%ecx)
  282843:	0f 8c b3 00 00 00    	jl     2828fc <sheet_refreshsub2+0x11b>
	{
		//calculate the need-refresh rect of each sheet.
		sht = ctl->sheets[h];
  282849:	8b 45 08             	mov    0x8(%ebp),%eax
  28284c:	8b 7d d8             	mov    -0x28(%ebp),%edi
  28284f:	8b 4c b8 14          	mov    0x14(%eax,%edi,4),%ecx
		buf = sht->buf;
  282853:	8b 01                	mov    (%ecx),%eax
  282855:	89 45 ec             	mov    %eax,-0x14(%ebp)
		bx0 = vx0 - sht->vx0;
  282858:	8b 41 0c             	mov    0xc(%ecx),%eax
		by0 = vy0 - sht->vy0;
  28285b:	8b 71 10             	mov    0x10(%ecx),%esi
		bx1 = vx1 - sht->vx0;
  28285e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  282861:	29 c2                	sub    %eax,%edx
		by1 = vy1 - sht->vy0;
  282863:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  282866:	29 f3                	sub    %esi,%ebx
  282868:	8b 7d c8             	mov    -0x38(%ebp),%edi
  28286b:	29 c7                	sub    %eax,%edi
  28286d:	89 f8                	mov    %edi,%eax
  28286f:	bf 00 00 00 00       	mov    $0x0,%edi
  282874:	0f 48 c7             	cmovs  %edi,%eax
  282877:	89 45 dc             	mov    %eax,-0x24(%ebp)
  28287a:	8b 45 d0             	mov    -0x30(%ebp),%eax
  28287d:	29 f0                	sub    %esi,%eax
  28287f:	0f 49 f8             	cmovns %eax,%edi

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
  282882:	8b 41 04             	mov    0x4(%ecx),%eax
  282885:	39 c2                	cmp    %eax,%edx
  282887:	0f 4e c2             	cmovle %edx,%eax
  28288a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(by1>sht->bysize) by1=sht->bysize;
  28288d:	8b 41 08             	mov    0x8(%ecx),%eax
  282890:	39 c3                	cmp    %eax,%ebx
  282892:	0f 4e c3             	cmovle %ebx,%eax
  282895:	89 45 e0             	mov    %eax,-0x20(%ebp)
		for(by=by0;by<by1;by++)
  282898:	39 f8                	cmp    %edi,%eax
  28289a:	7e 4d                	jle    2828e9 <sheet_refreshsub2+0x108>
		{
			vy = sht->vy0+by;
  28289c:	89 f8                	mov    %edi,%eax
  28289e:	03 41 10             	add    0x10(%ecx),%eax
  2828a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
			for(bx=bx0;bx<bx1;bx++)
  2828a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  2828a7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  2828aa:	7e 35                	jle    2828e1 <sheet_refreshsub2+0x100>
			{
				vx = sht->vx0+bx;
				c  = buf[by*sht->bxsize+bx];
  2828ac:	89 fa                	mov    %edi,%edx
  2828ae:	0f af 51 04          	imul   0x4(%ecx),%edx
  2828b2:	8b 75 ec             	mov    -0x14(%ebp),%esi
  2828b5:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
  2828b8:	0f b6 1c 13          	movzbl (%ebx,%edx,1),%ebx
				if(c!=sht->col_inv)
  2828bc:	0f b6 d3             	movzbl %bl,%edx
  2828bf:	3b 51 14             	cmp    0x14(%ecx),%edx
  2828c2:	74 15                	je     2828d9 <sheet_refreshsub2+0xf8>
					map[vy*ctl->xsize+vx] = c;
  2828c4:	8b 55 08             	mov    0x8(%ebp),%edx
  2828c7:	8b 75 e8             	mov    -0x18(%ebp),%esi
  2828ca:	0f af 72 08          	imul   0x8(%edx),%esi
  2828ce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  2828d1:	01 c2                	add    %eax,%edx
  2828d3:	03 51 0c             	add    0xc(%ecx),%edx
  2828d6:	88 1c 32             	mov    %bl,(%edx,%esi,1)
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
		{
			vy = sht->vy0+by;
			for(bx=bx0;bx<bx1;bx++)
  2828d9:	83 c0 01             	add    $0x1,%eax
  2828dc:	39 45 f0             	cmp    %eax,-0x10(%ebp)
  2828df:	75 cb                	jne    2828ac <sheet_refreshsub2+0xcb>

		if(bx0<0) bx0=0;
		if(by0<0) by0=0;
		if(bx1>sht->bxsize) bx1=sht->bxsize;
		if(by1>sht->bysize) by1=sht->bysize;
		for(by=by0;by<by1;by++)
  2828e1:	83 c7 01             	add    $0x1,%edi
  2828e4:	39 7d e0             	cmp    %edi,-0x20(%ebp)
  2828e7:	75 b3                	jne    28289c <sheet_refreshsub2+0xbb>
	if(vy0<0) vy0 = 0;
	if(vx1>ctl->xsize) vx1 = ctl->xsize;
	if(vy1>ctl->ysize) vy1 = ctl->ysize;
	
	if(h0 <0) h0 = 0;
	for(h=h0;h<=ctl->top;h++)
  2828e9:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  2828ed:	8b 45 d8             	mov    -0x28(%ebp),%eax
  2828f0:	8b 7d 08             	mov    0x8(%ebp),%edi
  2828f3:	39 47 10             	cmp    %eax,0x10(%edi)
  2828f6:	0f 8d 4d ff ff ff    	jge    282849 <sheet_refreshsub2+0x68>
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  2828fc:	8b 7d d0             	mov    -0x30(%ebp),%edi
  2828ff:	39 7d cc             	cmp    %edi,-0x34(%ebp)
  282902:	7f 2a                	jg     28292e <sheet_refreshsub2+0x14d>
  282904:	eb 40                	jmp    282946 <sheet_refreshsub2+0x165>
  282906:	89 4d f0             	mov    %ecx,-0x10(%ebp)
		for(vx=vx0;vx<vx1;vx++)
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
  282909:	8b 45 f0             	mov    -0x10(%ebp),%eax
  28290c:	0f af 47 08          	imul   0x8(%edi),%eax
  282910:	01 d0                	add    %edx,%eax
  282912:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  282916:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
		for(vx=vx0;vx<vx1;vx++)
  282919:	83 c2 01             	add    $0x1,%edx
  28291c:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
  28291f:	75 e8                	jne    282909 <sheet_refreshsub2+0x128>
  282921:	8b 4d f0             	mov    -0x10(%ebp),%ecx
				if(c!=sht->col_inv)
					map[vy*ctl->xsize+vx] = c;
			}
		}
	}
	for(vy=vy0;vy<vy1;vy++)
  282924:	83 c1 01             	add    $0x1,%ecx
  282927:	3b 4d cc             	cmp    -0x34(%ebp),%ecx
  28292a:	74 1a                	je     282946 <sheet_refreshsub2+0x165>
  28292c:	eb 0c                	jmp    28293a <sheet_refreshsub2+0x159>
  28292e:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  282931:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  282934:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  282937:	8b 7d 08             	mov    0x8(%ebp),%edi
		for(vx=vx0;vx<vx1;vx++)
  28293a:	8b 45 c8             	mov    -0x38(%ebp),%eax
  28293d:	89 c2                	mov    %eax,%edx
  28293f:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  282942:	7f c2                	jg     282906 <sheet_refreshsub2+0x125>
  282944:	eb de                	jmp    282924 <sheet_refreshsub2+0x143>
			vram[vy*ctl->xsize+vx] = map[vy*ctl->xsize+vx];
}
  282946:	83 c4 30             	add    $0x30,%esp
  282949:	5b                   	pop    %ebx
  28294a:	5e                   	pop    %esi
  28294b:	5f                   	pop    %edi
  28294c:	5d                   	pop    %ebp
  28294d:	c3                   	ret    

0028294e <sheet_refresh>:

void sheet_refresh(struct SHEET *sht,int bx0,int by0,int bx1,int by1)
{
  28294e:	55                   	push   %ebp
  28294f:	89 e5                	mov    %esp,%ebp
  282951:	53                   	push   %ebx
  282952:	8b 45 08             	mov    0x8(%ebp),%eax
	//if(sht->height >= 0)
	//{
		struct SHTCTL *ctl = sht->ctl;
		sheet_refreshsub2(ctl,sht->vx0+bx0,sht->vy0+by0,sht->vx0+bx1,sht->vy0+by1,sht->height);
  282955:	8b 48 10             	mov    0x10(%eax),%ecx
  282958:	8b 50 0c             	mov    0xc(%eax),%edx
  28295b:	ff 70 18             	pushl  0x18(%eax)
  28295e:	89 cb                	mov    %ecx,%ebx
  282960:	03 5d 18             	add    0x18(%ebp),%ebx
  282963:	53                   	push   %ebx
  282964:	89 d3                	mov    %edx,%ebx
  282966:	03 5d 14             	add    0x14(%ebp),%ebx
  282969:	53                   	push   %ebx
  28296a:	03 4d 10             	add    0x10(%ebp),%ecx
  28296d:	51                   	push   %ecx
  28296e:	03 55 0c             	add    0xc(%ebp),%edx
  282971:	52                   	push   %edx
  282972:	ff 70 20             	pushl  0x20(%eax)
  282975:	e8 67 fe ff ff       	call   2827e1 <sheet_refreshsub2>
	//}
	return;
  28297a:	83 c4 18             	add    $0x18,%esp
}
  28297d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  282980:	c9                   	leave  
  282981:	c3                   	ret    

00282982 <sheet_updown>:
	return;
}

//update the sheet with new height
void sheet_updown(struct SHEET *sht,int height)
{
  282982:	55                   	push   %ebp
  282983:	89 e5                	mov    %esp,%ebp
  282985:	57                   	push   %edi
  282986:	56                   	push   %esi
  282987:	53                   	push   %ebx
  282988:	8b 75 08             	mov    0x8(%ebp),%esi
  28298b:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct SHTCTL *ctl = sht->ctl;
  28298e:	8b 4e 20             	mov    0x20(%esi),%ecx
	int h,old = sht->height;
  282991:	8b 46 18             	mov    0x18(%esi),%eax
	if(height>ctl->top+1) height = ctl->top + 1;
  282994:	8b 79 10             	mov    0x10(%ecx),%edi
  282997:	8d 57 01             	lea    0x1(%edi),%edx
  28299a:	39 da                	cmp    %ebx,%edx
  28299c:	0f 4f d3             	cmovg  %ebx,%edx
  28299f:	85 d2                	test   %edx,%edx
  2829a1:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  2829a6:	0f 49 da             	cmovns %edx,%ebx
	if(height<-1) height = -1;
	sht->height = height;
  2829a9:	89 5e 18             	mov    %ebx,0x18(%esi)

	//push down the sheet
	if(old>height)
  2829ac:	39 d8                	cmp    %ebx,%eax
  2829ae:	7e 59                	jle    282a09 <sheet_updown+0x87>
	{
		//if the sheet still shows
		if(height >=0 )
  2829b0:	85 db                	test   %ebx,%ebx
  2829b2:	79 09                	jns    2829bd <sheet_updown+0x3b>
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  2829b4:	8b 59 10             	mov    0x10(%ecx),%ebx
  2829b7:	39 d8                	cmp    %ebx,%eax
  2829b9:	7c 1c                	jl     2829d7 <sheet_updown+0x55>
  2829bb:	eb 31                	jmp    2829ee <sheet_updown+0x6c>
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  2829bd:	8d 50 ff             	lea    -0x1(%eax),%edx
  2829c0:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  2829c4:	89 7c 91 18          	mov    %edi,0x18(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  2829c8:	89 47 18             	mov    %eax,0x18(%edi)
	if(old>height)
	{
		//if the sheet still shows
		if(height >=0 )
		{
			for(h=old;h>height;h--)
  2829cb:	89 d0                	mov    %edx,%eax
  2829cd:	39 d3                	cmp    %edx,%ebx
  2829cf:	75 ec                	jne    2829bd <sheet_updown+0x3b>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;	
  2829d1:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  2829d5:	eb 1d                	jmp    2829f4 <sheet_updown+0x72>
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  2829d7:	8d 50 01             	lea    0x1(%eax),%edx
  2829da:	8b 5c 91 14          	mov    0x14(%ecx,%edx,4),%ebx
  2829de:	89 5c 91 10          	mov    %ebx,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  2829e2:	89 43 18             	mov    %eax,0x18(%ebx)
			}
			ctl->sheets[height] = sht;	
		}
		else //the sheet hides from showing
		{
			for(h=old;h<ctl->top;h++)
  2829e5:	8b 59 10             	mov    0x10(%ecx),%ebx
  2829e8:	89 d0                	mov    %edx,%eax
  2829ea:	39 d3                	cmp    %edx,%ebx
  2829ec:	7f e9                	jg     2829d7 <sheet_updown+0x55>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->top--;
  2829ee:	83 eb 01             	sub    $0x1,%ebx
  2829f1:	89 59 10             	mov    %ebx,0x10(%ecx)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  2829f4:	ff 76 08             	pushl  0x8(%esi)
  2829f7:	ff 76 04             	pushl  0x4(%esi)
  2829fa:	6a 00                	push   $0x0
  2829fc:	6a 00                	push   $0x0
  2829fe:	56                   	push   %esi
  2829ff:	e8 4a ff ff ff       	call   28294e <sheet_refresh>
  282a04:	83 c4 14             	add    $0x14,%esp
  282a07:	eb 5a                	jmp    282a63 <sheet_updown+0xe1>
	}
	else if(old<height) //pop up the sheet
  282a09:	39 d8                	cmp    %ebx,%eax
  282a0b:	7d 56                	jge    282a63 <sheet_updown+0xe1>
	{
		if(old >= 0) //the sheet still shows.
  282a0d:	85 c0                	test   %eax,%eax
  282a0f:	78 1a                	js     282a2b <sheet_updown+0xa9>
		{
			for(h=old;h<height;h++)
			{
				ctl->sheets[h] = ctl->sheets[h+1];
  282a11:	8d 50 01             	lea    0x1(%eax),%edx
  282a14:	8b 7c 91 14          	mov    0x14(%ecx,%edx,4),%edi
  282a18:	89 7c 91 10          	mov    %edi,0x10(%ecx,%edx,4)
				ctl->sheets[h]->height = h;
  282a1c:	89 47 18             	mov    %eax,0x18(%edi)
	}
	else if(old<height) //pop up the sheet
	{
		if(old >= 0) //the sheet still shows.
		{
			for(h=old;h<height;h++)
  282a1f:	89 d0                	mov    %edx,%eax
  282a21:	39 d3                	cmp    %edx,%ebx
  282a23:	75 ec                	jne    282a11 <sheet_updown+0x8f>
			{
				ctl->sheets[h] = ctl->sheets[h+1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  282a25:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
  282a29:	eb 25                	jmp    282a50 <sheet_updown+0xce>
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
  282a2b:	8b 41 10             	mov    0x10(%ecx),%eax
  282a2e:	8d 50 01             	lea    0x1(%eax),%edx
  282a31:	89 51 10             	mov    %edx,0x10(%ecx)
			for(h=ctl->top;h>height;h--)
  282a34:	39 d3                	cmp    %edx,%ebx
  282a36:	7d 14                	jge    282a4c <sheet_updown+0xca>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
  282a38:	8d 42 ff             	lea    -0x1(%edx),%eax
  282a3b:	8b 7c 81 14          	mov    0x14(%ecx,%eax,4),%edi
  282a3f:	89 7c 81 18          	mov    %edi,0x18(%ecx,%eax,4)
				ctl->sheets[h]->height = h;
  282a43:	89 57 18             	mov    %edx,0x18(%edi)
			ctl->sheets[height] = sht;
		}
		else //the sheet shows from hiding.
		{
			ctl->top++;
			for(h=ctl->top;h>height;h--)
  282a46:	89 c2                	mov    %eax,%edx
  282a48:	39 c3                	cmp    %eax,%ebx
  282a4a:	75 ec                	jne    282a38 <sheet_updown+0xb6>
			{
				ctl->sheets[h] = ctl->sheets[h-1];
				ctl->sheets[h]->height = h;
			}
			ctl->sheets[height] = sht;
  282a4c:	89 74 99 14          	mov    %esi,0x14(%ecx,%ebx,4)
		}
		//sheet_refresh(ctl);
		sheet_refresh(sht,0,0,sht->bxsize,sht->bysize);
  282a50:	ff 76 08             	pushl  0x8(%esi)
  282a53:	ff 76 04             	pushl  0x4(%esi)
  282a56:	6a 00                	push   $0x0
  282a58:	6a 00                	push   $0x0
  282a5a:	56                   	push   %esi
  282a5b:	e8 ee fe ff ff       	call   28294e <sheet_refresh>
  282a60:	83 c4 14             	add    $0x14,%esp
	}
	//else height not change.
	return;
}
  282a63:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282a66:	5b                   	pop    %ebx
  282a67:	5e                   	pop    %esi
  282a68:	5f                   	pop    %edi
  282a69:	5d                   	pop    %ebp
  282a6a:	c3                   	ret    

00282a6b <sheet_slide>:
	//}
	return;
}

void sheet_slide(struct SHEET *sht,int vx0,int vy0)
{
  282a6b:	55                   	push   %ebp
  282a6c:	89 e5                	mov    %esp,%ebp
  282a6e:	57                   	push   %edi
  282a6f:	56                   	push   %esi
  282a70:	53                   	push   %ebx
  282a71:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282a74:	8b 75 10             	mov    0x10(%ebp),%esi
	//(vx0,vy0): the sheet buf in the vram pos.
	int old_vx0 = sht->vx0,old_vy0 = sht->vy0;
  282a77:	8b 43 0c             	mov    0xc(%ebx),%eax
  282a7a:	8b 53 10             	mov    0x10(%ebx),%edx
	sht->vx0 = vx0;
  282a7d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  282a80:	89 7b 0c             	mov    %edi,0xc(%ebx)
	sht->vy0 = vy0;
  282a83:	89 73 10             	mov    %esi,0x10(%ebx)
	if(sht->height >= 0)
  282a86:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  282a8a:	78 36                	js     282ac2 <sheet_slide+0x57>
	{
		struct SHTCTL *ctl = sht->ctl;
  282a8c:	8b 7b 20             	mov    0x20(%ebx),%edi
		sheet_refreshsub2(ctl,old_vx0,old_vy0,old_vx0+sht->bxsize,old_vy0+sht->bysize, 0);
  282a8f:	6a 00                	push   $0x0
  282a91:	89 d1                	mov    %edx,%ecx
  282a93:	03 4b 08             	add    0x8(%ebx),%ecx
  282a96:	51                   	push   %ecx
  282a97:	89 c1                	mov    %eax,%ecx
  282a99:	03 4b 04             	add    0x4(%ebx),%ecx
  282a9c:	51                   	push   %ecx
  282a9d:	52                   	push   %edx
  282a9e:	50                   	push   %eax
  282a9f:	57                   	push   %edi
  282aa0:	e8 3c fd ff ff       	call   2827e1 <sheet_refreshsub2>
		sheet_refreshsub2(ctl,vx0,vy0,vx0+sht->bxsize,vy0+sht->bysize,sht->height);
  282aa5:	ff 73 18             	pushl  0x18(%ebx)
  282aa8:	89 f0                	mov    %esi,%eax
  282aaa:	03 43 08             	add    0x8(%ebx),%eax
  282aad:	50                   	push   %eax
  282aae:	8b 45 0c             	mov    0xc(%ebp),%eax
  282ab1:	03 43 04             	add    0x4(%ebx),%eax
  282ab4:	50                   	push   %eax
  282ab5:	56                   	push   %esi
  282ab6:	ff 75 0c             	pushl  0xc(%ebp)
  282ab9:	57                   	push   %edi
  282aba:	e8 22 fd ff ff       	call   2827e1 <sheet_refreshsub2>
  282abf:	83 c4 30             	add    $0x30,%esp
	}
	return;
}
  282ac2:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282ac5:	5b                   	pop    %ebx
  282ac6:	5e                   	pop    %esi
  282ac7:	5f                   	pop    %edi
  282ac8:	5d                   	pop    %ebp
  282ac9:	c3                   	ret    

00282aca <sheet_free>:

void sheet_free(struct SHEET *sht)
{
  282aca:	55                   	push   %ebp
  282acb:	89 e5                	mov    %esp,%ebp
  282acd:	53                   	push   %ebx
  282ace:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(sht->height >= 0)
  282ad1:	83 7b 18 00          	cmpl   $0x0,0x18(%ebx)
  282ad5:	78 0b                	js     282ae2 <sheet_free+0x18>
	{
		sheet_updown(sht,-1); //hide the sheet
  282ad7:	6a ff                	push   $0xffffffff
  282ad9:	53                   	push   %ebx
  282ada:	e8 a3 fe ff ff       	call   282982 <sheet_updown>
  282adf:	83 c4 08             	add    $0x8,%esp
	}
	sht->flags = 0; //set sheet unused.
  282ae2:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
	return;
}
  282ae9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  282aec:	c9                   	leave  
  282aed:	c3                   	ret    

00282aee <timer_alloc>:
	timerctl.next = 0xffffffff;
	return;
}

struct TIMER *timer_alloc(void)
{
  282aee:	55                   	push   %ebp
  282aef:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TIMER;i++)
	{
		if(timerctl.timers0[i].flags == 0)
  282af1:	83 3d 70 73 28 00 00 	cmpl   $0x0,0x287370
  282af8:	74 11                	je     282b0b <timer_alloc+0x1d>
  282afa:	ba 84 73 28 00       	mov    $0x287384,%edx
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282aff:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(timerctl.timers0[i].flags == 0)
  282b04:	83 3a 00             	cmpl   $0x0,(%edx)
  282b07:	75 25                	jne    282b2e <timer_alloc+0x40>
  282b09:	eb 05                	jmp    282b10 <timer_alloc+0x22>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282b0b:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(timerctl.timers0[i].flags == 0)
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
  282b10:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  282b17:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282b1a:	c7 04 8d 70 73 28 00 	movl   $0x1,0x287370(,%ecx,4)
  282b21:	01 00 00 00 
			return &timerctl.timers0[i];
  282b25:	8d 04 8d 68 73 28 00 	lea    0x287368(,%ecx,4),%eax
  282b2c:	eb 12                	jmp    282b40 <timer_alloc+0x52>
}

struct TIMER *timer_alloc(void)
{
	int i;
	for(i=0;i<MAX_TIMER;i++)
  282b2e:	83 c0 01             	add    $0x1,%eax
  282b31:	83 c2 14             	add    $0x14,%edx
  282b34:	3d f4 01 00 00       	cmp    $0x1f4,%eax
  282b39:	75 c9                	jne    282b04 <timer_alloc+0x16>
		{
			timerctl.timers0[i].flags = TIMER_FLAGS_ALLOC;
			return &timerctl.timers0[i];
		}
	}
	return 0;
  282b3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282b40:	5d                   	pop    %ebp
  282b41:	c3                   	ret    

00282b42 <init_pit>:
#include "task.h"

struct TIMERCTL timerctl;

void init_pit(void)
{
  282b42:	55                   	push   %ebp
  282b43:	89 e5                	mov    %esp,%ebp
  282b45:	83 ec 10             	sub    $0x10,%esp
	io_out8(PIT_CTRL,0X34);
  282b48:	6a 34                	push   $0x34
  282b4a:	6a 43                	push   $0x43
  282b4c:	e8 b5 e1 ff ff       	call   280d06 <io_out8>
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
  282b51:	83 c4 08             	add    $0x8,%esp
  282b54:	68 9c 00 00 00       	push   $0x9c
  282b59:	6a 40                	push   $0x40
  282b5b:	e8 a6 e1 ff ff       	call   280d06 <io_out8>
	io_out8(PIT_CNT0,0x2e);
  282b60:	83 c4 08             	add    $0x8,%esp
  282b63:	6a 2e                	push   $0x2e
  282b65:	6a 40                	push   $0x40
  282b67:	e8 9a e1 ff ff       	call   280d06 <io_out8>
  282b6c:	b8 70 73 28 00       	mov    $0x287370,%eax
  282b71:	ba 80 9a 28 00       	mov    $0x289a80,%edx
  282b76:	83 c4 10             	add    $0x10,%esp
	for(int i=0;i<MAX_TIMER;i++)
		timerctl.timers0[i].flags = 0;
  282b79:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  282b7f:	83 c0 14             	add    $0x14,%eax
{
	io_out8(PIT_CTRL,0X34);
	//out 0x2e9c (11932), make the pit freq = 100hz
	io_out8(PIT_CNT0,0X9C);
	io_out8(PIT_CNT0,0x2e);
	for(int i=0;i<MAX_TIMER;i++)
  282b82:	39 d0                	cmp    %edx,%eax
  282b84:	75 f3                	jne    282b79 <init_pit+0x37>
		timerctl.timers0[i].flags = 0;
	struct TIMER *t = timer_alloc();
  282b86:	e8 63 ff ff ff       	call   282aee <timer_alloc>
	t->next = 0;
  282b8b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	t->timeout = 0xffffffff;
  282b91:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%eax)
	t->flags = TIMER_FLAGS_USING;
  282b98:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	timerctl.t0 = t;
  282b9f:	a3 78 9a 28 00       	mov    %eax,0x289a78
	timerctl.next = 0xffffffff;
  282ba4:	c7 05 64 73 28 00 ff 	movl   $0xffffffff,0x287364
  282bab:	ff ff ff 
	return;
}
  282bae:	c9                   	leave  
  282baf:	c3                   	ret    

00282bb0 <timer_free>:
	}
	return 0;
}

void timer_free(struct TIMER *timer)
{
  282bb0:	55                   	push   %ebp
  282bb1:	89 e5                	mov    %esp,%ebp
	timer->flags = 0;
  282bb3:	8b 45 08             	mov    0x8(%ebp),%eax
  282bb6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return;
}
  282bbd:	5d                   	pop    %ebp
  282bbe:	c3                   	ret    

00282bbf <timer_init>:

void timer_init(struct TIMER *timer,struct FIFO32 *fifo,unsigned char data)
{
  282bbf:	55                   	push   %ebp
  282bc0:	89 e5                	mov    %esp,%ebp
  282bc2:	8b 45 08             	mov    0x8(%ebp),%eax
	timer->fifo = fifo;
  282bc5:	8b 55 0c             	mov    0xc(%ebp),%edx
  282bc8:	89 50 0c             	mov    %edx,0xc(%eax)
	timer->data = data;
  282bcb:	8b 55 10             	mov    0x10(%ebp),%edx
  282bce:	88 50 10             	mov    %dl,0x10(%eax)
	return ;
}
  282bd1:	5d                   	pop    %ebp
  282bd2:	c3                   	ret    

00282bd3 <timer_settime>:

void timer_settime(struct TIMER *timer,unsigned int timeout)
{
  282bd3:	55                   	push   %ebp
  282bd4:	89 e5                	mov    %esp,%ebp
  282bd6:	57                   	push   %edi
  282bd7:	56                   	push   %esi
  282bd8:	53                   	push   %ebx
  282bd9:	83 ec 0c             	sub    $0xc,%esp
  282bdc:	8b 5d 08             	mov    0x8(%ebp),%ebx
	timer->timeout = timeout + timerctl.count;
  282bdf:	a1 60 73 28 00       	mov    0x287360,%eax
  282be4:	03 45 0c             	add    0xc(%ebp),%eax
  282be7:	89 43 04             	mov    %eax,0x4(%ebx)
	timer->flags = TIMER_FLAGS_USING;
  282bea:	c7 43 08 02 00 00 00 	movl   $0x2,0x8(%ebx)
	int e = io_load_eflags();
  282bf1:	e8 2f e1 ff ff       	call   280d25 <io_load_eflags>
  282bf6:	89 c6                	mov    %eax,%esi
	io_cli();
  282bf8:	e8 d5 e0 ff ff       	call   280cd2 <io_cli>
	struct TIMER *t, *s;
	if(timer->timeout<=timerctl.t0->timeout)
  282bfd:	8b 4b 04             	mov    0x4(%ebx),%ecx
  282c00:	8b 3d 78 9a 28 00    	mov    0x289a78,%edi
  282c06:	3b 4f 04             	cmp    0x4(%edi),%ecx
  282c09:	77 1e                	ja     282c29 <timer_settime+0x56>
	{
		timer->next = timerctl.t0;
  282c0b:	89 3b                	mov    %edi,(%ebx)
		timerctl.t0 = timer;
  282c0d:	89 1d 78 9a 28 00    	mov    %ebx,0x289a78
		timerctl.next = timer->timeout;
  282c13:	8b 43 04             	mov    0x4(%ebx),%eax
  282c16:	a3 64 73 28 00       	mov    %eax,0x287364
		io_store_eflags(e);
  282c1b:	83 ec 0c             	sub    $0xc,%esp
  282c1e:	56                   	push   %esi
  282c1f:	e8 04 e1 ff ff       	call   280d28 <io_store_eflags>
		return;
  282c24:	83 c4 10             	add    $0x10,%esp
  282c27:	eb 3e                	jmp    282c67 <timer_settime+0x94>
	}
	t = timerctl.t0->next;
  282c29:	8b 17                	mov    (%edi),%edx
	s = timerctl.t0;
	while(t)
  282c2b:	85 d2                	test   %edx,%edx
  282c2d:	74 2c                	je     282c5b <timer_settime+0x88>
	{
		if(timer->timeout<=t->timeout)
  282c2f:	3b 4a 04             	cmp    0x4(%edx),%ecx
  282c32:	77 21                	ja     282c55 <timer_settime+0x82>
  282c34:	eb 07                	jmp    282c3d <timer_settime+0x6a>
  282c36:	3b 48 04             	cmp    0x4(%eax),%ecx
  282c39:	77 18                	ja     282c53 <timer_settime+0x80>
  282c3b:	eb 04                	jmp    282c41 <timer_settime+0x6e>
		timerctl.t0 = timer;
		timerctl.next = timer->timeout;
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
  282c3d:	89 d0                	mov    %edx,%eax
	s = timerctl.t0;
  282c3f:	89 fa                	mov    %edi,%edx
	while(t)
	{
		if(timer->timeout<=t->timeout)
		{
			timer->next = t;
  282c41:	89 03                	mov    %eax,(%ebx)
			s->next = timer;
  282c43:	89 1a                	mov    %ebx,(%edx)
			io_store_eflags(e);
  282c45:	83 ec 0c             	sub    $0xc,%esp
  282c48:	56                   	push   %esi
  282c49:	e8 da e0 ff ff       	call   280d28 <io_store_eflags>
			return;
  282c4e:	83 c4 10             	add    $0x10,%esp
  282c51:	eb 14                	jmp    282c67 <timer_settime+0x94>
		}
		s = t;
		t = t->next;
  282c53:	89 c2                	mov    %eax,%edx
  282c55:	8b 02                	mov    (%edx),%eax
		io_store_eflags(e);
		return;
	}
	t = timerctl.t0->next;
	s = timerctl.t0;
	while(t)
  282c57:	85 c0                	test   %eax,%eax
  282c59:	75 db                	jne    282c36 <timer_settime+0x63>
			return;
		}
		s = t;
		t = t->next;
	}
	io_store_eflags(e);
  282c5b:	83 ec 0c             	sub    $0xc,%esp
  282c5e:	56                   	push   %esi
  282c5f:	e8 c4 e0 ff ff       	call   280d28 <io_store_eflags>
	return;
  282c64:	83 c4 10             	add    $0x10,%esp
}
  282c67:	8d 65 f4             	lea    -0xc(%ebp),%esp
  282c6a:	5b                   	pop    %ebx
  282c6b:	5e                   	pop    %esi
  282c6c:	5f                   	pop    %edi
  282c6d:	5d                   	pop    %ebp
  282c6e:	c3                   	ret    

00282c6f <inthandler20>:

extern struct TIMER *task_timer;

//handler for int 20 (timer interrupts)
void inthandler20(int *esp)
{
  282c6f:	55                   	push   %ebp
  282c70:	89 e5                	mov    %esp,%ebp
  282c72:	56                   	push   %esi
  282c73:	53                   	push   %ebx
	char ts = 0;

	io_out8(PIC0_OCW2,0x60); //tell pic continue watch 20 int
  282c74:	83 ec 08             	sub    $0x8,%esp
  282c77:	6a 60                	push   $0x60
  282c79:	6a 20                	push   $0x20
  282c7b:	e8 86 e0 ff ff       	call   280d06 <io_out8>
	timerctl.count ++;
  282c80:	a1 60 73 28 00       	mov    0x287360,%eax
  282c85:	8d 50 01             	lea    0x1(%eax),%edx
  282c88:	89 15 60 73 28 00    	mov    %edx,0x287360
	
	if(timerctl.count >= timerctl.next)
  282c8e:	83 c4 10             	add    $0x10,%esp
  282c91:	3b 15 64 73 28 00    	cmp    0x287364,%edx
  282c97:	72 6e                	jb     282d07 <inthandler20+0x98>
	{
		struct TIMER *t = timerctl.t0;
  282c99:	8b 1d 78 9a 28 00    	mov    0x289a78,%ebx
		while(t)
  282c9f:	85 db                	test   %ebx,%ebx
  282ca1:	75 4b                	jne    282cee <inthandler20+0x7f>
  282ca3:	eb 62                	jmp    282d07 <inthandler20+0x98>
		{
			if(t->timeout <= timerctl.count)
  282ca5:	8b 43 04             	mov    0x4(%ebx),%eax
  282ca8:	3b 05 60 73 28 00    	cmp    0x287360,%eax
  282cae:	77 31                	ja     282ce1 <inthandler20+0x72>
			{
				t->flags = TIMER_FLAGS_ALLOC;
  282cb0:	c7 43 08 01 00 00 00 	movl   $0x1,0x8(%ebx)
				if(t!=task_timer) fifo32_put(t->fifo,t->data);
  282cb7:	39 1d 80 9a 28 00    	cmp    %ebx,0x289a80
  282cbd:	74 15                	je     282cd4 <inthandler20+0x65>
  282cbf:	83 ec 08             	sub    $0x8,%esp
  282cc2:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  282cc6:	50                   	push   %eax
  282cc7:	ff 73 0c             	pushl  0xc(%ebx)
  282cca:	e8 9a f0 ff ff       	call   281d69 <fifo32_put>
  282ccf:	83 c4 10             	add    $0x10,%esp
  282cd2:	eb 05                	jmp    282cd9 <inthandler20+0x6a>
				else ts=1;
  282cd4:	be 01 00 00 00       	mov    $0x1,%esi
				t = t->next;
  282cd9:	8b 1b                	mov    (%ebx),%ebx
	timerctl.count ++;
	
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
  282cdb:	85 db                	test   %ebx,%ebx
  282cdd:	75 c6                	jne    282ca5 <inthandler20+0x36>
  282cdf:	eb 1b                	jmp    282cfc <inthandler20+0x8d>
				else ts=1;
				t = t->next;
			}
			else
			{
				timerctl.next = t->timeout;
  282ce1:	a3 64 73 28 00       	mov    %eax,0x287364
				timerctl.t0 = t;
  282ce6:	89 1d 78 9a 28 00    	mov    %ebx,0x289a78
				break;
  282cec:	eb 0e                	jmp    282cfc <inthandler20+0x8d>
	if(timerctl.count >= timerctl.next)
	{
		struct TIMER *t = timerctl.t0;
		while(t)
		{
			if(t->timeout <= timerctl.count)
  282cee:	8b 43 04             	mov    0x4(%ebx),%eax
  282cf1:	be 00 00 00 00       	mov    $0x0,%esi
  282cf6:	39 c2                	cmp    %eax,%edx
  282cf8:	73 b6                	jae    282cb0 <inthandler20+0x41>
  282cfa:	eb e5                	jmp    282ce1 <inthandler20+0x72>
				break;
			}
		}
	}

	if(ts!=0)task_switch();
  282cfc:	89 f0                	mov    %esi,%eax
  282cfe:	84 c0                	test   %al,%al
  282d00:	74 05                	je     282d07 <inthandler20+0x98>
  282d02:	e8 04 04 00 00       	call   28310b <task_switch>
	return;
}
  282d07:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282d0a:	5b                   	pop    %ebx
  282d0b:	5e                   	pop    %esi
  282d0c:	5d                   	pop    %ebp
  282d0d:	c3                   	ret    
  282d0e:	66 90                	xchg   %ax,%ax

00282d10 <load_tr>:
  282d10:	0f 00 5c 24 04       	ltr    0x4(%esp)
  282d15:	c3                   	ret    

00282d16 <farjmp>:
  282d16:	ff 6c 24 04          	ljmp   *0x4(%esp)
  282d1a:	c3                   	ret    

00282d1b <farcall>:
  282d1b:	ff 5c 24 04          	lcall  *0x4(%esp)
  282d1f:	c3                   	ret    

00282d20 <asm_end_app>:
  282d20:	8b 20                	mov    (%eax),%esp
  282d22:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  282d29:	61                   	popa   
  282d2a:	c3                   	ret    

00282d2b <task_idle>:

struct TASKCTL *taskctl;
struct TIMER *task_timer;

void task_idle(void)
{
  282d2b:	55                   	push   %ebp
  282d2c:	89 e5                	mov    %esp,%ebp
  282d2e:	83 ec 08             	sub    $0x8,%esp
	for(;;)
	{
		io_hlt();
  282d31:	e8 9a df ff ff       	call   280cd0 <io_hlt>
  282d36:	eb f9                	jmp    282d31 <task_idle+0x6>

00282d38 <task_alloc>:
	task_run(idle,MAX_TASKLEVELS-1,1);
	return task;
}

struct TASK *task_alloc(void)
{
  282d38:	55                   	push   %ebp
  282d39:	89 e5                	mov    %esp,%ebp
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
	{
		if(taskctl->tasks0[i].flags == 0)
  282d3b:	8b 0d 7c 9a 28 00    	mov    0x289a7c,%ecx
  282d41:	83 b9 fc 0f 00 00 00 	cmpl   $0x0,0xffc(%ecx)
  282d48:	74 16                	je     282d60 <task_alloc+0x28>
  282d4a:	8d 91 90 10 00 00    	lea    0x1090(%ecx),%edx

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282d50:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
  282d55:	83 3a 00             	cmpl   $0x0,(%edx)
  282d58:	0f 85 b9 00 00 00    	jne    282e17 <task_alloc+0xdf>
  282d5e:	eb 05                	jmp    282d65 <task_alloc+0x2d>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282d60:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->tasks0[i].flags == 0)
		{
			task = &taskctl->tasks0[i];
  282d65:	69 c0 94 00 00 00    	imul   $0x94,%eax,%eax
			task->flags = 1;
  282d6b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
  282d6e:	c7 82 fc 0f 00 00 01 	movl   $0x1,0xffc(%edx)
  282d75:	00 00 00 
			task->tss.eflags = 0x202;
  282d78:	c7 82 48 10 00 00 02 	movl   $0x202,0x1048(%edx)
  282d7f:	02 00 00 
			task->tss.eax = 0;
  282d82:	c7 82 4c 10 00 00 00 	movl   $0x0,0x104c(%edx)
  282d89:	00 00 00 
			task->tss.ecx = 0;
  282d8c:	c7 82 50 10 00 00 00 	movl   $0x0,0x1050(%edx)
  282d93:	00 00 00 
			task->tss.edx = 0;
  282d96:	c7 82 54 10 00 00 00 	movl   $0x0,0x1054(%edx)
  282d9d:	00 00 00 
			task->tss.ebx = 0;
  282da0:	c7 82 58 10 00 00 00 	movl   $0x0,0x1058(%edx)
  282da7:	00 00 00 
			task->tss.ebp = 0;
  282daa:	c7 82 60 10 00 00 00 	movl   $0x0,0x1060(%edx)
  282db1:	00 00 00 
			task->tss.esi = 0;
  282db4:	c7 82 64 10 00 00 00 	movl   $0x0,0x1064(%edx)
  282dbb:	00 00 00 
			task->tss.edi = 0;
  282dbe:	c7 82 68 10 00 00 00 	movl   $0x0,0x1068(%edx)
  282dc5:	00 00 00 
			task->tss.es  = 0;
  282dc8:	c7 82 6c 10 00 00 00 	movl   $0x0,0x106c(%edx)
  282dcf:	00 00 00 
			task->tss.ds  = 0;
  282dd2:	c7 82 78 10 00 00 00 	movl   $0x0,0x1078(%edx)
  282dd9:	00 00 00 
			task->tss.fs  = 0;
  282ddc:	c7 82 7c 10 00 00 00 	movl   $0x0,0x107c(%edx)
  282de3:	00 00 00 
			task->tss.gs  = 0;
  282de6:	c7 82 80 10 00 00 00 	movl   $0x0,0x1080(%edx)
  282ded:	00 00 00 
			task->tss.ldtr= 0;
  282df0:	c7 82 84 10 00 00 00 	movl   $0x0,0x1084(%edx)
  282df7:	00 00 00 
			task->tss.iomap = 0x40000000;
  282dfa:	c7 82 88 10 00 00 00 	movl   $0x40000000,0x1088(%edx)
  282e01:	00 00 40 
			task->tss.ss0 = 0;
  282e04:	c7 82 2c 10 00 00 00 	movl   $0x0,0x102c(%edx)
  282e0b:	00 00 00 
			return task;
  282e0e:	8d 84 01 f8 0f 00 00 	lea    0xff8(%ecx,%eax,1),%eax
  282e15:	eb 19                	jmp    282e30 <task_alloc+0xf8>

struct TASK *task_alloc(void)
{
	int i;
	struct TASK *task;
	for(i=0;i<MAX_TASKS;i++)
  282e17:	83 c0 01             	add    $0x1,%eax
  282e1a:	81 c2 94 00 00 00    	add    $0x94,%edx
  282e20:	3d e8 03 00 00       	cmp    $0x3e8,%eax
  282e25:	0f 85 2a ff ff ff    	jne    282d55 <task_alloc+0x1d>
			task->tss.iomap = 0x40000000;
			task->tss.ss0 = 0;
			return task;
		}
	}
	return 0;
  282e2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  282e30:	5d                   	pop    %ebp
  282e31:	c3                   	ret    

00282e32 <task_now>:
	}
	return;
}

struct TASK *task_now(void)
{
  282e32:	55                   	push   %ebp
  282e33:	89 e5                	mov    %esp,%ebp
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  282e35:	8b 15 7c 9a 28 00    	mov    0x289a7c,%edx
  282e3b:	8b 02                	mov    (%edx),%eax
	return tl->tasks[tl->now];
  282e3d:	69 c8 98 01 00 00    	imul   $0x198,%eax,%ecx
  282e43:	6b c0 66             	imul   $0x66,%eax,%eax
  282e46:	03 44 0a 0c          	add    0xc(%edx,%ecx,1),%eax
  282e4a:	8b 44 82 10          	mov    0x10(%edx,%eax,4),%eax
}
  282e4e:	5d                   	pop    %ebp
  282e4f:	c3                   	ret    

00282e50 <task_add>:

void task_add(struct TASK *task)
{
  282e50:	55                   	push   %ebp
  282e51:	89 e5                	mov    %esp,%ebp
  282e53:	56                   	push   %esi
  282e54:	53                   	push   %ebx
  282e55:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  282e58:	8b 35 7c 9a 28 00    	mov    0x289a7c,%esi
  282e5e:	8b 4b 08             	mov    0x8(%ebx),%ecx
  282e61:	69 c1 98 01 00 00    	imul   $0x198,%ecx,%eax
  282e67:	01 f0                	add    %esi,%eax
	if(tl->running == MAX_TASKS_LV) return;
  282e69:	8b 50 08             	mov    0x8(%eax),%edx
  282e6c:	83 fa 64             	cmp    $0x64,%edx
  282e6f:	74 14                	je     282e85 <task_add+0x35>
	tl->tasks[tl->running] = task;
  282e71:	6b c9 66             	imul   $0x66,%ecx,%ecx
  282e74:	01 ca                	add    %ecx,%edx
  282e76:	89 5c 96 10          	mov    %ebx,0x10(%esi,%edx,4)
	tl->running++;
  282e7a:	83 40 08 01          	addl   $0x1,0x8(%eax)
	task->flags = 2;	//alive
  282e7e:	c7 43 04 02 00 00 00 	movl   $0x2,0x4(%ebx)
	return;
}
  282e85:	5b                   	pop    %ebx
  282e86:	5e                   	pop    %esi
  282e87:	5d                   	pop    %ebp
  282e88:	c3                   	ret    

00282e89 <task_remove>:

void task_remove(struct TASK *task)
{
  282e89:	55                   	push   %ebp
  282e8a:	89 e5                	mov    %esp,%ebp
  282e8c:	57                   	push   %edi
  282e8d:	56                   	push   %esi
  282e8e:	53                   	push   %ebx
  282e8f:	83 ec 04             	sub    $0x4,%esp
  282e92:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASKLEVEL *tl = &taskctl->level[task->level];
  282e95:	8b 3d 7c 9a 28 00    	mov    0x289a7c,%edi
  282e9b:	8b 43 08             	mov    0x8(%ebx),%eax
  282e9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  282ea1:	69 d0 98 01 00 00    	imul   $0x198,%eax,%edx
  282ea7:	01 fa                	add    %edi,%edx
	int i;
	for(i=0;i<tl->running;i++)
  282ea9:	8b 4a 08             	mov    0x8(%edx),%ecx
  282eac:	85 c9                	test   %ecx,%ecx
  282eae:	7e 1d                	jle    282ecd <task_remove+0x44>
	{
		if(tl->tasks[i] == task)
  282eb0:	3b 5a 10             	cmp    0x10(%edx),%ebx
  282eb3:	74 1f                	je     282ed4 <task_remove+0x4b>
  282eb5:	b8 00 00 00 00       	mov    $0x0,%eax
  282eba:	eb 06                	jmp    282ec2 <task_remove+0x39>
  282ebc:	3b 5c 82 10          	cmp    0x10(%edx,%eax,4),%ebx
  282ec0:	74 17                	je     282ed9 <task_remove+0x50>

void task_remove(struct TASK *task)
{
	struct TASKLEVEL *tl = &taskctl->level[task->level];
	int i;
	for(i=0;i<tl->running;i++)
  282ec2:	83 c0 01             	add    $0x1,%eax
  282ec5:	39 c8                	cmp    %ecx,%eax
  282ec7:	75 f3                	jne    282ebc <task_remove+0x33>
  282ec9:	89 c8                	mov    %ecx,%eax
  282ecb:	eb 0c                	jmp    282ed9 <task_remove+0x50>
  282ecd:	b8 00 00 00 00       	mov    $0x0,%eax
  282ed2:	eb 05                	jmp    282ed9 <task_remove+0x50>
  282ed4:	b8 00 00 00 00       	mov    $0x0,%eax
		if(tl->tasks[i] == task)
		{
			break;
		}
	}
	tl->running--;
  282ed9:	83 e9 01             	sub    $0x1,%ecx
  282edc:	89 4a 08             	mov    %ecx,0x8(%edx)
	if(i<tl->now)
  282edf:	8b 72 0c             	mov    0xc(%edx),%esi
  282ee2:	39 c6                	cmp    %eax,%esi
  282ee4:	7e 06                	jle    282eec <task_remove+0x63>
	{
		tl->now--;
  282ee6:	83 ee 01             	sub    $0x1,%esi
  282ee9:	89 72 0c             	mov    %esi,0xc(%edx)
	}
	if(tl->now >= tl->running)
  282eec:	3b 4a 0c             	cmp    0xc(%edx),%ecx
  282eef:	7f 07                	jg     282ef8 <task_remove+0x6f>
	{
		tl->now = 0;
  282ef1:	c7 42 0c 00 00 00 00 	movl   $0x0,0xc(%edx)
	}
	task->flags = 1; //sleep;
  282ef8:	c7 43 04 01 00 00 00 	movl   $0x1,0x4(%ebx)
	
	for(;i<tl->running;i++)
  282eff:	39 42 08             	cmp    %eax,0x8(%edx)
  282f02:	7e 1b                	jle    282f1f <task_remove+0x96>
  282f04:	6b 4d f0 66          	imul   $0x66,-0x10(%ebp),%ecx
  282f08:	8d 4c 08 05          	lea    0x5(%eax,%ecx,1),%ecx
  282f0c:	8d 0c 8f             	lea    (%edi,%ecx,4),%ecx
	{
		tl->tasks[i] = tl->tasks[i+1];
  282f0f:	83 c0 01             	add    $0x1,%eax
  282f12:	8b 19                	mov    (%ecx),%ebx
  282f14:	89 59 fc             	mov    %ebx,-0x4(%ecx)
  282f17:	83 c1 04             	add    $0x4,%ecx
	{
		tl->now = 0;
	}
	task->flags = 1; //sleep;
	
	for(;i<tl->running;i++)
  282f1a:	39 42 08             	cmp    %eax,0x8(%edx)
  282f1d:	7f f0                	jg     282f0f <task_remove+0x86>
	{
		tl->tasks[i] = tl->tasks[i+1];
	}
	return;
}
  282f1f:	83 c4 04             	add    $0x4,%esp
  282f22:	5b                   	pop    %ebx
  282f23:	5e                   	pop    %esi
  282f24:	5f                   	pop    %edi
  282f25:	5d                   	pop    %ebp
  282f26:	c3                   	ret    

00282f27 <task_run>:
	}
	return 0;
}

void task_run(struct TASK *task,int level,int priority)
{
  282f27:	55                   	push   %ebp
  282f28:	89 e5                	mov    %esp,%ebp
  282f2a:	56                   	push   %esi
  282f2b:	53                   	push   %ebx
  282f2c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  282f2f:	8b 75 0c             	mov    0xc(%ebp),%esi
  282f32:	8b 45 10             	mov    0x10(%ebp),%eax
	if(level < 0) level = task->level;
  282f35:	85 f6                	test   %esi,%esi
  282f37:	79 03                	jns    282f3c <task_run+0x15>
  282f39:	8b 73 08             	mov    0x8(%ebx),%esi
	if(priority > 0) task->priority = priority;
  282f3c:	85 c0                	test   %eax,%eax
  282f3e:	7e 03                	jle    282f43 <task_run+0x1c>
  282f40:	89 43 0c             	mov    %eax,0xc(%ebx)
	if(task->flags == 2 && task->level != level)
  282f43:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282f47:	75 14                	jne    282f5d <task_run+0x36>
  282f49:	3b 73 08             	cmp    0x8(%ebx),%esi
  282f4c:	74 1b                	je     282f69 <task_run+0x42>
	{
		task_remove(task); //then task->flags = 1;
  282f4e:	53                   	push   %ebx
  282f4f:	e8 35 ff ff ff       	call   282e89 <task_remove>
	}
	if(task->flags != 2)
  282f54:	83 c4 04             	add    $0x4,%esp
  282f57:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  282f5b:	74 0c                	je     282f69 <task_run+0x42>
	{
		task->level = level;
  282f5d:	89 73 08             	mov    %esi,0x8(%ebx)
		task_add(task);
  282f60:	53                   	push   %ebx
  282f61:	e8 ea fe ff ff       	call   282e50 <task_add>
  282f66:	83 c4 04             	add    $0x4,%esp
	}
	taskctl->lv_change = 1;
  282f69:	a1 7c 9a 28 00       	mov    0x289a7c,%eax
  282f6e:	c6 40 04 01          	movb   $0x1,0x4(%eax)
	return;
}
  282f72:	8d 65 f8             	lea    -0x8(%ebp),%esp
  282f75:	5b                   	pop    %ebx
  282f76:	5e                   	pop    %esi
  282f77:	5d                   	pop    %ebp
  282f78:	c3                   	ret    

00282f79 <task_switchsub>:
	}
	return;
}

void task_switchsub(void)
{
  282f79:	55                   	push   %ebp
  282f7a:	89 e5                	mov    %esp,%ebp
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		if(taskctl->level[i].running>0) break;
  282f7c:	8b 0d 7c 9a 28 00    	mov    0x289a7c,%ecx
  282f82:	83 79 08 00          	cmpl   $0x0,0x8(%ecx)
  282f86:	7f 20                	jg     282fa8 <task_switchsub+0x2f>
  282f88:	8d 91 a0 01 00 00    	lea    0x1a0(%ecx),%edx
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282f8e:	b8 01 00 00 00       	mov    $0x1,%eax
	{
		if(taskctl->level[i].running>0) break;
  282f93:	83 3a 00             	cmpl   $0x0,(%edx)
  282f96:	7f 15                	jg     282fad <task_switchsub+0x34>
}

void task_switchsub(void)
{
	int i;
	for(i=0;i<MAX_TASKLEVELS;i++)
  282f98:	83 c0 01             	add    $0x1,%eax
  282f9b:	81 c2 98 01 00 00    	add    $0x198,%edx
  282fa1:	83 f8 0a             	cmp    $0xa,%eax
  282fa4:	75 ed                	jne    282f93 <task_switchsub+0x1a>
  282fa6:	eb 05                	jmp    282fad <task_switchsub+0x34>
  282fa8:	b8 00 00 00 00       	mov    $0x0,%eax
	{
		if(taskctl->level[i].running>0) break;
	}
	taskctl->now_lv = i;
  282fad:	89 01                	mov    %eax,(%ecx)
	taskctl->lv_change = 0;
  282faf:	a1 7c 9a 28 00       	mov    0x289a7c,%eax
  282fb4:	c6 40 04 00          	movb   $0x0,0x4(%eax)
	return;
}
  282fb8:	5d                   	pop    %ebp
  282fb9:	c3                   	ret    

00282fba <task_init>:
		io_hlt();
	}
}

struct TASK *task_init(struct MEMMAN *memman)
{
  282fba:	55                   	push   %ebp
  282fbb:	89 e5                	mov    %esp,%ebp
  282fbd:	57                   	push   %edi
  282fbe:	56                   	push   %esi
  282fbf:	53                   	push   %ebx
  282fc0:	83 ec 14             	sub    $0x14,%esp
  282fc3:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
  282fc6:	68 18 52 02 00       	push   $0x25218
  282fcb:	57                   	push   %edi
  282fcc:	e8 1c f5 ff ff       	call   2824ed <memman_alloc_4k>
  282fd1:	a3 7c 9a 28 00       	mov    %eax,0x289a7c
  282fd6:	83 c4 10             	add    $0x10,%esp
  282fd9:	be 20 00 00 00       	mov    $0x20,%esi
	for(i=0;i<MAX_TASKS;i++)
  282fde:	bb 00 00 00 00       	mov    $0x0,%ebx
	{
		taskctl->tasks0[i].flags = 0;
  282fe3:	8b 15 7c 9a 28 00    	mov    0x289a7c,%edx
  282fe9:	69 c3 94 00 00 00    	imul   $0x94,%ebx,%eax
  282fef:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  282ff2:	c7 81 fc 0f 00 00 00 	movl   $0x0,0xffc(%ecx)
  282ff9:	00 00 00 
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
  282ffc:	89 b1 f8 0f 00 00    	mov    %esi,0xff8(%ecx)
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
  283002:	68 89 00 00 00       	push   $0x89
  283007:	8d 84 02 24 10 00 00 	lea    0x1024(%edx,%eax,1),%eax
  28300e:	50                   	push   %eax
  28300f:	6a 67                	push   $0x67
  283011:	8d 86 00 00 27 00    	lea    0x270000(%esi),%eax
  283017:	50                   	push   %eax
  283018:	e8 e8 e5 ff ff       	call   281605 <set_segmdesc>
{
	int i;
	struct TASK *task;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	taskctl = (struct TASKCTL *)memman_alloc_4k(memman,sizeof(struct TASKCTL));
	for(i=0;i<MAX_TASKS;i++)
  28301d:	83 c3 01             	add    $0x1,%ebx
  283020:	83 c6 08             	add    $0x8,%esi
  283023:	83 c4 10             	add    $0x10,%esp
  283026:	81 fb e8 03 00 00    	cmp    $0x3e8,%ebx
  28302c:	75 b5                	jne    282fe3 <task_init+0x29>
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
	{
		taskctl->level[i].running = 0;
  28302e:	8b 15 7c 9a 28 00    	mov    0x289a7c,%edx
  283034:	8d 42 08             	lea    0x8(%edx),%eax
  283037:	81 c2 f8 0f 00 00    	add    $0xff8,%edx
  28303d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		taskctl->level[i].now = 0;
  283043:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  28304a:	05 98 01 00 00       	add    $0x198,%eax
		taskctl->tasks0[i].flags = 0;
		taskctl->tasks0[i].sel = (TASK_GDT0+i)*8;
		set_segmdesc(gdt+TASK_GDT0+i,103,(int)&taskctl->tasks0[i].tss,AR_TSS32);
	}

	for(i=0;i<MAX_TASKLEVELS;i++)
  28304f:	39 d0                	cmp    %edx,%eax
  283051:	75 ea                	jne    28303d <task_init+0x83>
	{
		taskctl->level[i].running = 0;
		taskctl->level[i].now = 0;
	}
	task = task_alloc();
  283053:	e8 e0 fc ff ff       	call   282d38 <task_alloc>
  283058:	89 c6                	mov    %eax,%esi
	task->flags = 2;
  28305a:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
	task->priority = 2;
  283061:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
	task->level = 0;
  283068:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	task_add(task);
  28306f:	83 ec 0c             	sub    $0xc,%esp
  283072:	50                   	push   %eax
  283073:	e8 d8 fd ff ff       	call   282e50 <task_add>
	
	task_switchsub();
  283078:	e8 fc fe ff ff       	call   282f79 <task_switchsub>
	load_tr(task->sel);
  28307d:	83 c4 04             	add    $0x4,%esp
  283080:	ff 36                	pushl  (%esi)
  283082:	e8 89 fc ff ff       	call   282d10 <load_tr>
	task_timer = timer_alloc();
  283087:	e8 62 fa ff ff       	call   282aee <timer_alloc>
  28308c:	a3 80 9a 28 00       	mov    %eax,0x289a80
	timer_settime(task_timer,task->priority);
  283091:	83 c4 08             	add    $0x8,%esp
  283094:	ff 76 0c             	pushl  0xc(%esi)
  283097:	50                   	push   %eax
  283098:	e8 36 fb ff ff       	call   282bd3 <timer_settime>

	struct TASK *idle = task_alloc();
  28309d:	e8 96 fc ff ff       	call   282d38 <task_alloc>
  2830a2:	89 c3                	mov    %eax,%ebx
	idle->tss.esp = memman_alloc(memman,64*1024)+64*1024;
  2830a4:	83 c4 08             	add    $0x8,%esp
  2830a7:	68 00 00 01 00       	push   $0x10000
  2830ac:	57                   	push   %edi
  2830ad:	e8 ff f0 ff ff       	call   2821b1 <memman_alloc>
  2830b2:	05 00 00 01 00       	add    $0x10000,%eax
  2830b7:	89 43 64             	mov    %eax,0x64(%ebx)
	idle->tss.eip = (int)&task_idle-0x280000;
  2830ba:	c7 43 4c 2b 2d 00 00 	movl   $0x2d2b,0x4c(%ebx)
	idle->tss.es = 1*8;
  2830c1:	c7 43 74 08 00 00 00 	movl   $0x8,0x74(%ebx)
	idle->tss.cs = 3*8;
  2830c8:	c7 43 78 18 00 00 00 	movl   $0x18,0x78(%ebx)
	idle->tss.ss = 1*8;
  2830cf:	c7 43 7c 08 00 00 00 	movl   $0x8,0x7c(%ebx)
	idle->tss.ds = 1*8;
  2830d6:	c7 83 80 00 00 00 08 	movl   $0x8,0x80(%ebx)
  2830dd:	00 00 00 
	idle->tss.fs = 1*8;
  2830e0:	c7 83 84 00 00 00 08 	movl   $0x8,0x84(%ebx)
  2830e7:	00 00 00 
	idle->tss.gs = 1*8;
  2830ea:	c7 83 88 00 00 00 08 	movl   $0x8,0x88(%ebx)
  2830f1:	00 00 00 
	task_run(idle,MAX_TASKLEVELS-1,1);
  2830f4:	83 c4 0c             	add    $0xc,%esp
  2830f7:	6a 01                	push   $0x1
  2830f9:	6a 09                	push   $0x9
  2830fb:	53                   	push   %ebx
  2830fc:	e8 26 fe ff ff       	call   282f27 <task_run>
	return task;
}
  283101:	89 f0                	mov    %esi,%eax
  283103:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283106:	5b                   	pop    %ebx
  283107:	5e                   	pop    %esi
  283108:	5f                   	pop    %edi
  283109:	5d                   	pop    %ebp
  28310a:	c3                   	ret    

0028310b <task_switch>:
	taskctl->lv_change = 1;
	return;
}

void task_switch(void)
{
  28310b:	55                   	push   %ebp
  28310c:	89 e5                	mov    %esp,%ebp
  28310e:	56                   	push   %esi
  28310f:	53                   	push   %ebx
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  283110:	8b 0d 7c 9a 28 00    	mov    0x289a7c,%ecx
  283116:	8b 31                	mov    (%ecx),%esi
  283118:	69 c6 98 01 00 00    	imul   $0x198,%esi,%eax
  28311e:	01 c8                	add    %ecx,%eax
	struct TASK *new_task,*now_task = tl->tasks[tl->now];
  283120:	8b 50 0c             	mov    0xc(%eax),%edx
  283123:	6b de 66             	imul   $0x66,%esi,%ebx
  283126:	01 d3                	add    %edx,%ebx
  283128:	8b 5c 99 10          	mov    0x10(%ecx,%ebx,4),%ebx
	tl->now++;
  28312c:	83 c2 01             	add    $0x1,%edx
  28312f:	89 50 0c             	mov    %edx,0xc(%eax)
	if(tl->now == tl->running)
  283132:	3b 50 08             	cmp    0x8(%eax),%edx
  283135:	75 07                	jne    28313e <task_switch+0x33>
	{
		tl->now = 0;
  283137:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
	if(taskctl->lv_change!=0)
  28313e:	80 79 04 00          	cmpb   $0x0,0x4(%ecx)
  283142:	75 0c                	jne    283150 <task_switch+0x45>
	return;
}

void task_switch(void)
{
	struct TASKLEVEL *tl = &taskctl->level[taskctl->now_lv];
  283144:	69 f6 98 01 00 00    	imul   $0x198,%esi,%esi
  28314a:	8d 44 31 08          	lea    0x8(%ecx,%esi,1),%eax
  28314e:	eb 14                	jmp    283164 <task_switch+0x59>
	{
		tl->now = 0;
	}
	if(taskctl->lv_change!=0)
	{
		task_switchsub();
  283150:	e8 24 fe ff ff       	call   282f79 <task_switchsub>
		tl = &taskctl->level[taskctl->now_lv];
  283155:	a1 7c 9a 28 00       	mov    0x289a7c,%eax
  28315a:	69 10 98 01 00 00    	imul   $0x198,(%eax),%edx
  283160:	8d 44 10 08          	lea    0x8(%eax,%edx,1),%eax
	}
	new_task = tl->tasks[tl->now];
  283164:	8b 50 04             	mov    0x4(%eax),%edx
  283167:	8b 74 90 08          	mov    0x8(%eax,%edx,4),%esi
	timer_settime(task_timer,new_task->priority);
  28316b:	83 ec 08             	sub    $0x8,%esp
  28316e:	ff 76 0c             	pushl  0xc(%esi)
  283171:	ff 35 80 9a 28 00    	pushl  0x289a80
  283177:	e8 57 fa ff ff       	call   282bd3 <timer_settime>
	if(new_task != now_task)
  28317c:	83 c4 10             	add    $0x10,%esp
  28317f:	39 f3                	cmp    %esi,%ebx
  283181:	74 0f                	je     283192 <task_switch+0x87>
	{
		farjmp(0,new_task->sel);
  283183:	83 ec 08             	sub    $0x8,%esp
  283186:	ff 36                	pushl  (%esi)
  283188:	6a 00                	push   $0x0
  28318a:	e8 87 fb ff ff       	call   282d16 <farjmp>
  28318f:	83 c4 10             	add    $0x10,%esp
	}
	return;
}
  283192:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283195:	5b                   	pop    %ebx
  283196:	5e                   	pop    %esi
  283197:	5d                   	pop    %ebp
  283198:	c3                   	ret    

00283199 <task_sleep>:

void task_sleep(struct TASK *task)
{
  283199:	55                   	push   %ebp
  28319a:	89 e5                	mov    %esp,%ebp
  28319c:	56                   	push   %esi
  28319d:	53                   	push   %ebx
  28319e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct TASK *now_task;
	if(task->flags == 2)
  2831a1:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  2831a5:	75 2d                	jne    2831d4 <task_sleep+0x3b>
	{
		now_task = task_now();
  2831a7:	e8 86 fc ff ff       	call   282e32 <task_now>
  2831ac:	89 c6                	mov    %eax,%esi
		task_remove(task);
  2831ae:	53                   	push   %ebx
  2831af:	e8 d5 fc ff ff       	call   282e89 <task_remove>
		if(task == now_task)
  2831b4:	83 c4 04             	add    $0x4,%esp
  2831b7:	39 f3                	cmp    %esi,%ebx
  2831b9:	75 19                	jne    2831d4 <task_sleep+0x3b>
		{
			task_switchsub();
  2831bb:	e8 b9 fd ff ff       	call   282f79 <task_switchsub>
			now_task = task_now();
  2831c0:	e8 6d fc ff ff       	call   282e32 <task_now>
			farjmp(0,now_task->sel);
  2831c5:	83 ec 08             	sub    $0x8,%esp
  2831c8:	ff 30                	pushl  (%eax)
  2831ca:	6a 00                	push   $0x0
  2831cc:	e8 45 fb ff ff       	call   282d16 <farjmp>
  2831d1:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  2831d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2831d7:	5b                   	pop    %ebx
  2831d8:	5e                   	pop    %esi
  2831d9:	5d                   	pop    %ebp
  2831da:	c3                   	ret    

002831db <console_task>:
#include "header.h"
void console_task(struct SHEET *sheet,unsigned int memtotal)
{
  2831db:	55                   	push   %ebp
  2831dc:	89 e5                	mov    %esp,%ebp
  2831de:	57                   	push   %edi
  2831df:	56                   	push   %esi
  2831e0:	53                   	push   %ebx
  2831e1:	81 ec 5c 02 00 00    	sub    $0x25c,%esp
  2831e7:	8b 7d 08             	mov    0x8(%ebp),%edi
	char s[50],cmdline[30];
	struct TASK *task = task_now();
  2831ea:	e8 43 fc ff ff       	call   282e32 <task_now>
  2831ef:	89 85 a4 fd ff ff    	mov    %eax,-0x25c(%ebp)
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct CONSOLE cons;
	cons.sht = sheet;
  2831f5:	89 7d b4             	mov    %edi,-0x4c(%ebp)
	cons.cur_x = 8;
  2831f8:	c7 45 b8 08 00 00 00 	movl   $0x8,-0x48(%ebp)
	cons.cur_y = 28;
  2831ff:	c7 45 bc 1c 00 00 00 	movl   $0x1c,-0x44(%ebp)
	cons.cur_c = -1;
  283206:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
	*((int *)0x0fec) = (int)&cons; //for api
  28320d:	8d 5d b4             	lea    -0x4c(%ebp),%ebx
  283210:	89 1d ec 0f 00 00    	mov    %ebx,0xfec

	int i,fifobuf[128];
	fifo32_init(&task->fifo,128,fifobuf,task);
  283216:	8d 70 10             	lea    0x10(%eax),%esi
  283219:	50                   	push   %eax
  28321a:	8d 85 b4 fd ff ff    	lea    -0x24c(%ebp),%eax
  283220:	50                   	push   %eax
  283221:	68 80 00 00 00       	push   $0x80
  283226:	56                   	push   %esi
  283227:	e8 0c eb ff ff       	call   281d38 <fifo32_init>
	cons.timer = timer_alloc();
  28322c:	e8 bd f8 ff ff       	call   282aee <timer_alloc>
  283231:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	timer_init(cons.timer,&task->fifo,1);
  283234:	83 c4 0c             	add    $0xc,%esp
  283237:	6a 01                	push   $0x1
  283239:	56                   	push   %esi
  28323a:	50                   	push   %eax
  28323b:	e8 7f f9 ff ff       	call   282bbf <timer_init>
	timer_settime(cons.timer,50);
  283240:	83 c4 08             	add    $0x8,%esp
  283243:	6a 32                	push   $0x32
  283245:	ff 75 c4             	pushl  -0x3c(%ebp)
  283248:	e8 86 f9 ff ff       	call   282bd3 <timer_settime>
	
	int *fat = (int *)memman_alloc_4k(memman, 4*2880);
  28324d:	83 c4 08             	add    $0x8,%esp
  283250:	68 00 2d 00 00       	push   $0x2d00
  283255:	68 00 00 3c 00       	push   $0x3c0000
  28325a:	e8 8e f2 ff ff       	call   2824ed <memman_alloc_4k>
  28325f:	89 85 a0 fd ff ff    	mov    %eax,-0x260(%ebp)
	file_readfat(fat,(unsigned char *)(ADR_DISKIMG+0x000200));
  283265:	83 c4 08             	add    $0x8,%esp
  283268:	68 00 02 10 00       	push   $0x100200
  28326d:	50                   	push   %eax
  28326e:	e8 0e 02 00 00       	call   283481 <file_readfat>

	//draw prompt char
	cons_putchar(&cons,'>',1);
  283273:	83 c4 0c             	add    $0xc,%esp
  283276:	6a 01                	push   $0x1
  283278:	6a 3e                	push   $0x3e
  28327a:	53                   	push   %ebx
  28327b:	e8 9b 05 00 00       	call   28381b <cons_putchar>
  283280:	83 c4 10             	add    $0x10,%esp
	for(;;)
	{
		io_cli();
  283283:	e8 4a da ff ff       	call   280cd2 <io_cli>
		if(fifo32_status(&task->fifo)==0)
  283288:	83 ec 0c             	sub    $0xc,%esp
  28328b:	56                   	push   %esi
  28328c:	e8 85 eb ff ff       	call   281e16 <fifo32_status>
  283291:	83 c4 10             	add    $0x10,%esp
  283294:	85 c0                	test   %eax,%eax
  283296:	75 18                	jne    2832b0 <console_task+0xd5>
		{
			task_sleep(task);
  283298:	83 ec 0c             	sub    $0xc,%esp
  28329b:	ff b5 a4 fd ff ff    	pushl  -0x25c(%ebp)
  2832a1:	e8 f3 fe ff ff       	call   283199 <task_sleep>
			io_sti();
  2832a6:	e8 29 da ff ff       	call   280cd4 <io_sti>
  2832ab:	83 c4 10             	add    $0x10,%esp
  2832ae:	eb d3                	jmp    283283 <console_task+0xa8>
		}
		else
		{
			i=fifo32_get(&task->fifo);
  2832b0:	83 ec 0c             	sub    $0xc,%esp
  2832b3:	56                   	push   %esi
  2832b4:	e8 22 eb ff ff       	call   281ddb <fifo32_get>
  2832b9:	89 c3                	mov    %eax,%ebx
			io_sti();
  2832bb:	e8 14 da ff ff       	call   280cd4 <io_sti>
			if(i<=1) //for cursor
  2832c0:	83 c4 10             	add    $0x10,%esp
  2832c3:	83 fb 01             	cmp    $0x1,%ebx
  2832c6:	7f 57                	jg     28331f <console_task+0x144>
			{
				if(i!=0)
  2832c8:	85 db                	test   %ebx,%ebx
  2832ca:	74 20                	je     2832ec <console_task+0x111>
				{
					timer_init(cons.timer,&task->fifo,0);
  2832cc:	83 ec 04             	sub    $0x4,%esp
  2832cf:	6a 00                	push   $0x0
  2832d1:	56                   	push   %esi
  2832d2:	ff 75 c4             	pushl  -0x3c(%ebp)
  2832d5:	e8 e5 f8 ff ff       	call   282bbf <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_FFFFFF;
  2832da:	83 c4 10             	add    $0x10,%esp
  2832dd:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  2832e1:	78 27                	js     28330a <console_task+0x12f>
  2832e3:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
  2832ea:	eb 1e                	jmp    28330a <console_task+0x12f>
				}
				else
				{
					timer_init(cons.timer,&task->fifo,1);
  2832ec:	83 ec 04             	sub    $0x4,%esp
  2832ef:	6a 01                	push   $0x1
  2832f1:	56                   	push   %esi
  2832f2:	ff 75 c4             	pushl  -0x3c(%ebp)
  2832f5:	e8 c5 f8 ff ff       	call   282bbf <timer_init>
					if(cons.cur_c >= 0) cons.cur_c = COL8_000000;
  2832fa:	83 c4 10             	add    $0x10,%esp
  2832fd:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
  283301:	78 07                	js     28330a <console_task+0x12f>
  283303:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
				}
				timer_settime(cons.timer,50);
  28330a:	83 ec 08             	sub    $0x8,%esp
  28330d:	6a 32                	push   $0x32
  28330f:	ff 75 c4             	pushl  -0x3c(%ebp)
  283312:	e8 bc f8 ff ff       	call   282bd3 <timer_settime>
  283317:	83 c4 10             	add    $0x10,%esp
  28331a:	e9 16 01 00 00       	jmp    283435 <console_task+0x25a>
							
			}
			else if(i == 2) //get show cursor msg
  28331f:	83 fb 02             	cmp    $0x2,%ebx
  283322:	75 11                	jne    283335 <console_task+0x15a>
			{
				cons.cur_c = COL8_FFFFFF;
  283324:	c7 45 c0 07 00 00 00 	movl   $0x7,-0x40(%ebp)
						cmdline[cons.cur_x/8-2] = i-256;
						cons_putchar(&cons,i-256,1);
					}
				}
			}
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  28332b:	b8 07 00 00 00       	mov    $0x7,%eax
  283330:	e9 07 01 00 00       	jmp    28343c <console_task+0x261>
			}
			else if(i == 2) //get show cursor msg
			{
				cons.cur_c = COL8_FFFFFF;
			}
			else if(i == 3) //get hide cursor msg
  283335:	83 fb 03             	cmp    $0x3,%ebx
  283338:	75 2a                	jne    283364 <console_task+0x189>
			{
				cons.cur_c = -1;
  28333a:	c7 45 c0 ff ff ff ff 	movl   $0xffffffff,-0x40(%ebp)
				boxfill8(sheet->buf,sheet->bxsize,COL8_000000,cons.cur_x,28,cons.cur_x+7,43);
  283341:	8b 45 b8             	mov    -0x48(%ebp),%eax
  283344:	83 ec 04             	sub    $0x4,%esp
  283347:	6a 2b                	push   $0x2b
  283349:	8d 50 07             	lea    0x7(%eax),%edx
  28334c:	52                   	push   %edx
  28334d:	6a 1c                	push   $0x1c
  28334f:	50                   	push   %eax
  283350:	6a 00                	push   $0x0
  283352:	ff 77 04             	pushl  0x4(%edi)
  283355:	ff 37                	pushl  (%edi)
  283357:	e8 f8 da ff ff       	call   280e54 <boxfill8>
  28335c:	83 c4 20             	add    $0x20,%esp
  28335f:	e9 d1 00 00 00       	jmp    283435 <console_task+0x25a>
			}
			else if(256<=i && i<=511)
  283364:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
  28336a:	3d ff 00 00 00       	cmp    $0xff,%eax
  28336f:	0f 87 c0 00 00 00    	ja     283435 <console_task+0x25a>
			{
				if(i == 8+256) //back key
  283375:	81 fb 08 01 00 00    	cmp    $0x108,%ebx
  28337b:	75 26                	jne    2833a3 <console_task+0x1c8>
				{
					if(cons.cur_x > 16)
  28337d:	83 7d b8 10          	cmpl   $0x10,-0x48(%ebp)
  283381:	0f 8e ae 00 00 00    	jle    283435 <console_task+0x25a>
					{
						cons_putchar(&cons,' ',0);
  283387:	83 ec 04             	sub    $0x4,%esp
  28338a:	6a 00                	push   $0x0
  28338c:	6a 20                	push   $0x20
  28338e:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  283391:	50                   	push   %eax
  283392:	e8 84 04 00 00       	call   28381b <cons_putchar>
						cons.cur_x -= 8;
  283397:	83 6d b8 08          	subl   $0x8,-0x48(%ebp)
  28339b:	83 c4 10             	add    $0x10,%esp
  28339e:	e9 92 00 00 00       	jmp    283435 <console_task+0x25a>
					}
				}
				else if(i == 10+256) //return key
  2833a3:	81 fb 0a 01 00 00    	cmp    $0x10a,%ebx
  2833a9:	75 59                	jne    283404 <console_task+0x229>
				{
					cons_putchar(&cons,' ',0);
  2833ab:	83 ec 04             	sub    $0x4,%esp
  2833ae:	6a 00                	push   $0x0
  2833b0:	6a 20                	push   $0x20
  2833b2:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2833b5:	50                   	push   %eax
  2833b6:	e8 60 04 00 00       	call   28381b <cons_putchar>
					cmdline[cons.cur_x/8-2] = 0;
  2833bb:	8b 55 b8             	mov    -0x48(%ebp),%edx
  2833be:	8d 42 07             	lea    0x7(%edx),%eax
  2833c1:	85 d2                	test   %edx,%edx
  2833c3:	0f 49 c2             	cmovns %edx,%eax
  2833c6:	c1 f8 03             	sar    $0x3,%eax
  2833c9:	c6 44 05 c8 00       	movb   $0x0,-0x38(%ebp,%eax,1)
					cons_newline(&cons);
  2833ce:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2833d1:	89 04 24             	mov    %eax,(%esp)
  2833d4:	e8 77 03 00 00       	call   283750 <cons_newline>
					cons_runcmd(cmdline,&cons,fat,memtotal);
  2833d9:	ff 75 0c             	pushl  0xc(%ebp)
  2833dc:	ff b5 a0 fd ff ff    	pushl  -0x260(%ebp)
  2833e2:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2833e5:	50                   	push   %eax
  2833e6:	8d 45 ca             	lea    -0x36(%ebp),%eax
  2833e9:	50                   	push   %eax
  2833ea:	e8 05 0a 00 00       	call   283df4 <cons_runcmd>
					cons_putchar(&cons,'>',1);
  2833ef:	83 c4 1c             	add    $0x1c,%esp
  2833f2:	6a 01                	push   $0x1
  2833f4:	6a 3e                	push   $0x3e
  2833f6:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  2833f9:	50                   	push   %eax
  2833fa:	e8 1c 04 00 00       	call   28381b <cons_putchar>
  2833ff:	83 c4 10             	add    $0x10,%esp
  283402:	eb 31                	jmp    283435 <console_task+0x25a>
				}
				else
				{
					if(cons.cur_x<240)
  283404:	8b 45 b8             	mov    -0x48(%ebp),%eax
  283407:	3d ef 00 00 00       	cmp    $0xef,%eax
  28340c:	7f 27                	jg     283435 <console_task+0x25a>
					{
						s[0] = i-256;
						s[1] = 0;
						cmdline[cons.cur_x/8-2] = i-256;
  28340e:	8d 50 07             	lea    0x7(%eax),%edx
  283411:	85 c0                	test   %eax,%eax
  283413:	0f 48 c2             	cmovs  %edx,%eax
  283416:	c1 f8 03             	sar    $0x3,%eax
  283419:	88 5c 05 c8          	mov    %bl,-0x38(%ebp,%eax,1)
						cons_putchar(&cons,i-256,1);
  28341d:	83 ec 04             	sub    $0x4,%esp
  283420:	6a 01                	push   $0x1
  283422:	81 eb 00 01 00 00    	sub    $0x100,%ebx
  283428:	53                   	push   %ebx
  283429:	8d 45 b4             	lea    -0x4c(%ebp),%eax
  28342c:	50                   	push   %eax
  28342d:	e8 e9 03 00 00       	call   28381b <cons_putchar>
  283432:	83 c4 10             	add    $0x10,%esp
					}
				}
			}
			if(cons.cur_c >= 0) boxfill8(sheet->buf,sheet->bxsize,cons.cur_c,cons.cur_x,cons.cur_y,cons.cur_x+7,cons.cur_y+15);
  283435:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283438:	85 c0                	test   %eax,%eax
  28343a:	78 24                	js     283460 <console_task+0x285>
  28343c:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  28343f:	8b 55 b8             	mov    -0x48(%ebp),%edx
  283442:	83 ec 04             	sub    $0x4,%esp
  283445:	8d 59 0f             	lea    0xf(%ecx),%ebx
  283448:	53                   	push   %ebx
  283449:	8d 5a 07             	lea    0x7(%edx),%ebx
  28344c:	53                   	push   %ebx
  28344d:	51                   	push   %ecx
  28344e:	52                   	push   %edx
  28344f:	0f b6 c0             	movzbl %al,%eax
  283452:	50                   	push   %eax
  283453:	ff 77 04             	pushl  0x4(%edi)
  283456:	ff 37                	pushl  (%edi)
  283458:	e8 f7 d9 ff ff       	call   280e54 <boxfill8>
  28345d:	83 c4 20             	add    $0x20,%esp
			sheet_refresh(sheet,cons.cur_x,cons.cur_y,cons.cur_x+8,cons.cur_y+16);
  283460:	8b 55 bc             	mov    -0x44(%ebp),%edx
  283463:	8b 45 b8             	mov    -0x48(%ebp),%eax
  283466:	83 ec 0c             	sub    $0xc,%esp
  283469:	8d 4a 10             	lea    0x10(%edx),%ecx
  28346c:	51                   	push   %ecx
  28346d:	8d 48 08             	lea    0x8(%eax),%ecx
  283470:	51                   	push   %ecx
  283471:	52                   	push   %edx
  283472:	50                   	push   %eax
  283473:	57                   	push   %edi
  283474:	e8 d5 f4 ff ff       	call   28294e <sheet_refresh>
  283479:	83 c4 20             	add    $0x20,%esp
  28347c:	e9 02 fe ff ff       	jmp    283283 <console_task+0xa8>

00283481 <file_readfat>:
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
  283481:	55                   	push   %ebp
  283482:	89 e5                	mov    %esp,%ebp
  283484:	53                   	push   %ebx
  283485:	83 ec 10             	sub    $0x10,%esp
	int i,j=0;
  283488:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(i=0;i<2880;i+=2)
  28348f:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  283496:	e9 87 00 00 00       	jmp    283522 <file_readfat+0xa1>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
  28349b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28349e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  2834a5:	8b 45 08             	mov    0x8(%ebp),%eax
  2834a8:	01 d0                	add    %edx,%eax
  2834aa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  2834ad:	8b 55 0c             	mov    0xc(%ebp),%edx
  2834b0:	01 ca                	add    %ecx,%edx
  2834b2:	0f b6 12             	movzbl (%edx),%edx
  2834b5:	0f b6 d2             	movzbl %dl,%edx
  2834b8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  2834bb:	8d 59 01             	lea    0x1(%ecx),%ebx
  2834be:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  2834c1:	01 d9                	add    %ebx,%ecx
  2834c3:	0f b6 09             	movzbl (%ecx),%ecx
  2834c6:	0f b6 c9             	movzbl %cl,%ecx
  2834c9:	c1 e1 08             	shl    $0x8,%ecx
  2834cc:	09 ca                	or     %ecx,%edx
  2834ce:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  2834d4:	89 10                	mov    %edx,(%eax)
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
  2834d6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2834d9:	83 c0 01             	add    $0x1,%eax
  2834dc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  2834e3:	8b 45 08             	mov    0x8(%ebp),%eax
  2834e6:	01 d0                	add    %edx,%eax
  2834e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  2834eb:	8d 4a 01             	lea    0x1(%edx),%ecx
  2834ee:	8b 55 0c             	mov    0xc(%ebp),%edx
  2834f1:	01 ca                	add    %ecx,%edx
  2834f3:	0f b6 12             	movzbl (%edx),%edx
  2834f6:	c0 ea 04             	shr    $0x4,%dl
  2834f9:	0f b6 d2             	movzbl %dl,%edx
  2834fc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  2834ff:	8d 59 02             	lea    0x2(%ecx),%ebx
  283502:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  283505:	01 d9                	add    %ebx,%ecx
  283507:	0f b6 09             	movzbl (%ecx),%ecx
  28350a:	0f b6 c9             	movzbl %cl,%ecx
  28350d:	c1 e1 04             	shl    $0x4,%ecx
  283510:	09 ca                	or     %ecx,%edx
  283512:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  283518:	89 10                	mov    %edx,(%eax)
		j+=3;
  28351a:	83 45 f4 03          	addl   $0x3,-0xc(%ebp)
#include "file.h"

void file_readfat(int *fat,unsigned char *img)
{
	int i,j=0;
	for(i=0;i<2880;i+=2)
  28351e:	83 45 f8 02          	addl   $0x2,-0x8(%ebp)
  283522:	81 7d f8 3f 0b 00 00 	cmpl   $0xb3f,-0x8(%ebp)
  283529:	0f 8e 6c ff ff ff    	jle    28349b <file_readfat+0x1a>
	{
		fat[i+0] = (img[j+0]	| img[j+1] << 8) & 0xfff;
		fat[i+1] = (img[j+1]>>4	| img[j+2] << 4) & 0xfff;
		j+=3;
	}
	return;
  28352f:	90                   	nop
}
  283530:	83 c4 10             	add    $0x10,%esp
  283533:	5b                   	pop    %ebx
  283534:	5d                   	pop    %ebp
  283535:	c3                   	ret    

00283536 <file_loadfile>:

void file_loadfile(int clustno,int size,char *buf,int *fat,char *img)
{
  283536:	55                   	push   %ebp
  283537:	89 e5                	mov    %esp,%ebp
  283539:	83 ec 10             	sub    $0x10,%esp
	int i;
	for(;;)
	{
		if(size <= 512)
  28353c:	81 7d 0c 00 02 00 00 	cmpl   $0x200,0xc(%ebp)
  283543:	7f 38                	jg     28357d <file_loadfile+0x47>
		{
			for(i=0;i<size;i++)
  283545:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  28354c:	eb 25                	jmp    283573 <file_loadfile+0x3d>
			{
				buf[i] = img[clustno*512 + i];
  28354e:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283551:	8b 45 10             	mov    0x10(%ebp),%eax
  283554:	01 c2                	add    %eax,%edx
  283556:	8b 45 08             	mov    0x8(%ebp),%eax
  283559:	c1 e0 09             	shl    $0x9,%eax
  28355c:	89 c1                	mov    %eax,%ecx
  28355e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283561:	01 c8                	add    %ecx,%eax
  283563:	89 c1                	mov    %eax,%ecx
  283565:	8b 45 18             	mov    0x18(%ebp),%eax
  283568:	01 c8                	add    %ecx,%eax
  28356a:	0f b6 00             	movzbl (%eax),%eax
  28356d:	88 02                	mov    %al,(%edx)
	int i;
	for(;;)
	{
		if(size <= 512)
		{
			for(i=0;i<size;i++)
  28356f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  283573:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283576:	3b 45 0c             	cmp    0xc(%ebp),%eax
  283579:	7c d3                	jl     28354e <file_loadfile+0x18>
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
  28357b:	eb 5e                	jmp    2835db <file_loadfile+0xa5>
		}
		for(i=0;i<512;i++)
  28357d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  283584:	eb 25                	jmp    2835ab <file_loadfile+0x75>
		{
			buf[i] = img[clustno*512 + i];
  283586:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283589:	8b 45 10             	mov    0x10(%ebp),%eax
  28358c:	01 c2                	add    %eax,%edx
  28358e:	8b 45 08             	mov    0x8(%ebp),%eax
  283591:	c1 e0 09             	shl    $0x9,%eax
  283594:	89 c1                	mov    %eax,%ecx
  283596:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283599:	01 c8                	add    %ecx,%eax
  28359b:	89 c1                	mov    %eax,%ecx
  28359d:	8b 45 18             	mov    0x18(%ebp),%eax
  2835a0:	01 c8                	add    %ecx,%eax
  2835a2:	0f b6 00             	movzbl (%eax),%eax
  2835a5:	88 02                	mov    %al,(%edx)
			{
				buf[i] = img[clustno*512 + i];
			}
			return;
		}
		for(i=0;i<512;i++)
  2835a7:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  2835ab:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%ebp)
  2835b2:	7e d2                	jle    283586 <file_loadfile+0x50>
		{
			buf[i] = img[clustno*512 + i];
		}
		size -= 512;
  2835b4:	81 6d 0c 00 02 00 00 	subl   $0x200,0xc(%ebp)
		buf += 512;
  2835bb:	81 45 10 00 02 00 00 	addl   $0x200,0x10(%ebp)
		clustno = fat[clustno];
  2835c2:	8b 45 08             	mov    0x8(%ebp),%eax
  2835c5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  2835cc:	8b 45 14             	mov    0x14(%ebp),%eax
  2835cf:	01 d0                	add    %edx,%eax
  2835d1:	8b 00                	mov    (%eax),%eax
  2835d3:	89 45 08             	mov    %eax,0x8(%ebp)
	}
  2835d6:	e9 61 ff ff ff       	jmp    28353c <file_loadfile+0x6>
	return;
}
  2835db:	c9                   	leave  
  2835dc:	c3                   	ret    

002835dd <file_search>:

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
  2835dd:	55                   	push   %ebp
  2835de:	89 e5                	mov    %esp,%ebp
  2835e0:	83 ec 20             	sub    $0x20,%esp
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  2835e3:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  2835ea:	eb 0f                	jmp    2835fb <file_search+0x1e>
	{
		s[j] = ' ';
  2835ec:	8d 55 ec             	lea    -0x14(%ebp),%edx
  2835ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2835f2:	01 d0                	add    %edx,%eax
  2835f4:	c6 00 20             	movb   $0x20,(%eax)

struct FILEINFO *file_search(char *name,struct FILEINFO *finfo,int max)
{
	int i,j;
	char s[12];
	for(j=0;j<11;j++)
  2835f7:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  2835fb:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  2835ff:	7e eb                	jle    2835ec <file_search+0xf>
	{
		s[j] = ' ';
	}
	j=0;
  283601:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(i=0;name[i]!=0;i++)
  283608:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  28360f:	e9 83 00 00 00       	jmp    283697 <file_search+0xba>
	{
		if(j>=11) return 0; //length of name is bigger than 11
  283614:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  283618:	7e 0a                	jle    283624 <file_search+0x47>
  28361a:	b8 00 00 00 00       	mov    $0x0,%eax
  28361f:	e9 2a 01 00 00       	jmp    28374e <file_search+0x171>
		if(name[i] == '.' && j <= 8)
  283624:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283627:	8b 45 08             	mov    0x8(%ebp),%eax
  28362a:	01 d0                	add    %edx,%eax
  28362c:	0f b6 00             	movzbl (%eax),%eax
  28362f:	3c 2e                	cmp    $0x2e,%al
  283631:	75 0f                	jne    283642 <file_search+0x65>
  283633:	83 7d f8 08          	cmpl   $0x8,-0x8(%ebp)
  283637:	7f 09                	jg     283642 <file_search+0x65>
			j = 8;
  283639:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)
  283640:	eb 51                	jmp    283693 <file_search+0xb6>
		else
		{
			s[j] = name[i];
  283642:	8b 55 fc             	mov    -0x4(%ebp),%edx
  283645:	8b 45 08             	mov    0x8(%ebp),%eax
  283648:	01 d0                	add    %edx,%eax
  28364a:	0f b6 00             	movzbl (%eax),%eax
  28364d:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  283650:	8b 55 f8             	mov    -0x8(%ebp),%edx
  283653:	01 ca                	add    %ecx,%edx
  283655:	88 02                	mov    %al,(%edx)
			if('a' <= s[j] && s[j] <= 'z')
  283657:	8d 55 ec             	lea    -0x14(%ebp),%edx
  28365a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28365d:	01 d0                	add    %edx,%eax
  28365f:	0f b6 00             	movzbl (%eax),%eax
  283662:	3c 60                	cmp    $0x60,%al
  283664:	7e 29                	jle    28368f <file_search+0xb2>
  283666:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283669:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28366c:	01 d0                	add    %edx,%eax
  28366e:	0f b6 00             	movzbl (%eax),%eax
  283671:	3c 7a                	cmp    $0x7a,%al
  283673:	7f 1a                	jg     28368f <file_search+0xb2>
				s[j] -= 0x20;
  283675:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283678:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28367b:	01 d0                	add    %edx,%eax
  28367d:	0f b6 00             	movzbl (%eax),%eax
  283680:	83 e8 20             	sub    $0x20,%eax
  283683:	89 c1                	mov    %eax,%ecx
  283685:	8d 55 ec             	lea    -0x14(%ebp),%edx
  283688:	8b 45 f8             	mov    -0x8(%ebp),%eax
  28368b:	01 d0                	add    %edx,%eax
  28368d:	88 08                	mov    %cl,(%eax)
			j++;
  28368f:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
	for(j=0;j<11;j++)
	{
		s[j] = ' ';
	}
	j=0;
	for(i=0;name[i]!=0;i++)
  283693:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  283697:	8b 55 fc             	mov    -0x4(%ebp),%edx
  28369a:	8b 45 08             	mov    0x8(%ebp),%eax
  28369d:	01 d0                	add    %edx,%eax
  28369f:	0f b6 00             	movzbl (%eax),%eax
  2836a2:	84 c0                	test   %al,%al
  2836a4:	0f 85 6a ff ff ff    	jne    283614 <file_search+0x37>
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  2836aa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  2836b1:	e9 84 00 00 00       	jmp    28373a <file_search+0x15d>
	{
		if(finfo[i].name[0] == 0) break;
  2836b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2836b9:	c1 e0 06             	shl    $0x6,%eax
  2836bc:	89 c2                	mov    %eax,%edx
  2836be:	8b 45 0c             	mov    0xc(%ebp),%eax
  2836c1:	01 d0                	add    %edx,%eax
  2836c3:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  2836c7:	84 c0                	test   %al,%al
  2836c9:	74 7d                	je     283748 <file_search+0x16b>
		if((finfo[i].type & 0x18) == 0)
  2836cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2836ce:	c1 e0 06             	shl    $0x6,%eax
  2836d1:	89 c2                	mov    %eax,%edx
  2836d3:	8b 45 0c             	mov    0xc(%ebp),%eax
  2836d6:	01 d0                	add    %edx,%eax
  2836d8:	0f b6 40 2b          	movzbl 0x2b(%eax),%eax
  2836dc:	0f b6 c0             	movzbl %al,%eax
  2836df:	83 e0 18             	and    $0x18,%eax
  2836e2:	85 c0                	test   %eax,%eax
  2836e4:	75 50                	jne    283736 <file_search+0x159>
		{
			for(j=0;j<11;j++)
  2836e6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  2836ed:	eb 31                	jmp    283720 <file_search+0x143>
			{
				if(finfo[i].name[j] != s[j])
  2836ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
  2836f2:	c1 e0 06             	shl    $0x6,%eax
  2836f5:	89 c2                	mov    %eax,%edx
  2836f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  2836fa:	01 c2                	add    %eax,%edx
  2836fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  2836ff:	01 d0                	add    %edx,%eax
  283701:	83 c0 20             	add    $0x20,%eax
  283704:	0f b6 00             	movzbl (%eax),%eax
  283707:	0f b6 d0             	movzbl %al,%edx
  28370a:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  28370d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  283710:	01 c8                	add    %ecx,%eax
  283712:	0f b6 00             	movzbl (%eax),%eax
  283715:	0f be c0             	movsbl %al,%eax
  283718:	39 c2                	cmp    %eax,%edx
  28371a:	75 19                	jne    283735 <file_search+0x158>
	for(i=0;i<max;)
	{
		if(finfo[i].name[0] == 0) break;
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
  28371c:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
  283720:	83 7d f8 0a          	cmpl   $0xa,-0x8(%ebp)
  283724:	7e c9                	jle    2836ef <file_search+0x112>
			{
				if(finfo[i].name[j] != s[j])
					goto next;
			}
			return finfo+i;
  283726:	8b 45 fc             	mov    -0x4(%ebp),%eax
  283729:	c1 e0 06             	shl    $0x6,%eax
  28372c:	89 c2                	mov    %eax,%edx
  28372e:	8b 45 0c             	mov    0xc(%ebp),%eax
  283731:	01 d0                	add    %edx,%eax
  283733:	eb 19                	jmp    28374e <file_search+0x171>
		if((finfo[i].type & 0x18) == 0)
		{
			for(j=0;j<11;j++)
			{
				if(finfo[i].name[j] != s[j])
					goto next;
  283735:	90                   	nop
			}
			return finfo+i;
		}
next:
		i++;
  283736:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
				s[j] -= 0x20;
			j++;
		}
	}

	for(i=0;i<max;)
  28373a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  28373d:	3b 45 10             	cmp    0x10(%ebp),%eax
  283740:	0f 8c 70 ff ff ff    	jl     2836b6 <file_search+0xd9>
  283746:	eb 01                	jmp    283749 <file_search+0x16c>
	{
		if(finfo[i].name[0] == 0) break;
  283748:	90                   	nop
			return finfo+i;
		}
next:
		i++;
	}
	return 0;
  283749:	b8 00 00 00 00       	mov    $0x0,%eax
}
  28374e:	c9                   	leave  
  28374f:	c3                   	ret    

00283750 <cons_newline>:
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  283750:	55                   	push   %ebp
  283751:	89 e5                	mov    %esp,%ebp
  283753:	57                   	push   %edi
  283754:	56                   	push   %esi
  283755:	53                   	push   %ebx
  283756:	83 ec 1c             	sub    $0x1c,%esp
	int x,y;
	struct SHEET *sheet = cons->sht;
	if(cons->cur_y<28+112)
  283759:	8b 45 08             	mov    0x8(%ebp),%eax
  28375c:	8b 40 08             	mov    0x8(%eax),%eax
  28375f:	3d 8b 00 00 00       	cmp    $0x8b,%eax
  283764:	7e 0c                	jle    283772 <cons_newline+0x22>
}

void cons_newline(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
  283766:	8b 45 08             	mov    0x8(%ebp),%eax
  283769:	8b 18                	mov    (%eax),%ebx
  28376b:	bf 1c 00 00 00       	mov    $0x1c,%edi
  283770:	eb 43                	jmp    2837b5 <cons_newline+0x65>
	if(cons->cur_y<28+112)
	{
		cons->cur_y += 16;
  283772:	83 c0 10             	add    $0x10,%eax
  283775:	8b 7d 08             	mov    0x8(%ebp),%edi
  283778:	89 47 08             	mov    %eax,0x8(%edi)
  28377b:	e9 89 00 00 00       	jmp    283809 <cons_newline+0xb9>
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  283780:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  283783:	8b 43 04             	mov    0x4(%ebx),%eax
  283786:	8b 75 e0             	mov    -0x20(%ebp),%esi
  283789:	0f af f0             	imul   %eax,%esi
  28378c:	89 d1                	mov    %edx,%ecx
  28378e:	03 0b                	add    (%ebx),%ecx
  283790:	0f b6 34 31          	movzbl (%ecx,%esi,1),%esi
  283794:	0f af c7             	imul   %edi,%eax
  283797:	89 f3                	mov    %esi,%ebx
  283799:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
		cons->cur_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
  28379c:	83 c2 01             	add    $0x1,%edx
  28379f:	81 fa f8 00 00 00    	cmp    $0xf8,%edx
  2837a5:	75 d9                	jne    283780 <cons_newline+0x30>
  2837a7:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	{
		cons->cur_y += 16;
	}
	else
	{
		for(y=28;y<28+112;y++)
  2837aa:	83 c7 01             	add    $0x1,%edi
  2837ad:	81 ff 8c 00 00 00    	cmp    $0x8c,%edi
  2837b3:	74 33                	je     2837e8 <cons_newline+0x98>
	}
	return;
}

void cons_newline(struct CONSOLE *cons)
{
  2837b5:	ba 08 00 00 00       	mov    $0x8,%edx
	}
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
  2837ba:	8d 47 10             	lea    0x10(%edi),%eax
  2837bd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  2837c0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  2837c3:	eb bb                	jmp    283780 <cons_newline+0x30>
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  2837c5:	89 fa                	mov    %edi,%edx
  2837c7:	0f af 53 04          	imul   0x4(%ebx),%edx
  2837cb:	89 c1                	mov    %eax,%ecx
  2837cd:	03 0b                	add    (%ebx),%ecx
  2837cf:	c6 04 11 00          	movb   $0x0,(%ecx,%edx,1)
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
  2837d3:	83 c0 01             	add    $0x1,%eax
  2837d6:	3d f8 00 00 00       	cmp    $0xf8,%eax
  2837db:	75 e8                	jne    2837c5 <cons_newline+0x75>
	else
	{
		for(y=28;y<28+112;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
  2837dd:	83 c7 01             	add    $0x1,%edi
  2837e0:	81 ff 9c 00 00 00    	cmp    $0x9c,%edi
  2837e6:	74 07                	je     2837ef <cons_newline+0x9f>
}

void cons_newline(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
  2837e8:	b8 08 00 00 00       	mov    $0x8,%eax
  2837ed:	eb d6                	jmp    2837c5 <cons_newline+0x75>
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = sheet->buf[x+(y+16)*sheet->bxsize];
		for(y=28+112;y<28+128;y++)
			for(x=8;x<8+240;x++)
				sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		sheet_refresh(sheet,8,28,8+240,28+128);
  2837ef:	83 ec 0c             	sub    $0xc,%esp
  2837f2:	68 9c 00 00 00       	push   $0x9c
  2837f7:	68 f8 00 00 00       	push   $0xf8
  2837fc:	6a 1c                	push   $0x1c
  2837fe:	6a 08                	push   $0x8
  283800:	53                   	push   %ebx
  283801:	e8 48 f1 ff ff       	call   28294e <sheet_refresh>
  283806:	83 c4 20             	add    $0x20,%esp
	}
	cons->cur_x = 8;
  283809:	8b 45 08             	mov    0x8(%ebp),%eax
  28380c:	c7 40 04 08 00 00 00 	movl   $0x8,0x4(%eax)
}
  283813:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283816:	5b                   	pop    %ebx
  283817:	5e                   	pop    %esi
  283818:	5f                   	pop    %edi
  283819:	5d                   	pop    %ebp
  28381a:	c3                   	ret    

0028381b <cons_putchar>:
#include "header.h"
void cons_putchar(struct CONSOLE *cons,int chr,char move)
{
  28381b:	55                   	push   %ebp
  28381c:	89 e5                	mov    %esp,%ebp
  28381e:	56                   	push   %esi
  28381f:	53                   	push   %ebx
  283820:	83 ec 10             	sub    $0x10,%esp
  283823:	8b 5d 08             	mov    0x8(%ebp),%ebx
  283826:	8b 45 0c             	mov    0xc(%ebp),%eax
  283829:	8b 75 10             	mov    0x10(%ebp),%esi
	char s[2];
	s[0] = chr;
  28382c:	88 45 f6             	mov    %al,-0xa(%ebp)
	s[1] = 0;
  28382f:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
	if(s[0] == 0x09)
  283833:	3c 09                	cmp    $0x9,%al
  283835:	75 46                	jne    28387d <cons_putchar+0x62>
	{
		//tab
		for(;;)
		{
			putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000," ",1);
  283837:	83 ec 04             	sub    $0x4,%esp
  28383a:	6a 01                	push   $0x1
  28383c:	68 43 4b 28 00       	push   $0x284b43
  283841:	6a 00                	push   $0x0
  283843:	6a 07                	push   $0x7
  283845:	ff 73 08             	pushl  0x8(%ebx)
  283848:	ff 73 04             	pushl  0x4(%ebx)
  28384b:	ff 33                	pushl  (%ebx)
  28384d:	e8 61 da ff ff       	call   2812b3 <putfonts8_asc_sht>
			cons->cur_x += 8;
  283852:	8b 43 04             	mov    0x4(%ebx),%eax
  283855:	83 c0 08             	add    $0x8,%eax
  283858:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240) {
  28385b:	83 c4 20             	add    $0x20,%esp
  28385e:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283863:	75 0c                	jne    283871 <cons_putchar+0x56>
				cons_newline(cons);
  283865:	83 ec 0c             	sub    $0xc,%esp
  283868:	53                   	push   %ebx
  283869:	e8 e2 fe ff ff       	call   283750 <cons_newline>
  28386e:	83 c4 10             	add    $0x10,%esp
			}
			if(((cons->cur_x - 8) & 0x1f) == 0)
  283871:	8b 43 04             	mov    0x4(%ebx),%eax
  283874:	83 e8 08             	sub    $0x8,%eax
  283877:	a8 1f                	test   $0x1f,%al
  283879:	75 bc                	jne    283837 <cons_putchar+0x1c>
  28387b:	eb 55                	jmp    2838d2 <cons_putchar+0xb7>
				break;
		}
	}
	else if(s[0] == 0x0a) 
  28387d:	3c 0a                	cmp    $0xa,%al
  28387f:	75 0e                	jne    28388f <cons_putchar+0x74>
		cons_newline(cons);
  283881:	83 ec 0c             	sub    $0xc,%esp
  283884:	53                   	push   %ebx
  283885:	e8 c6 fe ff ff       	call   283750 <cons_newline>
  28388a:	83 c4 10             	add    $0x10,%esp
  28388d:	eb 43                	jmp    2838d2 <cons_putchar+0xb7>
	else if(s[0] == 0x0d) 
  28388f:	3c 0d                	cmp    $0xd,%al
  283891:	74 3f                	je     2838d2 <cons_putchar+0xb7>
		;//todo
	else
	{
		putfonts8_asc_sht(cons->sht,cons->cur_x,cons->cur_y,COL8_FFFFFF,COL8_000000,s,1);
  283893:	83 ec 04             	sub    $0x4,%esp
  283896:	6a 01                	push   $0x1
  283898:	8d 45 f6             	lea    -0xa(%ebp),%eax
  28389b:	50                   	push   %eax
  28389c:	6a 00                	push   $0x0
  28389e:	6a 07                	push   $0x7
  2838a0:	ff 73 08             	pushl  0x8(%ebx)
  2838a3:	ff 73 04             	pushl  0x4(%ebx)
  2838a6:	ff 33                	pushl  (%ebx)
  2838a8:	e8 06 da ff ff       	call   2812b3 <putfonts8_asc_sht>
		if(move != 0)
  2838ad:	83 c4 20             	add    $0x20,%esp
  2838b0:	89 f0                	mov    %esi,%eax
  2838b2:	84 c0                	test   %al,%al
  2838b4:	74 1c                	je     2838d2 <cons_putchar+0xb7>
		{
			cons->cur_x += 8;
  2838b6:	8b 43 04             	mov    0x4(%ebx),%eax
  2838b9:	83 c0 08             	add    $0x8,%eax
  2838bc:	89 43 04             	mov    %eax,0x4(%ebx)
			if(cons->cur_x == 8+240)
  2838bf:	3d f8 00 00 00       	cmp    $0xf8,%eax
  2838c4:	75 0c                	jne    2838d2 <cons_putchar+0xb7>
				cons_newline(cons);
  2838c6:	83 ec 0c             	sub    $0xc,%esp
  2838c9:	53                   	push   %ebx
  2838ca:	e8 81 fe ff ff       	call   283750 <cons_newline>
  2838cf:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  2838d2:	8d 65 f8             	lea    -0x8(%ebp),%esp
  2838d5:	5b                   	pop    %ebx
  2838d6:	5e                   	pop    %esi
  2838d7:	5d                   	pop    %ebp
  2838d8:	c3                   	ret    

002838d9 <cmd_mem>:
	}
	return;
}

void cmd_mem(struct CONSOLE *cons,unsigned int memtotal)
{
  2838d9:	55                   	push   %ebp
  2838da:	89 e5                	mov    %esp,%ebp
  2838dc:	56                   	push   %esi
  2838dd:	53                   	push   %ebx
  2838de:	83 ec 24             	sub    $0x24,%esp
  2838e1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	char s[30];
	sprintf(s,"total %dMB",memtotal/(1024*1024));
  2838e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  2838e7:	c1 e8 14             	shr    $0x14,%eax
  2838ea:	50                   	push   %eax
  2838eb:	68 e0 4a 28 00       	push   $0x284ae0
  2838f0:	8d 75 da             	lea    -0x26(%ebp),%esi
  2838f3:	56                   	push   %esi
  2838f4:	e8 84 e2 ff ff       	call   281b7d <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  2838f9:	83 c4 0c             	add    $0xc,%esp
  2838fc:	6a 1e                	push   $0x1e
  2838fe:	56                   	push   %esi
  2838ff:	6a 00                	push   $0x0
  283901:	6a 07                	push   $0x7
  283903:	ff 73 08             	pushl  0x8(%ebx)
  283906:	6a 08                	push   $0x8
  283908:	ff 33                	pushl  (%ebx)
  28390a:	e8 a4 d9 ff ff       	call   2812b3 <putfonts8_asc_sht>
	cons_newline(cons);
  28390f:	83 c4 14             	add    $0x14,%esp
  283912:	53                   	push   %ebx
  283913:	e8 38 fe ff ff       	call   283750 <cons_newline>
	sprintf(s,"free %dKB",memman_total(memman)/1024);
  283918:	c7 04 24 00 00 3c 00 	movl   $0x3c0000,(%esp)
  28391f:	e8 54 e8 ff ff       	call   282178 <memman_total>
  283924:	83 c4 0c             	add    $0xc,%esp
  283927:	c1 e8 0a             	shr    $0xa,%eax
  28392a:	50                   	push   %eax
  28392b:	68 eb 4a 28 00       	push   $0x284aeb
  283930:	56                   	push   %esi
  283931:	e8 47 e2 ff ff       	call   281b7d <sprintf>
	putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283936:	83 c4 0c             	add    $0xc,%esp
  283939:	6a 1e                	push   $0x1e
  28393b:	56                   	push   %esi
  28393c:	6a 00                	push   $0x0
  28393e:	6a 07                	push   $0x7
  283940:	ff 73 08             	pushl  0x8(%ebx)
  283943:	6a 08                	push   $0x8
  283945:	ff 33                	pushl  (%ebx)
  283947:	e8 67 d9 ff ff       	call   2812b3 <putfonts8_asc_sht>
	cons_newline(cons);
  28394c:	83 c4 14             	add    $0x14,%esp
  28394f:	53                   	push   %ebx
  283950:	e8 fb fd ff ff       	call   283750 <cons_newline>
	cons_newline(cons);
  283955:	89 1c 24             	mov    %ebx,(%esp)
  283958:	e8 f3 fd ff ff       	call   283750 <cons_newline>
	return;
  28395d:	83 c4 10             	add    $0x10,%esp
}
  283960:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283963:	5b                   	pop    %ebx
  283964:	5e                   	pop    %esi
  283965:	5d                   	pop    %ebp
  283966:	c3                   	ret    

00283967 <cmd_cls>:

void cmd_cls(struct CONSOLE *cons)
{
  283967:	55                   	push   %ebp
  283968:	89 e5                	mov    %esp,%ebp
  28396a:	57                   	push   %edi
  28396b:	56                   	push   %esi
  28396c:	53                   	push   %ebx
  28396d:	83 ec 0c             	sub    $0xc,%esp
  283970:	8b 7d 08             	mov    0x8(%ebp),%edi
	int x,y;
	struct SHEET *sheet = cons->sht;
  283973:	8b 17                	mov    (%edi),%edx
	for(y=28;y<28+128;y++)
  283975:	be 1c 00 00 00       	mov    $0x1c,%esi
  28397a:	eb 23                	jmp    28399f <cmd_cls+0x38>
	{
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
  28397c:	89 f1                	mov    %esi,%ecx
  28397e:	0f af 4a 04          	imul   0x4(%edx),%ecx
  283982:	89 c3                	mov    %eax,%ebx
  283984:	03 1a                	add    (%edx),%ebx
  283986:	c6 04 0b 00          	movb   $0x0,(%ebx,%ecx,1)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
	{
		for(x=8;x<8+240;x++)
  28398a:	83 c0 01             	add    $0x1,%eax
  28398d:	3d f8 00 00 00       	cmp    $0xf8,%eax
  283992:	75 e8                	jne    28397c <cmd_cls+0x15>

void cmd_cls(struct CONSOLE *cons)
{
	int x,y;
	struct SHEET *sheet = cons->sht;
	for(y=28;y<28+128;y++)
  283994:	83 c6 01             	add    $0x1,%esi
  283997:	81 fe 9c 00 00 00    	cmp    $0x9c,%esi
  28399d:	74 07                	je     2839a6 <cmd_cls+0x3f>
	cons_newline(cons);
	return;
}

void cmd_cls(struct CONSOLE *cons)
{
  28399f:	b8 08 00 00 00       	mov    $0x8,%eax
  2839a4:	eb d6                	jmp    28397c <cmd_cls+0x15>
		for(x=8;x<8+240;x++)
		{
			sheet->buf[x+y*sheet->bxsize] = COL8_000000;
		}
	}
	sheet_refresh(sheet,8,28,8+240,28+128);
  2839a6:	83 ec 0c             	sub    $0xc,%esp
  2839a9:	68 9c 00 00 00       	push   $0x9c
  2839ae:	68 f8 00 00 00       	push   $0xf8
  2839b3:	6a 1c                	push   $0x1c
  2839b5:	6a 08                	push   $0x8
  2839b7:	52                   	push   %edx
  2839b8:	e8 91 ef ff ff       	call   28294e <sheet_refresh>
	cons->cur_y = 28;
  2839bd:	c7 47 08 1c 00 00 00 	movl   $0x1c,0x8(%edi)
	return;
  2839c4:	83 c4 20             	add    $0x20,%esp
}
  2839c7:	8d 65 f4             	lea    -0xc(%ebp),%esp
  2839ca:	5b                   	pop    %ebx
  2839cb:	5e                   	pop    %esi
  2839cc:	5f                   	pop    %edi
  2839cd:	5d                   	pop    %ebp
  2839ce:	c3                   	ret    

002839cf <cmd_dir>:

void cmd_dir(struct CONSOLE *cons)
{
  2839cf:	55                   	push   %ebp
  2839d0:	89 e5                	mov    %esp,%ebp
  2839d2:	57                   	push   %edi
  2839d3:	56                   	push   %esi
  2839d4:	53                   	push   %ebx
  2839d5:	83 ec 2c             	sub    $0x2c,%esp
  2839d8:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  2839db:	0f b6 05 20 26 10 00 	movzbl 0x102620,%eax
  2839e2:	84 c0                	test   %al,%al
  2839e4:	0f 84 87 00 00 00    	je     283a71 <cmd_dir+0xa2>
  2839ea:	bb 00 26 10 00       	mov    $0x102600,%ebx
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  2839ef:	8d 75 ca             	lea    -0x36(%ebp),%esi
  2839f2:	eb 0b                	jmp    2839ff <cmd_dir+0x30>
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
	{
		if(finfo[i].name[0] == 0x0) break;
  2839f4:	83 c3 40             	add    $0x40,%ebx
  2839f7:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  2839fb:	84 c0                	test   %al,%al
  2839fd:	74 72                	je     283a71 <cmd_dir+0xa2>
		if(finfo[i].name[0] != 0xe5)
  2839ff:	3c e5                	cmp    $0xe5,%al
  283a01:	74 66                	je     283a69 <cmd_dir+0x9a>
		{
			if((finfo[i].type & 0x18) == 0)
  283a03:	f6 43 2b 18          	testb  $0x18,0x2b(%ebx)
  283a07:	75 60                	jne    283a69 <cmd_dir+0x9a>
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
  283a09:	83 ec 04             	sub    $0x4,%esp
  283a0c:	ff 73 3c             	pushl  0x3c(%ebx)
  283a0f:	68 f5 4a 28 00       	push   $0x284af5
  283a14:	56                   	push   %esi
  283a15:	e8 63 e1 ff ff       	call   281b7d <sprintf>
  283a1a:	83 c4 10             	add    $0x10,%esp
				for(j=0;j<8;j++)
  283a1d:	b8 00 00 00 00       	mov    $0x0,%eax
				{
					s[j] = finfo[i].name[j];
  283a22:	0f b6 54 03 20       	movzbl 0x20(%ebx,%eax,1),%edx
  283a27:	88 14 30             	mov    %dl,(%eax,%esi,1)
		if(finfo[i].name[0] != 0xe5)
		{
			if((finfo[i].type & 0x18) == 0)
			{
				sprintf(s,"filename.ext %d",finfo[i].size);
				for(j=0;j<8;j++)
  283a2a:	83 c0 01             	add    $0x1,%eax
  283a2d:	83 f8 08             	cmp    $0x8,%eax
  283a30:	75 f0                	jne    283a22 <cmd_dir+0x53>
				{
					s[j] = finfo[i].name[j];
				}
				s[9] = finfo[i].ext[0];
  283a32:	0f b6 43 28          	movzbl 0x28(%ebx),%eax
  283a36:	88 45 d3             	mov    %al,-0x2d(%ebp)
				s[10] = finfo[i].ext[1];
  283a39:	0f b6 43 29          	movzbl 0x29(%ebx),%eax
  283a3d:	88 45 d4             	mov    %al,-0x2c(%ebp)
				s[11] = finfo[i].ext[2];
  283a40:	0f b6 43 2a          	movzbl 0x2a(%ebx),%eax
  283a44:	88 45 d5             	mov    %al,-0x2b(%ebp)
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
  283a47:	83 ec 04             	sub    $0x4,%esp
  283a4a:	6a 1e                	push   $0x1e
  283a4c:	56                   	push   %esi
  283a4d:	6a 00                	push   $0x0
  283a4f:	6a 07                	push   $0x7
  283a51:	ff 77 08             	pushl  0x8(%edi)
  283a54:	6a 08                	push   $0x8
  283a56:	ff 37                	pushl  (%edi)
  283a58:	e8 56 d8 ff ff       	call   2812b3 <putfonts8_asc_sht>
				cons_newline(cons);
  283a5d:	83 c4 14             	add    $0x14,%esp
  283a60:	57                   	push   %edi
  283a61:	e8 ea fc ff ff       	call   283750 <cons_newline>
  283a66:	83 c4 10             	add    $0x10,%esp
void cmd_dir(struct CONSOLE *cons)
{
	struct FILEINFO *finfo = (struct FILEINFO *)(ADR_DISKIMG + 0x2600);
	int i,j;
	char s[30];
	for(i=0;i<224;i++)
  283a69:	81 fb c0 5d 10 00    	cmp    $0x105dc0,%ebx
  283a6f:	75 83                	jne    2839f4 <cmd_dir+0x25>
				putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,s,30);
				cons_newline(cons);
			}
		}
	}
	cons_newline(cons);
  283a71:	83 ec 0c             	sub    $0xc,%esp
  283a74:	57                   	push   %edi
  283a75:	e8 d6 fc ff ff       	call   283750 <cons_newline>
	return;
  283a7a:	83 c4 10             	add    $0x10,%esp
}
  283a7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283a80:	5b                   	pop    %ebx
  283a81:	5e                   	pop    %esi
  283a82:	5f                   	pop    %edi
  283a83:	5d                   	pop    %ebp
  283a84:	c3                   	ret    

00283a85 <cmd_type>:

void cmd_type(struct CONSOLE *cons,int *fat,char *cmdline)
{
  283a85:	55                   	push   %ebp
  283a86:	89 e5                	mov    %esp,%ebp
  283a88:	57                   	push   %edi
  283a89:	56                   	push   %esi
  283a8a:	53                   	push   %ebx
  283a8b:	83 ec 10             	sub    $0x10,%esp
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo = file_search(cmdline +5,(struct FILEINFO *)(ADR_DISKIMG + 0x002600),224);
  283a8e:	68 e0 00 00 00       	push   $0xe0
  283a93:	68 00 26 10 00       	push   $0x102600
  283a98:	8b 45 10             	mov    0x10(%ebp),%eax
  283a9b:	83 c0 05             	add    $0x5,%eax
  283a9e:	50                   	push   %eax
  283a9f:	e8 39 fb ff ff       	call   2835dd <file_search>
	char *p;
	int i;
	if(finfo != 0)
  283aa4:	83 c4 10             	add    $0x10,%esp
  283aa7:	85 c0                	test   %eax,%eax
  283aa9:	74 6e                	je     283b19 <cmd_type+0x94>
  283aab:	89 c6                	mov    %eax,%esi
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  283aad:	83 ec 08             	sub    $0x8,%esp
  283ab0:	ff 70 3c             	pushl  0x3c(%eax)
  283ab3:	68 00 00 3c 00       	push   $0x3c0000
  283ab8:	e8 30 ea ff ff       	call   2824ed <memman_alloc_4k>
  283abd:	89 c7                	mov    %eax,%edi
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  283abf:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  283ac6:	ff 75 0c             	pushl  0xc(%ebp)
  283ac9:	50                   	push   %eax
  283aca:	ff 76 3c             	pushl  0x3c(%esi)
  283acd:	0f b7 46 3a          	movzwl 0x3a(%esi),%eax
  283ad1:	50                   	push   %eax
  283ad2:	e8 5f fa ff ff       	call   283536 <file_loadfile>
		for(i=0;i<finfo->size;i++)
  283ad7:	8b 46 3c             	mov    0x3c(%esi),%eax
  283ada:	83 c4 20             	add    $0x20,%esp
  283add:	85 c0                	test   %eax,%eax
  283adf:	74 24                	je     283b05 <cmd_type+0x80>
  283ae1:	bb 00 00 00 00       	mov    $0x0,%ebx
		{
			cons_putchar(cons,p[i],1);
  283ae6:	83 ec 04             	sub    $0x4,%esp
  283ae9:	6a 01                	push   $0x1
  283aeb:	0f be 04 3b          	movsbl (%ebx,%edi,1),%eax
  283aef:	50                   	push   %eax
  283af0:	ff 75 08             	pushl  0x8(%ebp)
  283af3:	e8 23 fd ff ff       	call   28381b <cons_putchar>
	int i;
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		for(i=0;i<finfo->size;i++)
  283af8:	83 c3 01             	add    $0x1,%ebx
  283afb:	8b 46 3c             	mov    0x3c(%esi),%eax
  283afe:	83 c4 10             	add    $0x10,%esp
  283b01:	39 d8                	cmp    %ebx,%eax
  283b03:	77 e1                	ja     283ae6 <cmd_type+0x61>
		{
			cons_putchar(cons,p[i],1);
		}
		memman_free_4k(memman,(int)p,finfo->size);
  283b05:	83 ec 04             	sub    $0x4,%esp
  283b08:	50                   	push   %eax
  283b09:	57                   	push   %edi
  283b0a:	68 00 00 3c 00       	push   $0x3c0000
  283b0f:	e8 05 ea ff ff       	call   282519 <memman_free_4k>
  283b14:	83 c4 10             	add    $0x10,%esp
  283b17:	eb 2b                	jmp    283b44 <cmd_type+0xbf>
	}
	else
	{
		putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"File not found.",15);
  283b19:	83 ec 04             	sub    $0x4,%esp
  283b1c:	6a 0f                	push   $0xf
  283b1e:	68 05 4b 28 00       	push   $0x284b05
  283b23:	6a 00                	push   $0x0
  283b25:	6a 07                	push   $0x7
  283b27:	8b 45 08             	mov    0x8(%ebp),%eax
  283b2a:	ff 70 08             	pushl  0x8(%eax)
  283b2d:	6a 08                	push   $0x8
  283b2f:	ff 30                	pushl  (%eax)
  283b31:	e8 7d d7 ff ff       	call   2812b3 <putfonts8_asc_sht>
		cons_newline(cons);
  283b36:	83 c4 14             	add    $0x14,%esp
  283b39:	ff 75 08             	pushl  0x8(%ebp)
  283b3c:	e8 0f fc ff ff       	call   283750 <cons_newline>
  283b41:	83 c4 10             	add    $0x10,%esp
	}
	cons_newline(cons);
  283b44:	83 ec 0c             	sub    $0xc,%esp
  283b47:	ff 75 08             	pushl  0x8(%ebp)
  283b4a:	e8 01 fc ff ff       	call   283750 <cons_newline>
	return;
  283b4f:	83 c4 10             	add    $0x10,%esp
}
  283b52:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283b55:	5b                   	pop    %ebx
  283b56:	5e                   	pop    %esi
  283b57:	5f                   	pop    %edi
  283b58:	5d                   	pop    %ebp
  283b59:	c3                   	ret    

00283b5a <cons_putstr0>:
	return 0;
}


void cons_putstr0(struct CONSOLE *cons,char *s)
{
  283b5a:	55                   	push   %ebp
  283b5b:	89 e5                	mov    %esp,%ebp
  283b5d:	56                   	push   %esi
  283b5e:	53                   	push   %ebx
  283b5f:	8b 75 08             	mov    0x8(%ebp),%esi
  283b62:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	for(;*s!=0;s++)
  283b65:	0f b6 03             	movzbl (%ebx),%eax
  283b68:	84 c0                	test   %al,%al
  283b6a:	74 1c                	je     283b88 <cons_putstr0+0x2e>
	{
		cons_putchar(cons,*s,1);
  283b6c:	83 ec 04             	sub    $0x4,%esp
  283b6f:	6a 01                	push   $0x1
  283b71:	0f be c0             	movsbl %al,%eax
  283b74:	50                   	push   %eax
  283b75:	56                   	push   %esi
  283b76:	e8 a0 fc ff ff       	call   28381b <cons_putchar>
}


void cons_putstr0(struct CONSOLE *cons,char *s)
{
	for(;*s!=0;s++)
  283b7b:	83 c3 01             	add    $0x1,%ebx
  283b7e:	0f b6 03             	movzbl (%ebx),%eax
  283b81:	83 c4 10             	add    $0x10,%esp
  283b84:	84 c0                	test   %al,%al
  283b86:	75 e4                	jne    283b6c <cons_putstr0+0x12>
	{
		cons_putchar(cons,*s,1);
	}
	return;
}
  283b88:	8d 65 f8             	lea    -0x8(%ebp),%esp
  283b8b:	5b                   	pop    %ebx
  283b8c:	5e                   	pop    %esi
  283b8d:	5d                   	pop    %ebp
  283b8e:	c3                   	ret    

00283b8f <cmd_app>:
}



int cmd_app(struct CONSOLE *cons,int *fat,char *cmdline)
{
  283b8f:	55                   	push   %ebp
  283b90:	89 e5                	mov    %esp,%ebp
  283b92:	57                   	push   %edi
  283b93:	56                   	push   %esi
  283b94:	53                   	push   %ebx
  283b95:	83 ec 4c             	sub    $0x4c,%esp
  283b98:	8b 75 10             	mov    0x10(%ebp),%esi
	struct MEMMAN *memman = (struct MEMMAN *)MEMMAN_ADDR;
	struct FILEINFO *finfo;
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
  283b9b:	e8 92 f2 ff ff       	call   282e32 <task_now>
  283ba0:	89 45 c0             	mov    %eax,-0x40(%ebp)
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
  283ba3:	0f b6 06             	movzbl (%esi),%eax
  283ba6:	3c 20                	cmp    $0x20,%al
  283ba8:	0f 8f 31 02 00 00    	jg     283ddf <cmd_app+0x250>
  283bae:	eb 16                	jmp    283bc6 <cmd_app+0x37>
  283bb0:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
  283bb4:	3c 20                	cmp    $0x20,%al
  283bb6:	7e 13                	jle    283bcb <cmd_app+0x3c>
			break;
		name[i] = cmdline[i];
  283bb8:	88 44 1d d6          	mov    %al,-0x2a(%ebp,%ebx,1)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  283bbc:	83 c3 01             	add    $0x1,%ebx
  283bbf:	83 fb 0d             	cmp    $0xd,%ebx
  283bc2:	75 ec                	jne    283bb0 <cmd_app+0x21>
  283bc4:	eb 05                	jmp    283bcb <cmd_app+0x3c>
  283bc6:	bb 00 00 00 00       	mov    $0x0,%ebx
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
	}
	name[i] = 0;
  283bcb:	c6 44 1d d6 00       	movb   $0x0,-0x2a(%ebp,%ebx,1)

	finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  283bd0:	83 ec 04             	sub    $0x4,%esp
  283bd3:	68 e0 00 00 00       	push   $0xe0
  283bd8:	68 00 26 10 00       	push   $0x102600
  283bdd:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  283be0:	50                   	push   %eax
  283be1:	e8 f7 f9 ff ff       	call   2835dd <file_search>
  283be6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	if(finfo == 0 && name[i-1]!='.')
  283be9:	83 c4 10             	add    $0x10,%esp
  283bec:	85 c0                	test   %eax,%eax
  283bee:	75 48                	jne    283c38 <cmd_app+0xa9>
  283bf0:	80 7c 1d d5 2e       	cmpb   $0x2e,-0x2b(%ebp,%ebx,1)
  283bf5:	0f 84 f1 01 00 00    	je     283dec <cmd_app+0x25d>
	{
		name[i  ] = '.';
  283bfb:	c6 44 1d d6 2e       	movb   $0x2e,-0x2a(%ebp,%ebx,1)
		name[i+1] = 'B';
  283c00:	c6 44 1d d7 42       	movb   $0x42,-0x29(%ebp,%ebx,1)
		name[i+2] = 'I';
  283c05:	c6 44 1d d8 49       	movb   $0x49,-0x28(%ebp,%ebx,1)
		name[i+3] = 'N';
  283c0a:	c6 44 1d d9 4e       	movb   $0x4e,-0x27(%ebp,%ebx,1)
		name[i+4] = 0;
  283c0f:	c6 44 1d da 00       	movb   $0x0,-0x26(%ebp,%ebx,1)
		finfo = file_search(name,(struct FILEINFO *)(ADR_DISKIMG + 0x2600),224);
  283c14:	83 ec 04             	sub    $0x4,%esp
  283c17:	68 e0 00 00 00       	push   $0xe0
  283c1c:	68 00 26 10 00       	push   $0x102600
  283c21:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  283c24:	50                   	push   %eax
  283c25:	e8 b3 f9 ff ff       	call   2835dd <file_search>
  283c2a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	}

	if(finfo != 0)
  283c2d:	83 c4 10             	add    $0x10,%esp
  283c30:	85 c0                	test   %eax,%eax
  283c32:	0f 84 a0 01 00 00    	je     283dd8 <cmd_app+0x249>
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
  283c38:	83 ec 08             	sub    $0x8,%esp
  283c3b:	8b 7d c4             	mov    -0x3c(%ebp),%edi
  283c3e:	ff 77 3c             	pushl  0x3c(%edi)
  283c41:	68 00 00 3c 00       	push   $0x3c0000
  283c46:	e8 a2 e8 ff ff       	call   2824ed <memman_alloc_4k>
  283c4b:	89 c6                	mov    %eax,%esi
  283c4d:	89 45 bc             	mov    %eax,-0x44(%ebp)
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
  283c50:	c7 04 24 00 3e 10 00 	movl   $0x103e00,(%esp)
  283c57:	ff 75 0c             	pushl  0xc(%ebp)
  283c5a:	50                   	push   %eax
  283c5b:	ff 77 3c             	pushl  0x3c(%edi)
  283c5e:	0f b7 47 3a          	movzwl 0x3a(%edi),%eax
  283c62:	50                   	push   %eax
  283c63:	e8 ce f8 ff ff       	call   283536 <file_loadfile>
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
  283c68:	83 c4 20             	add    $0x20,%esp
  283c6b:	83 7f 3c 23          	cmpl   $0x23,0x3c(%edi)
  283c6f:	0f 86 25 01 00 00    	jbe    283d9a <cmd_app+0x20b>
  283c75:	83 ec 04             	sub    $0x4,%esp
  283c78:	6a 04                	push   $0x4
  283c7a:	68 15 4b 28 00       	push   $0x284b15
  283c7f:	89 f0                	mov    %esi,%eax
  283c81:	83 c0 04             	add    $0x4,%eax
  283c84:	50                   	push   %eax
  283c85:	e8 2e e0 ff ff       	call   281cb8 <strncmp>
  283c8a:	83 c4 10             	add    $0x10,%esp
  283c8d:	85 c0                	test   %eax,%eax
  283c8f:	0f 85 05 01 00 00    	jne    283d9a <cmd_app+0x20b>
  283c95:	80 3e 00             	cmpb   $0x0,(%esi)
  283c98:	0f 85 fc 00 00 00    	jne    283d9a <cmd_app+0x20b>
		{
			int segsiz	=	*((int *)(p+0x0000));
  283c9e:	8b 45 bc             	mov    -0x44(%ebp),%eax
  283ca1:	8b 10                	mov    (%eax),%edx
			int esp		=	*((int *)(p+0x000c));
  283ca3:	8b 70 0c             	mov    0xc(%eax),%esi
			int datsiz	=	*((int *)(p+0x0010));
  283ca6:	8b 58 10             	mov    0x10(%eax),%ebx
			int dathrb	=	*((int *)(p+0x0014));
  283ca9:	8b 78 14             	mov    0x14(%eax),%edi

			q = (char *)memman_alloc_4k(memman,segsiz);
  283cac:	83 ec 08             	sub    $0x8,%esp
  283caf:	89 55 b8             	mov    %edx,-0x48(%ebp)
  283cb2:	52                   	push   %edx
  283cb3:	68 00 00 3c 00       	push   $0x3c0000
  283cb8:	e8 30 e8 ff ff       	call   2824ed <memman_alloc_4k>
			*((int *)0xfe8) = (int) q;
  283cbd:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  283cc0:	a3 e8 0f 00 00       	mov    %eax,0xfe8
			set_segmdesc(gdt + 1003,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
  283cc5:	68 fa 40 00 00       	push   $0x40fa
  283cca:	ff 75 bc             	pushl  -0x44(%ebp)
  283ccd:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  283cd0:	8b 40 3c             	mov    0x3c(%eax),%eax
  283cd3:	89 45 b0             	mov    %eax,-0x50(%ebp)
  283cd6:	83 e8 01             	sub    $0x1,%eax
  283cd9:	50                   	push   %eax
  283cda:	68 58 1f 27 00       	push   $0x271f58
  283cdf:	e8 21 d9 ff ff       	call   281605 <set_segmdesc>
			set_segmdesc(gdt + 1004,segsiz - 1,(int)q,AR_DATA32_RW + 0x60);
  283ce4:	83 c4 20             	add    $0x20,%esp
  283ce7:	68 f2 40 00 00       	push   $0x40f2
  283cec:	ff 75 b4             	pushl  -0x4c(%ebp)
  283cef:	8b 55 b8             	mov    -0x48(%ebp),%edx
  283cf2:	8d 42 ff             	lea    -0x1(%edx),%eax
  283cf5:	50                   	push   %eax
  283cf6:	68 60 1f 27 00       	push   $0x271f60
  283cfb:	e8 05 d9 ff ff       	call   281605 <set_segmdesc>
			for(int i = 0;i<datsiz;i++)
  283d00:	83 c4 10             	add    $0x10,%esp
  283d03:	85 db                	test   %ebx,%ebx
  283d05:	7e 1c                	jle    283d23 <cmd_app+0x194>
  283d07:	b8 00 00 00 00       	mov    $0x0,%eax
			{
				q[esp + i] = p[dathrb + i];
  283d0c:	03 7d bc             	add    -0x44(%ebp),%edi
  283d0f:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  283d12:	8d 14 31             	lea    (%ecx,%esi,1),%edx
  283d15:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  283d19:	88 0c 02             	mov    %cl,(%edx,%eax,1)

			q = (char *)memman_alloc_4k(memman,segsiz);
			*((int *)0xfe8) = (int) q;
			set_segmdesc(gdt + 1003,finfo->size - 1,(int)p,AR_CODE32_ER + 0x60);
			set_segmdesc(gdt + 1004,segsiz - 1,(int)q,AR_DATA32_RW + 0x60);
			for(int i = 0;i<datsiz;i++)
  283d1c:	83 c0 01             	add    $0x1,%eax
  283d1f:	39 c3                	cmp    %eax,%ebx
  283d21:	75 f2                	jne    283d15 <cmd_app+0x186>
			{
				q[esp + i] = p[dathrb + i];
			}
			start_app(0x1b,1003*8,esp,1004*8,&(task->tss.esp0));
  283d23:	83 ec 0c             	sub    $0xc,%esp
  283d26:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283d29:	83 c0 30             	add    $0x30,%eax
  283d2c:	50                   	push   %eax
  283d2d:	68 60 1f 00 00       	push   $0x1f60
  283d32:	56                   	push   %esi
  283d33:	68 58 1f 00 00       	push   $0x1f58
  283d38:	6a 1b                	push   $0x1b
  283d3a:	e8 f1 01 00 00       	call   283f30 <start_app>
			struct SHEET *sht;
			struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
  283d3f:	8b 3d e4 0f 00 00    	mov    0xfe4,%edi
  283d45:	8d 9f 30 04 00 00    	lea    0x430(%edi),%ebx
  283d4b:	8d b7 14 04 00 00    	lea    0x414(%edi),%esi
  283d51:	81 c7 14 2c 00 00    	add    $0x2c14,%edi
  283d57:	83 c4 20             	add    $0x20,%esp
			for(int i=0;i<MAX_SHEETS;i++)
			{
				sht = &(shtctl->sheets0[i]);
				if((sht->flags&0x11) == 0x11 && sht->task == task)
  283d5a:	8b 03                	mov    (%ebx),%eax
  283d5c:	83 e0 11             	and    $0x11,%eax
  283d5f:	83 f8 11             	cmp    $0x11,%eax
  283d62:	75 14                	jne    283d78 <cmd_app+0x1e9>
  283d64:	8b 45 c0             	mov    -0x40(%ebp),%eax
  283d67:	3b 43 08             	cmp    0x8(%ebx),%eax
  283d6a:	75 0c                	jne    283d78 <cmd_app+0x1e9>
					sheet_free(sht);
  283d6c:	83 ec 0c             	sub    $0xc,%esp
  283d6f:	56                   	push   %esi
  283d70:	e8 55 ed ff ff       	call   282aca <sheet_free>
  283d75:	83 c4 10             	add    $0x10,%esp
  283d78:	83 c3 28             	add    $0x28,%ebx
  283d7b:	83 c6 28             	add    $0x28,%esi
				q[esp + i] = p[dathrb + i];
			}
			start_app(0x1b,1003*8,esp,1004*8,&(task->tss.esp0));
			struct SHEET *sht;
			struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
			for(int i=0;i<MAX_SHEETS;i++)
  283d7e:	39 f7                	cmp    %esi,%edi
  283d80:	75 d8                	jne    283d5a <cmd_app+0x1cb>
			{
				sht = &(shtctl->sheets0[i]);
				if((sht->flags&0x11) == 0x11 && sht->task == task)
					sheet_free(sht);
			}
			memman_free_4k(memman,(int)q,segsiz);
  283d82:	83 ec 04             	sub    $0x4,%esp
  283d85:	ff 75 b8             	pushl  -0x48(%ebp)
  283d88:	ff 75 b4             	pushl  -0x4c(%ebp)
  283d8b:	68 00 00 3c 00       	push   $0x3c0000
  283d90:	e8 84 e7 ff ff       	call   282519 <memman_free_4k>
	if(finfo != 0)
	{
		p = (char *)memman_alloc_4k(memman,finfo->size);
		file_loadfile(finfo->clustno,finfo->size,p,fat,(char *)(ADR_DISKIMG + 0x3e00));
		if(finfo->size >= 36 && strncmp(p+4,"Hari",4) == 0 && *p == 0x00)
		{
  283d95:	83 c4 10             	add    $0x10,%esp
  283d98:	eb 13                	jmp    283dad <cmd_app+0x21e>
			}
			memman_free_4k(memman,(int)q,segsiz);
		}
		else
		{
			cons_putstr0(cons,".bin file format error.\n");
  283d9a:	83 ec 08             	sub    $0x8,%esp
  283d9d:	68 1a 4b 28 00       	push   $0x284b1a
  283da2:	ff 75 08             	pushl  0x8(%ebp)
  283da5:	e8 b0 fd ff ff       	call   283b5a <cons_putstr0>
  283daa:	83 c4 10             	add    $0x10,%esp
		}
		memman_free_4k(memman,(int)p,finfo->size);
  283dad:	83 ec 04             	sub    $0x4,%esp
  283db0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  283db3:	ff 70 3c             	pushl  0x3c(%eax)
  283db6:	ff 75 bc             	pushl  -0x44(%ebp)
  283db9:	68 00 00 3c 00       	push   $0x3c0000
  283dbe:	e8 56 e7 ff ff       	call   282519 <memman_free_4k>
		cons_newline(cons);
  283dc3:	83 c4 04             	add    $0x4,%esp
  283dc6:	ff 75 08             	pushl  0x8(%ebp)
  283dc9:	e8 82 f9 ff ff       	call   283750 <cons_newline>
		return 1;
  283dce:	83 c4 10             	add    $0x10,%esp
  283dd1:	b8 01 00 00 00       	mov    $0x1,%eax
  283dd6:	eb 14                	jmp    283dec <cmd_app+0x25d>
	}
	return 0;
  283dd8:	b8 00 00 00 00       	mov    $0x0,%eax
  283ddd:	eb 0d                	jmp    283dec <cmd_app+0x25d>

	for(i=0;i<13;i++)
	{
		if(cmdline[i] <= ' ')
			break;
		name[i] = cmdline[i];
  283ddf:	88 45 d6             	mov    %al,-0x2a(%ebp)
	struct SEGMENT_DESCRIPTOR *gdt = (struct SEGMENT_DESCRIPTOR *)ADR_GDT;
	struct TASK *task = task_now();
	char name[18],*p,*q;
	int i;

	for(i=0;i<13;i++)
  283de2:	bb 01 00 00 00       	mov    $0x1,%ebx
  283de7:	e9 c4 fd ff ff       	jmp    283bb0 <cmd_app+0x21>
		memman_free_4k(memman,(int)p,finfo->size);
		cons_newline(cons);
		return 1;
	}
	return 0;
}
  283dec:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283def:	5b                   	pop    %ebx
  283df0:	5e                   	pop    %esi
  283df1:	5f                   	pop    %edi
  283df2:	5d                   	pop    %ebp
  283df3:	c3                   	ret    

00283df4 <cons_runcmd>:
	cons->cur_x = 8;
}

#include "string.h"
void cons_runcmd(char *cmdline,struct CONSOLE *cons,int *fat,unsigned int memtotal)
{
  283df4:	55                   	push   %ebp
  283df5:	89 e5                	mov    %esp,%ebp
  283df7:	53                   	push   %ebx
  283df8:	83 ec 0c             	sub    $0xc,%esp
  283dfb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if(strcmp(cmdline,"mem") == 0)
  283dfe:	68 33 4b 28 00       	push   $0x284b33
  283e03:	53                   	push   %ebx
  283e04:	e8 49 de ff ff       	call   281c52 <strcmp>
  283e09:	83 c4 10             	add    $0x10,%esp
  283e0c:	85 c0                	test   %eax,%eax
  283e0e:	75 16                	jne    283e26 <cons_runcmd+0x32>
		cmd_mem(cons,memtotal);
  283e10:	83 ec 08             	sub    $0x8,%esp
  283e13:	ff 75 14             	pushl  0x14(%ebp)
  283e16:	ff 75 0c             	pushl  0xc(%ebp)
  283e19:	e8 bb fa ff ff       	call   2838d9 <cmd_mem>
  283e1e:	83 c4 10             	add    $0x10,%esp
  283e21:	e9 c9 00 00 00       	jmp    283eef <cons_runcmd+0xfb>
	else if(strcmp(cmdline,"cls") == 0)
  283e26:	83 ec 08             	sub    $0x8,%esp
  283e29:	68 37 4b 28 00       	push   $0x284b37
  283e2e:	53                   	push   %ebx
  283e2f:	e8 1e de ff ff       	call   281c52 <strcmp>
  283e34:	83 c4 10             	add    $0x10,%esp
  283e37:	85 c0                	test   %eax,%eax
  283e39:	75 13                	jne    283e4e <cons_runcmd+0x5a>
		cmd_cls(cons);
  283e3b:	83 ec 0c             	sub    $0xc,%esp
  283e3e:	ff 75 0c             	pushl  0xc(%ebp)
  283e41:	e8 21 fb ff ff       	call   283967 <cmd_cls>
  283e46:	83 c4 10             	add    $0x10,%esp
  283e49:	e9 a1 00 00 00       	jmp    283eef <cons_runcmd+0xfb>
	else if(strcmp(cmdline,"dir") == 0)
  283e4e:	83 ec 08             	sub    $0x8,%esp
  283e51:	68 3b 4b 28 00       	push   $0x284b3b
  283e56:	53                   	push   %ebx
  283e57:	e8 f6 dd ff ff       	call   281c52 <strcmp>
  283e5c:	83 c4 10             	add    $0x10,%esp
  283e5f:	85 c0                	test   %eax,%eax
  283e61:	75 10                	jne    283e73 <cons_runcmd+0x7f>
		cmd_dir(cons);
  283e63:	83 ec 0c             	sub    $0xc,%esp
  283e66:	ff 75 0c             	pushl  0xc(%ebp)
  283e69:	e8 61 fb ff ff       	call   2839cf <cmd_dir>
  283e6e:	83 c4 10             	add    $0x10,%esp
  283e71:	eb 7c                	jmp    283eef <cons_runcmd+0xfb>
	else if(strncmp(cmdline,"type ",5) == 0)
  283e73:	83 ec 04             	sub    $0x4,%esp
  283e76:	6a 05                	push   $0x5
  283e78:	68 3f 4b 28 00       	push   $0x284b3f
  283e7d:	53                   	push   %ebx
  283e7e:	e8 35 de ff ff       	call   281cb8 <strncmp>
  283e83:	83 c4 10             	add    $0x10,%esp
  283e86:	85 c0                	test   %eax,%eax
  283e88:	75 14                	jne    283e9e <cons_runcmd+0xaa>
		cmd_type(cons,fat,cmdline);
  283e8a:	83 ec 04             	sub    $0x4,%esp
  283e8d:	53                   	push   %ebx
  283e8e:	ff 75 10             	pushl  0x10(%ebp)
  283e91:	ff 75 0c             	pushl  0xc(%ebp)
  283e94:	e8 ec fb ff ff       	call   283a85 <cmd_type>
  283e99:	83 c4 10             	add    $0x10,%esp
  283e9c:	eb 51                	jmp    283eef <cons_runcmd+0xfb>
	else if(cmdline[0] != 0)
  283e9e:	80 3b 00             	cmpb   $0x0,(%ebx)
  283ea1:	74 4c                	je     283eef <cons_runcmd+0xfb>
	{
		if(cmd_app(cons,fat,cmdline) == 0)
  283ea3:	83 ec 04             	sub    $0x4,%esp
  283ea6:	53                   	push   %ebx
  283ea7:	ff 75 10             	pushl  0x10(%ebp)
  283eaa:	ff 75 0c             	pushl  0xc(%ebp)
  283ead:	e8 dd fc ff ff       	call   283b8f <cmd_app>
  283eb2:	83 c4 10             	add    $0x10,%esp
  283eb5:	85 c0                	test   %eax,%eax
  283eb7:	75 36                	jne    283eef <cons_runcmd+0xfb>
		{
			putfonts8_asc_sht(cons->sht,8,cons->cur_y,COL8_FFFFFF,COL8_000000,"Bad command.",12);
  283eb9:	83 ec 04             	sub    $0x4,%esp
  283ebc:	6a 0c                	push   $0xc
  283ebe:	68 45 4b 28 00       	push   $0x284b45
  283ec3:	6a 00                	push   $0x0
  283ec5:	6a 07                	push   $0x7
  283ec7:	8b 45 0c             	mov    0xc(%ebp),%eax
  283eca:	ff 70 08             	pushl  0x8(%eax)
  283ecd:	6a 08                	push   $0x8
  283ecf:	ff 30                	pushl  (%eax)
  283ed1:	e8 dd d3 ff ff       	call   2812b3 <putfonts8_asc_sht>
			cons_newline(cons);
  283ed6:	83 c4 14             	add    $0x14,%esp
  283ed9:	ff 75 0c             	pushl  0xc(%ebp)
  283edc:	e8 6f f8 ff ff       	call   283750 <cons_newline>
			cons_newline(cons);
  283ee1:	83 c4 04             	add    $0x4,%esp
  283ee4:	ff 75 0c             	pushl  0xc(%ebp)
  283ee7:	e8 64 f8 ff ff       	call   283750 <cons_newline>
  283eec:	83 c4 10             	add    $0x10,%esp
		}
	}
	return;
}
  283eef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  283ef2:	c9                   	leave  
  283ef3:	c3                   	ret    

00283ef4 <cons_putstr1>:
	}
	return;
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
  283ef4:	55                   	push   %ebp
  283ef5:	89 e5                	mov    %esp,%ebp
  283ef7:	57                   	push   %edi
  283ef8:	56                   	push   %esi
  283ef9:	53                   	push   %ebx
  283efa:	83 ec 0c             	sub    $0xc,%esp
  283efd:	8b 7d 08             	mov    0x8(%ebp),%edi
  283f00:	8b 75 0c             	mov    0xc(%ebp),%esi
  283f03:	8b 45 10             	mov    0x10(%ebp),%eax
	int i;
	for(i=0;i<l;i++)
  283f06:	85 c0                	test   %eax,%eax
  283f08:	7e 1d                	jle    283f27 <cons_putstr1+0x33>
  283f0a:	89 f3                	mov    %esi,%ebx
  283f0c:	01 c6                	add    %eax,%esi
	{
		cons_putchar(cons,s[i],1);
  283f0e:	83 ec 04             	sub    $0x4,%esp
  283f11:	6a 01                	push   $0x1
  283f13:	0f be 03             	movsbl (%ebx),%eax
  283f16:	50                   	push   %eax
  283f17:	57                   	push   %edi
  283f18:	e8 fe f8 ff ff       	call   28381b <cons_putchar>
  283f1d:	83 c3 01             	add    $0x1,%ebx
}

void cons_putstr1(struct CONSOLE *cons,char *s,int l)
{
	int i;
	for(i=0;i<l;i++)
  283f20:	83 c4 10             	add    $0x10,%esp
  283f23:	39 f3                	cmp    %esi,%ebx
  283f25:	75 e7                	jne    283f0e <cons_putstr1+0x1a>
	{
		cons_putchar(cons,s[i],1);
	}
	return;
}
  283f27:	8d 65 f4             	lea    -0xc(%ebp),%esp
  283f2a:	5b                   	pop    %ebx
  283f2b:	5e                   	pop    %esi
  283f2c:	5f                   	pop    %edi
  283f2d:	5d                   	pop    %ebp
  283f2e:	c3                   	ret    
  283f2f:	90                   	nop

00283f30 <start_app>:
  283f30:	60                   	pusha  
  283f31:	8b 44 24 24          	mov    0x24(%esp),%eax
  283f35:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  283f39:	8b 54 24 2c          	mov    0x2c(%esp),%edx
  283f3d:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  283f41:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  283f45:	89 65 00             	mov    %esp,0x0(%ebp)
  283f48:	8c 55 04             	mov    %ss,0x4(%ebp)
  283f4b:	8e c3                	mov    %ebx,%es
  283f4d:	8e db                	mov    %ebx,%ds
  283f4f:	8e e3                	mov    %ebx,%fs
  283f51:	8e eb                	mov    %ebx,%gs
  283f53:	83 c9 03             	or     $0x3,%ecx
  283f56:	83 cb 03             	or     $0x3,%ebx
  283f59:	53                   	push   %ebx
  283f5a:	52                   	push   %edx
  283f5b:	51                   	push   %ecx
  283f5c:	50                   	push   %eax
  283f5d:	cb                   	lret   

00283f5e <sys_api>:
#include "task.h"
#include "map_sheet.h"
#include "memory.h"
#include "graphics.h"
int *sys_api(int edi,int esi,int ebp,int esp,int ebx,int edx,int ecx,int eax)
{
  283f5e:	55                   	push   %ebp
  283f5f:	89 e5                	mov    %esp,%ebp
  283f61:	53                   	push   %ebx
  283f62:	83 ec 24             	sub    $0x24,%esp
	struct CONSOLE *cons = (struct CONSOLE *) *((int *)0x0fec);
  283f65:	b8 ec 0f 00 00       	mov    $0xfec,%eax
  283f6a:	8b 00                	mov    (%eax),%eax
  283f6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int ds_base = *((int *)0xfe8);
  283f6f:	b8 e8 0f 00 00       	mov    $0xfe8,%eax
  283f74:	8b 00                	mov    (%eax),%eax
  283f76:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct TASK *task = task_now();
  283f79:	e8 b4 ee ff ff       	call   282e32 <task_now>
  283f7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct SHTCTL *shtctl = (struct SHTCTL *) *((int *)0x0fe4);
  283f81:	b8 e4 0f 00 00       	mov    $0xfe4,%eax
  283f86:	8b 00                	mov    (%eax),%eax
  283f88:	89 45 e8             	mov    %eax,-0x18(%ebp)
	struct SHEET *sht;
	int *reg = &eax + 1;
  283f8b:	8d 45 24             	lea    0x24(%ebp),%eax
  283f8e:	83 c0 04             	add    $0x4,%eax
  283f91:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	   reg[0] = 1st_edi; reg[1] = 1st_esi ... reg[7] = 1st_eax
	   and the parameters:
	   edi = 2nd_edi; esi = 2nd_esi ... eax = 2nd_eax
	 */

	if(edx == 1) cons_putchar(cons,eax & 0xff,1);
  283f94:	83 7d 1c 01          	cmpl   $0x1,0x1c(%ebp)
  283f98:	75 1c                	jne    283fb6 <sys_api+0x58>
  283f9a:	8b 45 24             	mov    0x24(%ebp),%eax
  283f9d:	0f b6 c0             	movzbl %al,%eax
  283fa0:	83 ec 04             	sub    $0x4,%esp
  283fa3:	6a 01                	push   $0x1
  283fa5:	50                   	push   %eax
  283fa6:	ff 75 f4             	pushl  -0xc(%ebp)
  283fa9:	e8 6d f8 ff ff       	call   28381b <cons_putchar>
  283fae:	83 c4 10             	add    $0x10,%esp
  283fb1:	e9 a7 04 00 00       	jmp    28445d <sys_api+0x4ff>
	else if(edx == 2) cons_putstr0(cons,(char *)ebx+ds_base);
  283fb6:	83 7d 1c 02          	cmpl   $0x2,0x1c(%ebp)
  283fba:	75 1c                	jne    283fd8 <sys_api+0x7a>
  283fbc:	8b 55 f0             	mov    -0x10(%ebp),%edx
  283fbf:	8b 45 18             	mov    0x18(%ebp),%eax
  283fc2:	01 d0                	add    %edx,%eax
  283fc4:	83 ec 08             	sub    $0x8,%esp
  283fc7:	50                   	push   %eax
  283fc8:	ff 75 f4             	pushl  -0xc(%ebp)
  283fcb:	e8 8a fb ff ff       	call   283b5a <cons_putstr0>
  283fd0:	83 c4 10             	add    $0x10,%esp
  283fd3:	e9 85 04 00 00       	jmp    28445d <sys_api+0x4ff>
	else if(edx == 3) cons_putstr1(cons,(char *)ebx+ds_base,ecx);
  283fd8:	83 7d 1c 03          	cmpl   $0x3,0x1c(%ebp)
  283fdc:	75 1f                	jne    283ffd <sys_api+0x9f>
  283fde:	8b 55 f0             	mov    -0x10(%ebp),%edx
  283fe1:	8b 45 18             	mov    0x18(%ebp),%eax
  283fe4:	01 d0                	add    %edx,%eax
  283fe6:	83 ec 04             	sub    $0x4,%esp
  283fe9:	ff 75 20             	pushl  0x20(%ebp)
  283fec:	50                   	push   %eax
  283fed:	ff 75 f4             	pushl  -0xc(%ebp)
  283ff0:	e8 ff fe ff ff       	call   283ef4 <cons_putstr1>
  283ff5:	83 c4 10             	add    $0x10,%esp
  283ff8:	e9 60 04 00 00       	jmp    28445d <sys_api+0x4ff>
	else if(edx == 4)
  283ffd:	83 7d 1c 04          	cmpl   $0x4,0x1c(%ebp)
  284001:	75 0b                	jne    28400e <sys_api+0xb0>
	{
		//exit app
		return &(task->tss.esp0);
  284003:	8b 45 ec             	mov    -0x14(%ebp),%eax
  284006:	83 c0 30             	add    $0x30,%eax
  284009:	e9 54 04 00 00       	jmp    284462 <sys_api+0x504>
	}
	else if(edx == 5)
  28400e:	83 7d 1c 05          	cmpl   $0x5,0x1c(%ebp)
  284012:	0f 85 a5 00 00 00    	jne    2840bd <sys_api+0x15f>
	{
		sht = sheet_alloc(shtctl);
  284018:	83 ec 0c             	sub    $0xc,%esp
  28401b:	ff 75 e8             	pushl  -0x18(%ebp)
  28401e:	e8 b9 e5 ff ff       	call   2825dc <sheet_alloc>
  284023:	83 c4 10             	add    $0x10,%esp
  284026:	89 45 dc             	mov    %eax,-0x24(%ebp)
		sht->task = task;
  284029:	8b 45 dc             	mov    -0x24(%ebp),%eax
  28402c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  28402f:	89 50 24             	mov    %edx,0x24(%eax)
		sht->flags |= 0x11;
  284032:	8b 45 dc             	mov    -0x24(%ebp),%eax
  284035:	8b 40 1c             	mov    0x1c(%eax),%eax
  284038:	83 c8 11             	or     $0x11,%eax
  28403b:	89 c2                	mov    %eax,%edx
  28403d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  284040:	89 50 1c             	mov    %edx,0x1c(%eax)
		sheet_setbuf(sht,(char *)ebx+ds_base,esi,edi,eax);
  284043:	8b 45 24             	mov    0x24(%ebp),%eax
  284046:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  284049:	8b 55 18             	mov    0x18(%ebp),%edx
  28404c:	01 ca                	add    %ecx,%edx
  28404e:	83 ec 0c             	sub    $0xc,%esp
  284051:	50                   	push   %eax
  284052:	ff 75 08             	pushl  0x8(%ebp)
  284055:	ff 75 0c             	pushl  0xc(%ebp)
  284058:	52                   	push   %edx
  284059:	ff 75 dc             	pushl  -0x24(%ebp)
  28405c:	e8 ee e5 ff ff       	call   28264f <sheet_setbuf>
  284061:	83 c4 20             	add    $0x20,%esp
		make_window8((char *)ebx+ds_base,esi,edi,(char *)ecx+ds_base,0);
  284064:	8b 55 f0             	mov    -0x10(%ebp),%edx
  284067:	8b 45 20             	mov    0x20(%ebp),%eax
  28406a:	01 d0                	add    %edx,%eax
  28406c:	89 c1                	mov    %eax,%ecx
  28406e:	8b 55 f0             	mov    -0x10(%ebp),%edx
  284071:	8b 45 18             	mov    0x18(%ebp),%eax
  284074:	01 d0                	add    %edx,%eax
  284076:	83 ec 0c             	sub    $0xc,%esp
  284079:	6a 00                	push   $0x0
  28407b:	51                   	push   %ecx
  28407c:	ff 75 08             	pushl  0x8(%ebp)
  28407f:	ff 75 0c             	pushl  0xc(%ebp)
  284082:	50                   	push   %eax
  284083:	e8 cd d0 ff ff       	call   281155 <make_window8>
  284088:	83 c4 20             	add    $0x20,%esp
		sheet_slide(sht,100,50);
  28408b:	83 ec 04             	sub    $0x4,%esp
  28408e:	6a 32                	push   $0x32
  284090:	6a 64                	push   $0x64
  284092:	ff 75 dc             	pushl  -0x24(%ebp)
  284095:	e8 d1 e9 ff ff       	call   282a6b <sheet_slide>
  28409a:	83 c4 10             	add    $0x10,%esp
		sheet_updown(sht,3);	//above task_a
  28409d:	83 ec 08             	sub    $0x8,%esp
  2840a0:	6a 03                	push   $0x3
  2840a2:	ff 75 dc             	pushl  -0x24(%ebp)
  2840a5:	e8 d8 e8 ff ff       	call   282982 <sheet_updown>
  2840aa:	83 c4 10             	add    $0x10,%esp
		reg[7] = (int)sht;		//after sys_api ret and popad the eax will be sht
  2840ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  2840b0:	8d 50 1c             	lea    0x1c(%eax),%edx
  2840b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  2840b6:	89 02                	mov    %eax,(%edx)
  2840b8:	e9 a0 03 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 6)
  2840bd:	83 7d 1c 06          	cmpl   $0x6,0x1c(%ebp)
  2840c1:	75 71                	jne    284134 <sys_api+0x1d6>
	{
		sht = (struct SHEET *)ebx;
  2840c3:	8b 45 18             	mov    0x18(%ebp),%eax
  2840c6:	89 45 dc             	mov    %eax,-0x24(%ebp)
		putfonts8_asc(sht->buf,sht->bxsize,esi,edi,eax,(char *)ebp + ds_base);
  2840c9:	8b 55 f0             	mov    -0x10(%ebp),%edx
  2840cc:	8b 45 10             	mov    0x10(%ebp),%eax
  2840cf:	01 d0                	add    %edx,%eax
  2840d1:	89 c3                	mov    %eax,%ebx
  2840d3:	8b 4d 24             	mov    0x24(%ebp),%ecx
  2840d6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  2840d9:	8b 50 04             	mov    0x4(%eax),%edx
  2840dc:	8b 45 dc             	mov    -0x24(%ebp),%eax
  2840df:	8b 00                	mov    (%eax),%eax
  2840e1:	83 ec 08             	sub    $0x8,%esp
  2840e4:	53                   	push   %ebx
  2840e5:	51                   	push   %ecx
  2840e6:	ff 75 08             	pushl  0x8(%ebp)
  2840e9:	ff 75 0c             	pushl  0xc(%ebp)
  2840ec:	52                   	push   %edx
  2840ed:	50                   	push   %eax
  2840ee:	e8 c4 d4 ff ff       	call   2815b7 <putfonts8_asc>
  2840f3:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  2840f6:	8b 45 18             	mov    0x18(%ebp),%eax
  2840f9:	83 e0 01             	and    $0x1,%eax
  2840fc:	85 c0                	test   %eax,%eax
  2840fe:	0f 85 59 03 00 00    	jne    28445d <sys_api+0x4ff>
			sheet_refresh(sht,esi,edi,esi+ecx*8,edi+16);
  284104:	8b 45 08             	mov    0x8(%ebp),%eax
  284107:	8d 50 10             	lea    0x10(%eax),%edx
  28410a:	8b 45 20             	mov    0x20(%ebp),%eax
  28410d:	8d 0c c5 00 00 00 00 	lea    0x0(,%eax,8),%ecx
  284114:	8b 45 0c             	mov    0xc(%ebp),%eax
  284117:	01 c8                	add    %ecx,%eax
  284119:	83 ec 0c             	sub    $0xc,%esp
  28411c:	52                   	push   %edx
  28411d:	50                   	push   %eax
  28411e:	ff 75 08             	pushl  0x8(%ebp)
  284121:	ff 75 0c             	pushl  0xc(%ebp)
  284124:	ff 75 dc             	pushl  -0x24(%ebp)
  284127:	e8 22 e8 ff ff       	call   28294e <sheet_refresh>
  28412c:	83 c4 20             	add    $0x20,%esp
  28412f:	e9 29 03 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 7)
  284134:	83 7d 1c 07          	cmpl   $0x7,0x1c(%ebp)
  284138:	75 68                	jne    2841a2 <sys_api+0x244>
	{
		sht = (struct SHEET *)ebx;
  28413a:	8b 45 18             	mov    0x18(%ebp),%eax
  28413d:	89 45 dc             	mov    %eax,-0x24(%ebp)
		boxfill8(sht->buf,sht->bxsize,ebp,eax,ecx,esi,edi);
  284140:	8b 5d 24             	mov    0x24(%ebp),%ebx
  284143:	8b 45 10             	mov    0x10(%ebp),%eax
  284146:	0f b6 c8             	movzbl %al,%ecx
  284149:	8b 45 dc             	mov    -0x24(%ebp),%eax
  28414c:	8b 50 04             	mov    0x4(%eax),%edx
  28414f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  284152:	8b 00                	mov    (%eax),%eax
  284154:	83 ec 04             	sub    $0x4,%esp
  284157:	ff 75 08             	pushl  0x8(%ebp)
  28415a:	ff 75 0c             	pushl  0xc(%ebp)
  28415d:	ff 75 20             	pushl  0x20(%ebp)
  284160:	53                   	push   %ebx
  284161:	51                   	push   %ecx
  284162:	52                   	push   %edx
  284163:	50                   	push   %eax
  284164:	e8 eb cc ff ff       	call   280e54 <boxfill8>
  284169:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  28416c:	8b 45 18             	mov    0x18(%ebp),%eax
  28416f:	83 e0 01             	and    $0x1,%eax
  284172:	85 c0                	test   %eax,%eax
  284174:	0f 85 e3 02 00 00    	jne    28445d <sys_api+0x4ff>
			sheet_refresh(sht,eax,ecx,esi+1,edi+1);
  28417a:	8b 45 08             	mov    0x8(%ebp),%eax
  28417d:	8d 48 01             	lea    0x1(%eax),%ecx
  284180:	8b 45 0c             	mov    0xc(%ebp),%eax
  284183:	8d 50 01             	lea    0x1(%eax),%edx
  284186:	8b 45 24             	mov    0x24(%ebp),%eax
  284189:	83 ec 0c             	sub    $0xc,%esp
  28418c:	51                   	push   %ecx
  28418d:	52                   	push   %edx
  28418e:	ff 75 20             	pushl  0x20(%ebp)
  284191:	50                   	push   %eax
  284192:	ff 75 dc             	pushl  -0x24(%ebp)
  284195:	e8 b4 e7 ff ff       	call   28294e <sheet_refresh>
  28419a:	83 c4 20             	add    $0x20,%esp
  28419d:	e9 bb 02 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 8)
  2841a2:	83 7d 1c 08          	cmpl   $0x8,0x1c(%ebp)
  2841a6:	75 3b                	jne    2841e3 <sys_api+0x285>
	{
		memman_init((struct MEMMAN *)(ebx + ds_base));
  2841a8:	8b 55 18             	mov    0x18(%ebp),%edx
  2841ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  2841ae:	01 d0                	add    %edx,%eax
  2841b0:	83 ec 0c             	sub    $0xc,%esp
  2841b3:	50                   	push   %eax
  2841b4:	e8 92 df ff ff       	call   28214b <memman_init>
  2841b9:	83 c4 10             	add    $0x10,%esp
		ecx &= 0xfffffff0;
  2841bc:	83 65 20 f0          	andl   $0xfffffff0,0x20(%ebp)
		memman_free((struct MEMMAN *)(ebx + ds_base),eax,ecx);
  2841c0:	8b 45 20             	mov    0x20(%ebp),%eax
  2841c3:	8b 55 24             	mov    0x24(%ebp),%edx
  2841c6:	89 d3                	mov    %edx,%ebx
  2841c8:	8b 4d 18             	mov    0x18(%ebp),%ecx
  2841cb:	8b 55 f0             	mov    -0x10(%ebp),%edx
  2841ce:	01 ca                	add    %ecx,%edx
  2841d0:	83 ec 04             	sub    $0x4,%esp
  2841d3:	50                   	push   %eax
  2841d4:	53                   	push   %ebx
  2841d5:	52                   	push   %edx
  2841d6:	e8 bf e0 ff ff       	call   28229a <memman_free>
  2841db:	83 c4 10             	add    $0x10,%esp
  2841de:	e9 7a 02 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 9)
  2841e3:	83 7d 1c 09          	cmpl   $0x9,0x1c(%ebp)
  2841e7:	75 31                	jne    28421a <sys_api+0x2bc>
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;
  2841e9:	8b 45 20             	mov    0x20(%ebp),%eax
  2841ec:	83 c0 0f             	add    $0xf,%eax
  2841ef:	83 e0 f0             	and    $0xfffffff0,%eax
  2841f2:	89 45 20             	mov    %eax,0x20(%ebp)
		reg[7] = memman_alloc((struct MEMMAN *) (ebx + ds_base), ecx);
  2841f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  2841f8:	8d 58 1c             	lea    0x1c(%eax),%ebx
  2841fb:	8b 45 20             	mov    0x20(%ebp),%eax
  2841fe:	8b 4d 18             	mov    0x18(%ebp),%ecx
  284201:	8b 55 f0             	mov    -0x10(%ebp),%edx
  284204:	01 ca                	add    %ecx,%edx
  284206:	83 ec 08             	sub    $0x8,%esp
  284209:	50                   	push   %eax
  28420a:	52                   	push   %edx
  28420b:	e8 a1 df ff ff       	call   2821b1 <memman_alloc>
  284210:	83 c4 10             	add    $0x10,%esp
  284213:	89 03                	mov    %eax,(%ebx)
  284215:	e9 43 02 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 10)
  28421a:	83 7d 1c 0a          	cmpl   $0xa,0x1c(%ebp)
  28421e:	75 2f                	jne    28424f <sys_api+0x2f1>
	{
		ecx = (ecx + 0x0f) & 0xfffffff0;
  284220:	8b 45 20             	mov    0x20(%ebp),%eax
  284223:	83 c0 0f             	add    $0xf,%eax
  284226:	83 e0 f0             	and    $0xfffffff0,%eax
  284229:	89 45 20             	mov    %eax,0x20(%ebp)
		memman_free((struct MEMMAN *)(edx + ds_base),eax,ecx);
  28422c:	8b 45 20             	mov    0x20(%ebp),%eax
  28422f:	8b 55 24             	mov    0x24(%ebp),%edx
  284232:	89 d3                	mov    %edx,%ebx
  284234:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  284237:	8b 55 f0             	mov    -0x10(%ebp),%edx
  28423a:	01 ca                	add    %ecx,%edx
  28423c:	83 ec 04             	sub    $0x4,%esp
  28423f:	50                   	push   %eax
  284240:	53                   	push   %ebx
  284241:	52                   	push   %edx
  284242:	e8 53 e0 ff ff       	call   28229a <memman_free>
  284247:	83 c4 10             	add    $0x10,%esp
  28424a:	e9 0e 02 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 11)
  28424f:	83 7d 1c 0b          	cmpl   $0xb,0x1c(%ebp)
  284253:	75 58                	jne    2842ad <sys_api+0x34f>
	{
		sht = (struct SHEET *)ebx;
  284255:	8b 45 18             	mov    0x18(%ebp),%eax
  284258:	89 45 dc             	mov    %eax,-0x24(%ebp)
		sht->buf[sht->bxsize * edi + esi] = eax;
  28425b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  28425e:	8b 10                	mov    (%eax),%edx
  284260:	8b 45 dc             	mov    -0x24(%ebp),%eax
  284263:	8b 40 04             	mov    0x4(%eax),%eax
  284266:	0f af 45 08          	imul   0x8(%ebp),%eax
  28426a:	89 c1                	mov    %eax,%ecx
  28426c:	8b 45 0c             	mov    0xc(%ebp),%eax
  28426f:	01 c8                	add    %ecx,%eax
  284271:	01 d0                	add    %edx,%eax
  284273:	8b 55 24             	mov    0x24(%ebp),%edx
  284276:	88 10                	mov    %dl,(%eax)
		if(!(ebx&1))
  284278:	8b 45 18             	mov    0x18(%ebp),%eax
  28427b:	83 e0 01             	and    $0x1,%eax
  28427e:	85 c0                	test   %eax,%eax
  284280:	0f 85 d7 01 00 00    	jne    28445d <sys_api+0x4ff>
			sheet_refresh(sht,esi,edi,esi+1,edi+1);
  284286:	8b 45 08             	mov    0x8(%ebp),%eax
  284289:	8d 50 01             	lea    0x1(%eax),%edx
  28428c:	8b 45 0c             	mov    0xc(%ebp),%eax
  28428f:	83 c0 01             	add    $0x1,%eax
  284292:	83 ec 0c             	sub    $0xc,%esp
  284295:	52                   	push   %edx
  284296:	50                   	push   %eax
  284297:	ff 75 08             	pushl  0x8(%ebp)
  28429a:	ff 75 0c             	pushl  0xc(%ebp)
  28429d:	ff 75 dc             	pushl  -0x24(%ebp)
  2842a0:	e8 a9 e6 ff ff       	call   28294e <sheet_refresh>
  2842a5:	83 c4 20             	add    $0x20,%esp
  2842a8:	e9 b0 01 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 12)
  2842ad:	83 7d 1c 0c          	cmpl   $0xc,0x1c(%ebp)
  2842b1:	75 26                	jne    2842d9 <sys_api+0x37b>
	{
		sht = (struct SHEET *)ebx;
  2842b3:	8b 45 18             	mov    0x18(%ebp),%eax
  2842b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
		sheet_refresh(sht,eax,ecx,esi,edi);
  2842b9:	8b 45 24             	mov    0x24(%ebp),%eax
  2842bc:	83 ec 0c             	sub    $0xc,%esp
  2842bf:	ff 75 08             	pushl  0x8(%ebp)
  2842c2:	ff 75 0c             	pushl  0xc(%ebp)
  2842c5:	ff 75 20             	pushl  0x20(%ebp)
  2842c8:	50                   	push   %eax
  2842c9:	ff 75 dc             	pushl  -0x24(%ebp)
  2842cc:	e8 7d e6 ff ff       	call   28294e <sheet_refresh>
  2842d1:	83 c4 20             	add    $0x20,%esp
  2842d4:	e9 84 01 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 13)
  2842d9:	83 7d 1c 0d          	cmpl   $0xd,0x1c(%ebp)
  2842dd:	75 5d                	jne    28433c <sys_api+0x3de>
	{
		sht = (struct SHEET *)(ebx & 0xfffffffe);
  2842df:	8b 45 18             	mov    0x18(%ebp),%eax
  2842e2:	83 e0 fe             	and    $0xfffffffe,%eax
  2842e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		drawline8_sht(sht,eax,ecx,esi,edi,ebp);
  2842e8:	8b 45 24             	mov    0x24(%ebp),%eax
  2842eb:	83 ec 08             	sub    $0x8,%esp
  2842ee:	ff 75 10             	pushl  0x10(%ebp)
  2842f1:	ff 75 08             	pushl  0x8(%ebp)
  2842f4:	ff 75 0c             	pushl  0xc(%ebp)
  2842f7:	ff 75 20             	pushl  0x20(%ebp)
  2842fa:	50                   	push   %eax
  2842fb:	ff 75 dc             	pushl  -0x24(%ebp)
  2842fe:	e8 3e d1 ff ff       	call   281441 <drawline8_sht>
  284303:	83 c4 20             	add    $0x20,%esp
		if(!(ebx&1))
  284306:	8b 45 18             	mov    0x18(%ebp),%eax
  284309:	83 e0 01             	and    $0x1,%eax
  28430c:	85 c0                	test   %eax,%eax
  28430e:	0f 85 49 01 00 00    	jne    28445d <sys_api+0x4ff>
			sheet_refresh(sht,eax,ecx,esi+1,edi+1);
  284314:	8b 45 08             	mov    0x8(%ebp),%eax
  284317:	8d 48 01             	lea    0x1(%eax),%ecx
  28431a:	8b 45 0c             	mov    0xc(%ebp),%eax
  28431d:	8d 50 01             	lea    0x1(%eax),%edx
  284320:	8b 45 24             	mov    0x24(%ebp),%eax
  284323:	83 ec 0c             	sub    $0xc,%esp
  284326:	51                   	push   %ecx
  284327:	52                   	push   %edx
  284328:	ff 75 20             	pushl  0x20(%ebp)
  28432b:	50                   	push   %eax
  28432c:	ff 75 dc             	pushl  -0x24(%ebp)
  28432f:	e8 1a e6 ff ff       	call   28294e <sheet_refresh>
  284334:	83 c4 20             	add    $0x20,%esp
  284337:	e9 21 01 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 14)
  28433c:	83 7d 1c 0e          	cmpl   $0xe,0x1c(%ebp)
  284340:	75 14                	jne    284356 <sys_api+0x3f8>
	{
		sheet_free((struct SHEET *)ebx);
  284342:	8b 45 18             	mov    0x18(%ebp),%eax
  284345:	83 ec 0c             	sub    $0xc,%esp
  284348:	50                   	push   %eax
  284349:	e8 7c e7 ff ff       	call   282aca <sheet_free>
  28434e:	83 c4 10             	add    $0x10,%esp
  284351:	e9 07 01 00 00       	jmp    28445d <sys_api+0x4ff>
	}
	else if(edx == 15)
  284356:	83 7d 1c 0f          	cmpl   $0xf,0x1c(%ebp)
  28435a:	0f 85 fd 00 00 00    	jne    28445d <sys_api+0x4ff>
	{
		for(;;)
		{
			io_cli();
  284360:	e8 6d c9 ff ff       	call   280cd2 <io_cli>
			if(fifo32_status(&task->fifo) == 0)
  284365:	8b 45 ec             	mov    -0x14(%ebp),%eax
  284368:	83 c0 10             	add    $0x10,%eax
  28436b:	83 ec 0c             	sub    $0xc,%esp
  28436e:	50                   	push   %eax
  28436f:	e8 a2 da ff ff       	call   281e16 <fifo32_status>
  284374:	83 c4 10             	add    $0x10,%esp
  284377:	85 c0                	test   %eax,%eax
  284379:	75 32                	jne    2843ad <sys_api+0x44f>
			{
				if(eax != 0)
  28437b:	8b 45 24             	mov    0x24(%ebp),%eax
  28437e:	85 c0                	test   %eax,%eax
  284380:	74 10                	je     284392 <sys_api+0x434>
					task_sleep(task);
  284382:	83 ec 0c             	sub    $0xc,%esp
  284385:	ff 75 ec             	pushl  -0x14(%ebp)
  284388:	e8 0c ee ff ff       	call   283199 <task_sleep>
  28438d:	83 c4 10             	add    $0x10,%esp
  284390:	eb 1b                	jmp    2843ad <sys_api+0x44f>
				else
				{
					io_sti();
  284392:	e8 3d c9 ff ff       	call   280cd4 <io_sti>
					reg[7] = -1;
  284397:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  28439a:	83 c0 1c             	add    $0x1c,%eax
  28439d:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
					return 0;
  2843a3:	b8 00 00 00 00       	mov    $0x0,%eax
  2843a8:	e9 b5 00 00 00       	jmp    284462 <sys_api+0x504>
				}
			}
			int i = fifo32_get(&task->fifo);
  2843ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
  2843b0:	83 c0 10             	add    $0x10,%eax
  2843b3:	83 ec 0c             	sub    $0xc,%esp
  2843b6:	50                   	push   %eax
  2843b7:	e8 1f da ff ff       	call   281ddb <fifo32_get>
  2843bc:	83 c4 10             	add    $0x10,%esp
  2843bf:	89 45 e0             	mov    %eax,-0x20(%ebp)
			io_sti();
  2843c2:	e8 0d c9 ff ff       	call   280cd4 <io_sti>
			if(i <= 1)
  2843c7:	83 7d e0 01          	cmpl   $0x1,-0x20(%ebp)
  2843cb:	7f 34                	jg     284401 <sys_api+0x4a3>
			{
				timer_init(cons->timer,&task->fifo,1);
  2843cd:	8b 45 ec             	mov    -0x14(%ebp),%eax
  2843d0:	8d 50 10             	lea    0x10(%eax),%edx
  2843d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2843d6:	8b 40 10             	mov    0x10(%eax),%eax
  2843d9:	83 ec 04             	sub    $0x4,%esp
  2843dc:	6a 01                	push   $0x1
  2843de:	52                   	push   %edx
  2843df:	50                   	push   %eax
  2843e0:	e8 da e7 ff ff       	call   282bbf <timer_init>
  2843e5:	83 c4 10             	add    $0x10,%esp
				timer_settime(cons->timer,50);
  2843e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  2843eb:	8b 40 10             	mov    0x10(%eax),%eax
  2843ee:	83 ec 08             	sub    $0x8,%esp
  2843f1:	6a 32                	push   $0x32
  2843f3:	50                   	push   %eax
  2843f4:	e8 da e7 ff ff       	call   282bd3 <timer_settime>
  2843f9:	83 c4 10             	add    $0x10,%esp
  2843fc:	e9 5f ff ff ff       	jmp    284360 <sys_api+0x402>
			}
			else if(i == 2)
  284401:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
  284405:	75 0f                	jne    284416 <sys_api+0x4b8>
			{
				cons->cur_c = COL8_FFFFFF;
  284407:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28440a:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
  284411:	e9 4a ff ff ff       	jmp    284360 <sys_api+0x402>
			}
			else if(i == 3)
  284416:	83 7d e0 03          	cmpl   $0x3,-0x20(%ebp)
  28441a:	75 0f                	jne    28442b <sys_api+0x4cd>
			{
				cons->cur_c = -1;
  28441c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  28441f:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
  284426:	e9 35 ff ff ff       	jmp    284360 <sys_api+0x402>
			}
			else if(256 <= i && i <= 511)
  28442b:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%ebp)
  284432:	0f 8e 28 ff ff ff    	jle    284360 <sys_api+0x402>
  284438:	81 7d e0 ff 01 00 00 	cmpl   $0x1ff,-0x20(%ebp)
  28443f:	0f 8f 1b ff ff ff    	jg     284360 <sys_api+0x402>
			{
				reg[7] = i-256;
  284445:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  284448:	83 c0 1c             	add    $0x1c,%eax
  28444b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  28444e:	81 ea 00 01 00 00    	sub    $0x100,%edx
  284454:	89 10                	mov    %edx,(%eax)
				return 0;
  284456:	b8 00 00 00 00       	mov    $0x0,%eax
  28445b:	eb 05                	jmp    284462 <sys_api+0x504>
			}
		}
	}
	return 0;
  28445d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  284462:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  284465:	c9                   	leave  
  284466:	c3                   	ret    
  284467:	66 90                	xchg   %ax,%ax
  284469:	66 90                	xchg   %ax,%ax
  28446b:	66 90                	xchg   %ax,%ax
  28446d:	66 90                	xchg   %ax,%ax
  28446f:	90                   	nop

00284470 <api_putchar>:
  284470:	ba 01 00 00 00       	mov    $0x1,%edx
  284475:	8a 44 24 04          	mov    0x4(%esp),%al
  284479:	cd 40                	int    $0x40
  28447b:	c3                   	ret    

0028447c <api_putstr>:
  28447c:	ba 02 00 00 00       	mov    $0x2,%edx
  284481:	8b 5c 24 04          	mov    0x4(%esp),%ebx
  284485:	cd 40                	int    $0x40
  284487:	c3                   	ret    

00284488 <api_end>:
  284488:	ba 04 00 00 00       	mov    $0x4,%edx
  28448d:	cd 40                	int    $0x40

0028448f <api_test>:
  28448f:	05 80 00 00 00       	add    $0x80,%eax
  284494:	c3                   	ret    

00284495 <api_openwin>:
  284495:	57                   	push   %edi
  284496:	56                   	push   %esi
  284497:	53                   	push   %ebx
  284498:	ba 05 00 00 00       	mov    $0x5,%edx
  28449d:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  2844a1:	8b 74 24 14          	mov    0x14(%esp),%esi
  2844a5:	8b 7c 24 18          	mov    0x18(%esp),%edi
  2844a9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  2844ad:	8b 4c 24 20          	mov    0x20(%esp),%ecx
  2844b1:	cd 40                	int    $0x40
  2844b3:	5b                   	pop    %ebx
  2844b4:	5e                   	pop    %esi
  2844b5:	5f                   	pop    %edi
  2844b6:	c3                   	ret    

002844b7 <api_putstrwin>:
  2844b7:	57                   	push   %edi
  2844b8:	56                   	push   %esi
  2844b9:	55                   	push   %ebp
  2844ba:	53                   	push   %ebx
  2844bb:	ba 06 00 00 00       	mov    $0x6,%edx
  2844c0:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  2844c4:	8b 74 24 18          	mov    0x18(%esp),%esi
  2844c8:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  2844cc:	8b 44 24 20          	mov    0x20(%esp),%eax
  2844d0:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  2844d4:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  2844d8:	cd 40                	int    $0x40
  2844da:	5b                   	pop    %ebx
  2844db:	5d                   	pop    %ebp
  2844dc:	5e                   	pop    %esi
  2844dd:	5f                   	pop    %edi
  2844de:	c3                   	ret    

002844df <api_boxfilwin>:
  2844df:	57                   	push   %edi
  2844e0:	56                   	push   %esi
  2844e1:	55                   	push   %ebp
  2844e2:	53                   	push   %ebx
  2844e3:	ba 07 00 00 00       	mov    $0x7,%edx
  2844e8:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  2844ec:	8b 44 24 18          	mov    0x18(%esp),%eax
  2844f0:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  2844f4:	8b 74 24 20          	mov    0x20(%esp),%esi
  2844f8:	8b 7c 24 24          	mov    0x24(%esp),%edi
  2844fc:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  284500:	cd 40                	int    $0x40
  284502:	5b                   	pop    %ebx
  284503:	5d                   	pop    %ebp
  284504:	5e                   	pop    %esi
  284505:	5f                   	pop    %edi
  284506:	c3                   	ret    

00284507 <api_initmalloc>:
  284507:	53                   	push   %ebx
  284508:	ba 08 00 00 00       	mov    $0x8,%edx
  28450d:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  284514:	89 d8                	mov    %ebx,%eax
  284516:	05 00 80 00 00       	add    $0x8000,%eax
  28451b:	2e 8b 0d 00 00 00 00 	mov    %cs:0x0,%ecx
  284522:	29 c1                	sub    %eax,%ecx
  284524:	cd 40                	int    $0x40
  284526:	5b                   	pop    %ebx
  284527:	c3                   	ret    

00284528 <api_malloc>:
  284528:	53                   	push   %ebx
  284529:	ba 09 00 00 00       	mov    $0x9,%edx
  28452e:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  284535:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  284539:	cd 40                	int    $0x40
  28453b:	5b                   	pop    %ebx
  28453c:	c3                   	ret    

0028453d <api_free>:
  28453d:	53                   	push   %ebx
  28453e:	ba 0a 00 00 00       	mov    $0xa,%edx
  284543:	2e 8b 1d 20 00 00 00 	mov    %cs:0x20,%ebx
  28454a:	8b 44 24 08          	mov    0x8(%esp),%eax
  28454e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  284552:	cd 40                	int    $0x40
  284554:	5b                   	pop    %ebx
  284555:	c3                   	ret    

00284556 <api_pointwin>:
  284556:	57                   	push   %edi
  284557:	56                   	push   %esi
  284558:	53                   	push   %ebx
  284559:	ba 0b 00 00 00       	mov    $0xb,%edx
  28455e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  284562:	8b 74 24 14          	mov    0x14(%esp),%esi
  284566:	8b 7c 24 18          	mov    0x18(%esp),%edi
  28456a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
  28456e:	cd 40                	int    $0x40
  284570:	5b                   	pop    %ebx
  284571:	5e                   	pop    %esi
  284572:	5f                   	pop    %edi
  284573:	c3                   	ret    

00284574 <api_refreshwin>:
  284574:	57                   	push   %edi
  284575:	56                   	push   %esi
  284576:	53                   	push   %ebx
  284577:	ba 0c 00 00 00       	mov    $0xc,%edx
  28457c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  284580:	8b 44 24 14          	mov    0x14(%esp),%eax
  284584:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  284588:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  28458c:	8b 7c 24 20          	mov    0x20(%esp),%edi
  284590:	cd 40                	int    $0x40
  284592:	5b                   	pop    %ebx
  284593:	5e                   	pop    %esi
  284594:	5f                   	pop    %edi
  284595:	c3                   	ret    

00284596 <api_linewin>:
  284596:	57                   	push   %edi
  284597:	56                   	push   %esi
  284598:	55                   	push   %ebp
  284599:	53                   	push   %ebx
  28459a:	ba 0d 00 00 00       	mov    $0xd,%edx
  28459f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  2845a3:	8b 44 24 18          	mov    0x18(%esp),%eax
  2845a7:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
  2845ab:	8b 74 24 20          	mov    0x20(%esp),%esi
  2845af:	8b 7c 24 24          	mov    0x24(%esp),%edi
  2845b3:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  2845b7:	cd 40                	int    $0x40
  2845b9:	5b                   	pop    %ebx
  2845ba:	5d                   	pop    %ebp
  2845bb:	5e                   	pop    %esi
  2845bc:	5f                   	pop    %edi
  2845bd:	c3                   	ret    

002845be <api_closewin>:
  2845be:	53                   	push   %ebx
  2845bf:	ba 0e 00 00 00       	mov    $0xe,%edx
  2845c4:	8b 5c 24 08          	mov    0x8(%esp),%ebx
  2845c8:	cd 40                	int    $0x40
  2845ca:	5b                   	pop    %ebx
  2845cb:	c3                   	ret    

002845cc <api_getkey>:
  2845cc:	ba 0f 00 00 00       	mov    $0xf,%edx
  2845d1:	8b 44 24 04          	mov    0x4(%esp),%eax
  2845d5:	cd 40                	int    $0x40
  2845d7:	c3                   	ret    

002845d8 <change_wtitle8>:
	}
	return cur_c;
}

void change_wtitle8(struct SHEET *sht,char act)
{
  2845d8:	55                   	push   %ebp
  2845d9:	89 e5                	mov    %esp,%ebp
  2845db:	57                   	push   %edi
  2845dc:	56                   	push   %esi
  2845dd:	53                   	push   %ebx
  2845de:	83 ec 2c             	sub    $0x2c,%esp
  2845e1:	8b 45 0c             	mov    0xc(%ebp),%eax
	int x,y,xsize = sht->bxsize;
  2845e4:	8b 7d 08             	mov    0x8(%ebp),%edi
  2845e7:	8b 7f 04             	mov    0x4(%edi),%edi
  2845ea:	89 fe                	mov    %edi,%esi
  2845ec:	89 7d cc             	mov    %edi,-0x34(%ebp)
	else
	{
		tc_new = COL8_C6C6C6;
		tbc_new = COL8_848484;
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
  2845ef:	3c 01                	cmp    $0x1,%al
  2845f1:	19 ff                	sbb    %edi,%edi
  2845f3:	89 fb                	mov    %edi,%ebx
  2845f5:	83 e3 fd             	and    $0xfffffffd,%ebx
  2845f8:	83 c3 0f             	add    $0xf,%ebx
  2845fb:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  2845fe:	89 fb                	mov    %edi,%ebx
  284600:	83 c3 08             	add    $0x8,%ebx
  284603:	88 5d e7             	mov    %bl,-0x19(%ebp)
  284606:	83 e7 03             	and    $0x3,%edi
  284609:	83 c7 0c             	add    $0xc,%edi
  28460c:	3c 01                	cmp    $0x1,%al
  28460e:	19 c0                	sbb    %eax,%eax
  284610:	f7 d0                	not    %eax
  284612:	83 c0 08             	add    $0x8,%eax
  284615:	88 45 e5             	mov    %al,-0x1b(%ebp)
  284618:	89 f0                	mov    %esi,%eax
  28461a:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  28461d:	8d 0c 76             	lea    (%esi,%esi,2),%ecx
  284620:	8b 5d 08             	mov    0x8(%ebp),%ebx
  284623:	03 0b                	add    (%ebx),%ecx
			{
				c = tc_new;
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
  284625:	c7 45 d8 12 00 00 00 	movl   $0x12,-0x28(%ebp)
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
  28462c:	8d 5e fc             	lea    -0x4(%esi),%ebx
  28462f:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  284632:	83 e8 03             	sub    $0x3,%eax
  284635:	89 45 e0             	mov    %eax,-0x20(%ebp)
		{
			c = buf[y*xsize + x];
			if(c == tc_old && x<=xsize -22)
  284638:	8d 46 ea             	lea    -0x16(%esi),%eax
  28463b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  28463e:	eb 32                	jmp    284672 <change_wtitle8+0x9a>
  284640:	89 ce                	mov    %ecx,%esi
  284642:	89 d3                	mov    %edx,%ebx
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
		{
			c = buf[y*xsize + x];
  284644:	0f b6 04 11          	movzbl (%ecx,%edx,1),%eax
			if(c == tc_old && x<=xsize -22)
  284648:	38 45 e7             	cmp    %al,-0x19(%ebp)
  28464b:	75 05                	jne    284652 <change_wtitle8+0x7a>
  28464d:	39 55 dc             	cmp    %edx,-0x24(%ebp)
  284650:	7d 08                	jge    28465a <change_wtitle8+0x82>
			{
				c = tc_new;
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
  284652:	38 45 e6             	cmp    %al,-0x1a(%ebp)
  284655:	0f 44 c7             	cmove  %edi,%eax
  284658:	eb 04                	jmp    28465e <change_wtitle8+0x86>
		for(x=3;x<=xsize-4;x++)
		{
			c = buf[y*xsize + x];
			if(c == tc_old && x<=xsize -22)
			{
				c = tc_new;
  28465a:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
			}
			else if(c == tbc_old)
			{
				c = tbc_new;
			}
			buf[y*xsize+x] = c;
  28465e:	88 04 1e             	mov    %al,(%esi,%ebx,1)
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
	{
		for(x=3;x<=xsize-4;x++)
  284661:	83 c2 01             	add    $0x1,%edx
  284664:	3b 55 e0             	cmp    -0x20(%ebp),%edx
  284667:	75 d7                	jne    284640 <change_wtitle8+0x68>
  284669:	03 4d d4             	add    -0x2c(%ebp),%ecx
		tc_new = COL8_C6C6C6;
		tbc_new = COL8_848484;
		tc_old = COL8_FFFFFF;
		tbc_old = COL8_000084;
	}
	for(y=3;y<=20;y++)
  28466c:	83 6d d8 01          	subl   $0x1,-0x28(%ebp)
  284670:	74 0d                	je     28467f <change_wtitle8+0xa7>
	{
		for(x=3;x<=xsize-4;x++)
  284672:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
  284676:	7e f1                	jle    284669 <change_wtitle8+0x91>
  284678:	ba 03 00 00 00       	mov    $0x3,%edx
  28467d:	eb c1                	jmp    284640 <change_wtitle8+0x68>
				c = tbc_new;
			}
			buf[y*xsize+x] = c;
		}
	}
	sheet_refresh(sht,3,3,xsize,21);
  28467f:	83 ec 0c             	sub    $0xc,%esp
  284682:	6a 15                	push   $0x15
  284684:	ff 75 cc             	pushl  -0x34(%ebp)
  284687:	6a 03                	push   $0x3
  284689:	6a 03                	push   $0x3
  28468b:	ff 75 08             	pushl  0x8(%ebp)
  28468e:	e8 bb e2 ff ff       	call   28294e <sheet_refresh>
	return;
  284693:	83 c4 20             	add    $0x20,%esp
}
  284696:	8d 65 f4             	lea    -0xc(%ebp),%esp
  284699:	5b                   	pop    %ebx
  28469a:	5e                   	pop    %esi
  28469b:	5f                   	pop    %edi
  28469c:	5d                   	pop    %ebp
  28469d:	c3                   	ret    

0028469e <keywin_off>:
#include "common.h"
#include "graphics.h"
int keywin_off(struct SHEET *key_win,struct SHEET *sht_win,int cur_c,int cur_x)
{
  28469e:	55                   	push   %ebp
  28469f:	89 e5                	mov    %esp,%ebp
  2846a1:	53                   	push   %ebx
  2846a2:	83 ec 0c             	sub    $0xc,%esp
  2846a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
	change_wtitle8(key_win,0);
  2846a8:	6a 00                	push   $0x0
  2846aa:	53                   	push   %ebx
  2846ab:	e8 28 ff ff ff       	call   2845d8 <change_wtitle8>
	if(key_win == sht_win)
  2846b0:	83 c4 10             	add    $0x10,%esp
  2846b3:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  2846b6:	75 29                	jne    2846e1 <keywin_off+0x43>
	{
		cur_c = -1;
		boxfill8(sht_win->buf,sht_win->bxsize,COL8_FFFFFF,cur_x,28,cur_x+7,43);
  2846b8:	83 ec 04             	sub    $0x4,%esp
  2846bb:	6a 2b                	push   $0x2b
  2846bd:	8b 45 14             	mov    0x14(%ebp),%eax
  2846c0:	83 c0 07             	add    $0x7,%eax
  2846c3:	50                   	push   %eax
  2846c4:	6a 1c                	push   $0x1c
  2846c6:	ff 75 14             	pushl  0x14(%ebp)
  2846c9:	6a 07                	push   $0x7
  2846cb:	ff 73 04             	pushl  0x4(%ebx)
  2846ce:	ff 33                	pushl  (%ebx)
  2846d0:	e8 7f c7 ff ff       	call   280e54 <boxfill8>
  2846d5:	83 c4 20             	add    $0x20,%esp
int keywin_off(struct SHEET *key_win,struct SHEET *sht_win,int cur_c,int cur_x)
{
	change_wtitle8(key_win,0);
	if(key_win == sht_win)
	{
		cur_c = -1;
  2846d8:	c7 45 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebp)
  2846df:	eb 1a                	jmp    2846fb <keywin_off+0x5d>
		boxfill8(sht_win->buf,sht_win->bxsize,COL8_FFFFFF,cur_x,28,cur_x+7,43);
	} else {
		if((key_win->flags & 0x20))
  2846e1:	f6 43 1c 20          	testb  $0x20,0x1c(%ebx)
  2846e5:	74 14                	je     2846fb <keywin_off+0x5d>
		{
			fifo32_put(&key_win->task->fifo,3);
  2846e7:	83 ec 08             	sub    $0x8,%esp
  2846ea:	6a 03                	push   $0x3
  2846ec:	8b 43 24             	mov    0x24(%ebx),%eax
  2846ef:	83 c0 10             	add    $0x10,%eax
  2846f2:	50                   	push   %eax
  2846f3:	e8 71 d6 ff ff       	call   281d69 <fifo32_put>
  2846f8:	83 c4 10             	add    $0x10,%esp
		}
	}
	return cur_c;
}
  2846fb:	8b 45 10             	mov    0x10(%ebp),%eax
  2846fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  284701:	c9                   	leave  
  284702:	c3                   	ret    

00284703 <keywin_on>:

int keywin_on(struct SHEET *key_win,struct SHEET *sht_win,int cur_c)
{
  284703:	55                   	push   %ebp
  284704:	89 e5                	mov    %esp,%ebp
  284706:	53                   	push   %ebx
  284707:	83 ec 0c             	sub    $0xc,%esp
  28470a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	change_wtitle8(key_win,1);
  28470d:	6a 01                	push   $0x1
  28470f:	53                   	push   %ebx
  284710:	e8 c3 fe ff ff       	call   2845d8 <change_wtitle8>
	if(key_win == sht_win)
  284715:	83 c4 10             	add    $0x10,%esp
  284718:	3b 5d 0c             	cmp    0xc(%ebp),%ebx
  28471b:	74 1c                	je     284739 <keywin_on+0x36>
	{
		cur_c = COL8_000000;
	} else {
		if((key_win->flags & 0x20))
  28471d:	f6 43 1c 20          	testb  $0x20,0x1c(%ebx)
  284721:	74 1d                	je     284740 <keywin_on+0x3d>
		{
			fifo32_put(&key_win->task->fifo,2);
  284723:	83 ec 08             	sub    $0x8,%esp
  284726:	6a 02                	push   $0x2
  284728:	8b 43 24             	mov    0x24(%ebx),%eax
  28472b:	83 c0 10             	add    $0x10,%eax
  28472e:	50                   	push   %eax
  28472f:	e8 35 d6 ff ff       	call   281d69 <fifo32_put>
  284734:	83 c4 10             	add    $0x10,%esp
  284737:	eb 07                	jmp    284740 <keywin_on+0x3d>
int keywin_on(struct SHEET *key_win,struct SHEET *sht_win,int cur_c)
{
	change_wtitle8(key_win,1);
	if(key_win == sht_win)
	{
		cur_c = COL8_000000;
  284739:	c7 45 10 00 00 00 00 	movl   $0x0,0x10(%ebp)
		{
			fifo32_put(&key_win->task->fifo,2);
		}
	}
	return cur_c;
}
  284740:	8b 45 10             	mov    0x10(%ebp),%eax
  284743:	8b 5d fc             	mov    -0x4(%ebp),%ebx
  284746:	c9                   	leave  
  284747:	c3                   	ret    

00284748 <test>:
#include "test.h"
int test(int screenx, int screeny)
{
  284748:	55                   	push   %ebp
  284749:	89 e5                	mov    %esp,%ebp
	return screenx*screeny;
  28474b:	8b 45 0c             	mov    0xc(%ebp),%eax
  28474e:	0f af 45 08          	imul   0x8(%ebp),%eax
}
  284752:	5d                   	pop    %ebp
  284753:	c3                   	ret    
